package ModelicaServices
  "ModelicaServices (Default implementation) - Models and functions used in the Modelica Standard Library requiring a tool specific implementation"
extends Modelica.Icons.Package;

package ExternalReferences

  function loadResource
    "Return the absolute path name of a URI or local file name (in this default implementation URIs are not supported, but only local file names)"
    input String uri;
    output String fileReference;
  external "builtin" fileReference=Dymola_ResolveURI(uri);
  annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = <b>loadResource</b>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<b>loadResource</b>(uri)</code>\" returns the
<b>absolute path name</b> of the file that is either defined by an URI or by a local
(e.g. relative) path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific, and this implementation is for Dymola.
However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute and relative local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\data\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
  end loadResource;
end ExternalReferences;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="3.2.3",
  versionBuild=0,
  versionDate="2016-01-15",
  dateModified = "2016-01-15 08:44:41Z",
  revisionId="$Id:: package.mo 9141 2016-03-03 19:26:06Z #$",
  uses(Modelica(version="3.2.3")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2",
    noneFromVersion="3.2.1"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">ModelicaServices.Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This implementation is targeted for Dymola.
</p>

<p>
<b>Licensed by DLR and Dassault Syst&egrave;mes AB under the Modelica License 2</b><br>
Copyright &copy; 2009-2016, DLR and Dassault Syst&egrave;mes AB.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>"));
end ModelicaServices;

package Buildings "Library with models for building energy and control systems"
  extends Modelica.Icons.Package;

  package Airflow
  "Package to compute airflow and contaminant transport between rooms"
    extends Modelica.Icons.Package;

    package Multizone
    "Package with models for multizone airflow and contaminant transport"
      extends Modelica.Icons.VariantsPackage;

      model DoorOpen
        "Door model for bi-directional air flow between rooms"
        extends Buildings.Airflow.Multizone.BaseClasses.Door(
          final vAB = VAB_flow/AOpe,
          final vBA = VBA_flow/AOpe);

        parameter Real CD=0.65 "Discharge coefficient"
          annotation (Dialog(group="Orifice characteristics"));

        parameter Real m = 0.5 "Flow coefficient"
          annotation (Dialog(group="Orifice characteristics"));


    protected
        constant Real gamma(min=1) = 1.5
          "Normalized flow rate where dphi(0)/dpi intersects phi(1)";
        constant Real a = gamma
          "Polynomial coefficient for regularized implementation of flow resistance";
        parameter Real b = 1/8*m^2 - 3*gamma - 3/2*m + 35.0/8
          "Polynomial coefficient for regularized implementation of flow resistance";
        parameter Real c = -1/4*m^2 + 3*gamma + 5/2*m - 21.0/4
          "Polynomial coefficient for regularized implementation of flow resistance";
        parameter Real d = 1/8*m^2 - gamma - m + 15.0/8
          "Polynomial coefficient for regularized implementation of flow resistance";

        parameter Real kVal=CD*AOpe*sqrt(2/rho_default) "Flow coefficient, k = V_flow/ dp^m";
        parameter Real kT = rho_default * CD * AOpe/3 *
          sqrt(Modelica.Constants.g_n /(Medium.T_default*conTP) * hOpe)
          "Constant coefficient for buoyancy driven air flow rate";

        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent=
          kVal * rho_default * sqrt(dp_turbulent)
          "Mass flow rate where regularization to laminar flow occurs for temperature-driven flow";

      equation
        // Air flow rate due to static pressure difference
        VABp_flow = Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM(
            k=kVal,
            dp=port_a1.p-port_a2.p,
            m=m,
            a=a,
            b=b,
            c=c,
            d=d,
            dp_turbulent=dp_turbulent);
        // Air flow rate due to buoyancy
        // Because powerLawFixedM requires as an input a pressure difference pa-pb,
        // we convert Ta-Tb by multiplying it with rho*R, and we divide
        // above the constant expression by (rho*R)^m on the right hand-side of kT.
        // Note that here, k is for mass flow rate, whereas in powerLawFixedM, it is for volume flow rate.
        // We can use m=0.5 as this is from Bernoulli.
        mABt_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
            k=kT,
            dp=conTP*(Medium.temperature(state_a1_inflow)-Medium.temperature(state_a2_inflow)),
            m_flow_turbulent=m_flow_turbulent);

        annotation (defaultComponentName="doo",
      Documentation(info="<html>
<p>
Model for bi-directional air flow through a large opening such as a door.
</p>
<p>
In this model, the air flow is composed of two components,
a one-directional bulk air flow
due to static pressure difference in the adjoining two thermal zones, and
a two-directional airflow due to temperature-induced differences in density
of the air in the two thermal zones.
Although turbulent air flow is a nonlinear phenomenon,
the model is based on the simplifying assumption that these two
air flow rates can be superposed.
(Superposition is only exact for laminar flow.)
This assumption is made because
it leads to a simple model and because there is significant uncertainty
and assumptions anyway in such simplified a model for bidirectional flow through a door.
</p>
<h4>Main equations</h4>
<p>
The air flow rate due to static pressure difference is
</p>
<p align=\"center\" style=\"font-style:italic;\">
    V&#775;<sub>ab,p</sub> =  C<sub>D</sub> w h (2/&rho;<sub>0</sub>)<sup>0.5</sup>  &Delta;p<sup>m</sup>,
</p>
<p>
where
<i>V&#775;</i> is the volumetric air flow rate,
<i>C<sub>D</sub></i> is the discharge coefficient,
<i>w</i> and <i>h</i> are the width and height of the opening,
<i>&rho;<sub>0</sub></i> is the mass density at the medium default pressure, temperature and humidity,
<i>m</i> is the flow exponent and
<i>&Delta;p = p<sub>a</sub> - p<sub>b</sub></i> is the static pressure difference between
the thermal zones.
For this model explanation, we will assume <i>p<sub>a</sub> &gt; p<sub>b</sub></i>.
For turbulent flow, <i>m=1/2</i> and for laminar flow <i>m=1</i>.
</p>
<p>
The air flow rate due to temperature difference in the thermal zones is
<i>V&#775;<sub>ab,t</sub></i> for flow from thermal zone <i>a</i> to <i>b</i>,
and
<i>V&#775;<sub>ba,t</sub></i> for air flow rate from thermal zone <i>b</i> to <i>a</i>.
The model has two air flow paths to allow bi-directional air flow.
The mass flow rates at these two air flow paths are
</p>
<p align=\"center\" style=\"font-style:italic;\">
    m&#775;<sub>a1</sub> = &rho;<sub>0</sub> &nbsp; (+V&#775;<sub>ab,p</sub>/2 + &nbsp; V&#775;<sub>ab,t</sub>),
</p>
<p>
and, similarly,
</p>
<p align=\"center\" style=\"font-style:italic;\">
    V&#775;<sub>ba</sub> = &rho;<sub>0</sub> &nbsp; (-V&#775;<sub>ab,p</sub>/2 + &nbsp; V&#775;<sub>ba,t</sub>),
</p>
<p>
where we simplified the calculation by using the density <i>&rho;<sub>0</sub></i>.
To calculate <i>V&#775;<sub>ba,t</sub></i>, we again use the density <i>&rho;<sub>0</sub></i>
and because of this simplification, we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
    m&#775;<sub>ab,t</sub> =  -m&#775;<sub>ba,t</sub> = &rho;<sub>0</sub> &nbsp; V&#775;<sub>ab,t</sub>
  =  -&rho;<sub>0</sub> &nbsp; V&#775;<sub>ba,t</sub>,
</p>
<p>
from which follows that the neutral height, e.g., the height where the air flow rate due to flow
induced by temperature difference is zero, is at <i>h/2</i>.
Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
V&#775;<sub>ab,t</sub> = C<sub>D</sub> &int;<sub>0</sub><sup>h/2</sup> w v(z) dz,
</p>
<p>
where <i>v(z)</i> is the velocity at height <i>z</i>. From the Bernoulli equation, we obtain
</p>
<p align=\"center\" style=\"font-style:italic;\">
v(z) = (2 g z &Delta;&rho; &frasl; &rho;<sub>0</sub>)<sup>1/2</sup>.
</p>
<p>
The density difference can be written as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;&rho; = &rho;<sub>a</sub>-&rho;<sub>b</sub>
  &asymp; &rho;<sub>0</sub> (T<sub>b</sub> - T<sub>a</sub>) &frasl; T<sub>0</sub>,
</p>
<p>
where we used
<i>&rho;<sub>a</sub> = p<sub>0</sub> /(R T<sub>a</sub>)</i> and
<i>T<sub>a</sub> T<sub>b</sub> &asymp; T<sub>0</sub><sup>2</sup></i>.
Substituting this expression into the integral and integrating from <i>0</i> to <i>z</i> yields
</p>
<p align=\"center\" style=\"font-style:italic;\">
V&#775;<sub>ab,t</sub> = 1&frasl;3  C<sub>D</sub> w h
(g h &frasl; (R T<sub>0</sub> &rho;<sub>0</sub>))<sup>1/2</sup> &Delta;p<sup>1/2</sup>.
</p>
<p>
The above equation is equivalent to (6) in Brown and Solvason (1962).
<h4>Main assumptions</h4>
<p>
The main assumptions are as follows:
</p>
<ul>
<li>
<p>
The air flow rates due to static pressure difference and due to temperature-difference can be superposed.
</p>
</li>
<li>
<p>
For buoyancy-driven air flow, a constant density can be used to convert air volume flow rate to air mass flow rate.
</p>
</li>
</ul>
<p>
From these assumptions follows that the neutral height for buoyancy-driven air flow is at half of the height
of the opening.
</p>
<h4>Notes</h4>
<p>
For a more detailed model, use
<a href=\"modelica://Buildings.Airflow.Multizone.DoorDiscretizedOpen\">
Buildings.Airflow.Multizone.DoorDiscretizedOpen</a>.
</p>
<h4>References</h4>
<ul>
<li>
Brown, W.G. and K. R. Solvason.
Natural Convection through rectangular openings in partitions - 1.
<i>Int. Journal of Heat and Mass Transfer</i>.
Vol. 5, p. 859-868. 1962.
<a href=\"https://doi.org/10.1016/0017-9310(62)90184-9\">doi:10.1016/0017-9310(62)90184-9</a>.<br/>
Also available at
<a href=\"https://nrc-publications.canada.ca/eng/view/ft/?id=081c0ace-7c31-449c-9b3b-e6c14864b196\">
https://nrc-publications.canada.ca/eng/view/ft/?id=081c0ace-7c31-449c-9b3b-e6c14864b196</a>.
</li>
</ul>
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2020, by Michael Wetter:<br/>
Revised buoyancy-driven flow based on Brown and Solvason (1962).
</li>
<li>
January 19, 2020, by Klaas De Jonge:<br/>
Revised influence of stack effect.
</li>
<li>
October 6, 2020, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1353\">#1353</a>.
</li>
</ul>
</html>"));
      end DoorOpen;

      package BaseClasses
      "Package with base classes for Buildings.Airflow.Multizone"
        extends Modelica.Icons.BasesPackage;

        partial model Door
          "Partial door model for bi-directional flow"
          extends Buildings.Fluid.Interfaces.PartialFourPortInterface(
            redeclare final package Medium1 = Medium,
            redeclare final package Medium2 = Medium,
            final allowFlowReversal1=true,
            final allowFlowReversal2=true,
            final m1_flow_nominal=10/3600*1.2,
            final m2_flow_nominal=m1_flow_nominal,
            final m1_flow_small=1E-4*abs(m1_flow_nominal),
            final m2_flow_small=1E-4*abs(m2_flow_nominal));

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choices(
                choice(redeclare package Medium = Buildings.Media.Air "Moist air")));

          parameter Modelica.SIunits.Length wOpe=0.9 "Width of opening"
            annotation (Dialog(group="Geometry"));
          parameter Modelica.SIunits.Length hOpe=2.1 "Height of opening"
            annotation (Dialog(group="Geometry"));

          parameter Modelica.SIunits.PressureDifference dp_turbulent(
            min=0,
            displayUnit="Pa") = 0.01
            "Pressure difference where laminar and turbulent flow relation coincide"
            annotation(Dialog(tab="Advanced"));

          Modelica.SIunits.VolumeFlowRate VAB_flow(nominal=0.001)
            "Volume flow rate from A to B if positive";
          Modelica.SIunits.VolumeFlowRate VBA_flow(nominal=0.001)
            "Volume flow rate from B to A if positive";

          input Modelica.SIunits.Velocity vAB(nominal=0.01) "Average velocity from A to B";
          input Modelica.SIunits.Velocity vBA(nominal=0.01) "Average velocity from B to A";

      protected
          final parameter Modelica.SIunits.Area AOpe = wOpe*hOpe "Open aperture area";

          constant Real conTP = Buildings.Media.Air.dStp*Modelica.Media.IdealGases.Common.SingleGasesData.Air.R
            "Conversion factor for converting temperature difference to pressure difference";

          parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default);

          parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
            "Density";

          Modelica.SIunits.VolumeFlowRate VABp_flow(nominal=0.001)
            "Volume flow rate from A to B if positive due to static pressure difference";
          Modelica.SIunits.MassFlowRate mABt_flow(nominal=0.001)
            "Mass flow rate from A to B if positive due to buoyancy";

        equation
          // Net flow rate
          port_a1.m_flow = (rho_default * VABp_flow/2 + mABt_flow);
          port_b2.m_flow = (rho_default * VABp_flow/2 - mABt_flow);

          // Average velocity (using the whole orifice area)
          VAB_flow = (max(port_a1.m_flow, 0) + max(port_b2.m_flow, 0))/rho_default;
          VBA_flow = (max(port_a2.m_flow, 0) + max(port_b1.m_flow, 0))/rho_default;

          // Energy balance (no storage, no heat loss/gain)
          port_a1.h_outflow = inStream(port_b1.h_outflow);
          port_b1.h_outflow = inStream(port_a1.h_outflow);
          port_a2.h_outflow = inStream(port_b2.h_outflow);
          port_b2.h_outflow = inStream(port_a2.h_outflow);

          // Mass balance (no storage)
          port_a1.m_flow = -port_b1.m_flow;
          port_a2.m_flow = -port_b2.m_flow;

          port_a1.Xi_outflow = inStream(port_b1.Xi_outflow);
          port_b1.Xi_outflow = inStream(port_a1.Xi_outflow);
          port_a2.Xi_outflow = inStream(port_b2.Xi_outflow);
          port_b2.Xi_outflow = inStream(port_a2.Xi_outflow);

          // Transport of trace substances
          port_a1.C_outflow = inStream(port_b1.C_outflow);
          port_b1.C_outflow = inStream(port_a1.C_outflow);
          port_a2.C_outflow = inStream(port_b2.C_outflow);
          port_b2.C_outflow = inStream(port_a2.C_outflow);

          annotation (
            Icon(graphics={
                Rectangle(
                  extent={{-60,80},{60,-84}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={85,75,55},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,72},{56,-84}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{56,72},{-36,66},{-36,-90},{56,-84},{56,72}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-30,-10},{-16,-8},{-16,-14},{-30,-16},{-30,-10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This is a partial model for the bi-directional air flow through a door.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 6, 2020, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1353\">#1353</a>.
</li>
</ul>
</html>"));
        end Door;

        function powerLawFixedM
          "Power law used in orifice equations when m is constant"
          input Real k "Flow coefficient, k = V_flow/ dp^m";
          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa") "Pressure difference";
          input Real m(min=0.5, max=1)
            "Flow exponent, m=0.5 for turbulent, m=1 for laminar";
          input Real a "Polynomial coefficient";
          input Real b "Polynomial coefficient";
          input Real c "Polynomial coefficient";
          input Real d "Polynomial coefficient";
          input Modelica.SIunits.PressureDifference dp_turbulent(min=0)=0.001
            "Pressure difference where regularization starts";
          output Modelica.SIunits.VolumeFlowRate V_flow "Volume flow rate";
      protected
          constant Real gamma(min=1) = 1.5
            "Normalized flow rate where dphi(0)/dpi intersects phi(1)";
          Real pi "Normalized pressure";
          Real pi2 "Square of normalized pressure";
        algorithm
         if (dp >= dp_turbulent) then
           V_flow := k*dp^m;
         elseif (dp <= -dp_turbulent) then
           V_flow :=-k*(-dp)^m;
         else
           pi  := dp/dp_turbulent;
           pi2 := pi*pi;
           V_flow := k*dp_turbulent^m * pi * ( a + pi2 * ( b + pi2 * ( c + pi2 * d)));
         end if;

          annotation (smoothOrder=2,
        Documentation(info="<html>
<p>
This model describes the mass flow rate and pressure difference relation
of an orifice in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  V = k sign(&Delta;p) |&Delta;p|<sup>m</sup>
</p>
<p>
where
<i>V</i> is the volume flow rate,
<i>k &gt; 0</i> is a flow coefficient
<i>&Delta; p</i> is the pressure drop and
<i>m &isin; [0.5, 1]</i> is a flow coefficient.
The equation is regularized for
<i>|&Delta;p| &lt; &Delta;p<sub>t</sub></i>, where
<i>&Delta;p<sub>t</sub></i> is a parameter.
For turbulent flow, set <i>m=1 &frasl; 2</i> and
for laminar flow, set <i>m=1</i>.
</p>
<p>
The model is used for the interzonal air flow models.
It is identical to
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLaw\">
Buildings.Airflow.Multizone.BaseClasses.powerLaw</a> but it
requires the polynomial coefficients as an input.
This allows a more efficient simulation if <i>m</i> and therefore also
<i>a</i>, <i>b</i>, <i>c</i> and <i>d</i> are constant.
</p>
<h4>Implementation</h4>
<p>
For <i>|&Delta;p| &lt; &Delta;p<sub>t</sub></i>, the equation is regularized
so that it is twice continuously differentiable in <i>&Delta;p</i>, and that it
has an infinite number of continuous derivatives in <i>m</i> and in <i>k</i>.
</p>
<p>
If <i>m</i>, and therefore also
<i>a</i>, <i>b</i>, <i>c</i> and <i>d</i>, change with time, then
it is more convenient and efficient to use
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLaw\">
Buildings.Airflow.Multizone.BaseClasses.powerLaw</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
<i>August 12, 2011</i> by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end powerLawFixedM;

        function windPressureLowRise "Wind pressure coefficient for low-rise buildings"
          input Real Cp0(min=0)
            "Wind pressure coefficient for normal wind incidence angle";
          input Modelica.SIunits.Angle incAng
            "Wind incidence angle (0: normal to wall)";
          input Real G "Natural logarithm of side ratio";
          output Real Cp "Wind pressure coefficient";
      protected
          constant Modelica.SIunits.Angle pi2 = 2*Modelica.Constants.pi;
          constant Modelica.SIunits.Angle aRDel = 5*Modelica.Constants.pi/180
            "Lower bound where transition occurs";
          constant Modelica.SIunits.Angle aRDel2 = aRDel/2
            "Half-width of transition interval";
          constant Modelica.SIunits.Angle aRMax = 175*Modelica.Constants.pi/180
            "Upper bound where transition occurs";
          Real a180 = Modelica.Math.log(1.248 - 0.703 +
                      0.131*Modelica.Math.sin(2*Modelica.Constants.pi*G)^3
                      + 0.071*G^2) "Attenuation factor at 180 degree incidence angle";

          Modelica.SIunits.Angle aR "alpha, restricted to 0...pi";
          Modelica.SIunits.Angle incAng2 "0.5*wind incidence angle";
          Real sinA2 "=sin(alpha/2)";
          Real cosA2 "=cos(alpha/2)";
          Real a "Attenuation factor";
        algorithm
          // Restrict incAng to [0...pi]

          // Change sign to positive
          aR := if incAng < 0 then -incAng else incAng;
          // Constrain to [0...2*pi]
          if aR > pi2 then
            aR := aR - integer(aR/pi2)*pi2;
          end if;
          // Constrain to [0...pi]
          if aR > Modelica.Constants.pi then
            aR := pi2-aR;
          end if;

          // Evaluate eqn. 2-1 from FSEC-CR-163-86
          incAng2 :=aR/2;
          sinA2 :=Modelica.Math.sin(incAng2);
          cosA2 :=Modelica.Math.cos(incAng2);
          // Implementation of the wind pressure coefficient that is once
          // continuously differentiable for all incidence angles
          if aR < aRDel then
            Cp :=Cp0*Buildings.Utilities.Math.Functions.regStep(
              y1=Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2
                 + 0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2
                 + 0.717*cosA2^2),
              y2=1,
              x=aR - aRDel2,
              x_small=aRDel2);
          elseif aR > aRMax then
            Cp :=Cp0*Buildings.Utilities.Math.Functions.regStep(
              y1=a180,
              y2=Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2
                 + 0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2
                 + 0.717*cosA2^2),
              x=aR + aRDel2 - Modelica.Constants.pi,
              x_small=aRDel2);
          else
            Cp :=Cp0*Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2 +
              0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2 + 0.717*cosA2^2);
          end if;
        annotation (
        smoothOrder=1,
        Documentation(info="<html>
<p>
This function computes the wind pressure coefficient for
low-rise buildings with rectangular shape.
The correlation is the data fit from Swami and Chandra (1987),
who fitted a function to various wind pressure coefficients from the literature.
The same correlation is also implemented in CONTAM (Persily and Ivy, 2001).
</p>
<p>
The wind pressure coefficient is computed based on the
natural logarithm of the side ratio of the walls, which is defined as
</p>
<p align=\"center\" style=\"font-style:italic;\">
G = ln(x &frasl; y)
</p>
<p>
where <i>x</i> is the length of the wall that will be connected to
this model, and <i>y</i> is the length of the adjacent wall as shown
in the figure below.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Airflow/Multizone/BaseClasses/windPressureLowRise.png\" border=\"1\" alt=\"Definition of the aspect ratio.\"/>
</p>
<p>
Based on the wind incidence angle <i>&alpha;</i> and the side ratio
of the walls, the model computes how much the wind pressure
is attenuated compared to the reference wind pressure <code>Cp0</code>.
The reference wind pressure <code>Cp0</code> is a user-defined parameter,
and must be equal to the wind pressure at zero wind incidence angle, i.e.,
<i>&alpha; = 0</i>.
Swami and Chandra (1987) recommend <i>C<sub>p0</sub> = 0.6</i> for
all low-rise buildings as this represents the average of
various values reported in the literature.
The attenuation factor is
</p>
<p align=\"center\" style=\"font-style:italic;\">
C<sub>p</sub> &frasl; C<sub>p0</sub> = ln(1.248 - 0.703 sin(&alpha; &frasl; 2)
      - 1.175 sin<sup>2</sup>(&alpha;)
      - 0.131 sin<sup>3</sup>(2 &alpha; G)
      + 0.769 cos(&alpha; &frasl; 2)
       +0.071 G<sup>2</sup> * sin<sup>2</sup>(&alpha; &frasl; 2)
       + 0.717 cos<sup>2</sup>(&alpha; &frasl; 2)),
</p>
<p>
where
<i>C<sub>p</sub></i> is the wind pressure coefficient for
the current angle of incidence.
</p>
<p>
This function is used in
<a href=\"modelica://Buildings.Fluid.Sources.Outside_CpLowRise\">
Buildings.Fluid.Sources.Outside_CpLowRise</a>
which can be used directly with components of this package.
</p>
<h4>References</h4>
<ul>
<li>
Muthusamy V. Swami and
Subrato Chandra.
<i>
<a href=\"http://www.fsec.ucf.edu/en/publications/pdf/FSEC-CR-163-86.pdf\">
Procedures for
Calculating Natural
Ventilation Airflow
Rates in Buildings.</a></i>
Florida Solar Energy Center, FSEC-CR-163-86. March, 1987.
Cape Canaveral, Florida.
</li>
<li>
Andrew K. Persily and Elizabeth M. Ivy.
<i>
<a href=\"http://ws680.nist.gov/publication/get_pdf.cfm?pub_id=860831\">
Input Data for Multizone Airflow and IAQ Analysis.</a></i>
NIST, NISTIR 6585.
January, 2001.
Gaithersburg, MD.
</li>
</ul>
<h4>Implementation</h4>
<p>
Symmetry requires that the first derivative of the wind pressure coefficient
with respect to the incidence angle is zero for incidence angles of zero and &pi;.
However, the correlation of Swami and Chandra has non-zero derivatives at these values.
In this implementation, the original function is therefore slightly modified for incidence angles
between 0 and 5 degree, and between 175 and 180 degree.
This leads to a model that is differentiable in the incidence angle,
which generally leads to better numeric performance.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Removed <code>constant</code> keyword for <code>a180</code> as its value
depends on the input of the function.
</li>
<li>
October 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end windPressureLowRise;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Airflow.Multizone\">Buildings.Airflow.Multizone</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package provides
models to compute the airflow and contaminant transport between different rooms and between
a room and the exterior environment.
See the <a href=\"modelica://Buildings.Airflow.Multizone.UsersGuide\">
User's Guide</a> for more information.
</html>"));
    end Multizone;
  annotation (
    preferredView="info",
    Documentation(info="<html>
This package provides
models to compute the air flow between different rooms and between
a room and the exterior environment.
For models that compute airflow in duct networks, see
<a href=\"modelica://Buildings.Fluid\">
Buildings.Fluid</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
        Rectangle(
          extent={{-72,66},{68,-74}},
          lineColor={95,95,95},
          fillPattern=FillPattern.Solid,
          fillColor={95,95,95}),
        Rectangle(
          extent={{-24,10},{24,-10}},
          lineColor={255,255,255},
          fillPattern=FillPattern.Solid,
          fillColor={255,255,255},
          origin={0,56},
          rotation=180),
        Rectangle(
          extent={{-50,46},{46,-56}},
          lineColor={255,255,255},
          fillPattern=FillPattern.Solid,
          fillColor={255,255,255}),
        Rectangle(
          extent={{-24,11},{24,-11}},
          lineColor={255,255,255},
          fillPattern=FillPattern.Solid,
          fillColor={255,255,255},
          origin={-61,0},
          rotation=270),
        Polygon(
          points={{-84,6},{-44,6},{-44,18},{-24,0},{-44,-18},{-44,-6},{-84,-6},{
              -84,6}},
          lineColor={0,0,0},
          fillPattern=FillPattern.Solid,
          fillColor={0,0,0}),
        Polygon(
          points={{-30,6},{10,6},{10,18},{30,0},{10,-18},{10,-6},{-30,-6},{-30,6}},
          lineColor={0,0,0},
          fillPattern=FillPattern.Solid,
          fillColor={0,0,0},
          origin={0,62},
          rotation=90)}));
  end Airflow;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Icons.Block;

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa( min=0, max=1, unit="1")
          "Opaque sky cover [0, 1]"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput HHorIR(
          unit="W/m2",
          min=0,
          nominal=100) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
        Modelica.SIunits.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.SIunits.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover in [0, 10]";
      equation
        if calTSky == Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK =  Buildings.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 =  10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky =  (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky =  TDryBul*(epsSky^0.25);
        else
          TDewPoiK =  273.15;
          nOpa10   =  0.0;
          epsSky   =  0.0;
          TBlaSky  =  (HHorIR/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2017, by Michael Wetter:<br/>
Removed <code>import</code> statement.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/852\">#852</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed unit and comment of input <code>nOpa</code> for correct display of units
in <code>weaBus</code> and input <code>radHorIR</code> to <code>HHorIR</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                lineColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                lineColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                lineColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                lineColor={0,0,127},
                textString="radHorIR"),
              Text(
                extent={{16,-6},{54,-28}},
                lineColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                lineColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      block IncidenceAngle "Solar incidence angle on a tilted surface"
        extends Modelica.Blocks.Icons.Block;
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        parameter Modelica.SIunits.Angle til "Surface tilt";

        Modelica.Blocks.Interfaces.RealOutput y(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle" annotation (Placement(transformation(
                extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{
                  120,10}})));
        WeatherData.Bus weaBus "Weather data"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
    protected
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
          "Declination angle"
          annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.IncidenceAngle incAng(
          final lat=lat,
          final azi=azi,
          final til=til) "Incidence angle"
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
      equation
        connect(incAng.incAng, y) annotation (Line(
            points={{61,0},{88.25,0},{88.25,1.16573e-015},{95.5,1.16573e-015},{95.5,0},
                {110,0}},
            color={0,0,127}));
        connect(decAng.decAng, incAng.decAng) annotation (Line(
            points={{-19,40},{20,40},{20,5.4},{37.8,5.4}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, incAng.solHouAng) annotation (Line(
            points={{-19,-40},{20,-40},{20,-4.8},{38,-4.8}},
            color={0,0,127}));
        connect(weaBus.cloTim, decAng.nDay) annotation (Line(
            points={{-100,0},{-80,0},{-80,40},{-42,40}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
            points={{-100,0},{-80,0},{-80,-40},{-42,-40}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="incAng",
          Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface.
For a definition of the parameters, see the User's Guide
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">Buildings.BoundaryConditions.UsersGuide</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 30, 2011, by Michael Wetter:<br/>
Removed <code>connect(y, y)</code> statement.
</li>
<li>
February 28, 2011, by Wangda Zuo:<br/>
Use local civil time instead of clock time.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}), Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png")}));
      end IncidenceAngle;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block AltitudeAngle "Solar altitude angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput alt(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar altitude angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          alt = (Modelica.Constants.pi/2) - zen;
          annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
            defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the output connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        block Declination "Declination angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "Day number with units of seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Constant";
          constant Real k2 = 2*Modelica.Constants.pi/365.25 "Constant";
        equation
          decAng = Modelica.Math.asin(-k1 * Modelica.Math.cos((nDay/86400 + 10)*k2))
            "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the solar declination, which is
the angle between the equatorial plane and the solar beam.
The input signal <code>nDay</code> is the one-based number of the day, but in seconds.
Hence, during January 1, we should have <code>nDay = 86400</code> seconds.
Since the effect of using a continuous number rather than an integer is small,
we approximate this so that <code>nDay = 0</code> at the start of January 1,
and <code>nDay = 86400</code> at the end of January 1.
</p>
<h4>Validation</h4>
<p>
A validation with a more detailed calculation can be found at
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of output signal as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
November 11, 2015, by Michael Wetter:<br/>
Corrected typo in documentation.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end Declination;

        block IncidenceAngle "The solar incidence angle on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Modelica.SIunits.Angle azi(displayUnit="deg")
            "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
          Modelica.Blocks.Interfaces.RealOutput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incidence angle on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real dec_c=Modelica.Math.cos(decAng) "Cosine of declination angle";
          Real dec_s=Modelica.Math.sin(decAng) "Sine of declination angle";
          Real sol_c=Modelica.Math.cos(solHouAng) "Cosine of solar hour angle";
          Real sol_s=Modelica.Math.sin(solHouAng) "Sine of solar hour angle";
          Real lat_c=Modelica.Math.cos(lat) "Cosine of latitude";
          Real lat_s=Modelica.Math.sin(lat) "Sine of latitude";
        equation
          incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
            *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
            Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c))) "(A.4.13)";
          annotation (
            defaultComponentName="incAng",
            Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png"),
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,60},{-56,50}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-42},{-42,-54}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end IncidenceAngle;

        block SolarAzimuth "Solar azimuth"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time" annotation (Placement(transformation(extent={{-140,-80},{-100,
                    -40}}), iconTransformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput solAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar Azimuth"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination angle"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

      protected
          Real arg "cos(solAzi) after data validity check";
          Real tmp "cos(solAzi) before data validity check";
          Real solAziTem "Temporary variable for solar azimuth";

          constant Modelica.SIunits.Time day=86400 "Number of seconds in a day";
          constant Modelica.SIunits.Angle polarCircle = 1.1617
            "Latitude of polar circle (66 degree 33 min 44 sec)";
          final parameter Boolean outsidePolarCircle = lat < polarCircle and lat > -polarCircle
            "Flag, true if latitude is outside polar region";
        equation
          tmp = (Modelica.Math.sin(lat)*Modelica.Math.cos(zen) - Modelica.Math.sin(
            decAng))/(Modelica.Math.cos(lat)*Modelica.Math.sin(zen));
          arg = min(1.0, max(-1.0, tmp));

          solAziTem =  Modelica.Math.acos(arg); // Solar azimuth (A4.9a and b) as a positive number

          // If outside the polar circle, the only non-differentiability is at night when the sun is set.
          // Hence, we use noEvent.
          // If inside the polar circle, there is a jump at (solar-)midnight when the sun can
          // be above the horizon. Hence, we do not use noEvent(...)
          // Written as one line with functions so that lat does not become structural parameter with JModelica.org
          solAzi = if outsidePolarCircle then solarAzimuthNoEvent(solAziTem, solTim, day) else solarAzimuthWithEvent(solAziTem, solTim, day);

          annotation (
            defaultComponentName="solAzi",
            Documentation(info="<html>
<p>
This component computes the solar azimuth angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 9, 2020, by David Blum:<br/>
Reformulated to use one-line if-statements.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">issue 1373</a>.
</li>
<li>
October 13, 2017, by Michael Wetter:<br/>
Reformulated to use equation rather than algorithm section.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/834\">issue 834</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed model to avoid an event at solar noon.
</li>
<li>
February 28, 2012, by Wangda Zuo:<br/>
Add solar time conversion since it is removed from <code>solTim</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarAzimuth.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-100,68},{-58,58}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-102,-54},{-60,-64}},
                  lineColor={0,0,127},
                  textString="solTim"),
                Text(
                  extent={{-102,6},{-60,-4}},
                  lineColor={0,0,127},
                  textString="decAng")}));
        end SolarAzimuth;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
            "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end SolarHourAngle;

        block WallSolarAzimuth
          "Angle measured in a horizontal plane between the projection of the sun's rays and the normal to a vertical surface"
          extends Modelica.Blocks.Icons.Block;

          Modelica.Blocks.Interfaces.RealInput incAng(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="rad")
            "Solar incidence angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput alt(quantity="Angle",
                                                 unit="rad",
                                                 displayUnit="rad")
            "Solar altitude angle (angle between sun ray and horizontal surface)"
            annotation (Placement(transformation(extent={{-140,28},{-100,68}})));
          Modelica.Blocks.Interfaces.RealOutput verAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg")
            "Angle between projection of sun's rays and normal to vertical surface"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Modelica.SIunits.Angle delta = 1*Modelica.Constants.pi/180
            "Small angle";
          constant Modelica.SIunits.Angle ninety= Modelica.Constants.pi/2-delta
            "+89 degree";
          constant Real deltaX = 1E-4 "Small number used for smoothing";
          Real alt_c "Cosine of altitude, bounded away from zero";
          Real rat "Ratio of cosines";
        equation
          alt_c=Modelica.Math.cos(Buildings.Utilities.Math.Functions.smoothLimit(
                x=alt, l=-ninety, u=ninety, deltaX=delta));
          rat = Modelica.Math.cos(incAng)/alt_c;
          // Due to the smoothLimit, rat can be about 1E-3 greater than 1 or smaller than -1.
          // Hence, below we use another call to smoothLimit to ensure that the argument of
          // acos(.) is inside the interval [-1, 1].
          verAzi=Modelica.Math.acos(
               Buildings.Utilities.Math.Functions.smoothLimit(x=rat, l=-1+deltaX, u=1-deltaX, deltaX=deltaX/10));

          annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/WallSolarAzimuth.png")}),
        defaultComponentName="wallSolAzi",
        Documentation(info="<html>
<p>
This block computes the wall solar azimuth angle.
It is the angle between the projection of the sun ray on a horizontal surface
and the line perpendicular to the wall. The value of this angle varies from <i>0</i> to <i>180</i> degrees.
In the northern hemisphere at solar noon, the value of the wall solar azimuth angle is zero if the wall is facing south.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Decreased <code>deltaX</code> from <i>1e-3</i> to <i>1e-4</i>, as
the looser tolerance gives sharp changes in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang\">
Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang</a>.
</li>
<li>
February 23, 2012, by Michael Wetter:<br/>
Guarded against division by zero because the altitude angle can be <i>90</i> degree
in the tropics, and hence its cosine can take on zero.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
        end WallSolarAzimuth;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Solar declination angle"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the input connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-86,-88},{94,92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end ZenithAngle;

        function solarAzimuthNoEvent "Determines solar azimuth with no event"
          input Real solAziTem(quantity="Angle",unit="rad",displayUnit="deg") "Temporary solar azimuth";
          input Real solTim(quantity="Time", unit="s") "Solar time";
          input Real day(quantity="Time", unit="s") "Number of seconds in day";
          output Real solAzi(quantity="Angle",unit="rad",displayUnit="deg") "Solar azimuth";
        algorithm
          if noEvent(solTim - integer(solTim/day)*day<43200) then
            solAzi := -solAziTem;
          else
            solAzi := solAziTem;
          end if;

          annotation (
            Documentation(info="<html>
<p>
This function is used within
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth</a> 
to calculate solar azimuth with no events.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 9, 2020 by David Blum:<br/>
Initial implementation.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">#1373</a>. 
</li>
</ul>
</html>"));
        end solarAzimuthNoEvent;

        function solarAzimuthWithEvent "Determines solar azimuth with event"
          input Real solAziTem(quantity="Angle",unit="rad",displayUnit="deg") "Temporary solar azimuth";
          input Real solTim(quantity="Time", unit="s") "Solar time";
          input Real day(quantity="Time", unit="s") "Number of seconds in day";
          output Real solAzi(quantity="Angle",unit="rad",displayUnit="deg") "Solar azimuth";
        algorithm
          if (solTim - integer(solTim/day)*day<43200) then
            solAzi := -solAziTem;
          else
            solAzi := solAziTem;
          end if;
          annotation (
            Documentation(info="<html>
<p>
This function is used within
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth</a> 
to calculate solar azimuth with events.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 9, 2020 by David Blum:<br/>
Initial implementation.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">#1373</a>. 
</li>
</ul>
</html>"));
        end solarAzimuthWithEvent;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package SolarIrradiation "Package with models to compute solar irradition"
      extends Modelica.Icons.VariantsPackage;

      block DiffusePerez
        "Hemispherical diffuse irradiation on a tilted surface using Perez's anisotropic sky model"
        extends
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Real rho(min=0, max=1, final unit="1")=0.2 "Ground reflectance";
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        parameter Boolean outSkyCon=false
          "Output contribution of diffuse irradiation from sky";
        parameter Boolean outGroCon=false
          "Output contribution of diffuse irradiation from ground";

        Modelica.Blocks.Math.Add add "Block to add radiations"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil if outSkyCon
          "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Blocks.Interfaces.RealOutput HGroDifTil if outGroCon
          "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
        BaseClasses.DiffusePerez HDifTil(
          final til=til,
          final rho=rho) "Diffuse irradiation on tilted surface"
          annotation (Placement(transformation(extent={{0,-21},{42,21}})));
        BaseClasses.SkyClearness skyCle "Sky clearness"
          annotation (Placement(transformation(extent={{-62,16},{-54,24}})));
        BaseClasses.BrighteningCoefficient briCoe "Brightening coefficient"
          annotation (Placement(transformation(extent={{-40,-34},{-32,-26}})));
        BaseClasses.RelativeAirMass relAirMas "Relative air mass"
          annotation (Placement(transformation(extent={{-80,-44},{-72,-36}})));
        BaseClasses.SkyBrightness skyBri "Sky brightness"
          annotation (Placement(transformation(extent={{-60,-54},{-52,-46}})));
        SolarGeometry.IncidenceAngle incAng(
          final lat=lat,
          final azi=azi,
          final til=til) "Incidence angle"
          annotation (Placement(transformation(extent={{-86,-96},{-76,-86}})));

      equation
        connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
            points={{-71.6,-40},{-66,-40},{-66,-48.4},{-60.8,-48.4}},
            color={0,0,127}));
        connect(skyBri.skyBri, briCoe.skyBri) annotation (Line(
            points={{-51.6,-50},{-46,-50},{-46,-30},{-40.8,-30}},
            color={0,0,127}));
        connect(skyCle.skyCle, briCoe.skyCle) annotation (Line(
            points={{-53.6,20},{-46,20},{-46,-27.6},{-40.8,-27.6}},
            color={0,0,127}));
        connect(incAng.y, HDifTil.incAng) annotation (Line(
            points={{-75.5,-91},{-16,-91},{-16,-16},{-4.2,-16},{-4.2,-14.7}},
            color={0,0,127}));
        connect(weaBus.solZen, skyCle.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,17.6},{-62.8,17.6}},
            color={0,0,127}));
        connect(weaBus.solZen, relAirMas.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-40},{-80.8,-40}},
            color={0,0,127}));
        connect(weaBus.solZen, briCoe.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-20},{-66,-20},{-66,-32},
                {-40.8,-32},{-40.8,-32.4}},
            color={0,0,127}));
        connect(weaBus.HGloHor, skyCle.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,22.4},{-62.8,22.4}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,20},{-62.8,20}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-51.6},{-60.8,-51.6}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HGloHor, HDifTil.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{-70,0},{-38,0},{-38,16.8},{-4.2,16.8}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, HDifTil.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-38,5.55112e-16},{-38,10},{-4.2,10},{-4.2,
                10.5}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));

        connect(briCoe.F2, HDifTil.briCof2) annotation (Line(
            points={{-31.6,-31.6},{-24,-31.6},{-24,-2.1},{-4.2,-2.1}},
            color={0,0,127}));
        connect(briCoe.F1, HDifTil.briCof1) annotation (Line(
            points={{-31.6,-28.4},{-28,-28.4},{-28,4.2},{-4.2,4.2}},
            color={0,0,127}));
        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-90.8},{-86,-90.8}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solZen, HDifTil.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-58},{-20,-58},{-20,
                -8.4},{-4.2,-8.4}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(HDifTil.HSkyDifTil, add.u1) annotation (Line(
            points={{44.1,8.4},{52,8.4},{52,6},{58,6}},
            color={0,0,127}));
        connect(HDifTil.HGroDifTil, add.u2) annotation (Line(
            points={{44.1,-8.4},{52,-8.4},{52,-6},{58,-6}},
            color={0,0,127}));
        connect(add.y, H) annotation (Line(
            points={{81,6.10623e-16},{90.5,6.10623e-16},{90.5,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127}));

        connect(HDifTil.HSkyDifTil, HSkyDifTil) annotation (Line(
            points={{44.1,8.4},{52,8.4},{52,60},{110,60}},
            color={0,0,127}));
        connect(HDifTil.HGroDifTil, HGroDifTil) annotation (Line(
            points={{44.1,-8.4},{52,-8.4},{52,-60},{110,-60}},
            color={0,0,127}));
        annotation (
          defaultComponentName="HDifTil",
          Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface using an anisotropic
sky model proposed by Perez.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
Added <code>min</code>, <code>max</code> and <code>unit</code>
attributes for <code>rho</code>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Added contributions from sky and ground that were separated in base class.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Changed component to get zenith angle from weather bus.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DiffusePerez;

      block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
        extends
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

        Modelica.Blocks.Interfaces.RealOutput inc(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

    protected
        SolarGeometry.IncidenceAngle incAng(
          final azi=azi,
          final til=til,
          final lat=lat) "Incidence angle"
          annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.DirectTiltedSurface
          HDirTil "Direct irradition on tilted surface"
          annotation (Placement(transformation(extent={{0,-20},{40,20}})));

      equation
        connect(incAng.y, HDirTil.incAng) annotation (Line(
            points={{-29,-20},{-12,-20},{-12,-12},{-4,-12}},
            color={0,0,127}));

        connect(weaBus.HDirNor, HDirTil.HDirNor) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,12},{-4,12}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(incAng.y, inc) annotation (Line(
            points={{-29,-20},{-20,-20},{-20,-40},{110,-40}},
            color={0,0,127}));
        connect(HDirTil.HDirTil, H) annotation (Line(
            points={{42,1.22125e-15},{72,1.22125e-15},{72,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127}));

        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,-20},{-50,-20}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="HDirTil",
          Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed duplicate instance <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/461\">
https://github.com/ibpsa/modelica-ibpsa/issues/461</a>.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Added incidence angle as output as this is needed for the room model.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DirectTiltedSurface;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.SolarIrradiation"
        extends Modelica.Icons.BasesPackage;

        block BrighteningCoefficient "Circumsolar and horizon brightening coefficients"
          extends Modelica.Blocks.Icons.Block;
          import H = Buildings.Utilities.Math.Functions.regStep;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput skyCle
            "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput F1
            "Circumsolar brightening coefficient"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput F2 "Horizon brightening coefficient"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      protected
          Real F11;
          Real F12;
          Real F13;
          Real F21;
          Real F22;
          Real F23;
          Real d=0.01;
          Real a1;
          Real a2;
          Real a3;
          Real a4;
          Real a5;
          Real a6;
          Real a7;
          Real a8;
          Real b1;
          Real b2;
          Real b3;
          Real b4;
          Real b5;
          Real b6;
          Real b7;
          Real b8;
        equation
          b1 = H(
            y1=1,
            y2=0,
            x=1.065 - skyCle,
            x_small=d);
          b2 = H(
            y1=1,
            y2=0,
            x=1.23 - skyCle,
            x_small=d);
          b3 = H(
            y1=1,
            y2=0,
            x=1.50 - skyCle,
            x_small=d);
          b4 = H(
            y1=1,
            y2=0,
            x=1.95 - skyCle,
            x_small=d);
          b5 = H(
            y1=1,
            y2=0,
            x=2.80 - skyCle,
            x_small=d);

          b6 = H(
            y1=1,
            y2=0,
            x=4.50 - skyCle,
            x_small=d);
          b7 = H(
            y1=1,
            y2=0,
            x=6.20 - skyCle,
            x_small=d);
          b8 = H(
            y1=1,
            y2=0,
            x=skyCle - 6.20,
            x_small=d);

          a1 = b1;
          a2 = b2 - b1;
          a3 = b3 - b2;
          a4 = b4 - b3;
          a5 = b5 - b4;
          a6 = b6 - b5;
          a7 = b7 - b6;
          a8 = b8;

          F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
            a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
          F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
            a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
          F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
            a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
          F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
            a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
          F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
            a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
          F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
            a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
          F1 = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            F11 + F12*skyBri + F13*zen,
            0.01);
          F2 = F21 + F22*skyBri + F23*zen;
          annotation (
            defaultComponentName="briCoe",
            Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-96,72},{-52,50}},
                  lineColor={0,0,127},
                  textString="skyCle"),
                Text(
                  extent={{-96,14},{-52,-8}},
                  lineColor={0,0,127},
                  textString="skyBri"),
                Text(
                  extent={{-96,-46},{-52,-68}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{62,50},{106,28}},
                  lineColor={0,0,127},
                  textString="F1"),
                Text(
                  extent={{60,-30},{104,-52}},
                  lineColor={0,0,127},
                  textString="F2")}));
        end BrighteningCoefficient;

        block DiffusePerez
          "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
          extends Modelica.Blocks.Icons.Block;
          parameter Real rho=0.2 "Ground reflectance";
          parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt angle";
          Modelica.Blocks.Interfaces.RealInput briCof1 "Brightening Coeffcient F1"
            annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput briCof2 "Brightening Coeffcient F2"
            annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Diffuse horizontal solar radiation"
            annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Global horizontal radiation"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Solar incidence angle on the surface"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));

          Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
      protected
          Real a;
          Real b;
          constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
            "Lower bound for b";
        equation
          a = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            Modelica.Math.cos(incAng),
            0.01);
          b = Buildings.Utilities.Math.Functions.smoothMax(
            bMin,
            Modelica.Math.cos(zen),
            0.01);
          HSkyDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
            briCof1*a/b + briCof2*Modelica.Math.sin(til));
          HGroDifTil = HGloHor*0.5*rho*(1 - Modelica.Math.cos(til));

          annotation (
            defaultComponentName="HDifTil",
            Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contribution from the sky and the ground.
</li>
</ul>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,74},{-100,86}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-50,44},{-102,56}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-50,14},{-102,26}},
                  lineColor={0,0,127},
                  textString="briCof1"),
                Text(
                  extent={{-50,-16},{-102,-4}},
                  lineColor={0,0,127},
                  textString="briCof2"),
                Text(
                  extent={{-50,-46},{-102,-34}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-52,-76},{-104,-64}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DiffusePerez;

        block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Incidence angle of the sun beam on a tilted surface"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Direct normal radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Direct solar irradiation on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          HDirTil =  max(0, Modelica.Math.cos(incAng)*HDirNor);
          annotation (
            defaultComponentName="HDirTil",
            Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-50,56},{-102,68}},
                  lineColor={0,0,127},
                  textString="HDirNor"),
                Text(
                  extent={{-54,-66},{-106,-54}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DirectTiltedSurface;

        partial block PartialSolarIrradiation
          "Partial model that is used to compute the direct and diffuse solar irradiation"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt";
          Modelica.Blocks.Interfaces.RealOutput H(
             final quantity="RadiantEnergyFluenceRate",
             final unit="W/m2") "Radiation per unit area"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          WeatherData.Bus weaBus "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          annotation (
            Documentation(info="<html>
<p>
This is a partial model that is used to implement the direct and diffuse irradiation.
</p>
</html>",         revisions="<html>
<ul>
<li>
Dec. 12, 2010, by Michael Wetter:<br/>
Changed output signal to avoid ambiguity in blocks that output also other
quantities such as the incidence angle.
</li>
<li>
Sep. 4, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialSolarIrradiation;

        block RelativeAirMass "Relative air mass"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real zenLim "Zenith angle bounded from above by 90 degree";
          Real zenDeg "Zenith angle in degree";
        equation
          zenLim = Buildings.Utilities.Math.Functions.smoothMin(
            zen,
            Modelica.Constants.pi/2,
            0.01);
          zenDeg = zenLim*180/Modelica.Constants.pi;
          relAirMas = 1/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
          annotation (
            defaultComponentName="relAirMas",
            Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.<br/>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end RelativeAirMass;

        block SkyBrightness "Sky brightness"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealOutput skyBri "Sky brightness"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          skyBri = Buildings.Utilities.Math.Functions.smoothMin(
            HDifHor*relAirMas/1367,
            1,
            0.025);
          annotation (
            defaultComponentName="skyBri",
            Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,36},{-96,48}},
                  lineColor={0,0,127},
                  textString="relAirMas"),
                Text(
                  extent={{-44,-46},{-96,-34}},
                  lineColor={0,0,127},
                  textString="HDifHor")}));
        end SkyBrightness;

        block SkyClearness "Sky clearness"
          extends Modelica.Blocks.Icons.Block;

          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degreeC") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal global solar radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput skyCle
            "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          // Set hSmall so that hSmall + deltaX < 1E-4. See info section.
      protected
          constant Modelica.SIunits.Irradiance hSmall = 0.5e-4
            "Small radiation for regularization";
          constant Modelica.SIunits.Irradiance deltaX = hSmall/2
            "Small radiation for regularization";
          constant Real k = 5.534e-6*(180/Modelica.Constants.pi)^3 "Constant factor";
          Real tmp1 "Intermediate variable";
          Modelica.SIunits.Irradiance HDifHorBou
            "Diffuse horizontal irradiation, bounded away from zero";
        equation
          tmp1 =  k*zen^3;
          HDifHorBou = Buildings.Utilities.Math.Functions.smoothMax(
                         x1 = HDifHor,
                         x2 = hSmall,
                         deltaX = deltaX);
          // In the Buildings library, HGloHor is always larger than 1E-4
          // (minus some small undershoot due to regularization. Hence,
          // it makes no sense to simplify the equation for
          // HGloHor < Modelica.Constants.small.
          skyCle = Buildings.Utilities.Math.Functions.smoothLimit(
                x = (HGloHor/HDifHorBou + tmp1)/(1 + tmp1),
                l = 1,
                u = 8,
                deltaX = 0.01);

          annotation (
            defaultComponentName="skyCle",
            Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
<h4>Implementation</h4>
<p>
In the <code>Buildings</code> library, <code>HGloHor</code>
is always larger than <i>1E-4</i>,
minus some small undershoot due to regularization. Hence,
the implementation is not simplified for
<code>HGloHor &lt; Modelica.Constants.small</code>.
</p>
<p>
The function call
<code>Buildings.Utilities.Math.Functions.smoothMax</code>
is such that the regularization is usually not triggered.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 23, 2016, by Michael Wetter:<br/>
Changed <code>deltaX</code> from <code>0.1</code> to <code>0.01</code>,
and also optimized the code.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/521\">issue 521</a>.
</li>
<li>
May 5, 2015, by Michael Wetter:<br/>
Introduced constant <code>k</code> to reduce number of operations.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,-6},{-100,6}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-48,54},{-100,66}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-48,-66},{-100,-54}},
                  lineColor={0,0,127},
                  textString="zen")}));
        end SkyClearness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">Buildings.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models that compute the solar irradiation
with different sky models.
</html>"));
    end SolarIrradiation;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;

        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      block ReaderTMY3 "Reader for TMY3 weather data"

        Bus weaBus "Weather data bus" annotation (Placement(transformation(extent={{
                  290,-10},{310,10}}), iconTransformation(extent={{190,-10},{210,10}})));

        //--------------------------------------------------------------
        parameter String filNam="" "Name of weather data file" annotation (
          Dialog(loadSelector(filter="Weather files (*.mos)",
                              caption="Select weather file")));

        parameter Boolean computeWetBulbTemperature = true
          "If true, then this model computes the wet bulb temperature"
          annotation(Evaluate=true);

        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter Buildings.BoundaryConditions.Types.DataSource pAtmSou=Buildings.BoundaryConditions.Types.DataSource.Parameter
          "Atmospheric pressure"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Pressure pAtm=101325
          "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input pressure"
          annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
              iconTransformation(extent={{-240,254},{-200,294}})));

        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDryBulSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dry bulb temperature"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Temperature TDryBul(displayUnit="degC") = 293.15
          "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,160},{-200,200}})));

        //--------------------------------------------------------------
        // Dew point temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDewPoiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dew point temperature"
          annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Temperature TDewPoi(displayUnit="degC") = 283.15
          "Dew point temperature (used if TDewPoi=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDewPoiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dew point temperature"
          annotation (Placement(transformation(extent={{-240,204},{-200,244}})));

        //--------------------------------------------------------------
        // Black body sky temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TBlaSkySou=Buildings.BoundaryConditions.Types.DataSource.File
          "Black-body sky temperature" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Temperature TBlaSky=273.15
          "Black-body sky temperature (used if TBlaSkySou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") if
          (TBlaSkySou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Black-body sky temperature"
          annotation (Placement(transformation(extent={{-240,120},{-200,160}}),
              iconTransformation(extent={{-240,120},{-200,160}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter Buildings.BoundaryConditions.Types.DataSource relHumSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Relative humidity" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,80},{-200,120}}),
              iconTransformation(extent={{-240,80},{-200,120}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter Buildings.BoundaryConditions.Types.DataSource winSpeSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind speed" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Velocity winSpe(min=0) = 1
          "Wind speed (used if winSpe=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0) if (winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind speed"
          annotation (Placement(transformation(extent={{-240,-98},{-200,-58}}),
              iconTransformation(extent={{-240,-98},{-200,-58}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter Buildings.BoundaryConditions.Types.DataSource winDirSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind direction" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.Angle winDir=1.0
          "Wind direction (used if winDir=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
              iconTransformation(extent={{-240,-140},{-200,-100}})));
        //--------------------------------------------------------------
        // Infrared horizontal radiation
        parameter Buildings.BoundaryConditions.Types.DataSource HInfHorSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Infrared horizontal radiation" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Modelica.SIunits.HeatFlux HInfHor=0.0
          "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput HInfHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HInfHorSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input infrared horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-180},{-200,-140}}),
              iconTransformation(extent={{-240,-180},{-200,-140}})));

         parameter Buildings.BoundaryConditions.Types.RadiationDataSource HSou=Buildings.BoundaryConditions.Types.RadiationDataSource.File
          "Global, diffuse, and direct normal radiation"
           annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        //--------------------------------------------------------------
        // Global horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if
               (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
              iconTransformation(extent={{-240,-280},{-200,-240}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if
               (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
          "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-240},{-200,-200}}),
              iconTransformation(extent={{-240,-210},{-200,-170}})));
        //--------------------------------------------------------------
        // Direct normal radiation
        Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
               (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or
                HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input direct normal radiation"
          annotation (Placement(transformation(extent={{-240,-280},{-200,-240}}),
              iconTransformation(extent={{-240,-240},{-200,-200}})));

      //--------------------------------------------------------------
        // Ceiling height
        parameter Buildings.BoundaryConditions.Types.DataSource ceiHeiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Ceiling height" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real ceiHei(
          final quantity="Height",
          final unit="m",
          displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput ceiHei_in(
          final quantity="Height",
          final unit="m",
          displayUnit="m") if (ceiHeiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input ceiling height"
          annotation (Placement(transformation(extent={{-240,-10},{-200,30}}),
              iconTransformation(extent={{-240,-10},{-200,30}})));
        //--------------------------------------------------------------
        // Total sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource totSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Total sky cover" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real totSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
          min=0,
          max=1,
          unit="1") if (totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input total sky cover"
          annotation (Placement(transformation(extent={{-240,-58},{-200,-18}}),
              iconTransformation(extent={{-240,-58},{-200,-18}})));
        // Opaque sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource opaSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Opaque sky cover" annotation (Evaluate=true, HideResult=true, Dialog(tab="Data source"));
        parameter Real opaSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
          annotation (Dialog(tab="Data source"));
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
          min=0,
          max=1,
          unit="1") if (opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input opaque sky cover"
          annotation (Placement(transformation(extent={{-240,32},{-200,72}}),
              iconTransformation(extent={{-240,32},{-200,72}})));

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Model choice for black-body sky temperature calculation" annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(tab="Advanced", group="Sky temperature"));

        final parameter Modelica.SIunits.Angle lon(displayUnit="deg")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
          filNam) "Longitude";
        final parameter Modelica.SIunits.Angle lat(displayUnit="deg")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
          filNam) "Latitude";
        final parameter Modelica.SIunits.Time timZon(displayUnit="h")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
          "Time zone";

    protected
        final parameter Modelica.SIunits.Time[2] timeSpan=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(filNam, "tab1")
        "Start time, end time of weather data";

        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          verboseRead=false,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30,8}) "Data reader"
          annotation (Placement(transformation(extent={{-70,-40},{-50,-20}})));

        BaseClasses.SourceSelector pAtmSel(
          final datSou=pAtmSou,
          final p=pAtm) "Source selection for atmospheric pressure"
          annotation (Placement(transformation(extent={{0,260},{20,280}})));
        BaseClasses.SourceSelector TDewPoiSel(
          final datSou=TDewPoiSou,
          final p=TDewPoi)
          "Source selection for dewpoint temperature pressure"
          annotation (Placement(transformation(extent={{92,-240},{112,-220}})));
        BaseClasses.SourceSelector TDryBulSel(
          final datSou=TDryBulSou,
          final p=TDryBul)
          "Source selection for drybulb temperature pressure"
          annotation (Placement(transformation(extent={{92,-200},{112,-180}})));
        BaseClasses.SourceSelector TBlaSkySel(
          final datSou=TBlaSkySou,
          final p=TBlaSky)
          "Source selection for sky black body radiation"
          annotation (Placement(transformation(extent={{240,-180},{260,-160}})));
        BaseClasses.SourceSelector relHumSel(
          final datSou=relHumSou,
          final p=relHum)
          "Source selection for relative humidity"
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.SourceSelector opaSkyCovSel(
          final datSou=opaSkyCovSou,
          final p=opaSkyCov)
          "Source selection for opaque sky cover"
          annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
        BaseClasses.SourceSelector ceiHeiSel(
          final datSou=ceiHeiSou,
          final p=ceiHei)
          "Source selection for ceiling height"
          annotation (Placement(transformation(extent={{120,-120},{140,-100}})));
        BaseClasses.SourceSelector totSkyCovSel(
          final datSou=totSkyCovSou,
          final p=totSkyCov)
          "Source selection for total sky cover"
          annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
        BaseClasses.SourceSelector winSpeSel(
          final datSou=winSpeSou,
          final p=winSpe)
          "Source selection for wind speed"
          annotation (Placement(transformation(extent={{120,-80},{140,-60}})));
        BaseClasses.SourceSelector winDirSel(
          final datSou=winDirSou,
          final p=winDir)
          "Source selection for wind speed"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        BaseClasses.SourceSelector horInfRadSel(
          final datSou=HInfHorSou,
          final p=HInfHor)
          "Source selection for horizontal infrared radiation"
          annotation (Placement(transformation(extent={{120,60},{140,80}})));
        BaseClasses.SourceSelectorRadiation souSelRad(
          final datSou=HSou)
          "Source selection for solar irradiation"
          annotation (Placement(transformation(extent={{120,180},{140,200}})));

        BaseClasses.CheckDryBulbTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckDewPointTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        Modelica.Blocks.Math.Gain conRelHum(final k=0.01) if
             relHumSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{40,14},{60,34}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,260},{180,280}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterRelativeHumidity limRelHum
          "Limiter for relative humidity"
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterTotalSkyCover limTotSkyCov
          "Limits the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterOpaqueSkyCover limOpaSkyCov
          "Limits the opaque sky cover"
          annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterCeilingHeight limCeiHei "Limits the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterWindSpeed limWinSpe "Limits the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterHorizontalInfraredIrradiation limHorInfRad
          "Limits the horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LimiterWindDirection limWinDir
          "Limits the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSkyCom(final calTSky=calTSky) if
             TBlaSkySou == Buildings.BoundaryConditions.Types.DataSource.File
          "Computation of the black-body sky temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Buildings.Utilities.Time.ModelTime modTim "Model time"
          annotation (Placement(transformation(extent={{-160,-10},{-140,10}})));
        Modelica.Blocks.Math.Add add30Min
          "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-112,180},{-92,200}})));
        Modelica.Blocks.Sources.Constant con30Min(final k=1800)
          "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-160,186},{-140,206}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea30Min(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          verboseRead=false,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=9:11) "Data reader with 30 min offset for solar irradiation"
          annotation (Placement(transformation(extent={{-50,180},{-30,200}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTimMin(final
            weaDatStaTim=timeSpan[1], final weaDatEndTim=timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-80,180},{-60,200}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
          final weaDatStaTim = timeSpan[1],
          final weaDatEndTim = timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-88,-140},{-68,-120}})));


        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
          "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{40,-286},{60,-266}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{40,-200},{60,-180}})));


        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
          "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{40,-240},{60,-220}})));
        SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
          annotation (Placement(transformation(extent={{-28,-226},{-8,-206}})));
         SolarGeometry.BaseClasses.ZenithAngle zenAng(
           final lat = lat) "Zenith angle"
          annotation (Placement(transformation(extent={{-70,-226},{-50,-206}})));
         SolarGeometry.BaseClasses.Declination decAng "Declination angle"
          annotation (Placement(transformation(extent={{-120,-220},{-100,-200}})));
         SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-120,-250},{-100,-230}})));
        Latitude latitude(final latitude=lat) "Latitude"
          annotation (Placement(transformation(extent={{-150,-290},{-130,-270}})));
        Longitude longitude(final longitude=lon) "Longitude"
          annotation (Placement(transformation(extent={{-120,-282},{-100,-262}})));

        //---------------------------------------------------------------------------
        // Optional instanciation of a block that computes the wet bulb temperature.
        // This block may be needed for evaporative cooling towers.
        // By default, it is enabled. This introduces a nonlinear equation, but
        // we have not observed an increase in computing time because of this equation.
        Buildings.Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(
            redeclare package Medium = Buildings.Media.Air,
            TDryBul(displayUnit="degC")) if computeWetBulbTemperature
          annotation (Placement(transformation(extent={{240,-60},{260,-40}})));

        //---------------------------------------------------------------------------
        // Conversion blocks for sky cover
        Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1) if
             totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
        Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1) if
             opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{40,-166},{60,-146}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature cheTemBlaSky(TMin=0)
          "Check black body sky temperature"
          annotation (Placement(transformation(extent={{240,-140},{260,-120}})));

        // Blocks that are added in order to set the name of the output signal,
        // which then is displayed in the GUI of the weather data connector.
        block Latitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Angle latitude "Latitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Latitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = latitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Latitude")}),
          Documentation(info="<html>
<p>
Block to output the latitude of the location.
This block is added so that the latitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the latitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Latitude;

        block Longitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Angle longitude "Longitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Longitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = longitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Longitude")}),
          Documentation(info="<html>
<p>
Block to output the longitude of the location.
This block is added so that the longitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the longitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Longitude;

      equation

        connect(modTim.y, add30Min.u2) annotation (Line(points={{-139,0},{-128,0},{-128,
                184},{-114,184}}, color={0,0,127}));
        connect(con30Min.y, add30Min.u1)
          annotation (Line(points={{-139,196},{-114,196}}, color={0,0,127}));
        connect(add30Min.y, conTimMin.modTim)
          annotation (Line(points={{-91,190},{-82,190}}, color={0,0,127}));
        connect(conTimMin.calTim, datRea30Min.u)
          annotation (Line(points={{-59,190},{-52,190}}, color={0,0,127}));
        connect(modTim.y, locTim.cloTim) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-150},{-122,-150}},
            color={0,0,127}));
        connect(modTim.y, conTim.modTim) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-30},{-102,-30}},
            color={0,0,127}));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-79,-30},{-72,-30}},
            color={0,0,127}));
        connect(modTim.y, eqnTim.nDay) annotation (Line(
            points={{-139,6.10623e-16},{-128,6.10623e-16},{-128,-110},{-122,-110}},
            color={0,0,127}));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-94,-110},{-94,-124},{-90,-124}},
            color={0,0,127}));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-96,-150},{-96,-135.4},{-90,-135.4}},
            color={0,0,127}));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-276},{38,-276}},
            color={0,0,127}));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-190},{38,-190}},
            color={0,0,127}));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-49,-30},{20,-30},{20,-230},{38,-230}},
            color={0,0,127}));
        connect(conRelHum.u, datRea.y[3]) annotation (Line(points={{38,24},{20,24},{20,
                -30},{-49,-30}},    color={0,0,127}));

        connect(decAng.decAng, zenAng.decAng)
                                        annotation (Line(
            points={{-99,-210},{-72,-210},{-72,-210.6}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, zenAng.solHouAng)  annotation (Line(
            points={{-99,-240},{-80,-240},{-80,-220.8},{-72,-220.8}},
            color={0,0,127}));
        connect(solHouAng.solTim, solTim.solTim) annotation (Line(
            points={{-122,-240},{-140,-240},{-140,-174},{-10,-174},{-10,-130},{-67,-130}},
            color={0,0,127}));
        connect(decAng.nDay, modTim.y) annotation (Line(
            points={{-122,-210},{-134,-210},{-134,-180},{0,-180},{0,6.10623e-16},{-139,
                6.10623e-16}},
            color={0,0,127}));
        connect(zenAng.zen, altAng.zen) annotation (Line(
            points={{-49,-216},{-30,-216}},
            color={0,0,127}));

        connect(limOpaSkyCov.nOpa, TBlaSkyCom.nOpa) annotation (Line(points={{181,-150},
                {220,-150},{220,-213},{238,-213}}, color={0,0,127}));
        connect(limRelHum.relHum, tWetBul_TDryBulXi.phi) annotation (Line(points={{181,30},
                {220,30},{220,-50},{239,-50}}, color={0,0,127}));

        connect(pAtmSel.y, chePre.PIn)
          annotation (Line(points={{21,270},{158,270}},   color={0,0,127}));
        connect(pAtmSel.uCon, pAtm_in) annotation (Line(points={{-1,278},{-110,278},{-110,
                274},{-220,274}}, color={0,0,127}));
        connect(datRea.y[4], pAtmSel.uFil) annotation (Line(points={{-49,-30},{-20,-30},
                {-20,262},{-1,262}}, color={0,0,127}));
        connect(cheTemDewPoi.TIn, TDewPoiSel.y)
          annotation (Line(points={{158,-230},{113,-230}}, color={0,0,127}));
        connect(TDewPoiSel.uFil, conTDewPoi.y) annotation (Line(points={{91,-238},{76,
                -238},{76,-230},{61,-230}}, color={0,0,127}));
        connect(TDewPoiSel.uCon, TDewPoi_in) annotation (Line(points={{91,-222},{82,-222},
                {82,146},{-168,146},{-168,224},{-220,224}}, color={0,0,127}));
        connect(TDryBulSel.y, cheTemDryBul.TIn)
          annotation (Line(points={{113,-190},{158,-190}}, color={0,0,127}));
        connect(TDryBulSel.uFil, conTDryBul.y) annotation (Line(points={{91,-198},{70,
                -198},{70,-190},{61,-190}}, color={0,0,127}));
        connect(TDryBulSel.uCon, TDryBul_in) annotation (Line(points={{91,-182},{78,-182},
                {78,142},{-176,142},{-176,180},{-220,180}}, color={0,0,127}));

        connect(TBlaSkySel.y, cheTemBlaSky.TIn) annotation (Line(points={{261,-170},{270,
                -170},{270,-148},{230,-148},{230,-130},{238,-130}}, color={0,0,127}));
        connect(TBlaSkyCom.TBlaSky, TBlaSkySel.uFil) annotation (Line(points={{261,-210},
                {268,-210},{268,-186},{232,-186},{232,-178},{239,-178}}, color={0,0,127}));
        connect(TBlaSky_in, TBlaSkySel.uCon) annotation (Line(points={{-220,140},{74,140},
                {74,-168},{228,-168},{228,-162},{239,-162}}, color={0,0,127}));
        connect(relHumSel.y, limRelHum.u)
          annotation (Line(points={{141,30},{158,30}}, color={0,0,127}));
        connect(relHumSel.uFil, conRelHum.y)
          annotation (Line(points={{119,22},{90,22},{90,24},{61,24}},
                                                       color={0,0,127}));
        connect(relHum_in, relHumSel.uCon) annotation (Line(points={{-220,100},{110,100},
                {110,38},{119,38}}, color={0,0,127}));
        connect(conOpaSkyCov.y, opaSkyCovSel.uFil)
          annotation (Line(points={{61,-156},{90,-156},{90,-158},{119,-158}},
                                                          color={0,0,127}));
        connect(opaSkyCov_in, opaSkyCovSel.uCon) annotation (Line(points={{-220,52},{70,
                52},{70,-142},{119,-142}}, color={0,0,127}));
        connect(ceiHeiSel.y, limCeiHei.u)
          annotation (Line(points={{141,-110},{158,-110}}, color={0,0,127}));
        connect(ceiHeiSel.uFil, datRea.y[16]) annotation (Line(points={{119,-118},{20,
                -118},{20,-30},{-49,-30}}, color={0,0,127}));
        connect(ceiHeiSel.uCon, ceiHei_in) annotation (Line(points={{119,-102},{-40,-102},
                {-40,-90},{-180,-90},{-180,10},{-220,10}}, color={0,0,127}));
        connect(totSkyCovSel.uFil, conTotSkyCov.y) annotation (Line(points={{119,-38},
                {100,-38},{100,-30},{61,-30}}, color={0,0,127}));
        connect(totSkyCovSel.uCon, totSkyCov_in) annotation (Line(points={{119,-22},{108,
                -22},{108,-50},{-190,-50},{-190,-38},{-220,-38}}, color={0,0,127}));
        connect(totSkyCovSel.y, limTotSkyCov.u)
          annotation (Line(points={{141,-30},{158,-30}}, color={0,0,127}));
        connect(winSpeSel.y, limWinSpe.u)
          annotation (Line(points={{141,-70},{158,-70}}, color={0,0,127}));
        connect(conTotSkyCov.u, datRea.y[13])
          annotation (Line(points={{38,-30},{-49,-30}}, color={0,0,127}));
        connect(winSpeSel.uFil, datRea.y[12]) annotation (Line(points={{119,-78},{-20,
                -78},{-20,-30},{-49,-30}}, color={0,0,127}));
        connect(winSpeSel.uCon, winSpe_in) annotation (Line(points={{119,-62},{-190,-62},
                {-190,-78},{-220,-78}}, color={0,0,127}));
        connect(winDirSel.y, limWinDir.u)
          annotation (Line(points={{141,-270},{158,-270}}, color={0,0,127}));
        connect(conWinDir.y, winDirSel.uFil)
          annotation (Line(points={{61,-276},{90,-276},{90,-278},{119,-278}},
                                                          color={0,0,127}));
        connect(winDirSel.uCon, winDir_in) annotation (Line(points={{119,-262},{66,-262},
                {66,-80},{-190,-80},{-190,-120},{-220,-120}}, color={0,0,127}));
        connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(points={{38,-156},{20,-156},
                {20,-30},{-49,-30}},       color={0,0,127}));
        connect(horInfRadSel.y, limHorInfRad.u) annotation (Line(points={{141,70},{158,
                70}},                      color={0,0,127}));
        connect(horInfRadSel.uFil, datRea.y[26]) annotation (Line(points={{119,62},{20,
                62},{20,-30},{-49,-30}},  color={0,0,127}));
        connect(horInfRadSel.uCon, HInfHor_in) annotation (Line(points={{119,78},{-174,
                78},{-174,-160},{-220,-160}},  color={0,0,127}));

        connect(souSelRad.HDifHorFil, datRea30Min.y[3]) annotation (Line(points={{119,199},
                {44,199},{44,190},{-29,190}}, color={0,0,127}));
        connect(souSelRad.HDifHorIn, HDifHor_in) annotation (Line(points={{119,196},{
                98,196},{98,166},{-170,166},{-170,-220},{-220,-220}},
                                                                   color={0,0,127}));
        connect(souSelRad.HDirNorFil, datRea30Min.y[2]) annotation (Line(points={{119,192},
                {44,192},{44,190},{-29,190}}, color={0,0,127}));
        connect(souSelRad.HDirNorIn, HDirNor_in) annotation (Line(points={{119,188},{
                100,188},{100,160},{-168,160},{-168,-260},{-220,-260}},
                                                                    color={0,0,127}));
        connect(souSelRad.HGloHorIn, HGloHor_in) annotation (Line(points={{119,181},{
                102,181},{102,156},{-164,156},{-164,-300},{-220,-300}},
                                                                    color={0,0,127}));
        connect(souSelRad.zen, zenAng.zen) annotation (Line(points={{124,179},{124,
                152},{-40,152},{-40,-216},{-49,-216}},
                                                  color={0,0,127}));
        connect(souSelRad.HGloHorFil, datRea30Min.y[1]) annotation (Line(points={{119,
                184},{44,184},{44,190},{-29,190}}, color={0,0,127}));

        connect(TBlaSkyCom.HHorIR, limHorInfRad.HHorIR) annotation (Line(points={{238,
                -218},{220,-218},{220,70},{181,70}}, color={0,0,127}));

        connect(opaSkyCovSel.y, limOpaSkyCov.u)
          annotation (Line(points={{141,-150},{158,-150}}, color={0,0,127}));
        connect(cheTemDryBul.TDryBul, TBlaSkyCom.TDryBul) annotation (Line(points={{
                181,-190},{220,-190},{220,-202},{238,-202}}, color={0,0,127}));
        connect(cheTemDryBul.TDryBul, tWetBul_TDryBulXi.TDryBul) annotation (Line(
              points={{181,-190},{220,-190},{220,-42},{239,-42}}, color={0,0,127}));

        connect(chePre.pAtm, tWetBul_TDryBulXi.p) annotation (Line(points={{181,270},
                {220,270},{220,-58},{239,-58}}, color={0,0,127}));

        connect(cheTemDewPoi.TDewPoi, TBlaSkyCom.TDewPoi) annotation (Line(points={{
                181,-230},{220,-230},{220,-207},{238,-207}}, color={0,0,127}));

        // Connections to weather data bus
        connect(cheTemDryBul.TDryBul, weaBus.TDryBul) annotation (Line(points={{181,
                -190},{220,-190},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(cheTemDewPoi.TDewPoi, weaBus.TDewPoi) annotation (Line(points={{181,
                -230},{280,-230},{280,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{261,-50},{280,-50},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(limRelHum.relHum, weaBus.relHum) annotation (Line(points={{181,30},{280,30},
                {280,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(souSelRad.HDirNor, weaBus.HDirNor) annotation (Line(points={{141,190},
                {220,190},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(souSelRad.HDifHor, weaBus.HDifHor) annotation (Line(points={{141,
                197.8},{220,197.8},{220,0},{300,0}},
                                              color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(souSelRad.HGloHor, weaBus.HGloHor) annotation (Line(points={{141,182},
                {220,182},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(cheTemBlaSky.TBlaSky, weaBus.TBlaSky) annotation (Line(points={{261,
                -130},{280,-130},{280,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(limHorInfRad.HHorIR, weaBus.HHorIR) annotation (Line(points={{181,70},
                {220,70},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limWinSpe.winSpe, weaBus.winSpe) annotation (Line(points={{181,-70},{220,
                -70},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limWinDir.winDir, weaBus.winDir) annotation (Line(points={{181,-270},{280,
                -270},{280,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(limCeiHei.ceiHei, weaBus.ceiHei) annotation (Line(points={{181,-110},{
                220,-110},{220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

        connect(limTotSkyCov.nTot, weaBus.nTot) annotation (Line(points={{181,-30},{220,
                -30},{220,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(limOpaSkyCov.nOpa, weaBus.nOpa) annotation (Line(points={{181,-150},{220,
                -150},{220,0},{300,0}}, color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(modTim.y, weaBus.cloTim) annotation (Line(
            points={{-139,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-67,-130},{-10,-130},{-10,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(altAng.alt, weaBus.solAlt) annotation (Line(
            points={{-7,-216},{0,-216},{0,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(zenAng.zen, weaBus.solZen) annotation (Line(
            points={{-49,-216},{-40,-216},{-40,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(decAng.decAng, weaBus.solDec) annotation (Line(
            points={{-99,-210},{-90,-210},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
            points={{-99,-240},{-90,-240},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(longitude.y, weaBus.lon) annotation (Line(
            points={{-99,-272},{-90,-272},{-90,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(latitude.y, weaBus.lat) annotation (Line(
            points={{-129,-280},{-124,-280},{-124,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));

        connect(chePre.pAtm, weaBus.pAtm) annotation (Line(points={{181,270},{220,270},
                {220,0},{300,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));

          annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={124,142,255},
                fillColor={124,142,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                visible=(pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
              visible=(winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
              visible=(HSou ==  Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
              extent={{-202,-88},{-112,-108}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-202,-142},{-116,-164}},
                lineColor={0,0,127},
                textString="HDifHor"),
              Text(
              visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-200,-186},{-126,-214}},
                lineColor={0,0,127},
                textString="HDirNor"),
              Ellipse(
                extent={{-146,154},{28,-20}},
                lineColor={255,220,220},
                lineThickness=1,
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,0}),
              Polygon(
                points={{94,106},{77.9727,42.9844},{78,42},{110,52},{138,50},{164,38},
                    {182,-28},{138,-102},{10,-110},{-140,-106},{-166,-30},{-150,24},{-102,
                    26},{-78.2109,8.1582},{-78,8},{-92,70},{-58,120},{34,140},{94,106}},
                lineColor={220,220,220},
                lineThickness=0.1,
                fillPattern=FillPattern.Sphere,
                smooth=Smooth.Bezier,
                fillColor={230,230,230}),
              Text(
                extent={{140,-106},{-126,-192}},
                lineColor={255,255,255},
                textString=DynamicSelect("", String(weaBus.TDryBul-273.15, format=".1f")))}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The Modelica built-in variable <code>time</code> determines what row
of the weather file is read.
The value of <code>time</code> is the number of seconds
that have passed since January 1st at midnight (00:00) in the local time zone.
The local time zone value, longitude and latitute are also read from the weather data,
such that the solar position computations are consistent with the weather data.
</p>
<p>
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>. These
data, which are in the EnergyPlus format, need to be converted as described
below.
</p>
<!-- ============================================== -->
<h4>Output to weaBus</h4>
<p>
The following variables serve as output and are accessible via <code>weaBus</code>:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Name
  </th>
  <th>Unit
  </th>
  <th>Description
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal diffuse solar radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifNor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Direct normal radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HGloHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal global radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HHorIR</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal infrared irradiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TBlaSky</code>
  </td>
  <td>
    K
  </td>
  <td>
    Output temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDewPoi</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dew point temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDryBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dry bulb temperature at ground level.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TWetBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Wet bulb temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>celHei</code>
  </td>
  <td>
    m
  </td>
  <td>
    Ceiling height.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>cloTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    One-based day number in seconds.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lat</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Latitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lon</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Longitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nOpa</code>
  </td>
  <td>
    1
  </td>
  <td>
  Opaque sky cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nTot</code>
  </td>
  <td>
    1
  </td>
  <td>
   Total sky Cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>pAtm</code>
  </td>
  <td>
    Pa
  </td>
  <td>
    Atmospheric pressure.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>relHum</code>
  </td>
  <td>
    1
  </td>
  <td>
    Relative humidity.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solAlt</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Altitude angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solDec</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Declination angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solHouAng</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Solar hour angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    Solar time.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solZen</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Zenith angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winDir</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Wind direction.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winSpe</code>
  </td>
  <td>
    m/s
  </td>
  <td>
    Wind speed.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>.
</li>
<li>
Add the file to <code>Buildings/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd Buildings/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
  if inputFile contains space in the name:
<pre>
  java -jar ../bin/ConvertWeatherData.jar \"inputFile .epw\"
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover,
</li>
<li>
the opaque sky cover,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the sky black body temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, temperatures, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.DataSource\">
Buildings.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.RadiationDataSource\">
Buildings.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Length of weather data and simulation period</h4>
<p>
If weather data span a year, which is the default for TMY3 data, or multiple years,
then this model can be used for simulations that span multiple years. The simulation
start time needs to be set to the clock time of the respective start time. For example,
to start at January 2 at 10am, set start time to <code>t=(24+10)*3600</code> seconds.
For this computation, the used date and time (here January 2, 10 am) must be expressed in the same time zone
as the one that is used to define the TMY3 file. This is usually the local (winter) time zone.
The parameter `timZon` represents the TMY3 file time zone, expressed in seconds compared to UTC.
</p>
<p>
Moreover, weather data need not span a whole year, or it can span across New Year.
In this case, the simulation cannot exceed the time of the weather data file. Otherwise,
the simulation stops with an error.
</p>
<p>
As weather data have one entry at the start of the time interval, the end time of the weather
data file is computed as the last time entry plus the average time increment of the file.
For example, an hourly weather data file has 8760 entries, starting on January 1 at 0:00.
The last entry in the file will be for December 31 at 23:00. As the time increment is 1 hour,
the model assumes the weather file to end at December 31 at 23:00 plus 1 hour, e.g., at January 1 at 0:00.
</p>
<!-- ============================================== -->
<h4>Notes</h4>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
<p>
Hourly and subhourly timestamp are handled in a different way in <code>.epw</code> files.
From the EnergyPlus Auxiliary Programs Document (v9.3.0, p. 63):
In hourly data the minute field can be <code>00</code> or <code>60</code>. In this case as mentioned in the previous section, the weather data
is reported at the hourly value and the minute field has to be ignored, writing <code>1, 60</code> or <code>1, 00</code> is equivalent.
If the minute field is between <code>00</code> and <code>60</code>, the file becomes subhourly, in this case the timestamp corresponds to the
minute field in the considered hour. For example: <code>1, 30</code> is equivalent to <i>00:30</i> and <code>3, 45</code> is equivalent to <i>02:45</i>.<br/>
(Note the offset in the hour digit.)
</p>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the Buildings library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program
<code>Buildings/Resources/bin/ConvertWeatherData.jar</code> that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
above.
The length of the weather data is calculated as the
end time stamp minus start time stamp plus average increment, where the
average increment is equal to the end time stamp minus start time stamp divided
by the number of rows minus 1.
This only works correctly for weather files with equidistant time stamps.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
October 4, 2020, by Ettore Zanetti:<br/>
Updated documentation for Java weather file generator.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1396\">#1396</a>.
</li>
<li>
August 20, 2019, by Filip Jorissen:<br/>
Better clarified the meaning of <code>time</code> in the documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1192\">#1192</a>.
</li>
<li>
March 5, 2019, by Michael Wetter:<br/>
Updated documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
September 20, 2018, by Michael Wetter:<br/>
Corrected documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1022\">#1022</a>.
</li>
<li>
December 4, 2017, by Michael Wetter:<br/>
Removed function call to <code>getAbsolutePath</code>, as this causes in Dymola 2018FD01
the error
\"A call of loadResource with a non-literal string remains in the generated code; it will not work for an URI.\"
when exporting <a href=\"modelica://Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone\">
Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone</a>
as an FMU. Instead, if the weather file is specified as a Modelica, URI, syntax such as
<code>Modelica.Utilities.Files.loadResource(\"modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos\")</code>
should be used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/867\">#867</a>.
</li>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Infrared radiation on horizontal surface is now delayed by 30 minutes
such that the results in
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature.Examples.BlackBody\">TBlaSky</a>
are consistent.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
Constrained the direct normal radiation to not be bigger than the solar constant when using
global and diffuse solar radiation data provided via the inputs connectors.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/608\">#608</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed output <code>radHorIR</code> to <code>HHorIR</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
January 4, 2016, by Moritz Lauster:<br/>
Added a table in documentation with output variables accessible via <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
December 15, 2015, by Michael Wetter:<br/>
Added the block <code>cheTemBlaSky</code>. This also allows to graphically
connect the black body sky temperature to the weather bus, which is required
in Dymola 2016 for the variable <code>weaBus.TBlaSky</code> to appear
in the graphical editor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/377\">#377</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed redundant but consistent
<code>connect(TBlaSkyCom.TBlaSky, weaBus.TBlaSky)</code>
statement.
This avoids a warning if
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness\">
Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness</a>
is translated in pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
March 26, 2015, by Michael Wetter:<br/>
Added option to obtain the black body sky temperature
from a parameter or an input signal.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://Buildings</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
<ol>
<li>
Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
</li>
<li>
Separate the unit conversion for TMY3 data and data validity check.
</li>
</ol>
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false,
           extent={{-200,-300},{300,300}})));
      end ReaderTMY3;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckBlackBodySkyTemperature
          "Check the validity of the black-body sky temperature data"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Modelica.Blocks.Interfaces.RealOutput TBlaSky(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          TBlaSky = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax),
            "In " + getInstanceName() + ": Weather data black-body sky temperature out of bounds.\n" + "   TIn = " +
             String(TIn));

          annotation (
            defaultComponentName="cheSkyBlaBodTem",
            Documentation(info="<html>
<p>
This component checks the value of the black-body sky temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
January 5, 2015 by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature</a>.
This was implemented to get the corrected documentation string in the weather bus connector.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-20,-78},{20,-40}},
                  lineColor={99,17,20},
                  lineThickness=0.5,
                  fillColor={99,17,20},
                  fillPattern=FillPattern.Solid),
                Line(points={{-40,40},{-12,40}}),
                Line(points={{-40,10},{-12,10}}),
                Line(points={{-40,-20},{-12,-20}}),
                Rectangle(
                  extent={{-12,40},{12,-44}},
                  lineColor={99,17,20},
                  fillColor={99,17,20},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-12,40},{-12,60},{-10,66},{-6,68},{0,70},{6,68},{10,66},{12,
                      60},{12,40},{-12,40}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-45}},
                  thickness=0.5)}));
        end CheckBlackBodySkyTemperature;

        block CheckDewPointTemperature
          "Check the validity of the dew point temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TDewPoi(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Dew point temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

        equation
          TDewPoi = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
             ": Weather data dew point temperature out of bounds.\n" + "   TIn = " + String(
            TIn));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-22,-74},{18,-36}},
                  lineColor={0,0,127},
                  lineThickness=0.5,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Line(points={{-42,44},{-14,44}}),
                Line(points={{-42,14},{-14,14}}),
                Line(points={{-42,-16},{-14,-16}}),
                Rectangle(
                  extent={{-14,44},{10,-40}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-14,44},{-14,64},{-12,70},{-8,72},{-2,74},{4,72},{8,70},{10,64},
                      {10,44},{-14,44}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-14,44},{-14,-41}},
                  thickness=0.5)}));
        end CheckDewPointTemperature;

        block CheckDryBulbTemperature
          "Check the validity of the dry bulb temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TDryBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Dry bulb temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

        equation
          TDryBul = TIn;
          assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
             ": Weather data dry bulb temperature out of bounds.\n" + "   TIn = " + String(
            TIn));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of the dry bulb temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-18,-72},{22,-34}},
                  lineColor={0,0,0},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-38,46},{-10,46}}),
                Line(points={{-38,16},{-10,16}}),
                Line(points={{-38,-14},{-10,-14}}),
                Rectangle(
                  extent={{-10,46},{14,-38}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-10,46},{-10,66},{-8,72},{-4,74},{2,76},{8,74},{12,72},{14,66},
                      {14,46},{-10,46}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-10,46},{-10,-39}},
                  thickness=0.5)}));
        end CheckDryBulbTemperature;

        block CheckPressure
          "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput PIn(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput pAtm(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Pressure PMin=3100 "Minimum allowed pressure";
          constant Modelica.SIunits.Pressure PMax=120000 "Maximum allowed pressure";
        equation
          pAtm = PIn;
          assert(noEvent(PIn > PMin and PIn < PMax), "In " + getInstanceName() +
            ": Weather data atmospheric pressure out of bounds.\n" + "   PIn = " + String(PIn));

          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block ConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Time weaDatStaTim(displayUnit="d") "Start time of weather data";
          parameter Modelica.SIunits.Time weaDatEndTim(displayUnit="d") "End time of weather data";

          Modelica.Blocks.Interfaces.RealInput modTim(
            final quantity="Time",
            final unit="s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(
            final quantity="Time",
            final unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          constant Modelica.SIunits.Time shiftSolarRad=1800 "Number of seconds for the shift for solar radiation calculation";
          parameter Modelica.SIunits.Time lenWea = weaDatEndTim-weaDatStaTim "Length of weather data";

          parameter Boolean canRepeatWeatherFile = abs(mod(lenWea, 365*24*3600)) < 1E-2
            "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it";

          discrete Modelica.SIunits.Time tNext(start=0, fixed=true) "Start time of next period";

        equation
          when {initial(), canRepeatWeatherFile and modTim > pre(tNext)} then
            // simulation time stamp went over the end time of the weather file
            //(last time stamp of the weather file + average increment)
            tNext = if canRepeatWeatherFile then integer(modTim/lenWea)*lenWea + lenWea else time;
          end when;
          calTim = if canRepeatWeatherFile then modTim - tNext + lenWea else modTim;

          assert(canRepeatWeatherFile or noEvent((time - weaDatEndTim) < shiftSolarRad),
            "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "         + String(time) +
            " exceeds the end time " + String(weaDatEndTim) + " of the weather data file.",
            AssertionLevel.error);

          assert(canRepeatWeatherFile or noEvent(time >= weaDatStaTim),
            "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "         + String(time) +
            " is less than the start time " + String(weaDatStaTim) + " of the weather data file.",
            AssertionLevel.error);

          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 15, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> to assertion to remove zero crossing function in OPTIMICA.
</li>
<li>
January 29, 2020, by Filip Jorissen:<br/>
Revised end time assert and added assert that verifies whether the time is before the
start time of the weather file.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1281\">#1281</a>.
</li>
<li>
June 12, 2019, by Michael Wetter:<br/>
Reformulated model to avoid having to evaluate the weather file during compilation
(as it determined the structural parameter <code>lenWea</code>). The new formulation
allows inclusion of the weather file in JModelica-generated FMUs, and it works with
Dymola as well.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1147\">#1147</a>.
</li>
<li>
May 21, 2019, by Michael Wetter:<br/>
Corrected code to avoid wrong type conversion.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1142\">#1142</a>.
</li>
<li>
March 4, 2019, by Michael Wetter:<br/>
Refactored implementation to correctly account for negative start times.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
July 27, 2018, by Ana Constantin:<br/>
Added shift for multiple time spans.
</li>
<li>
September 27, 2011, by Wangda Zuo and Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when
conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  lineColor={0,0,127},
                  textString="modTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim"),
                Rectangle(
                  extent={{-66,76},{60,58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  fillColor={120,120,120}),
                Rectangle(extent={{-66,58},{60,-62}}, lineColor={0,0,0}),
                Line(
                  points={{-24,-62},{-24,58}}),
                Line(
                  points={{18,-62},{18,58}}),
                Line(
                  points={{60,28},{-66,28}}),
                Line(
                  points={{60,-2},{-66,-2}}),
                Line(
                  points={{60,-32},{-66,-32}})}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(
            quantity="Time",
            unit="s")
            "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real Bt "Intermediate variable";
        equation
          Bt = Modelica.Constants.pi*((nDay + 86400)/86400 - 81)/182
            "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civic time.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        block LimiterCeilingHeight "Block that limits the relative humidity"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput ceiHei(
            final unit="m") = max(0, u) "Cloud cover ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the cloud cover ceiling height to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterCeilingHeight;

        block LimiterHorizontalInfraredIrradiation
          "Block that limits the horizontal infrared irradiation"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput HHorIR(
            final unit="W/m2") = max(0, u) "Horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the horizontal infrared irradiation to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterHorizontalInfraredIrradiation;

        block LimiterOpaqueSkyCover "Block that limits the opaque sky cover"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput nOpa(
            final unit="1") "Opaque sky cover"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          nOpa = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the opaque sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterOpaqueSkyCover;

        block LimiterRelativeHumidity "Block that limits the relative humidity"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput relHum(
            final unit="1") "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          relHum = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the relative humidity.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterRelativeHumidity;

        block LimiterTotalSkyCover "Block that limits the total sky cover"
          extends PartialLimiter;

          Modelica.Blocks.Interfaces.RealOutput nTot(
            final unit="1") "Total sky cover"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          nTot = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the total sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterTotalSkyCover;

        block LimiterWindDirection "Block that limits the wind direction"
          extends PartialLimiter(
            final uMax=2*Modelica.Constants.pi);

          Modelica.Blocks.Interfaces.RealOutput winDir(
            final unit="rad") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          winDir = min(uMax, max(uMin, u));

          annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that limits the wind direction.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterWindDirection;

        block LimiterWindSpeed "Block that limits the wind speed"
          extends PartialLimiterMin;

          Modelica.Blocks.Interfaces.RealOutput winSpe(
            final unit="m/s") = max(0, u) "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Block that limits the wind speed to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimiterWindSpeed;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput cloTim(
            final quantity="Time",
            final unit="s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(
            final quantity="Time",
            final unit="s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          final parameter Modelica.SIunits.Time diff = - timZon + lon*43200/Modelica.Constants.pi
            "Difference between local and clock time";
        equation
          locTim = cloTim + diff;

          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",         revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
Introduced <code>diff</code>.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  lineColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        partial block PartialLimiter
          "Partial block to limit a signal"
          extends Modelica.Blocks.Icons.Block;

          constant Real uMin = 0 "Minimum value";
          constant Real uMax = 1 "Maximum value";

          Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal" annotation (Placement(
                transformation(extent={{-140,-20},{-100,20}})));

        annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that computes <i>y_internal=min(uMax, max(uMin, u))</i>,
where <code>y_internal</code> is a protected connector.
</p>
<p>
This block is used because interpolation of weather data can lead to
a slight overshoot of values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),   Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Line(points={{0,-90},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,0},{68,0}}, color={192,192,192}),
            Polygon(
              points={{90,0},{68,-8},{68,8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
            Text(
              extent={{-150,-150},{150,-110}},
                  textString="%uMin <= u <= %uMax",
                  lineColor={0,0,0})}),
            Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}})));
        end PartialLimiter;

        partial block PartialLimiterMin
          "Partial block to limit a signal"
          extends Modelica.Blocks.Icons.Block;

          Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal"
          annotation (Placement(
                transformation(extent={{-140,-20},{-100,20}})));

        annotation (
        defaultComponentName="limMin",
        Documentation(info="<html>
<p>
Partial block that is used to limit a signal by a minimum value.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Text(
                  extent={{-100,30},{98,-16}},
                  lineColor={0,0,0},
                  textString="0 <= u")}));
        end PartialLimiterMin;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
            "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
            "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solTim = locTim + equTim "Our unit is s in stead of h in (A.4.3)";

          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  lineColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  lineColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;

        block SourceSelector
          "Block that selects as its output either a parameter value or its input"
          extends Modelica.Blocks.Interfaces.SO;
          parameter Buildings.BoundaryConditions.Types.DataSource datSou "Data source"
            annotation(Evaluate=true);
          parameter Real p "Parameter value";
          Modelica.Blocks.Interfaces.RealInput uFil if
              datSou == Buildings.BoundaryConditions.Types.DataSource.File
            "Input signal from file reader"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
                iconTransformation(extent={{-120,-90},{-100,-70}})));
          Modelica.Blocks.Interfaces.RealInput uCon if
             datSou == Buildings.BoundaryConditions.Types.DataSource.Input
            "Input signal from input connector"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
                iconTransformation(extent={{-120,70},{-100,90}})));
        equation
          if datSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
            y = p;
          end if;
          connect(uCon, y);
          connect(uFil, y);
          annotation (
          defaultComponentName="souSel",
        Documentation(info="<html>
<p>
Block that produces at its output the input value <code>uCon</code>, <code>uFil</code>
or the parameter value <code>p</code> depending on the parameter value
<code>datSou</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
              Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{12,0},{100,0}},
                  color={0,0,127}),
                Line(points={{-100,-80},{-40,-80},{-40,-80}},
                  color={0,0,127}),
                Line(points={{-100,80},{-38,80}},
                  color={0,0,127}),
                Line(points={{-38,80},{6,2}},
                  color={0,0,127},
                  visible=datSou == Buildings.BoundaryConditions.Types.DataSource.File,
                  thickness=1),
                Line(points={{-40,-80},{8,0}},
                  color={0,0,127},
                  visible=datSou == Buildings.BoundaryConditions.Types.DataSource.Input,
                  thickness=1),
                Ellipse(lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{2,-8},{18,8}})}));
        end SourceSelector;

        block SourceSelectorRadiation
          "Block that selects the solar radiation source and outputs the solar radiation quantities"
          extends Modelica.Blocks.Icons.Block;
          parameter Buildings.BoundaryConditions.Types.RadiationDataSource datSou "Data source"
            annotation(Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput HDirNorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Direct normal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                    -10},{-100,30}}), iconTransformation(extent={{-120,10},{-100,30}})));

          Modelica.Blocks.Interfaces.RealInput HDirNorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
            "Direct normal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                    -40},{-100,0}}),  iconTransformation(extent={{-120,-30},{-100,-10}})));

          Modelica.Blocks.Interfaces.RealInput HDifHorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
             datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Diffuse horizontal solar irradiation from weather data file" annotation (Placement(transformation(
                  extent={{-140,60},{-100,100}}), iconTransformation(extent={{-120,80},{
                    -100,100}})));

          Modelica.Blocks.Interfaces.RealInput HDifHorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
             datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
             datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor
            "Diffuse horizontal solar irradiation from input connector" annotation (Placement(transformation(
                  extent={{-140,30},{-100,70}}),  iconTransformation(extent={{-120,50},{
                    -100,70}})));

          Modelica.Blocks.Interfaces.RealInput HGloHorFil(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.File
            "Global horizontal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                    -70},{-100,-30}}),        iconTransformation(extent={{-120,-70},{-100,
                    -50}})));

          Modelica.Blocks.Interfaces.RealInput HGloHorIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or
              datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
            "Global horizontal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                    -98},{-100,-58}}),        iconTransformation(extent={{-120,-100},{-100,
                    -80}})));

          Modelica.Blocks.Interfaces.RealInput zen(
            final quantity="Angle",
            final unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-60,-110})));

          Modelica.Blocks.Interfaces.RealOutput HDirNor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Direct normal solar irradiation" annotation (Placement(
                transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},
                    {120,10}})));
          Modelica.Blocks.Interfaces.RealOutput HDifHor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Diffuse horizontal solar irradiation" annotation (Placement(
                transformation(extent={{100,60},{120,80}}),  iconTransformation(extent={{100,68},
                    {120,88}})));
          Modelica.Blocks.Interfaces.RealOutput HGloHor(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
            "Global horizontal solar irradiation" annotation (Placement(
                transformation(extent={{100,-80},{120,-60}}),iconTransformation(extent={{100,-90},
                    {120,-70}})));

      protected
          constant Real epsCos = 1e-6 "Small value to avoid division by 0";
          constant Modelica.SIunits.HeatFlux solCon = 1367.7 "Solar constant";

          // Conditional connectors
          Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Needed to connect to conditional connector";

        equation
          // Conditional connect statements
          connect(HGloHor_in_internal, HGloHorFil);
          connect(HDifHor_in_internal, HDifHorFil);
          connect(HDirNor_in_internal, HDirNorFil);
          connect(HGloHor_in_internal, HGloHorIn);
          connect(HDifHor_in_internal, HDifHorIn);
          connect(HDirNor_in_internal, HDirNorIn);

          //---------------------------------------------------------------------------
          // Select global horizontal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
            HGloHor = max(0, HDirNor_in_internal*cos(zen)+HDifHor_in_internal)
              "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
            HGloHor_in_internal = 0;
          else
            HGloHor = max(0, HGloHor_in_internal)
              "Get HGloHor using weather data file or input connector of weather data reader";
          end if;

          //---------------------------------------------------------------------------
          // Select diffuse horizontal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
            HDifHor = max(0, HGloHor_in_internal - HDirNor_in_internal*cos(zen))
              "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
            HDifHor_in_internal = 0;
          else
            HDifHor = max(0, HDifHor_in_internal)
              "Get HDifHor using weather data file or input connector of weather data reader";
          end if;

          //---------------------------------------------------------------------------
          // Select direct normal radiation connector
          if datSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
              HDirNor = max(0, min(
                solCon,
                (HGloHor_in_internal -HDifHor_in_internal)*
                  Buildings.Utilities.Math.Functions.spliceFunction(
                    x=cos(zen),
                    pos=Buildings.Utilities.Math.Functions.inverseXRegularized(cos(zen), epsCos),
                    neg=0,
                    deltax=epsCos)))
              "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
            HDirNor_in_internal = 0;
          else
            HDirNor = max(0, HDirNor_in_internal)
              "Get HDirNor using weather data file or input connector of weather data reader";
          end if;

          annotation (
          defaultComponentName="souSel",
        Documentation(info="<html>
<p>
Block that outputs the direct normal, diffuse horizontal and diffuse global
solar irradiation.
This block computes these output quantities based on conditionally provided
input signals.
</p>
<p>
The computations are based on Wetter (2004).
</p>
<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
              Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{12,0},{100,0}},
                  color={0,0,127}),
                Line(points={{40,-80},{100,-80},{100,-80}},
                  color={0,0,127}),
                Line(points={{40,80},{100,78}},
                  color={0,0,127}),
                Line(points={{6,0},{40,-82},{40,-80}},
                  color={0,0,127}),
                Line(points={{40,80},{6,0},{6,0}},
                  color={0,0,127}),
                Ellipse(lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{-2,-8},{14,8}})}));
        end SourceSelectorRadiation;

        function getHeaderElementTMY3
          "Gets an element from the header of a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         input Integer position(min=1)
            "Position of the element on the line that contains 'start'";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        function getLatitudeTMY3 "Gets the latitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lat "Latitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "latitude",
              position=7);
           (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the latitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lat :=lat*Modelica.Constants.pi/180;
           // Check if latitude is valid
           assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
               "Wrong value for latitude. Received lat = " +
               String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLatitudeTMY3;

        function getLongitudeTMY3 "Gets the longitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lon "Longitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        function getTimeSpanTMY3
            "Get the time span of the weather data from the file"
          extends Modelica.Icons.Function;

          input String filNam "Name of weather data file";
          input String tabNam "Name of table on weather file";
          output Modelica.SIunits.Time[2] timeSpan "Start time, end time of weather data";

        external "C" getTimeSpan(filNam, tabNam, timeSpan)
          annotation (
          Include="#include <getTimeSpan.c>",
          IncludeDirectory="modelica://Buildings/Resources/C-Sources");

          annotation (Documentation(info="<html>
<p>
This function returns the start time (first time stamp) and end time
(last time stamp plus average increment) of the TMY3 weather data file.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 16, 2019, by Jianjun Hu:<br/>
Reimplemented to use a C function, this is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1108\">#1108</a>.
</li>
<li>
November 15, 2017, by Ana Constantin:<br/>
First implementation, as part of solution to <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
</ul>
</html>"));
        end getTimeSpanTMY3;

        function getTimeZoneTMY3 "Gets the time zone from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Time timZon "Time zone from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");

          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
the <code>expandable connector</code>
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.Bus\">
Buildings.BoundaryConditions.WeatherData.Bus</a>
that is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;

    package Types "Package with type definitions"
     extends Modelica.Icons.TypesPackage;

      type DataSource = enumeration(
        File   "Use data from file",
        Parameter   "Use parameter",
        Input   "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type RadiationDataSource = enumeration(
        File   "Use data from file",
        Input_HGloHor_HDifHor
            "Global horizontal and diffuse horizontal radiation from connector",
        Input_HDirNor_HDifHor
            "Direct normal and diffuse horizontal radiation from connector",
        Input_HDirNor_HGloHor
            "Direct normal and global horizontal radiation from connector")
        "Enumeration to define solar radiation data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
        HorizontalRadiation
            "Use horizontal irradiation",
        TemperaturesAndSkyCover
            "Use dry-bulb and dew-point temperatures and sky cover")
        "Enumeration for computation of sky temperature" annotation (
        Documentation(info =       "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://Buildings.Fluid.Sources\">
Buildings.Fluid.Sources</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
          Ellipse(
          extent={{-76,80},{6,-2}},
          lineColor={255,255,255},
          lineThickness=1,
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255}),
        Line(
          points={{32,-24},{76,-82}},
          color={95, 95, 95}),
        Line(
          points={{4,-24},{48,-82}},
          color={95, 95, 95}),
        Line(
          points={{-26,-24},{18,-82}},
          color={95, 95, 95}),
        Line(
          points={{-56,-24},{-12,-82}},
          color={95, 95, 95}),
        Polygon(
          points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
              -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
              40},{64,6}},
          lineColor={150,150,150},
          lineThickness=0.1,
          fillPattern=FillPattern.Sphere,
          smooth=Smooth.Bezier,
          fillColor={150,150,150})}));
  end BoundaryConditions;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package OBC "Blocks and preconfigured control sequences"
      extends Modelica.Icons.Package;

      package ASHRAE "Package with control sequences from ASHRAE projects"

        package G36_PR1
        "Package with control sequences from ASHRAE Guideline 36"

          package AHUs "AHU Sequences as defined in guideline G36"

            package MultiZone "Sequences for multi zone AHU control"

              package VAV "Sequences for multi zone VAV AHU control"

                block Controller
                  "Multizone AHU controller that composes subsequences for controlling fan speed, dampers, and supply air temperature"

                  parameter Real samplePeriod(
                    final unit="s",
                    final quantity="Time")=120
                    "Sample period of component, set to the same value to the trim and respond sequence";

                  parameter Boolean have_perZonRehBox=true
                    "Check if there is any VAV-reheat boxes on perimeter zones"
                    annotation (Dialog(group="System and building parameters"));

                  parameter Boolean have_duaDucBox=false
                    "Check if the AHU serves dual duct boxes"
                    annotation (Dialog(group="System and building parameters"));

                  parameter Boolean have_airFloMeaSta=false
                    "Check if the AHU has AFMS (Airflow measurement station)"
                    annotation (Dialog(group="System and building parameters"));

                  // ----------- Parameters for economizer control -----------
                  parameter Boolean use_enthalpy=false
                    "Set to true if enthalpy measurement is used in addition to temperature measurement"
                    annotation (Dialog(tab="Economizer"));

                  parameter Real delta(
                    final unit="s",
                    final quantity="Time")=5
                    "Time horizon over which the outdoor air flow measurment is averaged"
                    annotation (Dialog(tab="Economizer"));

                  parameter Real delTOutHis(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=1
                    "Delta between the temperature hysteresis high and low limit"
                    annotation (Dialog(tab="Economizer"));

                  parameter Real delEntHis(
                    final unit="J/kg",
                    final quantity="SpecificEnergy")=1000
                    "Delta between the enthalpy hysteresis high and low limits"
                    annotation (Dialog(tab="Economizer", enable=use_enthalpy));

                  parameter Real retDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the return air damper"
                    annotation (Dialog(tab="Economizer", group="Damper limits"));

                  parameter Real retDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the return air damper"
                    annotation (Dialog(tab="Economizer", group="Damper limits"));

                  parameter Real outDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the outdoor air damper"
                    annotation (Dialog(tab="Economizer", group="Damper limits"));

                  parameter Real outDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the outdoor air damper"
                    annotation (Dialog(tab="Economizer", group="Damper limits"));

                  parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeMinOut=
                    Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    "Type of controller"
                    annotation (Dialog(group="Economizer PID controller"));

                  parameter Real kMinOut(final unit="1")=0.05
                    "Gain of controller for minimum outdoor air intake"
                    annotation (Dialog(group="Economizer PID controller"));

                  parameter Real TiMinOut(
                    final unit="s",
                    final quantity="Time")=120
                    "Time constant of controller for minimum outdoor air intake"
                    annotation (Dialog(group="Economizer PID controller",
                      enable=controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                          or controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Real TdMinOut(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for minimum outdoor air intake"
                    annotation (Dialog(group="Economizer PID controller",
                      enable=controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                          or controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Boolean use_TMix=true
                    "Set to true if mixed air temperature measurement is enabled"
                     annotation(Dialog(group="Economizer freeze protection"));

                  parameter Boolean use_G36FrePro=false
                    "Set to true to use G36 freeze protection"
                    annotation(Dialog(group="Economizer freeze protection"));

                  parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeFre=
                    Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    "Type of controller"
                    annotation(Dialog(group="Economizer freeze protection", enable=use_TMix));

                  parameter Real kFre(final unit="1/K") = 0.05
                    "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Economizer freeze protection", enable=use_TMix));

                  parameter Real TiFre(
                    final unit="s",
                    final quantity="Time",
                    final max=TiMinOut)=120
                    "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre <= TiMinOut"
                     annotation(Dialog(group="Economizer freeze protection",
                       enable=use_TMix
                         and (controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                           or controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real TdFre(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for freeze protection"
                    annotation (Dialog(group="Economizer freeze protection",
                      enable=use_TMix and
                          (controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                          or controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real TFreSet(
                     final unit="K",
                     final displayUnit="degC",
                     final quantity="ThermodynamicTemperature")= 279.15
                    "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Economizer freeze protection", enable=use_TMix));

                  parameter Real retDamFulOpeTim(
                    final unit="s",
                    final quantity="Time")=180
                    "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control
    at disable to avoid pressure fluctuations"
                    annotation (Dialog(tab="Economizer", group="Economizer delays at disable"));

                  parameter Real disDel(
                    final unit="s",
                    final quantity="Time")=15
                    "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                    annotation (Dialog(tab="Economizer", group="Economizer delays at disable"));

                  // ----------- parameters for fan speed control  -----------
                  parameter Real pIniSet(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=60
                    "Initial pressure setpoint for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pMinSet(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=25
                    "Minimum pressure setpoint for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pMaxSet(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=400
                    "Maximum pressure setpoint for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pDelTim(
                    final unit="s",
                    final quantity="Time")=600
                    "Delay time after which trim and respond is activated"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Integer pNumIgnReq=2
                    "Number of ignored requests for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pTriAmo(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=-12.0
                    "Trim amount for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pResAmo(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=15
                    "Respond amount (must be opposite in to triAmo) for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Real pMaxRes(
                    final unit="Pa",
                    final displayUnit="Pa",
                    final quantity="PressureDifference")=32
                    "Maximum response per time interval (same sign as resAmo) for fan speed control"
                    annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                  parameter Buildings.Controls.OBC.CDL.Types.SimpleController
                    controllerTypeFanSpe=Buildings.Controls.OBC.CDL.Types.SimpleController.PI "Type of controller"
                    annotation (Dialog(group="Fan speed PID controller"));

                  parameter Real kFanSpe(final unit="1")=0.1
                    "Gain of fan fan speed controller, normalized using pMaxSet"
                    annotation (Dialog(group="Fan speed PID controller"));

                  parameter Real TiFanSpe(
                    final unit="s",
                    final quantity="Time")=60
                    "Time constant of integrator block for fan speed"
                    annotation (Dialog(group="Fan speed PID controller",
                      enable=controllerTypeFanSpe == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                          or controllerTypeFanSpe == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Real TdFanSpe(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for fan speed"
                    annotation (Dialog(group="Fan speed PID controller",
                      enable=controllerTypeFanSpe == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                          or controllerTypeFanSpe == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Real yFanMax=1 "Maximum allowed fan speed"
                    annotation (Dialog(group="Fan speed PID controller"));

                  parameter Real yFanMin=0.1 "Lowest allowed fan speed if fan is on"
                    annotation (Dialog(group="Fan speed PID controller"));

                  // ----------- parameters for minimum outdoor airflow setting  -----------
                  parameter Real VPriSysMax_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Maximum expected system primary airflow at design stage"
                    annotation (Dialog(tab="Minimum outdoor airflow rate", group="Nominal conditions"));

                  parameter Real peaSysPop "Peak system population"
                    annotation (Dialog(tab="Minimum outdoor airflow rate", group="Nominal conditions"));

                  // ----------- parameters for supply air temperature control  -----------
                  parameter Real TSupSetMin(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=285.15
                    "Lowest cooling supply air temperature setpoint"
                    annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                  parameter Real TSupSetMax(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=291.15
                    "Highest cooling supply air temperature setpoint. It is typically 18 degC (65 degF) in mild and dry climates, 16 degC (60 degF) or lower in humid climates"
                    annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                  parameter Real TSupSetDes(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=286.15
                    "Nominal supply air temperature setpoint"
                    annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                  parameter Real TOutMin(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=289.15
                    "Lower value of the outdoor air temperature reset range. Typically value is 16 degC (60 degF)"
                    annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                  parameter Real TOutMax(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=294.15
                    "Higher value of the outdoor air temperature reset range. Typically value is 21 degC (70 degF)"
                    annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                  parameter Real iniSetSupTem(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=TSupSetMax
                    "Initial setpoint for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real maxSetSupTem(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=TSupSetMax
                    "Maximum setpoint for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real minSetSupTem(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=TSupSetDes
                    "Minimum setpoint for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real delTimSupTem(
                    final unit="s",
                    final quantity="Time")=600
                    "Delay timer for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Integer numIgnReqSupTem=2
                    "Number of ignorable requests for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real triAmoSupTem(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=0.1
                    "Trim amount for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real resAmoSupTem(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=-0.2
                    "Response amount for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Real maxResSupTem(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=-0.6
                    "Maximum response per time interval for supply temperature control"
                    annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                  parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeTSup=
                      Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    "Type of controller for supply air temperature signal"
                    annotation (Dialog(group="Supply air temperature"));

                  parameter Real kTSup(final unit="1/K")=0.05
                    "Gain of controller for supply air temperature signal"
                    annotation (Dialog(group="Supply air temperature"));

                  parameter Real TiTSup(
                    final unit="s",
                    final quantity="Time")=600
                    "Time constant of integrator block for supply air temperature control signal"
                    annotation (Dialog(group="Supply air temperature",
                      enable=controllerTypeTSup == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                          or controllerTypeTSup == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Real TdTSup(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of integrator block for supply air temperature control signal"
                    annotation (Dialog(group="Supply air temperature",
                      enable=controllerTypeTSup == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                          or controllerTypeTSup == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                  parameter Real uHeaMax(min=-0.9)=-0.25
                    "Upper limit of controller signal when heating coil is off. Require -1 < uHeaMax < uCooMin < 1."
                    annotation (Dialog(group="Supply air temperature"));

                  parameter Real uCooMin(max=0.9)=0.25
                    "Lower limit of controller signal when cooling coil is off. Require -1 < uHeaMax < uCooMin < 1."
                    annotation (Dialog(group="Supply air temperature"));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonHeaSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Zone air temperature heating setpoint"
                    annotation (Placement(transformation(extent={{-240,280},{-200,320}}),
                        iconTransformation(extent={{-240,320},{-200,360}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonCooSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Zone air temperature cooling setpoint"
                    annotation (Placement(transformation(extent={{-240,250},{-200,290}}),
                        iconTransformation(extent={{-240,290},{-200,330}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TOut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") "Outdoor air temperature"
                    annotation (Placement(transformation(extent={{-240,220},{-200,260}}),
                        iconTransformation(extent={{-240,260},{-200,300}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput ducStaPre(
                    final unit="Pa",
                    final displayUnit="Pa")
                    "Measured duct static pressure"
                    annotation (Placement(transformation(extent={{-240,190},{-200,230}}),
                        iconTransformation(extent={{-240,230},{-200,270}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput sumDesZonPop(
                    final min=0,
                    final unit="1")
                    "Sum of the design population of the zones in the group"
                    annotation (Placement(transformation(extent={{-240,160},{-200,200}}),
                        iconTransformation(extent={{-240,170},{-200,210}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumDesPopBreZon_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Sum of the population component design breathing zone flow rate"
                    annotation (Placement(transformation(extent={{-240,130},{-200,170}}),
                        iconTransformation(extent={{-240,140},{-200,180}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumDesAreBreZon_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Sum of the area component design breathing zone flow rate"
                    annotation (Placement(transformation(extent={{-240,100},{-200,140}}),
                        iconTransformation(extent={{-240,110},{-200,150}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput uDesSysVenEff(
                    final min=0,
                    final unit = "1")
                    "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                    annotation (Placement(transformation(extent={{-240,70},{-200,110}}),
                        iconTransformation(extent={{-240,80},{-200,120}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumUncOutAir_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Sum of all zones required uncorrected outdoor airflow rate"
                    annotation (Placement(transformation(extent={{-240,40},{-200,80}}),
                        iconTransformation(extent={{-240,50},{-200,90}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumSysPriAir_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "System primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                    annotation (Placement(transformation(extent={{-240,10},{-200,50}}),
                        iconTransformation(extent={{-240,20},{-200,60}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutAirFra_max(
                    final min=0,
                    final unit = "1")
                    "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                    annotation (Placement(transformation(extent={{-240,-20},{-200,20}}),
                        iconTransformation(extent={{-240,-10},{-200,30}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TSup(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Measured supply air temperature"
                    annotation (Placement(transformation(extent={{-240,-50},{-200,-10}}),
                        iconTransformation(extent={{-240,-70},{-200,-30}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TOutCut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                    annotation (Placement(transformation(extent={{-240,-80},{-200,-40}}),
                        iconTransformation(extent={{-240,-100},{-200,-60}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput hOut(
                    final unit="J/kg",
                    final quantity="SpecificEnergy") if use_enthalpy "Outdoor air enthalpy"
                    annotation (Placement(transformation(extent={{-240,-110},{-200,-70}}),
                        iconTransformation(extent={{-240,-130},{-200,-90}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput hOutCut(
                    final unit="J/kg",
                    final quantity="SpecificEnergy") if use_enthalpy
                    "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                    annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
                        iconTransformation(extent={{-240,-160},{-200,-120}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput VOut_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Measured outdoor volumetric airflow rate"
                    annotation (Placement(transformation(extent={{-240,-170},{-200,-130}}),
                        iconTransformation(extent={{-240,-190},{-200,-150}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput TMix(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity = "ThermodynamicTemperature") if use_TMix
                    "Measured mixed air temperature, used for freeze protection if use_TMix=true"
                    annotation (Placement(transformation(extent={{-240,-200},{-200,-160}}),
                        iconTransformation(extent={{-240,-230},{-200,-190}})));

                  Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                    "AHU operation mode status signal"
                    annotation (Placement(transformation(extent={{-240,-230},{-200,-190}}),
                        iconTransformation(extent={{-240,-270},{-200,-230}})));

                  Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uZonTemResReq
                    "Zone cooling supply air temperature reset request"
                    annotation (Placement(transformation(extent={{-240,-260},{-200,-220}}),
                        iconTransformation(extent={{-240,-300},{-200,-260}})));

                  Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uZonPreResReq
                    "Zone static pressure reset requests"
                    annotation (Placement(transformation(extent={{-240,-290},{-200,-250}}),
                        iconTransformation(extent={{-240,-330},{-200,-290}})));

                  Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uFreProSta if
                      use_G36FrePro
                   "Freeze protection status, used if use_G36FrePro=true"
                    annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
                        iconTransformation(extent={{-240,-360},{-200,-320}})));

                  Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySupFan
                    "Supply fan status, true if fan should be on"
                    annotation (Placement(transformation(extent={{200,260},{240,300}}),
                        iconTransformation(extent={{200,280},{240,320}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput ySupFanSpe(
                    final min=0,
                    final max=1,
                    final unit="1") "Supply fan speed"
                    annotation (Placement(transformation(extent={{200,190},{240,230}}),
                        iconTransformation(extent={{200,220},{240,260}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput TSupSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Setpoint for supply air temperature"
                    annotation (Placement(transformation(extent={{200,160},{240,200}}),
                        iconTransformation(extent={{200,160},{240,200}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDesUncOutAir_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Design uncorrected minimum outdoor airflow rate"
                    annotation (Placement(transformation(extent={{200,120},{240,160}}),
                      iconTransformation(extent={{200,100},{240,140}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput yAveOutAirFraPlu(
                    final min=0,
                    final unit = "1")
                    "Average outdoor air flow fraction plus 1"
                    annotation (Placement(transformation(extent={{200,80},{240,120}}),
                      iconTransformation(extent={{200,40},{240,80}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VEffOutAir_flow(
                    final min=0,
                    final unit = "m3/s",
                    final quantity = "VolumeFlowRate")
                    "Effective minimum outdoor airflow setpoint"
                    annotation (Placement(transformation(extent={{200,40},{240,80}}),
                      iconTransformation(extent={{200,-20},{240,20}})));

                  Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yReqOutAir
                    "True if the AHU supply fan is on and the zone is in occupied mode"
                    annotation (Placement(transformation(extent={{200,0},{240,40}}),
                        iconTransformation(extent={{200,-80},{240,-40}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput yHea(
                    final min=0,
                    final max=1,
                    final unit="1")
                    "Control signal for heating"
                    annotation (Placement(transformation(extent={{200,-50},{240,-10}}),
                        iconTransformation(extent={{200,-140},{240,-100}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput yCoo(
                    final min=0,
                    final max=1,
                    final unit="1") "Control signal for cooling"
                    annotation (Placement(transformation(extent={{200,-110},{240,-70}}),
                        iconTransformation(extent={{200,-200},{240,-160}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Return air damper position"
                    annotation (Placement(transformation(extent={{200,-170},{240,-130}}),
                        iconTransformation(extent={{200,-260},{240,-220}})));

                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Outdoor air damper position"
                    annotation (Placement(transformation(extent={{200,-210},{240,-170}}),
                        iconTransformation(extent={{200,-320},{240,-280}})));

                  Buildings.Controls.OBC.CDL.Continuous.Average TZonSetPoiAve
                    "Average of all zone set points"
                    annotation (Placement(transformation(extent={{-160,270},{-140,290}})));

                  Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan
                    supFan(
                    final samplePeriod=samplePeriod,
                    final have_perZonRehBox=have_perZonRehBox,
                    final have_duaDucBox=have_duaDucBox,
                    final have_airFloMeaSta=have_airFloMeaSta,
                    final iniSet=pIniSet,
                    final minSet=pMinSet,
                    final maxSet=pMaxSet,
                    final delTim=pDelTim,
                    final numIgnReq=pNumIgnReq,
                    final triAmo=pTriAmo,
                    final resAmo=pResAmo,
                    final maxRes=pMaxRes,
                    final controllerType=controllerTypeFanSpe,
                    final k=kFanSpe,
                    final Ti=TiFanSpe,
                    final Td=TdFanSpe,
                    final yFanMax=yFanMax,
                    final yFanMin=yFanMin)
                    "Supply fan controller"
                    annotation (Placement(transformation(extent={{-160,200},{-140,220}})));

                  Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature
                    supTemSetPoi(
                    final samplePeriod=samplePeriod,
                    final TSupSetMin=TSupSetMin,
                    final TSupSetMax=TSupSetMax,
                    final TSupSetDes=TSupSetDes,
                    final TOutMin=TOutMin,
                    final TOutMax=TOutMax,
                    final iniSet=iniSetSupTem,
                    final maxSet=maxSetSupTem,
                    final minSet=minSetSupTem,
                    final delTim=delTimSupTem,
                    final numIgnReq=numIgnReqSupTem,
                    final triAmo=triAmoSupTem,
                    final resAmo=resAmoSupTem,
                    final maxRes=maxResSupTem) "Setpoint for supply temperature"
                    annotation (Placement(transformation(extent={{0,170},{20,190}})));

                  Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU
                    sysOutAirSet(final VPriSysMax_flow=VPriSysMax_flow, final peaSysPop=
                        peaSysPop) "Minimum outdoor airflow setpoint"
                    annotation (Placement(transformation(extent={{-40,70},{-20,90}})));

                  Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller eco(
                    final use_enthalpy=use_enthalpy,
                    final delTOutHis=delTOutHis,
                    final delEntHis=delEntHis,
                    final retDamFulOpeTim=retDamFulOpeTim,
                    final disDel=disDel,
                    final controllerTypeMinOut=controllerTypeMinOut,
                    final kMinOut=kMinOut,
                    final TiMinOut=TiMinOut,
                    final TdMinOut=TdMinOut,
                    final retDamPhyPosMax=retDamPhyPosMax,
                    final retDamPhyPosMin=retDamPhyPosMin,
                    final outDamPhyPosMax=outDamPhyPosMax,
                    final outDamPhyPosMin=outDamPhyPosMin,
                    final uHeaMax=uHeaMax,
                    final uCooMin=uCooMin,
                    final uOutDamMax=(uHeaMax + uCooMin)/2,
                    final uRetDamMin=(uHeaMax + uCooMin)/2,
                    final TFreSet=TFreSet,
                    final controllerTypeFre=controllerTypeFre,
                    final kFre=kFre,
                    final TiFre=TiFre,
                    final TdFre=TdFre,
                    final delta=delta,
                    final use_TMix=use_TMix,
                    final use_G36FrePro=use_G36FrePro) "Economizer controller"
                    annotation (Placement(transformation(extent={{140,-170},{160,-150}})));

                  Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals val(
                    final controllerType=controllerTypeTSup,
                    final kTSup=kTSup,
                    final TiTSup=TiTSup,
                    final TdTSup=TdTSup,
                    final uHeaMax=uHeaMax,
                    final uCooMin=uCooMin) "AHU coil valve control"
                    annotation (Placement(transformation(extent={{80,-70},{100,-50}})));

              protected
                  Buildings.Controls.OBC.CDL.Continuous.Division VOut_flow_normalized(
                    u1(final unit="m3/s"),
                    u2(final unit="m3/s"),
                    y(final unit="1"))
                    "Normalization of outdoor air flow intake by design minimum outdoor air intake"
                    annotation (Placement(transformation(extent={{20,-130},{40,-110}})));

                equation
                  connect(eco.yRetDamPos, yRetDamPos)
                    annotation (Line(points={{161.25,-157.5},{180,-157.5},{180,-150},{220,-150}},
                      color={0,0,127}));
                  connect(eco.yOutDamPos, yOutDamPos)
                    annotation (Line(points={{161.25,-162.5},{180,-162.5},{180,-190},{220,-190}},
                      color={0,0,127}));
                  connect(eco.uSupFan, supFan.ySupFan)
                    annotation (Line(points={{138.75,-165},{-84,-165},{-84,217},{-138,217}},
                      color={255,0,255}));
                  connect(supFan.ySupFanSpe, ySupFanSpe)
                    annotation (Line(points={{-138,210},{220,210}},
                      color={0,0,127}));
                  connect(TOut, eco.TOut)
                    annotation (Line(points={{-220,240},{-60,240},{-60,-150.625},{138.75,-150.625}},
                      color={0,0,127}));
                  connect(eco.TOutCut, TOutCut)
                    annotation (Line(points={{138.75,-152.5},{-74,-152.5},{-74,-60},{-220,-60}},
                      color={0,0,127}));
                  connect(eco.hOut, hOut)
                    annotation (Line(points={{138.75,-154.375},{-78,-154.375},{-78,-90},{-220,-90}},
                      color={0,0,127}));
                  connect(eco.hOutCut, hOutCut)
                    annotation (Line(points={{138.75,-155.625},{-94,-155.625},{-94,-120},{-220,-120}},
                      color={0,0,127}));
                  connect(eco.uOpeMod, uOpeMod)
                    annotation (Line(points={{138.75,-166.875},{60,-166.875},{60,-210},{-220,-210}},
                      color={255,127,0}));
                  connect(supTemSetPoi.TSupSet, TSupSet)
                    annotation (Line(points={{22,180},{220,180}}, color={0,0,127}));
                  connect(supTemSetPoi.TOut, TOut)
                    annotation (Line(points={{-2,184},{-60,184},{-60,240},{-220,240}},
                      color={0,0,127}));
                  connect(supTemSetPoi.uSupFan, supFan.ySupFan)
                    annotation (Line(points={{-2,176},{-84,176},{-84,217},{-138,217}},
                      color={255,0,255}));
                  connect(supTemSetPoi.uZonTemResReq, uZonTemResReq)
                    annotation (Line(points={{-2,180},{-52,180},{-52,-240},{-220,-240}},
                      color={255,127,0}));
                  connect(supTemSetPoi.uOpeMod, uOpeMod)
                    annotation (Line(points={{-2,172},{-48,172},{-48,-210},{-220,-210}},
                      color={255,127,0}));
                  connect(supFan.uOpeMod, uOpeMod)
                    annotation (Line(points={{-162,218},{-180,218},{-180,-210},{-220,-210}},
                      color={255,127,0}));
                  connect(supFan.uZonPreResReq, uZonPreResReq)
                    annotation (Line(points={{-162,207},{-176,207},{-176,-270},{-220,-270}},
                      color={255,127,0}));
                  connect(supFan.ducStaPre, ducStaPre)
                    annotation (Line(points={{-162,202},{-192,202},{-192,210},{-220,210}},
                      color={0,0,127}));
                  connect(supTemSetPoi.TZonSetAve, TZonSetPoiAve.y)
                    annotation (Line(points={{-2,188},{-20,188},{-20,280},{-138,280}},
                      color={0,0,127}));
                  connect(supFan.ySupFan, ySupFan)
                    annotation (Line(points={{-138,217},{60,217},{60,280},{220,280}},
                      color={255,0,255}));
                  connect(TZonSetPoiAve.u2, TZonCooSet)
                    annotation (Line(points={{-162,274},{-180,274},{-180,270},{-220,270}},
                      color={0,0,127}));
                  connect(eco.TMix, TMix)
                    annotation (Line(points={{138.75,-163.125},{-12,-163.125},{-12,-180},{-220,-180}},
                      color={0,0,127}));
                  connect(TSup, val.TSup)
                    annotation (Line(points={{-220,-30},{-66,-30},{-66,-65},{78,-65}},
                      color={0,0,127}));
                  connect(supFan.ySupFan, val.uSupFan)
                    annotation (Line(points={{-138,217},{-84,217},{-84,-55},{78,-55}},
                      color={255,0,255}));
                  connect(val.uTSup, eco.uTSup)
                    annotation (Line(points={{102,-56},{120,-56},{120,-157.5},{138.75,-157.5}},
                      color={0,0,127}));
                  connect(val.yHea, yHea)
                    annotation (Line(points={{102,-60},{180,-60},{180,-30},{220,-30}},
                      color={0,0,127}));
                  connect(val.yCoo, yCoo)
                    annotation (Line(points={{102,-64},{180,-64},{180,-90},{220,-90}},
                      color={0,0,127}));
                  connect(supTemSetPoi.TSupSet, val.TSupSet)
                    annotation (Line(points={{22,180},{60,180},{60,-60},{78,-60}},
                      color={0,0,127}));
                  connect(TZonHeaSet, TZonSetPoiAve.u1)
                    annotation (Line(points={{-220,300},{-180,300},{-180,286},{-162,286}},
                      color={0,0,127}));
                  connect(eco.uFreProSta, uFreProSta)
                    annotation (Line(points={{138.75,-169.375},{66,-169.375},{66,-300},{-220,-300}},
                      color={255,127,0}));
                  connect(eco.VOut_flow_normalized, VOut_flow_normalized.y)
                    annotation (Line(points={{138.75,-159.375},{60,-159.375},{60,-120},{42,-120}},
                      color={0,0,127}));
                  connect(VOut_flow_normalized.u1, VOut_flow)
                    annotation (Line(points={{18,-114},{-160,-114},{-160,-150},{-220,-150}},
                      color={0,0,127}));
                  connect(sysOutAirSet.VDesUncOutAir_flow, VDesUncOutAir_flow) annotation (Line(
                        points={{-18,88},{0,88},{0,140},{220,140}}, color={0,0,127}));
                  connect(sysOutAirSet.VDesOutAir_flow, VOut_flow_normalized.u2) annotation (
                      Line(points={{-18,82},{0,82},{0,-126},{18,-126}}, color={0,0,127}));
                  connect(sysOutAirSet.effOutAir_normalized, eco.VOutMinSet_flow_normalized)
                    annotation (Line(points={{-18,75},{-4,75},{-4,-161.25},{138.75,-161.25}},
                        color={0,0,127}));
                  connect(supFan.ySupFan, sysOutAirSet.uSupFan) annotation (Line(points={{-138,217},
                          {-84,217},{-84,73},{-42,73}}, color={255,0,255}));
                  connect(uOpeMod, sysOutAirSet.uOpeMod) annotation (Line(points={{-220,-210},{-48,
                          -210},{-48,71},{-42,71}}, color={255,127,0}));
                  connect(sysOutAirSet.yAveOutAirFraPlu, yAveOutAirFraPlu) annotation (Line(
                        points={{-18,85},{20,85},{20,100},{220,100}}, color={0,0,127}));
                  connect(sysOutAirSet.VEffOutAir_flow, VEffOutAir_flow) annotation (Line(
                        points={{-18,78},{20,78},{20,60},{220,60}}, color={0,0,127}));
                  connect(sysOutAirSet.yReqOutAir, yReqOutAir) annotation (Line(points={{-18,
                          72},{16,72},{16,20},{220,20}}, color={255,0,255}));
                  connect(sysOutAirSet.sumDesZonPop, sumDesZonPop) annotation (Line(points={{-42,
                          89},{-120,89},{-120,180},{-220,180}}, color={0,0,127}));
                  connect(sysOutAirSet.VSumDesPopBreZon_flow, VSumDesPopBreZon_flow)
                    annotation (Line(points={{-42,87},{-126,87},{-126,150},{-220,150}}, color={0,
                          0,127}));
                  connect(sysOutAirSet.VSumDesAreBreZon_flow, VSumDesAreBreZon_flow)
                    annotation (Line(points={{-42,85},{-132,85},{-132,120},{-220,120}}, color={0,
                          0,127}));
                  connect(sysOutAirSet.uDesSysVenEff, uDesSysVenEff) annotation (Line(points={{-42,
                          83},{-138,83},{-138,90},{-220,90}}, color={0,0,127}));
                  connect(sysOutAirSet.VSumUncOutAir_flow, VSumUncOutAir_flow) annotation (Line(
                        points={{-42,81},{-138,81},{-138,60},{-220,60}}, color={0,0,127}));
                  connect(sysOutAirSet.VSumSysPriAir_flow, VSumSysPriAir_flow) annotation (Line(
                        points={{-42,79},{-132,79},{-132,30},{-220,30}}, color={0,0,127}));
                  connect(uOutAirFra_max, sysOutAirSet.uOutAirFra_max) annotation (Line(points={
                          {-220,0},{-126,0},{-126,77},{-42,77}}, color={0,0,127}));

                annotation (defaultComponentName="conAHU",
                    Diagram(coordinateSystem(extent={{-200,-320},{200,320}}, initialScale=0.2)),
                    Icon(coordinateSystem(extent={{-200,-360},{200,360}}, initialScale=0.2),
                        graphics={Rectangle(
                          extent={{200,360},{-200,-360}},
                          lineColor={0,0,0},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid), Text(
                          extent={{-200,450},{200,372}},
                          textString="%name",
                          lineColor={0,0,255}),           Text(
                          extent={{-200,348},{-116,332}},
                          lineColor={0,0,0},
                          textString="TZonHeaSet"),       Text(
                          extent={{102,-48},{202,-68}},
                          lineColor={255,0,255},
                          textString="yReqOutAir"),       Text(
                          extent={{-196,-238},{-122,-258}},
                          lineColor={255,127,0},
                          textString="uOpeMod"),          Text(
                          extent={{-200,318},{-114,302}},
                          lineColor={0,0,0},
                          textString="TZonCooSet"),       Text(
                          extent={{-198,260},{-120,242}},
                          lineColor={0,0,0},
                          textString="ducStaPre"),        Text(
                          extent={{-198,288},{-162,272}},
                          lineColor={0,0,0},
                          textString="TOut"),             Text(
                          extent={{-196,110},{-90,88}},
                          lineColor={0,0,0},
                          textString="uDesSysVenEff"),    Text(
                          extent={{-196,140},{-22,118}},
                          lineColor={0,0,0},
                          textString="VSumDesAreBreZon_flow"),
                                                          Text(
                          extent={{-196,170},{-20,148}},
                          lineColor={0,0,0},
                          textString="VSumDesPopBreZon_flow"),
                                                          Text(
                          extent={{-196,200},{-88,182}},
                          lineColor={0,0,0},
                          textString="sumDesZonPop"),     Text(
                          extent={{-200,-42},{-154,-62}},
                          lineColor={0,0,0},
                          textString="TSup"),             Text(
                          extent={{-200,18},{-84,0}},
                          lineColor={0,0,0},
                          textString="uOutAirFra_max"),   Text(
                          extent={{-196,48},{-62,30}},
                          lineColor={0,0,0},
                          textString="VSumSysPriAir_flow"),
                                                          Text(
                          extent={{-196,80},{-42,58}},
                          lineColor={0,0,0},
                          textString="VSumUncOutAir_flow"),
                                                          Text(
                          extent={{-200,-162},{-126,-180}},
                          lineColor={0,0,0},
                          textString="VOut_flow"),        Text(
                          visible=use_enthalpy,
                          extent={{-200,-130},{-134,-148}},
                          lineColor={0,0,0},
                          textString="hOutCut"),          Text(
                          visible=use_enthalpy,
                          extent={{-200,-100},{-160,-118}},
                          lineColor={0,0,0},
                          textString="hOut"),             Text(
                          extent={{-198,-70},{-146,-86}},
                          lineColor={0,0,0},
                          textString="TOutCut"),          Text(
                          visible=use_TMix,
                          extent={{-200,-200},{-154,-218}},
                          lineColor={0,0,0},
                          textString="TMix"),             Text(
                          extent={{-194,-270},{-68,-290}},
                          lineColor={255,127,0},
                          textString="uZonTemResReq"),    Text(
                          extent={{-192,-300},{-74,-320}},
                          lineColor={255,127,0},
                          textString="uZonPreResReq"),    Text(
                          visible=use_G36FrePro,
                          extent={{-200,-330},{-110,-348}},
                          lineColor={255,127,0},
                          textString="uFreProSta"),       Text(
                          extent={{106,252},{198,230}},
                          lineColor={0,0,0},
                          textString="ySupFanSpe"),       Text(
                          extent={{122,192},{202,172}},
                          lineColor={0,0,0},
                          textString="TSupSet"),          Text(
                          extent={{68,72},{196,52}},
                          lineColor={0,0,0},
                          textString="yAveOutAirFraPlu"), Text(
                          extent={{48,132},{196,110}},
                          lineColor={0,0,0},
                          textString="VDesUncOutAir_flow"),
                                                          Text(
                          extent={{150,-104},{200,-126}},
                          lineColor={0,0,0},
                          textString="yHea"),             Text(
                          extent={{94,-288},{200,-308}},
                          lineColor={0,0,0},
                          textString="yOutDamPos"),       Text(
                          extent={{98,-228},{198,-248}},
                          lineColor={0,0,0},
                          textString="yRetDamPos"),       Text(
                          extent={{78,14},{196,-6}},
                          lineColor={0,0,0},
                          textString="VEffOutAir_flow"),  Text(
                          extent={{120,312},{202,292}},
                          lineColor={255,0,255},
                          textString="ySupFan"),          Text(
                          extent={{150,-166},{200,-188}},
                          lineColor={0,0,0},
                          textString="yCoo")}),
                Documentation(info="<html>
<p>
Block that is applied for multizone VAV AHU control. It outputs the supply fan status
and the operation speed, outdoor and return air damper position, supply air
temperature setpoint and the valve position of the cooling and heating coils.
It is implemented according to the ASHRAE Guideline 36, PART 5.N.
</p>
<p>
The sequence consists of five subsequences.
</p>
<h4>Supply fan speed control</h4>
<p>
The fan speed control is implemented according to PART 5.N.1. It outputs
the boolean signal <code>ySupFan</code> to turn on or off the supply fan.
In addition, based on the pressure reset request <code>uZonPreResReq</code>
from the VAV zones controller, the
sequence resets the duct pressure setpoint, and uses this setpoint
to modulate the fan speed <code>ySupFanSpe</code> using a PI controller.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan</a>
for more detailed description.
</p>
<h4>Minimum outdoor airflow setting</h4>
<p>
According to current occupany, supply operation status <code>ySupFan</code>,
zone temperatures and the discharge air temperature, the sequence computes the
minimum outdoor airflow rate setpoint, which is used as input for the economizer control.
More detailed information can be found in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow</a>.
</p>
<h4>Economizer control</h4>
<p>
The block outputs outdoor and return air damper position, <code>yOutDamPos</code> and
<code>yRetDamPos</code>. First, it computes the position limits to satisfy the minimum
outdoor airflow requirement. Second, it determines the availability of the economizer based
on the outdoor condition. The dampers are modulated to track the supply air temperature
loop signal, which is calculated from the sequence below, subject to the minimum outdoor airflow
requirement and economizer availability. Optionally, there is also an override for freeze protection.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller</a>
for more detailed description.
</p>
<h4>Supply air temperature setpoint</h4>
<p>
Based on PART 5.N.2, the sequence first sets the maximum supply air temperature
based on reset requests collected from each zone <code>uZonTemResReq</code>. The
outdoor temperature <code>TOut</code> and operation mode <code>uOpeMod</code> are used
along with the maximum supply air temperature, for computing the supply air temperature
setpoint. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature</a>
for more detailed description.
</p>
<h4>Coil valve control</h4>
<p>
The subsequence retrieves supply air temperature setpoint from previous sequence.
Along with the measured supply air temperature and the supply fan status, it
generates coil valve positions. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
July 10, 2020, by Antoine Gautier:<br/>
Changed default value of integral time for minimum outdoor air control.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2019\">#2019</a>.
</li>
<li>
March 16, 2020, by Jianjun Hu:<br/>
Reimplemented to add new block for specifying the minimum outdoor airfow setpoint.
This new block avoids vector-valued calculations.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
October 27, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end Controller;

                package Economizers "Economizer control of multi zone VAV AHU"

                  block Controller "Multi zone VAV AHU economizer control sequence"

                    parameter Boolean use_enthalpy=false
                      "Set to true if enthalpy measurement is used in addition to temperature measurement";
                    parameter Boolean use_TMix=true
                      "Set to true if mixed air temperature measurement is enabled";
                    parameter Boolean use_G36FrePro=false
                      "Set to true to use G36 freeze protection";
                    parameter Real delTOutHis(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference")=1
                      "Delta between the temperature hysteresis high and low limit"
                      annotation (Dialog(tab="Advanced", group="Hysteresis"));
                    parameter Real delEntHis(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=1000
                      "Delta between the enthalpy hysteresis high and low limits"
                      annotation (Dialog(tab="Advanced",group="Hysteresis",enable=use_enthalpy));
                    parameter Real retDamFulOpeTim(
                      final unit="s",
                      final quantity="Time")=180
                      "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control at disable to avoid pressure fluctuations"
                      annotation (Dialog(tab="Advanced", group="Delays at disable"));
                    parameter Real disDel(
                      final unit="s",
                      final quantity="Time")=15
                      "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                      annotation (Dialog(tab="Advanced", group="Delays at disable"));

                    parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeMinOut=
                      Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      "Type of controller" annotation (Dialog(group="Minimum outdoor air"));

                    parameter Real kMinOut(final unit="1")=0.05
                      "Gain of controller for minimum outdoor air"
                      annotation (Dialog(group="Minimum outdoor air"));
                    parameter Real TiMinOut(
                      final unit="s",
                      final quantity="Time")=120
                      "Time constant of controller for minimum outdoor air intake"
                      annotation (Dialog(group="Minimum outdoor air",
                        enable=controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                            or controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));
                    parameter Real TdMinOut(
                      final unit="s",
                      final quantity="Time")=0.1
                      "Time constant of derivative block for minimum outdoor air intake"
                      annotation (Dialog(group="Minimum outdoor air",
                        enable=controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                            or controllerTypeMinOut == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                    parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeFre=
                      Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      "Type of controller"
                      annotation(Dialog(group="Freeze protection", enable=use_TMix));

                    parameter Real TFreSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")= 279.15
                      "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                       annotation(Dialog(group="Freeze protection", enable=use_TMix));
                    parameter Real kFre(final unit="1/K") = 0.1
                      "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                       annotation(Dialog(group="Freeze protection", enable=use_TMix));

                    parameter Real TiFre(
                      final unit="s",
                      final quantity="Time",
                      final max=TiMinOut)=120
                      "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre <= TiMinOut"
                      annotation(Dialog(group="Freeze protection",
                        enable=use_TMix
                          and (controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                            or controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PID)));

                    parameter Real TdFre(
                      final unit="s",
                      final quantity="Time")=0.1
                      "Time constant of derivative block for freeze protection"
                      annotation (Dialog(group="Economizer freeze protection",
                        enable=use_TMix and
                            (controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                            or controllerTypeFre == Buildings.Controls.OBC.CDL.Types.SimpleController.PID)));

                    parameter Real delta(
                      final unit="s",
                      final quantity="Time")=5
                      "Time horizon over which the outdoor air flow measurment is averaged";
                    parameter Real uHeaMax=-0.25
                      "Lower limit of controller input when outdoor damper opens for modulation control. Require -1 < uHeaMax < uCooMin < 1."
                      annotation (Dialog(tab="Commissioning", group="Supply air temperature control"));
                    parameter Real uCooMin=+0.25
                      "Upper limit of controller input when return damper is closed for modulation control. Require -1 < uHeaMax < uCooMin < 1."
                      annotation (Dialog(tab="Commissioning", group="Supply air temperature control"));

                    parameter Real uOutDamMax(
                      final min=-1,
                      final max=1,
                      final unit="1") = (uHeaMax + uCooMin)/2
                      "Maximum loop signal for the OA damper to be fully open. Require -1 < uHeaMax < uOutDamMax <= uRetDamMin < uCooMin < 1."
                      annotation (Dialog(tab="Commissioning", group="Supply air temperature control"));
                    parameter Real uRetDamMin(
                      final min=-1,
                      final max=1,
                      final unit="1") = (uHeaMax + uCooMin)/2
                      "Minimum loop signal for the RA damper to be fully open. Require -1 < uHeaMax < uOutDamMax <= uRetDamMin < uCooMin < 1."
                      annotation (Dialog(tab="Commissioning", group="Supply air temperature control"));

                    parameter Real uRetDamMinLim(
                      final min=0,
                      final max=1,
                      final unit="1") = 0.5
                      "Loop signal value to start decreasing the maximum return air damper position"
                    annotation (Dialog(tab="Commissioning", group="Minimum outdoor air control"));

                    parameter Real retDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1
                      "Physically fixed maximum position of the return air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real retDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the return air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real outDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1
                      "Physically fixed maximum position of the outdoor air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real outDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the outdoor air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));

                    Buildings.Controls.OBC.CDL.Interfaces.RealInput uTSup(final unit="1")
                      "Signal for supply air temperature control (T Sup Control Loop Signal in diagram)"
                      annotation (Placement(transformation(extent={{-200,20},{-160,60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TOut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") "Outdoor air (OA) temperature"
                      annotation (Placement(transformation(extent={{-200,130},{-160,170}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TOutCut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                      annotation (Placement(transformation(extent={{-200,100},{-160,140}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput hOut(
                      final unit="J/kg",
                      final quantity="SpecificEnergy") if use_enthalpy "Outdoor air enthalpy"
                      annotation (Placement(transformation(extent={{-200,70},{-160,110}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput hOutCut(
                      final unit="J/kg",
                      final quantity="SpecificEnergy") if use_enthalpy
                      "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                      annotation (Placement(transformation(extent={{-200,50},{-160,90}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TMix(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity = "ThermodynamicTemperature") if use_TMix
                      "Measured mixed air temperature, used for freeze protection"
                      annotation (Placement(transformation(extent={{-200,-70},{-160,-30}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput VOut_flow_normalized(
                      final unit="1")
                      "Measured outdoor volumetric airflow rate, normalized by design minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-200,-10},{-160,30}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput VOutMinSet_flow_normalized(
                      final unit="1")
                      "Effective minimum outdoor airflow setpoint, normalized by design minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-200,-40},{-160,0}})));
                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uFreProSta if use_G36FrePro
                      "Freeze protection status"
                      annotation (Placement(transformation(extent={{-200,-170},{-160,-130}})));
                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                      "AHU operation mode status signal"
                      annotation (Placement(transformation(extent={{-200,-130},{-160,-90}})));
                    Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                      "Supply fan status"
                      annotation (Placement(transformation(extent={{-200,-100},{-160,-60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Return air damper position"
                      annotation (Placement(transformation(extent={{160,20},{200,60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Outdoor air damper position"
                      annotation (Placement(transformation(extent={{160,-60},{200,-20}})));

                    Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable enaDis(
                      final use_enthalpy=use_enthalpy,
                      final delTOutHis=delTOutHis,
                      final delEntHis=delEntHis,
                      final retDamFulOpeTim=retDamFulOpeTim,
                      final disDel=disDel)
                      "Multi zone VAV AHU economizer enable/disable sequence"
                      annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
                    Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                      damLim(
                      final retDamPhyPosMax=retDamPhyPosMax,
                      final retDamPhyPosMin=retDamPhyPosMin,
                      final outDamPhyPosMax=outDamPhyPosMax,
                      final outDamPhyPosMin=outDamPhyPosMin,
                      final k=kMinOut,
                      final Ti=TiMinOut,
                      final Td=TdMinOut,
                      final uRetDamMin=uRetDamMinLim,
                      final controllerType=controllerTypeMinOut)
                      "Multi zone VAV AHU economizer minimum outdoor air requirement damper limit sequence"
                      annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
                    Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation
                      mod(
                      final uRetDamMin=uRetDamMin,
                      final uMin=uHeaMax,
                      final uMax=uCooMin,
                      final uOutDamMax=uOutDamMax)
                      "Multi zone VAV AHU economizer damper modulation sequence"
                      annotation (Placement(transformation(extent={{40,0},{60,20}})));
                    Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir freProTMix(
                      final controllerType=controllerTypeFre,
                      final TFreSet = TFreSet,
                      final k=kFre,
                      final Ti=TiFre,
                      final Td=TdFre) if use_TMix
                      "Block that tracks TMix against a freeze protection setpoint"
                      annotation (Placement(transformation(extent={{80,-20},{100,0}})));

                protected
                    Buildings.Controls.OBC.CDL.Continuous.MovingMean movAve(final delta=delta)
                      "Moving average of outdoor air flow measurement, normalized by design minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-140,10},{-120,30}})));
                    Buildings.Controls.OBC.CDL.Continuous.Min outDamMaxFre
                      "Maximum control signal for outdoor air damper due to freeze protection"
                      annotation (Placement(transformation(extent={{120,-50},{140,-30}})));
                    Buildings.Controls.OBC.CDL.Continuous.Max retDamMinFre
                      "Minimum position for return air damper due to freeze protection"
                      annotation (Placement(transformation(extent={{120,30},{140,50}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant noTMix(k=0) if not use_TMix
                      "Ignore max evaluation if there is no mixed air temperature sensor"
                      annotation (Placement(transformation(extent={{76,36},{96,56}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant noTMix1(k=1) if not use_TMix
                      "Ignore min evaluation if there is no mixed air temperature sensor"
                      annotation (Placement(transformation(extent={{80,-56},{100,-36}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant freProSta(
                      final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0) if not use_G36FrePro
                      "Freeze protection status is 0. Use if G36 freeze protection is not implemented"
                      annotation (Placement(transformation(extent={{-140,-140},{-120,-120}})));

                  equation
                    connect(uSupFan, enaDis.uSupFan)
                      annotation (Line(points={{-180,-80},{-80,-80},{-80,-28},{-2,-28}}, color={255,0,255}));
                    connect(uFreProSta, enaDis.uFreProSta)
                      annotation (Line(points={{-180,-150},{-60,-150},{-60,-30},{-2,-30}}, color={255,127,0}));
                    connect(hOutCut, enaDis.hOutCut)
                      annotation (Line(points={{-180,70},{-46,70},{-46,-26},{-2,-26}}, color={0,0,127}));
                    connect(hOut, enaDis.hOut)
                      annotation (Line(points={{-180,90},{-44,90},{-44,-24},{-2,-24}},   color={0,0,127}));
                    connect(TOutCut, enaDis.TOutCut)
                      annotation (Line(points={{-180,120},{-42,120},{-42,-22},{-2,-22}}, color={0,0,127}));
                    connect(TOut, enaDis.TOut)
                      annotation (Line(points={{-180,150},{-40,150},{-40,-20},{-2,-20}}, color={0,0,127}));
                    connect(VOutMinSet_flow_normalized, damLim.VOutMinSet_flow_normalized)
                      annotation (Line(points={{-180,-20},{-110,-20},{-110,18},{-82,18}}, color={0,0,127}));
                    connect(uSupFan, damLim.uSupFan)
                      annotation (Line(points={{-180,-80},{-104,-80},{-104,10},{-82,10}}, color={255,0,255}));
                    connect(uOpeMod, damLim.uOpeMod)
                      annotation (Line(points={{-180,-110},{-102,-110},{-102,2},{-82,2}}, color={255,127,0}));
                    connect(uFreProSta, damLim.uFreProSta)
                      annotation (Line(points={{-180,-150},{-100,-150},{-100,6},{-82,6}}, color={255,127,0}));
                    connect(damLim.yOutDamPosMax, enaDis.uOutDamPosMax)
                      annotation (Line(points={{-58,14},{-24,14},{-24,-32},{-2,-32}}, color={0,0,127}));
                    connect(damLim.yOutDamPosMin, enaDis.uOutDamPosMin)
                      annotation (Line(points={{-58,18},{-26,18},{-26,12},{-26,-34},{-2,-34}}, color={0,0,127}));
                    connect(damLim.yRetDamPosMin, enaDis.uRetDamPosMin)
                      annotation (Line(points={{-58,10},{-28,10},{-28,-40},{-2,-40}}, color={0,0,127}));
                    connect(damLim.yRetDamPhyPosMax, enaDis.uRetDamPhyPosMax)
                      annotation (Line(points={{-58,2},{-32,2},{-32,-36},{-2,-36}}, color={0,0,127}));
                    connect(damLim.yRetDamPosMax, enaDis.uRetDamPosMax)
                      annotation (Line(points={{-58,6},{-30,6},{-30,-38},{-2,-38}}, color={0,0,127}));
                    connect(enaDis.yOutDamPosMax, mod.uOutDamPosMax)
                      annotation (Line(points={{22,-24},{26,-24},{26,5},{38,5}}, color={0,0,127}));
                    connect(enaDis.yRetDamPosMax, mod.uRetDamPosMax)
                      annotation (Line(points={{22,-30},{28,-30},{28,19},{38,19}}, color={0,0,127}));
                    connect(damLim.yOutDamPosMin, mod.uOutDamPosMin)
                      annotation (Line(points={{-58,18},{0,18},{0,1},{38,1}}, color={0,0,127}));
                    connect(enaDis.yRetDamPosMin, mod.uRetDamPosMin)
                      annotation (Line(points={{22,-36},{30,-36},{30,15},{38,15}}, color={0,0,127}));
                    connect(uTSup, mod.uTSup)
                      annotation (Line(points={{-180,40},{10,40},{10,10},{38,10}}, color={0,0,127}));
                    connect(VOut_flow_normalized, movAve.u)
                      annotation (Line(points={{-180,10},{-150,10},{-150,20},{-142,20}}, color={0,0,127}));
                    connect(movAve.y, damLim.VOut_flow_normalized)
                      annotation (Line(points={{-118,20},{-100,20},{-100,14},{-82,14}}, color={0,0,127}));
                    connect(retDamMinFre.y, yRetDamPos)
                      annotation (Line(points={{142,40},{180,40}}, color={0,0,127}));
                    connect(mod.yOutDamPos, outDamMaxFre.u1)
                      annotation (Line(points={{62,4},{110,4},{110,-34},{118,-34}}, color={0,0,127}));
                    connect(outDamMaxFre.y, yOutDamPos)
                      annotation (Line(points={{142,-40},{180,-40}}, color={0,0,127}));
                    connect(outDamMaxFre.u2, noTMix1.y)
                      annotation (Line(points={{118,-46},{102,-46}}, color={0,0,127}));
                    connect(mod.yRetDamPos, retDamMinFre.u2)
                      annotation (Line(points={{62,16},{110,16},{110,34},{118,34}}, color={0,0,127}));
                    connect(retDamMinFre.u1, noTMix.y)
                      annotation (Line(points={{118,46},{98,46}}, color={0,0,127}));
                    connect(TMix, freProTMix.TMix)
                      annotation (Line(points={{-180,-50},{-120,-50},{-120,-60},{60,-60},{60,-10},
                        {78,-10}}, color={0,0,127}));
                    connect(freProTMix.yFrePro, retDamMinFre.u1)
                      annotation (Line(points={{102,-13},{104,-13},{104,46},{118,46}}, color={0,0,127}));
                    connect(freProTMix.yFreProInv, outDamMaxFre.u2)
                      annotation (Line(points={{102,-7},{104,-7},{104,-46},{118,-46}},
                        color={0,0,127}));
                    connect(freProSta.y, damLim.uFreProSta)
                      annotation (Line(points={{-118,-130},{-90,-130},{-90,6},{-82,6}}, color={255,127,0}));
                    connect(freProSta.y, enaDis.uFreProSta)
                      annotation (Line(points={{-118,-130},{-60,-130},{-60,-30},{-2,-30}}, color={255,127,0}));

                  annotation (
                      defaultComponentName="conEco",
                      Icon(coordinateSystem(extent={{-160,-160},{160,160}}),
                           graphics={
                          Rectangle(
                            extent={{-160,-160},{160,162}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Line(
                            points={{-96,-40},{-18,-40},{20,62},{58,62}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-92,62},{-14,62},{24,-36},{88,-36}},
                            color={0,0,127},
                            pattern=LinePattern.Dash,
                            thickness=0.5),
                          Line(
                            points={{58,62},{58,-14},{58,-26},{90,-26}},
                            color={0,0,127},
                            thickness=0.5),
                          Text(
                            extent={{-176,216},{152,178}},
                            lineColor={0,0,127},
                            textString="%name")}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-160},{
                              160,160}}), graphics={Text(
                            extent={{-140,22},{-110,6}},
                            lineColor={95,95,95},
                            textString="Not included
in G36",                    horizontalAlignment=TextAlignment.Left),
                          Rectangle(
                            extent={{70,100},{150,-100}},
                            lineColor={0,0,127},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                    Text(
                            extent={{76,-86},{154,-96}},
                            lineColor={95,95,95},
                            textString="Freeze protection based on TMix,
not a part of G36",         horizontalAlignment=TextAlignment.Left)}),
                      Documentation(info="<html>
<p>
Multi zone VAV AHU economizer control sequence that calculates
outdoor and return air damper positions based on ASHRAE
Guidline 36, PART 5 sections: N.2.c, N.5, N.6.c, N.7, A.17, N.12.
</p>
<p>
The sequence consists of three subsequences.
</p>
<ul>
<li>
First, the block <code>damLim</code> computes the damper position limits to satisfy
outdoor air requirements. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a>
for a description.
</li>
<li>
Second, the block <code>enaDis</code> enables or disables the economizer based on
outdoor temperature and optionally enthalpy, and based on the supply fan status,
freeze protection stage and zone state.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
for a description.
</li>
<li>
Third, the block <code>mod</code> modulates the outdoor and return damper position
to track the supply air temperature setpoint, subject to the limits of the damper positions
that were computed in the above two blocks.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation</a>
for a description.
</li>
</ul>
<p>
To enable freeze protection control logic that closes the outdoor air damper based
on the mixed air temperature <code>TMix</code>, set <code>use_TMix=true</code>.
This part of the control logic is not in Guideline 36, public review draft 1.
</p>
<p>
To enable the freeze protection according to Guideline 36, public review draft 1,
which may be revised in future versions, set
<code>use_G36FrePro=true</code>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 10, 2020, by Antoine Gautier:<br/>
Changed default value of integral time for minimum outdoor air control.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2019\">#2019</a>.
</li>
<li>
October 11, 2017, by Michael Wetter:<br/>
Corrected implementation to use control loop signal as input.
</li>
<li>
June 28, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Controller;

                  package Subsequences "Subsequences for economizer control"

                    block Enable
                      "Multi zone VAV AHU economizer enable/disable switch"

                      parameter Boolean use_enthalpy = true
                        "Set to true to evaluate outdoor air enthalpy in addition to temperature"
                        annotation(Dialog(group="Conditional"));
                      parameter Real delTOutHis(
                        final unit="K",
                        final displayUnit="K",
                        final quantity="TemperatureDifference")=1
                        "Delta between the temperature hysteresis high and low limit"
                        annotation(Dialog(tab="Advanced", group="Hysteresis"));
                      parameter Real delEntHis(
                        final unit="J/kg",
                        final quantity="SpecificEnergy")=1000
                        "Delta between the enthalpy hysteresis high and low limits"
                        annotation(Dialog(tab="Advanced", group="Hysteresis", enable = use_enthalpy));
                      parameter Real retDamFulOpeTim(
                        final unit="s",
                        final quantity="Time")=180
                        "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control
    at disable to avoid pressure fluctuations"
                        annotation(Dialog(tab="Advanced", group="Delays at disable"));
                      parameter Real disDel(
                        final unit="s",
                        final quantity="Time")=15
                        "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                        annotation(Dialog(tab="Advanced", group="Delays at disable"));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput TOut(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity = "ThermodynamicTemperature")
                        "Outdoor air temperature"
                        annotation (Placement(transformation(extent={{-320,250},{-280,290}}),
                            iconTransformation(extent={{-140,80},{-100,120}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput hOut(
                        final unit="J/kg",
                        final quantity="SpecificEnergy") if use_enthalpy
                        "Outdoor air enthalpy"
                        annotation (Placement(transformation(extent={{-320,170},{-280,210}}),
                            iconTransformation(extent={{-140,40},{-100,80}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput TOutCut(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity = "ThermodynamicTemperature")
                        "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                        annotation (Placement(transformation(extent={{-320,210},{-280,250}}),
                            iconTransformation(extent={{-140,60},{-100,100}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput hOutCut(
                        final unit="J/kg",
                        final quantity="SpecificEnergy") if use_enthalpy
                        "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                        annotation (Placement(transformation(extent={{-320,130},{-280,170}}),
                            iconTransformation(extent={{-140,20},{-100,60}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutDamPosMin(
                        final unit="1",
                        final min=0,
                        final max=1)
                        "Minimum outdoor air damper position, output from damper position limits sequence"
                        annotation (Placement(transformation(extent={{-320,-80},{-280,-40}}),
                            iconTransformation(extent={{-140,-60},{-100,-20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutDamPosMax(
                        final unit="1",
                        final min=0,
                        final max=1)
                        "Maximum outdoor air damper position, output from damper position limits sequence"
                        annotation (Placement(transformation(extent={{-320,-40},{-280,0}}),
                            iconTransformation(extent={{-140,-40},{-100,0}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uRetDamPosMax(
                        final unit="1",
                        final min=0,
                        final max=1)
                        "Maximum return air damper position, output from damper position limits sequence"
                        annotation (Placement(transformation(extent={{-320,-160},{-280,-120}}),
                            iconTransformation(extent={{-140,-100},{-100,-60}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uRetDamPosMin(
                        final unit="1",
                        final min=0,
                        final max=1)
                        "Minimum return air damper position, output from damper position limits sequence"
                        annotation (Placement(transformation(extent={{-320,-200},{-280,-160}}),
                            iconTransformation(extent={{-140,-120},{-100,-80}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uRetDamPhyPosMax(
                        final unit="1",
                        final min=0,
                        final max=1)
                        "Physical maximum return air damper position, output from damper position limits sequence"
                        annotation (Placement(transformation(extent={{-320,-120},{-280,-80}}),
                            iconTransformation(extent={{-140,-80},{-100,-40}})));
                      Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                        "Supply fan on/off status signal"
                        annotation (Placement(transformation(extent={{-320,80},{-280,120}}),
                            iconTransformation(extent={{-140,0},{-100,40}})));
                      Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uFreProSta "Freeze protection stage status signal"
                        annotation (Placement(transformation(extent={{-320,30},{-280,70}}),
                            iconTransformation(extent={{-140,-20},{-100,20}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPosMax(
                        final unit="1",
                        final min=0,
                        final max=1) "Maximum outdoor air damper position"
                        annotation (Placement(transformation(extent={{220,40},{260,80}}),
                            iconTransformation(extent={{100,40},{140,80}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPosMin(
                        final unit="1",
                        final min=0,
                        final max=1) "Minimum return air damper position"
                        annotation (Placement(transformation(extent={{220,-80},{260,-40}}),
                            iconTransformation(extent={{100,-80},{140,-40}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPosMax(
                        final unit="1",
                        final min=0,
                        final max=1) "Maximum return air damper position"
                        annotation (Placement(transformation(extent={{220,-20},{260,20}}),
                            iconTransformation(extent={{100,-20},{140,20}})));

                      Buildings.Controls.OBC.CDL.Logical.TrueFalseHold truFalHol(
                        trueHoldDuration=600) "10 min on/off delay"
                        annotation (Placement(transformation(extent={{0,200},{20,220}})));
                      Buildings.Controls.OBC.CDL.Logical.And andEnaDis
                        "Logical and that checks freeze protection stage and zone state"
                        annotation (Placement(transformation(extent={{40,30},{60,50}})));

                  protected
                      final parameter Real TOutHigLimCutHig(
                        final unit="K",
                        final displayUnit="K",
                        final quantity="TemperatureDifference")= 0
                        "Hysteresis high limit cutoff";
                      final parameter Real TOutHigLimCutLow = TOutHigLimCutHig - delTOutHis
                        "Hysteresis low limit cutoff";
                      final parameter Real hOutHigLimCutHig(
                        final unit="J/kg",
                        final quantity="SpecificEnergy")= 0
                        "Hysteresis block high limit cutoff";
                      final parameter Real hOutHigLimCutLow = hOutHigLimCutHig - delEntHis
                        "Hysteresis block low limit cutoff";

                      Buildings.Controls.OBC.CDL.Logical.Sources.Constant entSubst(
                        final k=false) if not use_enthalpy
                        "Deactivates outdoor air enthalpy condition if there is no enthalpy sensor"
                        annotation (Placement(transformation(extent={{-100,190},{-80,210}})));
                      Buildings.Controls.OBC.CDL.Continuous.Add add2(
                        final k2=-1) if use_enthalpy "Add block determines difference between hOut and hOutCut"
                        annotation (Placement(transformation(extent={{-140,160},{-120,180}})));
                      Buildings.Controls.OBC.CDL.Continuous.Add add1(
                        final k2=-1) "Add block determines difference between TOut and TOutCut"
                        annotation (Placement(transformation(extent={{-140,240},{-120,260}})));
                      Buildings.Controls.OBC.CDL.Continuous.Hysteresis hysOutTem(
                        final uLow=TOutHigLimCutLow,
                        final uHigh=TOutHigLimCutHig)
                        "Outdoor air temperature hysteresis for both fixed and differential dry bulb temperature cutoff conditions"
                        annotation (Placement(transformation(extent={{-100,240},{-80,260}})));
                      Buildings.Controls.OBC.CDL.Continuous.Hysteresis hysOutEnt(
                        final uLow=hOutHigLimCutLow,
                        final uHigh=hOutHigLimCutHig) if use_enthalpy
                        "Outdoor air enthalpy hysteresis for both fixed and differential enthalpy cutoff conditions"
                        annotation (Placement(transformation(extent={{-100,160},{-80,180}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch outDamSwitch
                        "Set maximum OA damper position to minimum at disable (after a given time delay)"
                        annotation (Placement(transformation(extent={{62,-60},{82,-40}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch retDamSwitch "Set minimum RA damper position to maximum at disable"
                        annotation (Placement(transformation(extent={{-40,-162},{-20,-142}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch maxRetDamSwitch
                        "Keep maximum RA damper position at physical maximum for a short time period after disable signal"
                        annotation (Placement(transformation(extent={{40,-120},{60,-100}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch minRetDamSwitch
                        "Keep minimum RA damper position at physical maximum for a short time period after disable"
                        annotation (Placement(transformation(extent={{40,-160},{60,-140}})));
                      Buildings.Controls.OBC.CDL.Logical.Nor nor1 "Logical nor"
                        annotation (Placement(transformation(extent={{-40,200},{-20,220}})));
                      Buildings.Controls.OBC.CDL.Logical.Not not2 "Logical not that starts the timer at disable signal "
                        annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
                      Buildings.Controls.OBC.CDL.Logical.And  and2 "Logical and"
                        annotation (Placement(transformation(extent={{140,-80},{160,-60}})));
                      Buildings.Controls.OBC.CDL.Logical.And and1 "Logical and checks supply fan status"
                        annotation (Placement(transformation(extent={{0,100},{20,120}})));
                      Buildings.Controls.OBC.CDL.Logical.And and3 "Logical and which checks supply fan status"
                        annotation (Placement(transformation(extent={{20,-36},{40,-16}})));

                      Buildings.Controls.OBC.CDL.Integers.Equal intEqu
                        "Logical block to check if the freeze protection is deactivated"
                        annotation (Placement(transformation(extent={{-98,50},{-78,70}})));
                      Buildings.Controls.OBC.CDL.Logical.TrueDelay delOutDamOsc(
                        final delayTime=disDel)
                        "Small delay before closing the outdoor air damper to avoid pressure fluctuations"
                        annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
                      Buildings.Controls.OBC.CDL.Logical.TrueDelay delRetDam(
                        final delayTime=retDamFulOpeTim)
                        "Keep return damper open to its physical maximum for a short period of time before closing the outdoor air damper and resuming the maximum return air damper position, per G36 Part N7"
                        annotation (Placement(transformation(extent={{-40,-90},{-20,-70}})));
                      Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not"
                        annotation (Placement(transformation(extent={{0,-90},{20,-70}})));
                      Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt(
                        final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Integer constant, stage 0"
                        annotation (Placement(transformation(extent={{-138,30},{-118,50}})));

                    equation
                      connect(TOut, add1.u1)
                        annotation (Line(points={{-300,270},{-270,270},{-270,256},{-142,256}},color={0,0,127}));
                      connect(TOutCut, add1.u2)
                        annotation (Line(points={{-300,230},{-252,230},{-252,244},{-142,244}},color={0,0,127}));
                      connect(add1.y, hysOutTem.u)
                        annotation (Line(points={{-118,250},{-102,250}}, color={0,0,127}));
                      connect(hOut, add2.u1)
                        annotation (Line(points={{-300,190},{-252,190},{-252,176},{-142,176}},color={0,0,127}));
                      connect(hOutCut, add2.u2)
                        annotation (Line(points={{-300,150},{-252,150},{-252,164},{-142,164}}, color={0,0,127}));
                      connect(add2.y, hysOutEnt.u)
                        annotation (Line(points={{-118,170},{-102,170}}, color={0,0,127}));
                      connect(hysOutTem.y, nor1.u1)
                        annotation (Line(points={{-78,250},{-60,250},{-60,210},{-42,210}},color={255,0,255}));
                      connect(hysOutEnt.y, nor1.u2)
                        annotation (Line(points={{-78,170},{-60,170},{-60,202},{-42,202}},color={255,0,255}));
                      connect(entSubst.y, nor1.u2)
                        annotation (Line(points={{-78,200},{-60,200},{-60,202},{-42,202}},color={255,0,255}));
                      connect(uOutDamPosMin, outDamSwitch.u1)
                        annotation (Line(points={{-300,-60},{-10,-60},{-10,-42},{60,-42}},color={0,0,127}));
                      connect(uOutDamPosMax, outDamSwitch.u3)
                        annotation (Line(points={{-300,-20},{-240,-20},{-240,-58},{60,-58}},color={0,0,127}));
                      connect(uRetDamPhyPosMax, maxRetDamSwitch.u1)
                        annotation (Line(points={{-300,-100},{-178,-100},{-178,-102},{38,-102}},color={0,0,127}));
                      connect(uRetDamPosMax, maxRetDamSwitch.u3)
                        annotation (Line(points={{-300,-140},{-178,-140},{-178,-118},{38,-118}},color={0,0,127}));
                      connect(nor1.y, truFalHol.u)
                        annotation (Line(points={{-18,210},{-2,210}}, color={255,0,255}));
                      connect(andEnaDis.y, not2.u)
                        annotation (Line(points={{62,40},{72,40},{72,10},{-100,10},{-100,-30},{-82,-30}},
                          color={255,0,255}));
                      connect(maxRetDamSwitch.y, yRetDamPosMax)
                        annotation (Line(points={{62,-110},{180,-110},{180,0},{240,0}},color={0,0,127}));
                      connect(and2.y, maxRetDamSwitch.u2)
                        annotation (Line(points={{162,-70},{170,-70},{170,-130},{20,-130},{20,-110},
                          {38,-110}}, color={255,0,255}));
                      connect(and2.y, minRetDamSwitch.u2)
                        annotation (Line(points={{162,-70},{170,-70},{170,-130},{20,-130},{20,-150},
                          {38,-150}}, color={255,0,255}));
                      connect(not2.y, retDamSwitch.u2)
                        annotation (Line(points={{-58,-30},{-50,-30},{-50,-152},{-42,-152}},color={255,0,255}));
                      connect(uRetDamPosMax, retDamSwitch.u1)
                        annotation (Line(points={{-300,-140},{-240,-140},{-240,-144},{-42,-144}},color={0,0,127}));
                      connect(uRetDamPosMin, retDamSwitch.u3)
                        annotation (Line(points={{-300,-180},{-172,-180},{-172,-160},{-42,-160}},color={0,0,127}));
                      connect(retDamSwitch.y, minRetDamSwitch.u3)
                        annotation (Line(points={{-18,-152},{0,-152},{0,-158},{38,-158}},color={0,0,127}));
                      connect(uRetDamPhyPosMax, minRetDamSwitch.u1)
                        annotation (Line(points={{-300,-100},{-220,-100},{-220,-130},{0,-130},{0,-142},{38,-142}},
                          color={0,0,127}));
                      connect(truFalHol.y, and1.u1)
                        annotation (Line(points={{22,210},{30,210},{30,130},{-10,130},{-10,110},
                          {-2,110}}, color={255,0,255}));
                      connect(and1.y, andEnaDis.u1)
                        annotation (Line(points={{22,110},{22,110},{30,110},{30,40},{38,40}},color={255,0,255}));
                      connect(uSupFan, and1.u2)
                        annotation (Line(points={{-300,100},{-152,100},{-152,102},{-2,102}},color={255,0,255}));
                      connect(outDamSwitch.u2, and3.y)
                        annotation (Line(points={{60,-50},{50,-50},{50,-26},{42,-26}},color={255,0,255}));
                      connect(not2.y, and3.u1)
                        annotation (Line(points={{-58,-30},{-50,-30},{-50,-4},{8,-4},{8,-26},{18,-26}},
                        color={255,0,255}));
                      connect(and2.u1, not2.y)
                        annotation (Line(points={{138,-70},{106,-70},{106,-4},{-50,-4},{-50,-30},
                          {-58,-30}}, color={255,0,255}));
                      connect(and3.u2, delOutDamOsc.y)
                        annotation (Line(points={{18,-34},{0,-34},{0,-30},{-18,-30}},color={255,0,255}));
                      connect(delOutDamOsc.u, not2.y)
                        annotation (Line(points={{-42,-30},{-46,-30},{-46,-30},{-50,-30},{-50,-30},
                          {-58,-30}}, color={255,0,255}));
                      connect(not2.y, delRetDam.u)
                        annotation (Line(points={{-58,-30},{-50,-30},{-50,-80},{-42,-80}},color={255,0,255}));
                      connect(delRetDam.y, not1.u)
                        annotation (Line(points={{-18,-80},{-14,-80},{-14,-80},{-10,-80},{-10,-80},
                          {-2,-80}}, color={255,0,255}));
                      connect(not1.y, and2.u2)
                        annotation (Line(points={{22,-80},{80,-80},{80,-78},{138,-78}},color={255,0,255}));
                      connect(uFreProSta, intEqu.u1)
                        annotation (Line(points={{-300,50},{-240,50},{-240,60},{-100,60}},color={255,127,0}));
                      connect(conInt.y, intEqu.u2)
                        annotation (Line(points={{-116,40},{-110,40},{-110,52},{-100,52}},color={255,127,0}));
                      connect(intEqu.y, andEnaDis.u2)
                        annotation (Line(points={{-76,60},{20,60},{20,32},{38,32}},color={255,0,255}));
                      connect(outDamSwitch.y, yOutDamPosMax)
                        annotation (Line(points={{84,-50},{170,-50},{170,60},{240,60}}, color={0,0,127}));
                      connect(minRetDamSwitch.y, yRetDamPosMin)
                        annotation (Line(points={{62,-150},{190,-150},{190,-60},{240,-60}}, color={0,0,127}));

                    annotation (
                        defaultComponentName = "enaDis",
                        Icon(graphics={
                            Rectangle(
                              extent={{-100,-100},{100,100}},
                              lineColor={0,0,127},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-174,142},{154,104}},
                              lineColor={0,0,127},
                              textString="%name"),
                            Line(
                              points={{0,60},{80,60}},
                              color={0,0,127},
                              thickness=0.5),
                            Line(
                              points={{-80,-60},{0,-60},{0,60}},
                              color={0,0,127},
                              thickness=0.5)}),
                        Diagram(coordinateSystem(
                            preserveAspectRatio=false,
                            extent={{-280,-240},{220,280}},
                            initialScale=0.05),              graphics={
                            Rectangle(
                              extent={{-260,16},{200,-232}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-260,76},{200,24}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-260,136},{200,84}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-260,272},{200,144}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                                                         Text(
                              extent={{102,168},{184,156}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Outdoor air
conditions"),                                            Text(
                              extent={{100,70},{278,36}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Freeze protection -
disable if stage1
and above"),                                             Text(
                              extent={{100,-180},{268,-228}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Damper position
limit assignments
with delays"),                                       Text(
                              extent={{100,102},{194,92}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Supply fan status")}),
                    Documentation(info="<html>
<p>
This is a multi zone VAV AHU economizer enable/disable sequence
based on ASHRAE G36 PART 5.N.7 and PART 5.A.17. Additional
conditions included in the sequence are: freeze protection (freeze protection
stage 0-3, see PART 5.N.12), supply fan status (on or off, see PART 5.N.5).
</p>
<p>
The economizer is disabled whenever the outdoor air conditions
exceed the economizer high limit setpoint.
This sequence allows for all device types listed in
ASHRAE 90.1-2013 and Title 24-2013.
</p>
<p>
In addition, the economizer gets disabled without a delay whenever any of the
following is <code>true</code>:
</p>
<ul>
<li>
The supply fan is off (<code>uSupFan = false</code>),
</li>
<li>
the freeze protection stage
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages</a>
is not <code>stage0</code>.
</li>
</ul>
<p>
The following state machine chart illustrates the transitions between enabling and disabling:
</p>
<p align=\"center\">
<img alt=\"Image of economizer enable-disable state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconEnableDisableStateMachineChart.png\"/>
</p>
<p>
After the disable signal is activated, the following procedure is applied, per PART 5.N.7.d, in order to
prevent pressure fluctuations in the HVAC system:
</p>
<ul>
<li>
The return damper gets fully opened (<code>yRetDamPosMax = uRetDamPhyPosMax</code> and
<code>yRetDamPosMin = uRetDamPhyPosMax</code>) for <code>retDamFulOpeTim</code>
time period, after which the return damper gets released to its minimum outdoor airflow control position
(<code>yRetDamPosMax = uRetDamPosMax</code> and <code>yRetDamPosMin = uRetDamPosMax</code>).
</li>
<li>
The outdoor air damper is closed to its minimum outoor airflow control limit (<code>yOutDamPosMax = uOutDamPosMin</code>)
after a <code>disDel</code> time delay.
</li>
</ul>
<p>
This sequence also has an overwrite of the damper positions to track
a minimum mixed air temperature of <code>TFreSet</code>, which is
by default set to <i>4</i>&deg;C (<i>39.2</i> F).
This is implemented using a proportional controller with a default deadband of
<i>1</i> K, which can be adjusted using the parameter <code>kPFrePro</code>.
</p>
</html>",                     revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Added freeze protection that tracks mixed air temperature.
</li>
<li>
August 3, 2017, by Michael Wetter:<br/>
Removed unrequired input into block <code>and2</code> as this input
was always <code>true</code> if <code>and2.u2 = true</code>.
</li>
<li>
June 27, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Enable;

                    block Limits
                      "Multi zone VAV AHU minimum outdoor air control - damper position limits"

                      parameter Real uRetDamMin(
                        final min=yMin,
                        final max=yMax,
                        final unit="1") = 0.5
                        "Loop signal value to start decreasing the maximum return air damper position"
                        annotation (Dialog(tab="Commissioning", group="Controller"));

                      parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=
                        Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                        "Type of controller"
                        annotation (Dialog(group="Controller"));

                      parameter Real k(
                        final unit="1")=0.05 "Gain of damper limit controller"
                        annotation (Dialog(group="Controller"));

                      parameter Real Ti(
                        final unit="s",
                        final quantity="Time")=120
                        "Time constant of damper limit controller integrator block"
                        annotation (Dialog(group="Controller",
                        enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                            or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                      parameter Real Td(
                        final unit="s",
                        final quantity="Time")=0.1
                      "Time constant of damper limit controller derivative block"
                        annotation (Dialog(group="Controller",
                        enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                            or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                      parameter Real retDamPhyPosMax(
                        final min=0,
                        final max=1,
                        final unit="1") = 1 "Physically fixed maximum position of the return air damper"
                        annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                      parameter Real retDamPhyPosMin(
                        final min=0,
                        final max=1,
                        final unit="1") = 0
                        "Physically fixed minimum position of the return air damper"
                        annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                      parameter Real outDamPhyPosMax(
                        final min=0,
                        final max=1,
                        final unit="1") = 1
                        "Physically fixed maximum position of the outdoor air damper"
                        annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                      parameter Real outDamPhyPosMin(
                        final min=0,
                        final max=1,
                        final unit="1") = 0
                        "Physically fixed minimum position of the outdoor air damper"
                        annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VOut_flow_normalized(
                       final unit="1")
                        "Measured outdoor volumetric airflow rate, normalized by design minimum outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-220,150},{-180,190}}),
                            iconTransformation(extent={{-140,20},{-100,60}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VOutMinSet_flow_normalized(
                        final unit="1")
                        "Effective minimum outdoor airflow setpoint, normalized by design minimum outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-220,200},{-180,240}}),
                            iconTransformation(extent={{-140,60},{-100,100}})));
                      Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                        "AHU operation mode status signal"
                        annotation (Placement(transformation(extent={{-220,-200},{-180,-160}}),
                            iconTransformation(extent={{-140,-100},{-100,-60}})));
                      Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uFreProSta
                        "Freeze protection status signal"
                        annotation (Placement(transformation(extent={{-220,-160},{-180,-120}}),
                            iconTransformation(extent={{-140,-60},{-100,-20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                        "Supply fan status signal"
                        annotation (Placement(transformation(extent={{-220,-120},{-180,-80}}),
                            iconTransformation(extent={{-140,-20},{-100,20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPosMin(
                        final min=outDamPhyPosMin,
                        final max=outDamPhyPosMax,
                        final unit="1") "Minimum outdoor air damper position limit"
                        annotation (Placement(transformation(extent={{180,80},{220,120}}),
                            iconTransformation(extent={{100,60},{140,100}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPosMax(
                        final min=outDamPhyPosMin,
                        final max=outDamPhyPosMax,
                        final unit="1") "Maximum outdoor air damper position limit"
                        annotation (Placement(transformation(extent={{180,30},{220,70}}),
                            iconTransformation(extent={{100,20},{140,60}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPosMin(
                        final min=retDamPhyPosMin,
                        final max=retDamPhyPosMax,
                        final unit="1") "Minimum return air damper position limit"
                        annotation (Placement(transformation(extent={{180,-20},{220,20}}),
                            iconTransformation(extent={{100,-20},{140,20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPosMax(
                        final min=retDamPhyPosMin,
                        final max=retDamPhyPosMax,
                        final unit="1") "Maximum return air damper position limit"
                        annotation (Placement(transformation(extent={{180,-70},{220,-30}}),
                            iconTransformation(extent={{100,-60},{140,-20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPhyPosMax(
                        final min=0,
                        final max=1,
                        final unit="1")
                        "Physical maximum return air damper position limit. Required as an input for the economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{180,-110},{220,-70}}),
                            iconTransformation(extent={{100,-100},{140,-60}})));

                      Buildings.Controls.OBC.CDL.Continuous.PIDWithReset damLimCon(
                        final controllerType=controllerType,
                        final k=k,
                        final Ti=Ti,
                        final Td=Td,
                        final yMax=yMax,
                        final yMin=yMin)
                        "Damper position limit controller"
                        annotation (Placement(transformation(extent={{-140,180},{-120,200}})));

                  protected
                      parameter Real yMin=0 "Lower limit of control loop signal";
                      parameter Real yMax=1 "Upper limit of control loop signal";
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant outDamPhyPosMinSig(
                        final k=outDamPhyPosMin)
                        "Physically fixed minimum position of the outdoor air damper. This is the initial position of the economizer damper"
                        annotation (Placement(transformation(extent={{-160,70},{-140,90}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant outDamPhyPosMaxSig(
                        final k=outDamPhyPosMax)
                        "Physically fixed maximum position of the outdoor air damper."
                        annotation (Placement(transformation(extent={{-160,30},{-140,50}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant retDamPhyPosMinSig(
                        final k=retDamPhyPosMin)
                        "Physically fixed minimum position of the return air damper"
                        annotation (Placement(transformation(extent={{-160,-10},{-140,10}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant retDamPhyPosMaxSig(
                        final k=retDamPhyPosMax)
                        "Physically fixed maximum position of the return air damper. This is the initial condition of the return air damper"
                        annotation (Placement(transformation(extent={{-160,-50},{-140,-30}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minSigLim(
                        final k=yMin)
                        "Equals minimum controller output signal"
                        annotation (Placement(transformation(extent={{-100,200},{-80,220}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxSigLim(
                        final k=yMax)
                        "Equals maximum controller output signal"
                        annotation (Placement(transformation(extent={{-20,200},{0,220}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant sigFraForOutDam(
                        final k=uRetDamMin) "Equals the fraction of the control loop signal below which the outdoor air damper
    limit gets modulated and above which the return air damper limit gets modulated"
                        annotation (Placement(transformation(extent={{-60,200},{-40,220}})));
                      Buildings.Controls.OBC.CDL.Continuous.Line minOutDam(
                        final limitBelow=true,
                        final limitAbove=true)
                        "Linear mapping of the outdoor air damper position to the control signal"
                        annotation (Placement(transformation(extent={{120,140},{140,160}})));
                      Buildings.Controls.OBC.CDL.Continuous.Line minRetDam(
                        final limitBelow=true,
                        final limitAbove=true)
                        "Linear mapping of the return air damper position to the control signal"
                        annotation (Placement(transformation(extent={{120,100},{140,120}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch retDamPosMinSwitch
                        "A switch to deactivate the return air damper minimal outdoor airflow control"
                        annotation (Placement(transformation(extent={{40,-30},{60,-10}})));
                      Buildings.Controls.OBC.CDL.Logical.Switch outDamPosMaxSwitch
                        "A switch to deactivate the outdoor air damper minimal outdoor airflow control"
                        annotation (Placement(transformation(extent={{40,10},{60,30}})));
                      Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not block"
                        annotation (Placement(transformation(extent={{-8,-110},{12,-90}})));
                      Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt(
                        final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage 1"
                        annotation (Placement(transformation(extent={{-160,-170},{-140,-150}})));
                      Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt1(
                        final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "Occupied mode index"
                        annotation (Placement(transformation(extent={{-160,-210},{-140,-190}})));
                      Buildings.Controls.OBC.CDL.Integers.LessEqual intLesEqu
                        "Check if freeze protection stage is stage 0"
                        annotation (Placement(transformation(extent={{-120,-150},{-100,-130}})));
                      Buildings.Controls.OBC.CDL.Integers.Equal intEqu
                        "Check if operation mode is occupied"
                        annotation (Placement(transformation(extent={{-120,-190},{-100,-170}})));
                      Buildings.Controls.OBC.CDL.Logical.And and2 "Logical and"
                        annotation (Placement(transformation(extent={{-80,-110},{-60,-90}})));
                      Buildings.Controls.OBC.CDL.Logical.And and3 "Logical and"
                        annotation (Placement(transformation(extent={{-40,-110},{-20,-90}})));

                    equation
                      connect(minRetDam.y, yRetDamPosMax) annotation (Line(points={{142,110},{150,110},
                              {150,-50},{200,-50}}, color={0,0,127}));
                      connect(retDamPosMinSwitch.y, minRetDam.f2) annotation (Line(points={{62,-20},
                              {62,-18},{62,-20},{100,-20},{100,102},{118,102}}, color={0,0,127}));
                      connect(sigFraForOutDam.y, minRetDam.x1) annotation (Line(points={{-38,210},{-30,
                              210},{-30,118},{118,118}}, color={0,0,127}));
                      connect(maxSigLim.y, minRetDam.x2) annotation (Line(points={{2,210},{8,210},{8,
                              106},{118,106}}, color={0,0,127}));
                      connect(VOut_flow_normalized, damLimCon.u_m) annotation (Line(points={{-200,170},
                              {-130,170},{-130,178}}, color={0,0,127}));
                      connect(VOutMinSet_flow_normalized, damLimCon.u_s) annotation (Line(points={{-200,
                              220},{-160,220},{-160,190},{-142,190}}, color={0,0,127}));
                      connect(damLimCon.y, minRetDam.u) annotation (Line(points={{-118,190},{-80,190},
                              {-80,110},{118,110}},      color={0,0,127}));
                      connect(outDamPosMaxSwitch.y, minOutDam.f2) annotation (Line(points={{62,20},{
                              110,20},{110,142},{118,142}}, color={0,0,127}));
                      connect(minSigLim.y, minOutDam.x1) annotation (Line(points={{-78,210},{-70,210},
                              {-70,182},{104,182},{104,158},{118,158}},      color={0,0,127}));
                      connect(sigFraForOutDam.y, minOutDam.x2) annotation (Line(points={{-38,210},{-38,
                              210},{-30,210},{-30,146},{118,146}},     color={0,0,127}));
                      connect(damLimCon.y, minOutDam.u) annotation (Line(points={{-118,190},{-80,190},
                              {-80,150},{118,150}},      color={0,0,127}));
                      connect(outDamPosMaxSwitch.y, yOutDamPosMax) annotation (Line(points={{62,20},
                              {110,20},{110,50},{200,50}}, color={0,0,127}));
                      connect(minOutDam.y, yOutDamPosMin) annotation (Line(points={{142,150},{160,150},
                              {160,100},{200,100}},    color={0,0,127}));
                      connect(retDamPhyPosMaxSig.y, retDamPosMinSwitch.u1) annotation (Line(points={{-138,
                              -40},{-60,-40},{-60,-12},{38,-12}},   color={0,0,127}));
                      connect(retDamPhyPosMaxSig.y, minRetDam.f1) annotation (Line(points={{-138,-40},
                              {-60,-40},{-60,114},{118,114}}, color={0,0,127}));
                      connect(retDamPhyPosMinSig.y, retDamPosMinSwitch.u3) annotation (Line(points={{-138,0},
                              {-120,0},{-120,-28},{38,-28}},          color={0,0,127}));
                      connect(outDamPhyPosMaxSig.y, outDamPosMaxSwitch.u3) annotation (Line(points={{-138,40},
                              {-120,40},{-120,12},{38,12}},           color={0,0,127}));
                      connect(outDamPhyPosMinSig.y, outDamPosMaxSwitch.u1) annotation (Line(points={{-138,80},
                              {0,80},{0,28},{38,28}},           color={0,0,127}));
                      connect(outDamPhyPosMinSig.y, minOutDam.f1) annotation (Line(points={{-138,80},
                              {0,80},{0,154},{118,154}}, color={0,0,127}));
                      connect(not1.y, retDamPosMinSwitch.u2) annotation (Line(points={{14,-100},{20,
                              -100},{20,-20},{38,-20}},color={255,0,255}));
                      connect(not1.y, outDamPosMaxSwitch.u2) annotation (Line(points={{14,-100},{20,
                              -100},{20,20},{38,20}},color={255,0,255}));
                      connect(retDamPosMinSwitch.y, yRetDamPosMin) annotation (Line(points={{62,-20},
                              {100,-20},{100,0},{200,0}}, color={0,0,127}));
                      connect(retDamPhyPosMaxSig.y, yRetDamPhyPosMax) annotation (Line(points={{-138,
                              -40},{40,-40},{40,-90},{200,-90}}, color={0,0,127}));
                      connect(uOpeMod, intEqu.u1)
                        annotation (Line(points={{-200,-180},{-122,-180}}, color={255,127,0}));
                      connect(conInt1.y, intEqu.u2)
                        annotation (Line(points={{-138,-200},{-130,-200},{-130,-188},{-122,-188}},
                          color={255,127,0}));
                      connect(conInt.y, intLesEqu.u2)
                        annotation (Line(points={{-138,-160},{-130,-160},{-130,-148},{-122,-148}},
                          color={255,127,0}));
                      connect(uFreProSta, intLesEqu.u1)
                        annotation (Line(points={{-200,-140},{-122,-140}}, color={255,127,0}));
                      connect(damLimCon.trigger, uSupFan)
                        annotation (Line(points={{-136,178},{-136,166},{-100,166},{-100,-100},{-200,
                              -100}},               color={255,0,255}));
                      connect(uSupFan, and2.u1) annotation (Line(points={{-200,-100},{-140,-100},{-140,
                              -100},{-82,-100}}, color={255,0,255}));
                      connect(intLesEqu.y, and2.u2) annotation (Line(points={{-98,-140},{-90,-140},{
                              -90,-108},{-82,-108}}, color={255,0,255}));
                      connect(and2.y, and3.u1)
                        annotation (Line(points={{-58,-100},{-42,-100}}, color={255,0,255}));
                      connect(and3.y, not1.u)
                        annotation (Line(points={{-18,-100},{-10,-100}}, color={255,0,255}));
                      connect(intEqu.y, and3.u2) annotation (Line(points={{-98,-180},{-50,-180},{-50,
                              -108},{-42,-108}}, color={255,0,255}));

                    annotation (
                        defaultComponentName="damLim",
                        Icon(graphics={
                            Rectangle(
                              extent={{-100,-100},{100,100}},
                              lineColor={0,0,127},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-88,138},{88,108}},
                              lineColor={0,0,127},
                              textString="%name"),
                            Line(
                              points={{-60,-60},{2,62},{2,62},{64,-60},{-60,-60}},
                              color={0,0,127},
                              thickness=0.5)}),
                        Diagram(coordinateSystem(extent={{-180,-240},{180,240}}), graphics={
                            Rectangle(
                              extent={{-172,-74},{16,-234}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-172,232},{16,128}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{24,232},{172,-232}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-172,124},{16,-68}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{26,230},{172,184}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Damper position limit
calculation and
assignments"),              Text(
                              extent={{-170,160},{-4,130}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Physical damper position
limits set at commissioning"),
                            Text(
                              extent={{28,78},{150,30}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Switches to deactivate
limit modulation"),         Text(
                              extent={{-80,-196},{124,-226}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Enable/disable conditions
for damper position limits
control loop"),             Text(
                              extent={{-170,126},{14,94}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Damper position limits
outdoor air volume flow
control loop")}),       Documentation(info="<html>
<p>
This block models the multi zone VAV AHU minimum outdoor air control with a single
common damper for minimum outdoor air and economizer functions based on outdoor airflow
measurement, designed in line with ASHRAE Guidline 36 (G36), PART 5.N.6.c.
</p>
<p>
The controller is enabled when the supply fan is proven on (<code>uSupFan=true</code>),
the AHU operation mode <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes</a> equals <code>occupied</code>,
and the freeze protection stage <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages</a> is <code>stage1</code> or lower.
Otherwise the damper position limits are set to their corresponding maximum and minimum physical or at
commissioning fixed limits. The state machine chart below illustrates listed conditions:
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsStateMachineChart.png\"/>
</p>
<p>
The controller sets the outdoor and return damper position limits so
that the outdoor airflow rate <code>VOut_flow</code> stays equal or above the
minimum outdoor air setpoint <code>VOutMinSet_flow</code>. The fraction of the controller
output signal between <code>yMin</code> and <code>uRetDamMin</code> is
linearly mapped to the outdoor air damper minimal position <code>yOutDamPosMin</code>
while the fraction of the controller output between <code>uRetDamMin</code> and
<code>yMax</code> is linearly mapped to the return air damper maximum position
<code>yRetDamPosMax</code>. Thus the dampers are not interlocked.
</p>
<p>
The following control charts show the input/output structure and an expected damper position
limits for a well configured controller.
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits control diagram\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsControlDiagram.png\"/>
</p>
<p>
The expected damper position limits vs. the control loop signal are as follows:
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits control chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsControlChart.png\"/>
</p>
</html>",                     revisions="<html>
<ul>
<li>
July 10, 2020, by Antoine Gautier:<br/>
Changed default value of integral time for minimum outdoor air control.
Set <code>yMin</code> to 0.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2019\">#2019</a>.
</li>
<li>
March 14, 2020, by Jianjun Hu:<br/>
Replaced mulAnd by logic and block to avoid vector-valued calculation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 17, 2017, by Michael Wetter:<br/>
Replaced block that checks for equality of real values within a tolerance
by two inequality checks.
</li>
<li>
June 06, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Limits;

                    block Modulation
                      "Outdoor and return air damper position modulation sequence for multi zone VAV AHU"

                      parameter Real uMin(
                        final max=0,
                        final unit="1")=-0.25
                        "Lower limit of controller input when outdoor damper opens (see diagram)"
                        annotation (Dialog(tab="Commissioning", group="Controller"));
                      parameter Real uMax(
                        final min=0,
                        final unit="1")=+0.25
                        "Upper limit of controller input when return damper is closed (see diagram)"
                        annotation (Dialog(tab="Commissioning", group="Controller"));
                      parameter Real uOutDamMax(
                        final min=-1,
                        final max=1,
                        final unit="1") = (uMin + uMax)/2
                        "Maximum loop signal for the OA damper to be fully open"
                        annotation (Dialog(tab="Commissioning", group="Controller"));
                      parameter Real uRetDamMin(
                        final min=-1,
                        final max=1,
                        final unit="1") = (uMin + uMax)/2
                        "Minimum loop signal for the RA damper to be fully open"
                        annotation (Dialog(tab="Commissioning", group="Controller"));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uTSup(final unit="1")
                        "Signal for supply air temperature control (T Sup Control Loop Signal in diagram)"
                        annotation (Placement(transformation(extent={{-160,-20},{-120,20}}),
                            iconTransformation(extent={{-140,-20},{-100,20}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutDamPosMin(
                        final min=0,
                        final max=1,
                        final unit="1")
                        "Minimum economizer damper position limit as returned by the damper position limits  sequence"
                        annotation (Placement(transformation(extent={{-160,-120},{-120,-80}}),
                            iconTransformation(extent={{-140,-110},{-100,-70}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutDamPosMax(
                        final min=0,
                        final max=1,
                        final unit="1") "Maximum economizer damper position limit as returned by the economizer enable-disable sequence.
    If the economizer is disabled, this value equals uOutDamPosMin"
                        annotation (Placement(transformation(extent={{-160,-70},{-120,-30}}),
                            iconTransformation(extent={{-140,-70},{-100,-30}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uRetDamPosMin(
                        final min=0,
                        final max=1,
                        final unit="1")
                        "Minimum return air damper position limit as returned by the economizer enable-disable sequence"
                        annotation (Placement(transformation(extent={{-160,30},{-120,70}}),
                            iconTransformation(extent={{-140,30},{-100,70}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uRetDamPosMax(
                        final min=0,
                        final max=1,
                        final unit="1")
                        "Maximum return air damper position limit as returned by the economizer enable-disable sequence"
                        annotation (Placement(transformation(extent={{-160,80},{-120,120}}),
                            iconTransformation(extent={{-140,70},{-100,110}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                        final min=0,
                        final max=1,
                        final unit="1") "Economizer damper position"
                        annotation (Placement(transformation(extent={{120,-80},{160,-40}}),
                            iconTransformation(extent={{100,-80},{140,-40}})));
                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                        final min=0,
                        final max=1,
                        final unit="1") "Return air damper position"
                        annotation (Placement(transformation(extent={{120,40},{160,80}}),
                            iconTransformation(extent={{100,40},{140,80}})));

                  protected
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant outDamMinLimSig(
                        final k=uMin) "Minimal control loop signal for the outdoor air damper"
                        annotation (Placement(transformation(extent={{-60,-32},{-40,-12}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant outDamMaxLimSig(
                        final k=uOutDamMax) "Maximum control loop signal for the outdoor air damper"
                        annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant retDamConMinLimSig(
                        final k=uRetDamMin)
                        "Minimal control loop signal for the return air damper"
                        annotation (Placement(transformation(extent={{-80,68},{-60,88}})));
                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant retDamMaxLimSig(
                        final k=uMax) "Maximal control loop signal for the return air damper"
                        annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
                      Buildings.Controls.OBC.CDL.Continuous.Line outDamPos(
                        final limitBelow=true,
                        final limitAbove=true)
                        "Damper position is linearly proportional to the control signal between signal limits"
                        annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
                      Buildings.Controls.OBC.CDL.Continuous.Line retDamPos(
                        final limitBelow=true,
                        final limitAbove=true)
                        "Damper position is linearly proportional to the control signal between signal limits"
                        annotation (Placement(transformation(extent={{0,60},{20,80}})));
                      Buildings.Controls.OBC.CDL.Continuous.Min min "Overwrite due to freeze protection"
                        annotation (Placement(transformation(extent={{60,-70},{80,-50}})));
                      Buildings.Controls.OBC.CDL.Continuous.Max max "Overwrite due to freeze protection"
                        annotation (Placement(transformation(extent={{60,50},{80,70}})));

                    equation
                      connect(outDamPos.x2, outDamMaxLimSig.y)
                        annotation (Line(points={{-2,-34},{-30,-34},{-30,-50},{-78,-50}},color={0,0,127}));
                      connect(outDamPos.x1, outDamMinLimSig.y)
                        annotation (Line(points={{-2,-22},{-38,-22}}, color={0,0,127}));
                      connect(outDamPos.f1, uOutDamPosMin)
                        annotation (Line(points={{-2,-26},{-24,-26},{-24,-100},{-140,-100}},color={0,0,127}));
                      connect(outDamPos.f2, uOutDamPosMax)
                        annotation (Line(points={{-2,-38},{-20,-38},{-20,-66},{-108,-66},{-108,-50},{-140,-50}},
                        color={0,0,127}));
                      connect(retDamPos.x2, retDamMaxLimSig.y)
                        annotation (Line(points={{-2,66},{-28,66},{-28,20},{-38,20}},color={0,0,127}));
                      connect(retDamPos.x1, retDamConMinLimSig.y)
                        annotation (Line(points={{-2,78},{-58,78}},color={0,0,127}));
                      connect(retDamPos.f1, uRetDamPosMax)
                        annotation (Line(points={{-2,74},{-48,74},{-48,100},{-140,100}},color={0,0,127}));
                      connect(retDamPos.f2, uRetDamPosMin)
                        annotation (Line(points={{-2,62},{-12,62},{-12,50},{-140,50}}, color={0,0,127}));
                      connect(min.u2, uOutDamPosMax)
                        annotation (Line(points={{58,-66},{-36,-66},{-36,-50},{-140,-50}},  color={0,0,127}));
                      connect(min.u1, outDamPos.y)
                        annotation (Line(points={{58,-54},{48,-54},{48,-30},{22,-30}}, color={0,0,127}));
                      connect(max.u1, retDamPos.y)
                        annotation (Line(points={{58,66},{30,66},{30,70},{22,70}}, color={0,0,127}));
                      connect(uRetDamPosMin, max.u2)
                        annotation (Line(points={{-140,50},{-12,50},{-12,54},{58,54}}, color={0,0,127}));
                      connect(uTSup, retDamPos.u)
                        annotation (Line(points={{-140,0},{-22,0},{-22,70},{-2,70}}, color={0,0,127}));
                      connect(uTSup, outDamPos.u)
                        annotation (Line(points={{-140,0},{-22,0},{-22,-30},{-2,-30}}, color={0,0,127}));

                      connect(yOutDamPos, min.y)
                        annotation (Line(points={{140,-60},{82,-60}}, color={0,0,127}));
                      connect(max.y, yRetDamPos)
                        annotation (Line(points={{82,60},{120,60}}, color={0,0,127}));
                    annotation (
                        defaultComponentName="mod",
                        Icon(graphics={
                            Rectangle(
                              extent={{-100,-100},{100,100}},
                              lineColor={0,0,127},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Line(points={{20,58}}, color={28,108,200}),
                            Line(
                              points={{-92,-84},{-50,-84},{12,70},{82,70}},
                              color={0,0,127},
                              thickness=0.5),
                            Line(
                              points={{-66,58},{12,58},{50,-76},{100,-76}},
                              color={0,0,127},
                              pattern=LinePattern.Dash,
                              thickness=0.5),
                            Text(
                              extent={{-108,138},{102,110}},
                              lineColor={0,0,127},
                              textString="%name")}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-120,-120},{
                                120,120}}), graphics={
                            Rectangle(
                              extent={{-26,118},{46,-118}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Rectangle(
                              extent={{-118,118},{-34,-118}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-116,118},{-34,102}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Damper position supply
air temperature control loop"),
                            Text(
                              extent={{-24,118},{24,106}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Damper position
assignments"),              Rectangle(
                              extent={{52,118},{118,-118}},
                              lineColor={0,0,0},
                              fillColor={215,215,215},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{54,118},{120,96}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Overwrite if the freeze protection
that tracks TFre at the measured
mixed air temperature limits the
damper position")}),    Documentation(info="<html>
<p>
This is a multi zone VAV AHU economizer modulation block. It calculates
the outdoor and return air damper positions based on the supply air temperature
control loop signal. The implementation is in line with ASHRAE
Guidline 36 (G36), PART 5.N.2.c. Damper positions are linearly mapped to
the supply air control loop signal. This is a final sequence in the
composite multi zone VAV AHU economizer control sequence. Damper position
limits, which are the inputs to the sequence, are the outputs of
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a> and
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
sequences.
</p>
<p>
When the economizer is enabled, the PI controller modulates the damper
positions. Return and outdoor damper are not interlocked. When the economizer is disabled,
the damper positions are set to the minimum outdoor air damper position limits.
</p>
<p>
The control charts below show the input-output structure and an economizer damper
modulation sequence assuming a well configured controller. Control diagram:
</p>
<p align=\"center\">
<img alt=\"Image of the multi zone AHU modulation sequence control diagram\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconModulationControlDiagram.png\"/>
</p>
<p>
Multi zone AHU economizer modulation control chart:
<br/>
</p>
<p align=\"center\">
<img alt=\"Image of the multi zone AHU modulation sequence expected performance\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconModulationControlChart.png\"/>
</p>
</html>",                     revisions="<html>
<ul>
<li>
April 24, 2021, by Michael Wetter:<br/>
Removed limit on time rate of change on damper signal.
The dampers model has already a delay which should make them sufficiently slow.
Adding this delay in the controller makes it harder to tune the controls.
This change also removed the parameter <code>samplePeriod</code>.
</li>
<li>
October 13, 2017, by Michael Wetter:<br/>
Corrected implementation for when dampers are
such positioned that they prevent the mixed air temperature from being
below the freezing set point.
</li>
<li>
October 11, 2017, by Michael Wetter:<br/>
Corrected implementation to use control loop signal as input.
</li>
<li>
September 29, 2017, by Michael Wetter:<br/>
Corrected implementation by adding reverse action.
</li>
<li>
June 28, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Modulation;
                  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains subsequences for multi zone VAV AHU economizer control.
</p>
</html>"),          Icon(graphics={
                          Rectangle(
                            lineColor={200,200,200},
                            fillColor={248,248,248},
                            fillPattern=FillPattern.HorizontalCylinder,
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Rectangle(
                            lineColor={128,128,128},
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Ellipse(
                            origin={10.0,10.0},
                            lineColor={128,128,128},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid,
                            extent={{-80.0,0.0},{-20.0,60.0}}),
                          Ellipse(
                            origin={10.0,10.0},
                            fillColor={128,128,128},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{0.0,0.0},{60.0,60.0}}),
                          Ellipse(
                            origin={10.0,10.0},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{0.0,-80.0},{60.0,-20.0}}),
                          Ellipse(
                            origin={10.0,10.0},
                            fillColor={76,76,76},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                  end Subsequences;
                annotation (preferredView="info", Documentation(info="<html>
<p>
The package contains a multi zone VAV AHU economizer control
sequence and the related economizer subsequences.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Ellipse(
                          origin={10.0,10.0},
                          lineColor={128,128,128},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,0.0},{-20.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={128,128,128},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,0.0},{60.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,-80.0},{60.0,-20.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={76,76,76},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                end Economizers;

                package SetPoints "Output setpoints for AHU control"

                  block SupplyFan  "Block to control multi zone VAV AHU supply fan"

                    parameter Boolean have_perZonRehBox = false
                      "Check if there is any VAV-reheat boxes on perimeter zones"
                      annotation(Dialog(group="System configuration"));
                    parameter Boolean have_duaDucBox = false
                      "Check if the AHU serves dual duct boxes"
                      annotation(Dialog(group="System configuration"));
                    parameter Boolean have_airFloMeaSta = false
                      "Check if the AHU has AFMS (Airflow measurement station)"
                      annotation(Dialog(group="System configuration"));
                    parameter Real iniSet(
                      final unit="Pa",
                      final quantity="PressureDifference") = 120
                      "Initial setpoint"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real minSet(
                      final unit="Pa",
                      final quantity="PressureDifference") = 25
                      "Minimum setpoint"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real maxSet(
                      final unit="Pa",
                      final quantity="PressureDifference")
                      "Maximum setpoint"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real delTim(
                      final unit="s",
                      final quantity="Time")= 600
                     "Delay time after which trim and respond is activated"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real samplePeriod(
                      final unit="s",
                      final quantity="Time") = 120  "Sample period"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Integer numIgnReq = 2
                      "Number of ignored requests"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real triAmo(
                      final unit="Pa",
                      final quantity="PressureDifference") = -12.0
                      "Trim amount"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real resAmo(
                      final unit="Pa",
                      final quantity="PressureDifference") = 15
                      "Respond amount (must be opposite in to triAmo)"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Real maxRes(
                      final unit="Pa",
                      final quantity="PressureDifference") = 32
                      "Maximum response per time interval (same sign as resAmo)"
                      annotation (Dialog(group="Trim and respond for pressure setpoint"));
                    parameter Buildings.Controls.OBC.CDL.Types.SimpleController
                      controllerType=Buildings.Controls.OBC.CDL.Types.SimpleController.PI "Type of controller"
                      annotation (Dialog(group="Fan PID controller"));
                    parameter Real k(final unit="1")=0.1
                      "Gain of controller, normalized using maxSet"
                      annotation (Dialog(group="Fan PID controller"));
                    parameter Real Ti(
                      final unit="s",
                      final quantity="Time",
                      min=0)=60
                      "Time constant of integrator block"
                      annotation (Dialog(group="Fan PID controller",
                        enable=controllerType==Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                           or  controllerType==Buildings.Controls.OBC.CDL.Types.SimpleController.PID));
                    parameter Real Td(
                      final unit="s",
                      final quantity="Time",
                      final min=0) = 0.1
                      "Time constant of derivative block"
                      annotation (Dialog(group="Fan PID controller",
                        enable=controllerType==Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                            or controllerType==Buildings.Controls.OBC.CDL.Types.SimpleController.PID));
                    parameter Real yFanMax(min=0.1, max=1, unit="1") = 1
                      "Maximum allowed fan speed"
                      annotation (Dialog(group="Fan PID controller"));
                    parameter Real yFanMin(min=0.1, max=1, unit="1") = 0.1
                      "Lowest allowed fan speed if fan is on"
                      annotation (Dialog(group="Fan PID controller"));

                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                     "System operation mode"
                      annotation (Placement(transformation(extent={{-200,100},{-160,140}}),
                          iconTransformation(extent={{-140,60},{-100,100}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput ducStaPre(
                      final unit="Pa",
                      quantity="PressureDifference")
                      "Measured duct static pressure"
                      annotation (Placement(transformation(extent={{-200,-130},{-160,-90}}),
                          iconTransformation(extent={{-140,-100},{-100,-60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uZonPreResReq
                      "Zone static pressure reset requests"
                      annotation (Placement(transformation(extent={{-200,-80},{-160,-40}}),
                        iconTransformation(extent={{-140,-50},{-100,-10}})));
                    Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySupFan "Supply fan on status"
                      annotation (Placement(transformation(extent={{140,50},{180,90}}),
                          iconTransformation(extent={{100,50},{140,90}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput ySupFanSpe(
                      min=0,
                      max=1,
                      final unit="1") "Supply fan speed"
                      annotation (Placement(transformation(extent={{140,-120},{180,-80}}),
                          iconTransformation(extent={{100,-20},{140,20}})));

                    Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond staPreSetRes(
                      final iniSet=iniSet,
                      final minSet=minSet,
                      final maxSet=maxSet,
                      final delTim=delTim,
                      final samplePeriod=samplePeriod,
                      final numIgnReq=numIgnReq,
                      final triAmo=triAmo,
                      final resAmo=resAmo,
                      final maxRes=maxRes) "Static pressure setpoint reset using trim and respond logic"
                      annotation (Placement(transformation(extent={{-130,-60},{-110,-40}})));
                    Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conSpe(
                      final controllerType=controllerType,
                      final k=k,
                      final Ti=Ti,
                      final Td=Td,
                      r=maxSet,
                      final yMax=yFanMax,
                      final yMin=yFanMin,
                      y_reset=yFanMin) "Supply fan speed control"
                      annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));

                protected
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerSpe(k=0)
                      "Zero fan speed when it becomes OFF"
                      annotation (Placement(transformation(extent={{20,-90},{40,-70}})));
                    Buildings.Controls.OBC.CDL.Logical.Switch swi
                      "If fan is OFF, fan speed outputs to zero"
                      annotation (Placement(transformation(extent={{80,-90},{100,-110}})));
                    Buildings.Controls.OBC.CDL.Logical.Or or1
                      "Check whether supply fan should be ON"
                      annotation (Placement(transformation(extent={{80,60},{100,80}})));
                    Buildings.Controls.OBC.CDL.Logical.Or or2 if have_perZonRehBox
                      "Setback or warmup mode"
                      annotation (Placement(transformation(extent={{20,30},{40,50}})));
                    Buildings.Controls.OBC.CDL.Logical.Or3 or3
                      "Cool-down or setup or occupied mode"
                      annotation (Placement(transformation(extent={{20,90},{40,110}})));
                    Buildings.Controls.OBC.CDL.Logical.Sources.Constant con(
                      k=false) if not have_perZonRehBox
                      "Constant true"
                      annotation (Placement(transformation(extent={{20,0},{40,20}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt(
                      k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                      "Cool down mode"
                      annotation (Placement(transformation(extent={{-120,120},{-100,140}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt4(
                      k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                      "Warm-up mode"
                      annotation (Placement(transformation(extent={{-120,0},{-100,20}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt1(
                      k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                      "Set up mode"
                      annotation (Placement(transformation(extent={{-120,90},{-100,110}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt2(
                      k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "Occupied mode"
                      annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
                    Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt3(
                      k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                      "Set back mode"
                      annotation (Placement(transformation(extent={{-120,30},{-100,50}})));
                    Buildings.Controls.OBC.CDL.Integers.Equal intEqu
                      "Check if current operation mode is cool-down mode"
                      annotation (Placement(transformation(extent={{-60,120},{-40,140}})));
                    Buildings.Controls.OBC.CDL.Integers.Equal intEqu1
                      "Check if current operation mode is setup mode"
                      annotation (Placement(transformation(extent={{-60,90},{-40,110}})));
                    Buildings.Controls.OBC.CDL.Integers.Equal intEqu2
                      "Check if current operation mode is occupied mode"
                      annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
                    Buildings.Controls.OBC.CDL.Integers.Equal intEqu3
                      "Check if current operation mode is setback mode"
                      annotation (Placement(transformation(extent={{-60,30},{-40,50}})));
                    Buildings.Controls.OBC.CDL.Integers.Equal intEqu4
                      "Check if current operation mode is warmup mode"
                      annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
                    Buildings.Controls.OBC.CDL.Discrete.FirstOrderHold firOrdHol(
                      final samplePeriod=samplePeriod)
                      "Extrapolation through the values of the last two sampled input signals"
                      annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));

                  equation
                    connect(or2.y, or1.u2)
                      annotation (Line(points={{42,40},{60,40},{60,62},{78,62}},
                        color={255,0,255}));
                    connect(or1.y, ySupFan)
                      annotation (Line(points={{102,70},{160,70}},
                        color={255,0,255}));
                    connect(or1.y, staPreSetRes.uDevSta)
                      annotation (Line(points={{102,70},{120,70},{120,-8},{-150,-8},{-150,-42},{-132,
                            -42}},     color={255,0,255}));
                    connect(or1.y, swi.u2)
                      annotation (Line(points={{102,70},{120,70},{120,-8},{0,-8},{0,-100},{78,-100}},
                        color={255,0,255}));
                    connect(conSpe.y, swi.u1)
                      annotation (Line(points={{-18,-50},{-4,-50},{-4,-108},{78,-108}},
                        color={0,0,127}));
                    connect(zerSpe.y, swi.u3)
                      annotation (Line(points={{42,-80},{60,-80},{60,-92},{78,-92}},
                        color={0,0,127}));
                    connect(swi.y, ySupFanSpe)
                      annotation (Line(points={{102,-100},{160,-100}},
                        color={0,0,127}));
                    connect(uZonPreResReq, staPreSetRes.numOfReq)
                      annotation (Line(points={{-180,-60},{-148,-60},{-148,-58},{-132,-58}},
                        color={255,127,0}));
                    connect(con.y, or1.u2)
                      annotation (Line(points={{42,10},{60,10},{60,62},{78,62}},
                        color={255,0,255}));
                    connect(intEqu.y, or3.u1)
                      annotation (Line(points={{-38,130},{0,130},{0,108},{18,108}},
                        color={255,0,255}));
                    connect(intEqu2.y, or3.u3)
                      annotation (Line(points={{-38,70},{0,70},{0,92},{18,92}},
                        color={255,0,255}));
                    connect(intEqu1.y, or3.u2)
                      annotation (Line(points={{-38,100},{18,100}}, color={255,0,255}));
                    connect(conInt.y, intEqu.u2)
                      annotation (Line(points={{-98,130},{-90,130},{-90,122},{-62,122}},
                        color={255,127,0}));
                    connect(conInt1.y, intEqu1.u2)
                      annotation (Line(points={{-98,100},{-90,100},{-90,92},{-62,92}},
                        color={255,127,0}));
                    connect(conInt2.y, intEqu2.u2)
                      annotation (Line(points={{-98,70},{-90,70},{-90,62},{-62,62}},
                        color={255,127,0}));
                    connect(conInt3.y, intEqu3.u2)
                      annotation (Line(points={{-98,40},{-90,40},{-90,32},{-62,32}},
                        color={255,127,0}));
                    connect(conInt4.y, intEqu4.u2)
                      annotation (Line(points={{-98,10},{-90,10},{-90,2},{-62,2}},
                        color={255,127,0}));
                    connect(uOpeMod, intEqu.u1)
                      annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},{-80,130},
                        {-62,130}}, color={255,127,0}));
                    connect(uOpeMod, intEqu1.u1)
                      annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},{-80,100},
                        {-62,100}}, color={255,127,0}));
                    connect(uOpeMod, intEqu2.u1)
                      annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                        {-80,70},{-62,70}}, color={255,127,0}));
                    connect(uOpeMod, intEqu3.u1)
                      annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                        {-80,40},{-62,40}}, color={255,127,0}));
                    connect(uOpeMod, intEqu4.u1)
                      annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                        {-80,10},{-62,10}}, color={255,127,0}));
                    connect(or3.y, or1.u1)
                      annotation (Line(points={{42,100},{60,100},{60,70},{78,70}},
                        color={255,0,255}));
                    connect(intEqu3.y, or2.u1)
                      annotation (Line(points={{-38,40},{18,40}}, color={255,0,255}));
                    connect(intEqu4.y, or2.u2)
                      annotation (Line(points={{-38,10},{0,10},{0,32},{18,32}},
                        color={255,0,255}));
                    connect(staPreSetRes.y, firOrdHol.u)
                      annotation (Line(points={{-108,-50},{-102,-50}}, color={0,0,127}));
                    connect(conSpe.trigger, or1.y)
                      annotation (Line(points={{-36,-62},{-36,-100},{0,-100},{0,-8},{120,-8},{120,
                            70},{102,70}},  color={255,0,255}));

                    connect(ducStaPre, conSpe.u_m) annotation (Line(points={{-180,-110},{-30,-110},
                            {-30,-62}}, color={0,0,127}));
                    connect(firOrdHol.y, conSpe.u_s)
                      annotation (Line(points={{-78,-50},{-42,-50}}, color={0,0,127}));
                  annotation (
                    defaultComponentName="conSupFan",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-140},{140,160}}),
                          graphics={
                          Rectangle(
                            extent={{-156,-22},{134,-128}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            pattern=LinePattern.None),
                          Rectangle(
                            extent={{-156,156},{134,-6}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            pattern=LinePattern.None),
                          Text(
                            extent={{42,156},{124,134}},
                            lineColor={0,0,255},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            horizontalAlignment=TextAlignment.Left,
                            textString="Check current operation mode"),
                          Text(
                            extent={{54,-26},{124,-38}},
                            lineColor={0,0,255},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            horizontalAlignment=TextAlignment.Left,
                            textString="Reset pressure setpoint"),
                          Text(
                            extent={{-34,-106},{20,-136}},
                            lineColor={0,0,255},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            textString="Control fan speed"),
                          Text(
                            extent={{42,142},{96,126}},
                            lineColor={0,0,255},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid,
                            horizontalAlignment=TextAlignment.Left,
                            textString="Check fan on or off")}),
                    Icon(graphics={
                          Text(
                            extent={{-102,140},{96,118}},
                            lineColor={0,0,255},
                            textString="%name"),
                                 Rectangle(
                            extent={{-100,100},{100,-100}},
                            lineColor={0,0,0},
                            fillColor={223,211,169},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-96,90},{-54,70}},
                            lineColor={0,0,127},
                            textString="uOpeMod"),
                          Text(
                            extent={{-96,-16},{-44,-44}},
                            lineColor={0,0,127},
                            textString="uZonPreResReq"),
                          Text(
                            extent={{-96,-70},{-54,-90}},
                            lineColor={0,0,127},
                            textString="ducStaPre"),
                          Text(
                            extent={{54,-60},{96,-80}},
                            lineColor={0,0,127},
                            textString="sumVDis_flow"),
                          Text(
                            extent={{52,10},{94,-10}},
                            lineColor={0,0,127},
                            textString="yFanSpe"),
                          Text(
                            extent={{52,78},{94,58}},
                            lineColor={0,0,127},
                            textString="ySupFan")}),
                    Documentation(info="<html>
<p>
Supply fan control for a multi zone VAV AHU according to
ASHRAE guideline G36, PART 5.N.1 (Supply fan control).
</p>
<h4>Supply fan start/stop</h4>
<ul>
<li>Supply fan shall run when system is in the Cool-down, Setup, or Occupied mode</li>
<li>If there are any VAV-reheat boxes on perimeter zones, supply fan shall also
run when system is in Setback or Warmup mode;</li>
<li>If the AHU does not serve dual duct boxes
that do not have hot-duct inlet airflow sensors (<code>have_duaDucBox=true</code>)
or the AHU does not have airflow measurement station (<code>have_airFloMeaSta=false</code>),
sum the current airflow rate from the VAV boxes and output to a software point.</li>
</ul>
<h4>Static pressure setpoint reset</h4>
<p>
Static pressure setpoint shall be reset using trim-respond logic using following
parameters as a starting point:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th> Variable </th> <th> Value </th> <th> Definition </th> </tr>
<tr><td>Device</td><td>AHU Supply Fan</td> <td>Associated device</td></tr>
<tr><td>SP0</td><td><code>iniSet</code></td><td>Initial setpoint</td></tr>
<tr><td>SPmin</td><td><code>minSet</code></td><td>Minimum setpoint</td></tr>
<tr><td>SPmax</td><td><code>maxSet</code></td><td>Maximum setpoint</td></tr>
<tr><td>Td</td><td><code>delTim</code></td><td>Delay timer</td></tr>
<tr><td>T</td><td><code>samplePeriod</code></td><td>Time step</td></tr>
<tr><td>I</td><td><code>numIgnReq</code></td><td>Number of ignored requests</td></tr>
<tr><td>R</td><td><code>uZonPreResReq</code></td><td>Number of requests</td></tr>
<tr><td>SPtrim</td><td><code>triAmo</code></td><td>Trim amount</td></tr>
<tr><td>SPres</td><td><code>resAmo</code></td><td>Respond amount</td></tr>
<tr><td>SPres_max</td><td><code>maxRes</code></td><td>Maximum response per time interval</td></tr>
</table>
<br/>
<h4>Static pressure control</h4>
<p>
Supply fan speed is controlled with a PI controller to maintain duct static pressure at setpoint
when the fan is proven on. The setpoint for the PI controller and the measured
duct static pressure are normalized with the maximum design static presssure
<code>maxSet</code>.
Where the zone groups served by the system are small,
provide multiple sets of gains that are used in the control loop as a function
of a load indicator (such as supply fan airflow rate, the area of the zone groups
that are occupied, etc.).
</p>
</html>",                   revisions="<html>
<ul>
<li>
October 15, 2020, by Michael Wetter:<br/>
Moved normalization of control error to PID controller.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2182\">#2182</a>.
</li>
<li>
March 12, 2020, by Jianjun Hu:<br/>
Removed the sum of flow rate as it is not used in any other sequences.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">issue 1829</a>.
</li>
<li>
January 7, 2020, by Michael Wetter:<br/>
Reformulated to avoid relying on the <code>final</code> keyword.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1701\">issue 1701</a>.
</li>
<li>
October 14, 2017, by Michael Wetter:<br/>
Added normalization of pressure set point and measurement as the measured
quantity is a few hundred Pascal.
</li>
<li>
August 15, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end SupplyFan;

                  block SupplySignals "Multizone VAV AHU coil valve positions"

                    parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=
                        Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      "Type of controller for supply air temperature signal";
                    parameter Real kTSup(final unit="1/K")=0.05
                      "Gain of controller for supply air temperature signal";
                    parameter Real TiTSup(
                      final unit="s",
                      final quantity="Time")=600
                      "Time constant of integrator block for supply temperature control signal"
                      annotation(Dialog(
                        enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                            or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                    parameter Real TdTSup(
                      final unit="s",
                      final quantity="Time")=0.1
                      "Time constant of derivative block for supply temperature control signal"
                      annotation(Dialog(enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                                            or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                    parameter Real uHeaMax(
                      final min=-0.9,
                      final unit="1")=-0.25
                      "Upper limit of controller signal when heating coil is off. Require -1 < uHeaMax < uCooMin < 1.";
                    parameter Real uCooMin(
                      final max=0.9,
                      final unit="1")=0.25
                      "Lower limit of controller signal when cooling coil is off. Require -1 < uHeaMax < uCooMin < 1.";

                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TSup(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Measured supply air temperature"
                      annotation (Placement(transformation(extent={{-140,-40},{-100,0}}),
                          iconTransformation(extent={{-140,-70},{-100,-30}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TSupSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Setpoint for supply air temperature"
                      annotation (Placement(transformation(extent={{-140,10},{-100,50}}),
                          iconTransformation(extent={{-140,-20},{-100,20}})));
                    Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                      "Supply fan status"
                      annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                          iconTransformation(extent={{-140,30},{-100,70}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput yHea(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Control signal for heating"
                      annotation (Placement(transformation(extent={{100,0},{140,40}}),
                          iconTransformation(extent={{100,-20},{140,20}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput yCoo(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Control signal for cooling"
                      annotation (Placement(transformation(extent={{100,-40},{140,0}}),
                          iconTransformation(extent={{100,-60},{140,-20}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput uTSup(
                      final max=1,
                      final unit="1",
                      final min=-1)
                      "Supply temperature control signal"
                      annotation (Placement(transformation(extent={{100,40},{140,80}}),
                          iconTransformation(extent={{100,20},{140,60}})));

                protected
                    Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conTSup(
                      final controllerType=controllerType,
                      final k=kTSup,
                      final Ti=TiTSup,
                      final Td=TdTSup,
                      final yMax=1,
                      final yMin=-1,
                      final y_reset=0,
                      final reverseActing=false)
                      "Controller for supply air temperature control signal (to be used by heating coil, cooling coil and economizer)"
                      annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
                    Buildings.Controls.OBC.CDL.Logical.Switch swi
                      "Switch to select supply temperature control signal based on status of supply fan"
                      annotation (Placement(transformation(extent={{0,50},{20,70}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant uHeaMaxCon(
                      final k=uHeaMax)
                      "Constant signal to map control action"
                      annotation (Placement(transformation(extent={{0,-20},{20,0}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant negOne(final k=-1)
                      "Negative unity signal"
                      annotation (Placement(transformation(extent={{0,18},{20,38}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant uCooMinCon(
                      final k=uCooMin)
                      "Constant signal to map control action"
                      annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zer(final k=0)
                      "Zero control signal"
                      annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant one(final k=1)
                      "Unity signal"
                      annotation (Placement(transformation(extent={{0,-90},{20,-70}})));
                    Buildings.Controls.OBC.CDL.Continuous.Line conSigCoo(
                      final limitBelow=true,
                      final limitAbove=false)
                      "Cooling control signal"
                      annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
                    Buildings.Controls.OBC.CDL.Continuous.Line conSigHea(
                      final limitBelow=false,
                      final limitAbove=true)
                      "Heating control signal"
                      annotation (Placement(transformation(extent={{60,10},{80,30}})));

                  equation
                    connect(zer.y,swi. u3)
                      annotation (Line(points={{-38,-40},{-20,-40},{-20,52},{-2,52}},
                        color={0,0,127}));
                    connect(TSup,conTSup. u_m)
                      annotation (Line(points={{-120,-20},{-50,-20},{-50,18}}, color={0,0,127}));
                    connect(negOne.y,conSigHea. x1)
                      annotation (Line(points={{22,28},{58,28}},
                        color={0,0,127}));
                    connect(one.y,conSigHea. f1)
                      annotation (Line(points={{22,-80},{50,-80},{50,24},{58,24}},
                        color={0,0,127}));
                    connect(swi.y,conSigHea. u)
                      annotation (Line(points={{22,60},{46,60},{46,20},{58,20}},
                        color={0,0,127}));
                    connect(swi.y,conSigCoo. u)
                      annotation (Line(points={{22,60},{46,60},{46,-20},{58,-20}},
                        color={0,0,127}));
                    connect(uHeaMaxCon.y,conSigHea. x2)
                      annotation (Line(points={{22,-10},{30,-10},{30,16},{58,16}},
                        color={0,0,127}));
                    connect(zer.y,conSigHea. f2)
                      annotation (Line(points={{-38,-40},{-20,-40},{-20,-30},{36,-30},{36,12},
                        {58,12}}, color={0,0,127}));
                    connect(uCooMinCon.y,conSigCoo. x1)
                      annotation (Line(points={{22,-50},{40,-50},{40,-12},{58,-12}},
                        color={0,0,127}));
                    connect(zer.y,conSigCoo. f1)
                      annotation (Line(points={{-38,-40},{-20,-40},{-20,-30},{36,-30},{36,-16},
                        {58,-16}}, color={0,0,127}));
                    connect(one.y,conSigCoo. x2)
                      annotation (Line(points={{22,-80},{50,-80},{50,-24},{58,-24}},
                        color={0,0,127}));
                    connect(one.y,conSigCoo. f2)
                      annotation (Line(points={{22,-80},{50,-80},{50,-28},{58,-28}},
                        color={0,0,127}));
                    connect(conSigHea.y,yHea)
                      annotation (Line(points={{82,20},{120,20}},  color={0,0,127}));
                    connect(conSigCoo.y,yCoo)
                      annotation (Line(points={{82,-20},{120,-20}}, color={0,0,127}));
                    connect(swi.y,uTSup)
                      annotation (Line(points={{22,60},{120,60}},  color={0,0,127}));
                    connect(TSupSet, conTSup.u_s)
                      annotation (Line(points={{-120,30},{-62,30}},
                        color={0,0,127}));
                    connect(uSupFan, swi.u2)
                      annotation (Line(points={{-120,80},{-80,80},{-80,60},{-2,60}},
                        color={255,0,255}));
                    connect(conTSup.y, swi.u1)
                      annotation (Line(points={{-38,30},{-28,30},{-28,68},{-2,68}},
                        color={0,0,127}));
                    connect(uSupFan, conTSup.trigger)
                      annotation (Line(points={{-120,80},{-80,80},{-80,8},{-56,8},{-56,18}},
                        color={255,0,255}));

                  annotation (
                    defaultComponentName = "supSig",
                    Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                          Rectangle(
                          extent={{-100,-100},{100,100}},
                          lineColor={0,0,127},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-96,8},{-64,-6}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="TSup"),
                          Text(
                            extent={{-94,-38},{-48,-62}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="uSupFan"),
                          Text(
                            extent={{76,8},{96,-2}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="yHea"),
                          Text(
                            extent={{74,46},{96,34}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="uTSup"),
                          Text(
                            extent={{76,-34},{96,-44}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="yCoo"),
                          Text(
                            extent={{-96,56},{-56,42}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="TSupSet"),
                          Text(
                            extent={{-124,146},{96,108}},
                            lineColor={0,0,255},
                            textString="%name")}),Documentation(info="<html>
<p>
Block that outputs the supply temperature control loop signal,
and the coil valve postions for VAV system with multiple zones,
implemented according to the ASHRAE Guideline G36, PART 5.N.2
(Supply air temperature control).
</p>
<p>
The supply air temperature control loop signal <code>uTSup</code>
is computed using a PI controller that tracks the supply air temperature
setpoint <code>TSupSet</code>.
If the fan is off, then <code>uTSup = 0</code>.
</p>
<p>
Heating valve control signal (or modulating electric heating
coil if applicable) <code>yHea</code> and cooling valve control signal <code>yCoo</code>
are sequenced based on the supply air temperature control loop signal <code>uTSup</code>.
From <code>uTSup = uHeaMax</code> to <code>uTSup = -1</code>,
<code>yHea</code> increases linearly from <i>0</i> to <i>1</i>.
Similarly, <code>uTSup = uCooMin</code> to <code>uTSup = +1</code>,
<code>yCoo</code> increases linearly from <i>0</i> to <i>1</i>.
</p>
<p>
The output <code>uTSup</code> can be used in a controller for the economizer.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end SupplySignals;

                  block SupplyTemperature
                    "Supply air temperature setpoint for multi zone system"

                    parameter Real TSupSetMin(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = 285.15
                      "Lowest cooling supply air temperature setpoint"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real TSupSetMax(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = 291.15
                      "Highest cooling supply air temperature setpoint. It is typically 18 degC (65 degF) 
    in mild and dry climates, 16 degC (60 degF) or lower in humid climates"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real TSupSetDes(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = 286.15
                      "Nominal supply air temperature setpoint"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real TOutMin(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = 289.15
                      "Lower value of the outdoor air temperature reset range. Typically value is 16 degC (60 degF)"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real TOutMax(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = 294.15
                      "Higher value of the outdoor air temperature reset range. Typically value is 21 degC (70 degF)"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real TSupWarUpSetBac(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=308.15
                      "Supply temperature in warm up and set back mode"
                      annotation (Dialog(group="Temperatures"));
                    parameter Real iniSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = maxSet
                      "Initial setpoint"
                      annotation (Dialog(group="Trim and respond logic"));
                    parameter Real maxSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = TSupSetMax
                      "Maximum setpoint"
                      annotation (Dialog(group="Trim and respond logic"));
                    parameter Real minSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") = TSupSetDes
                      "Minimum setpoint"
                      annotation (Dialog(group="Trim and respond logic"));
                    parameter Real delTim(
                      final unit="s",
                      final quantity="Time") = 600
                      "Delay timer"
                      annotation(Dialog(group="Trim and respond logic"));
                    parameter Real samplePeriod(
                      final unit="s",
                      final quantity="Time",
                      final min=1E-3) = 120
                      "Sample period of component"
                      annotation(Dialog(group="Trim and respond logic"));
                    parameter Integer numIgnReq = 2
                      "Number of ignorable requests for TrimResponse logic"
                      annotation(Dialog(group="Trim and respond logic"));
                    parameter Real triAmo(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference") = 0.1
                      "Trim amount"
                      annotation (Dialog(group="Trim and respond logic"));
                    parameter Real resAmo(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference") = -0.2
                      "Response amount"
                      annotation (Dialog(group="Trim and respond logic"));
                    parameter Real maxRes(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference") = -0.6
                      "Maximum response per time interval"
                      annotation (Dialog(group="Trim and respond logic"));

                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TOut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Outdoor air temperature"
                      annotation (Placement(transformation(extent={{-180,40},{-140,80}}),
                          iconTransformation(extent={{-140,20},{-100,60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonSetAve(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Average of heating and cooling setpoint"
                      annotation (Placement(transformation(extent={{-180,70},{-140,110}}),
                          iconTransformation(extent={{-140,60},{-100,100}})));
                    Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                      "Supply fan status"
                      annotation (Placement(transformation(extent={{-180,-50},{-140,-10}}),
                          iconTransformation(extent={{-140,-60},{-100,-20}})));
                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                      "System operation mode"
                      annotation (Placement(transformation(extent={{-180,-120},{-140,-80}}),
                          iconTransformation(extent={{-140,-100},{-100,-60}})));
                    Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uZonTemResReq
                      "Zone cooling supply air temperature reset request"
                      annotation (Placement( transformation(extent={{-180,0},{-140,40}}),
                          iconTransformation(extent={{-140,-20},{-100,20}})));
                    Buildings.Controls.OBC.CDL.Interfaces.RealOutput TSupSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Setpoint for supply air temperature"
                      annotation (Placement(transformation(extent={{140,-20},{180,20}}),
                          iconTransformation(extent={{100,-20},{140,20}})));

                    Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond maxSupTemRes(
                      final delTim=delTim,
                      final iniSet=iniSet,
                      final minSet=minSet,
                      final maxSet=maxSet,
                      final samplePeriod=samplePeriod,
                      final numIgnReq=numIgnReq,
                      final triAmo=triAmo,
                      final resAmo=resAmo,
                      final maxRes=maxRes) "Maximum cooling supply temperature reset"
                      annotation (Placement(transformation(extent={{-100,20},{-80,40}})));

                protected
                    Buildings.Controls.OBC.CDL.Continuous.Line lin
                      "Supply temperature distributes linearly between minimum and maximum supply 
    air temperature, according to outdoor temperature"
                      annotation (Placement(transformation(extent={{20,40},{40,60}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minOutTem(k=TOutMin)
                      "Lower value of the outdoor air temperature reset range"
                      annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxOutTem(k=TOutMax)
                      "Higher value of the outdoor air temperature reset range"
                      annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minSupTem(k=TSupSetMin)
                      "Lowest cooling supply air temperature setpoint"
                      annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
                    Buildings.Controls.OBC.CDL.Logical.And and2
                      "Check if it is in Setup or Cool-down mode"
                      annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
                    Buildings.Controls.OBC.CDL.Logical.And and1
                      "Check if it is in Warmup or Setback mode"
                      annotation (Placement(transformation(extent={{20,-100},{40,-80}})));
                    Buildings.Controls.OBC.CDL.Continuous.Sources.Constant supTemWarUpSetBac(k=
                          TSupWarUpSetBac)
                      "Supply temperature setpoint under warm-up and setback mode"
                      annotation (Placement(transformation(extent={{20,-130},{40,-110}})));
                    Buildings.Controls.OBC.CDL.Logical.Switch swi1
                      "If operation mode is setup or cool-down, setpoint shall be 35 degC"
                      annotation (Placement(transformation(extent={{80,-60},{100,-40}})));
                    Buildings.Controls.OBC.CDL.Logical.Switch swi2
                      "If operation mode is setup or cool-down, setpoint shall be TSupSetMin"
                      annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
                    Buildings.Controls.OBC.CDL.Continuous.Limiter TDea(
                      uMax=297.15,
                      uMin=294.15)
                      "Limiter that outputs the dead band value for the supply air temperature"
                      annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
                    Buildings.Controls.OBC.CDL.Logical.Switch swi3
                      "Check output regarding supply fan status"
                      annotation (Placement(transformation(extent={{80,-10},{100,10}})));
                    Buildings.Controls.OBC.CDL.Integers.LessThreshold intLesThr(t=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                      "Check if operation mode index is less than warm-up mode index (4)"
                      annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
                    Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr(t=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "Check if operation mode index is greater than occupied mode index (1)"
                      annotation (Placement(transformation(extent={{-100,-90},{-80,-70}})));
                    Buildings.Controls.OBC.CDL.Integers.LessThreshold intLesThr1(t=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                      "Check if operation mode index is less than unoccupied mode index (7)"
                      annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
                    Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr1(t=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                      "Check if operation mode index is greater than set up mode index (3)"
                      annotation (Placement(transformation(extent={{-40,-130},{-20,-110}})));

                  equation
                    connect(minOutTem.y, lin.x1)
                      annotation (Line(points={{-18,70},{0,70},{0,58},{18,58}},
                        color={0,0,127}));
                    connect(TOut, lin.u)
                      annotation (Line(points={{-160,60},{-100,60},{-100,50},{18,50}},
                        color={0,0,127}));
                    connect(maxOutTem.y, lin.x2)
                      annotation (Line(points={{-18,30},{0,30},{0,46},{18,46}},
                        color={0,0,127}));
                    connect(minSupTem.y, lin.f2)
                      annotation (Line(points={{-78,-10},{10,-10},{10,42},{18,42}},
                        color={0,0,127}));
                    connect(and1.y, swi1.u2)
                      annotation (Line(points={{42,-90},{60,-90},{60,-50},{78,-50}},
                        color={255,0,255}));
                    connect(supTemWarUpSetBac.y, swi1.u1)
                      annotation (Line(points={{42,-120},{68,-120},{68,-42},{78,-42}},
                        color={0,0,127}));
                    connect(and2.y, swi2.u2)
                      annotation (Line(points={{-18,-50},{18,-50}},color={255,0,255}));
                    connect(minSupTem.y, swi2.u1)
                      annotation (Line(points={{-78,-10},{0,-10},{0,-42},{18,-42}},
                        color={0,0,127}));
                    connect(swi2.y, swi1.u3)
                      annotation (Line(points={{42,-50},{50,-50},{50,-58},{78,-58}},
                        color={0,0,127}));
                    connect(TZonSetAve, TDea.u)
                      annotation (Line(points={{-160,90},{-102,90}},
                        color={0,0,127}));
                    connect(uSupFan, swi3.u2)
                      annotation (Line(points={{-160,-30},{-120,-30},{-120,10},{-60,10},{-60,0},
                        {78,0}}, color={255,0,255}));
                    connect(swi1.y, swi3.u1)
                      annotation (Line(points={{102,-50},{110,-50},{110,-20},{68,-20},{68,8},{78,8}},
                        color={0,0,127}));
                    connect(TDea.y, swi3.u3)
                      annotation (Line(points={{-78,90},{60,90},{60,-8},{78,-8}},
                        color={0,0,127}));
                    connect(intLesThr1.y, and1.u1)
                      annotation (Line(points={{-18,-90},{18,-90}},
                        color={255,0,255}));
                    connect(intGreThr1.y, and1.u2)
                      annotation (Line(points={{-18,-120},{0,-120},{0,-98},{18,-98}},
                        color={255,0,255}));
                    connect(intLesThr.y, and2.u1)
                      annotation (Line(points={{-78,-50},{-42,-50}},color={255,0,255}));
                    connect(intGreThr.y, and2.u2)
                      annotation (Line(points={{-78,-80},{-60,-80},{-60,-58},{-42,-58}},
                        color={255,0,255}));
                    connect(uOpeMod, intLesThr.u)
                      annotation (Line(points={{-160,-100},{-120,-100},{-120,-50},{-102,-50}},
                        color={255,127,0}));
                    connect(uOpeMod, intGreThr.u)
                      annotation (Line(points={{-160,-100},{-120,-100},{-120,-80},{-102,-80}},
                        color={255,127,0}));
                    connect(uOpeMod, intLesThr1.u)
                      annotation (Line(points={{-160,-100},{-60,-100},{-60,-90},{-42,-90}},
                        color={255,127,0}));
                    connect(uOpeMod, intGreThr1.u)
                      annotation (Line(points={{-160,-100},{-120,-100},{-120,-120},{-42,-120}},
                        color={255,127,0}));
                    connect(lin.y, swi2.u3)
                      annotation (Line(points={{42,50},{50,50},{50,-30},{8,-30},{8,-58},{18,-58}},
                        color={0,0,127}));
                    connect(uZonTemResReq, maxSupTemRes.numOfReq)
                      annotation (Line(points={{-160,20},{-112,20},{-112,22},{-102,22}},
                        color={255,127,0}));
                    connect(uSupFan, maxSupTemRes.uDevSta)
                      annotation (Line(points={{-160,-30},{-120,-30},{-120,38},{-102,38}},
                        color={255,0,255}));
                    connect(maxSupTemRes.y, lin.f1)
                      annotation (Line(points={{-78,30},{-60,30},{-60,54},{18,54}},
                        color={0,0,127}));
                    connect(swi3.y, TSupSet)
                      annotation (Line(points={{102,0},{160,0}},   color={0,0,127}));

                  annotation (
                    defaultComponentName = "conTSupSet",
                    Icon(graphics={
                          Rectangle(
                          extent={{-100,-100},{100,100}},
                          lineColor={0,0,127},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-94,92},{-42,66}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="TZonSetAve"),
                          Text(
                            extent={{-96,46},{-68,34}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="TOut"),
                          Text(
                            extent={{-94,-22},{-14,-58}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="uZonTemResReq"),
                          Text(
                            extent={{-94,12},{-48,-12}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="uSupFan"),
                          Text(
                            extent={{-94,-70},{-50,-90}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="uOpeMod"),
                          Text(
                            extent={{68,8},{96,-8}},
                            lineColor={0,0,127},
                            pattern=LinePattern.Dash,
                            textString="TSupSet"),
                          Text(
                            extent={{-124,146},{96,108}},
                            lineColor={0,0,255},
                            textString="%name")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-140},{140,120}})),
                    Documentation(info="<html>
<p>
Block that outputs the supply air temperature setpoint and the coil valve control
inputs for VAV system with multiple zones, implemented according to the ASHRAE
Guideline G36, PART 5.N.2 (Supply air temperature control).
</p>
<p>
The control loop is enabled when the supply air fan <code>uSupFan</code> is proven on,
and disabled and the output set to Deadband otherwise.
</p>
<p> The supply air temperature setpoint is computed as follows.</p>
<h4>Setpoints for <code>TSupSetMin</code>, <code>TSupSetMax</code>,
<code>TSupSetDes</code>, <code>TOutMin</code>, <code>TOutMax</code></h4>
<p>
The default range of outdoor air temperature (<code>TOutMin=16&deg;C</code>,
<code>TOutMax=21&deg;C</code>) used to reset the occupied mode <code>TSupSet</code>
was chosen to maximize economizer hours. It may be preferable to use a lower
range of outdoor air temperature (e.g. <code>TOutMin=13&deg;C</code>,
<code>TOutMax=18&deg;C</code>) to minimize fan energy.
</p>
<p>
The <code>TSupSetMin</code> variable is used during warm weather when little reheat
is expected to minimize fan energy. It should not be set too low or it may cause
excessive chilled water temperature reset requests which will reduce chiller
plant efficiency. It should be set no lower than the design coil leaving air
temperature.
</p>
<p>
The <code>TSupSetMax</code> variable is typically 18 &deg;C in mild and dry climate,
16 &deg;C or lower in humid climates. It should not typically be greater than
18 &deg;C since this may lead to excessive fan energy that can offset the mechanical
cooling savings from economizer operation.
</p>

<h4>During occupied mode (<code>uOpeMod=1</code>)</h4>
<p>
The <code>TSupSet</code> shall be reset from <code>TSupSetMin</code> when the outdoor
air temperature is <code>TOutMax</code> and above, proportionally up to
maximum supply temperature when the outdoor air temperature is <code>TOutMin</code> and
below. The maximum supply temperature shall be reset using trim and respond logic between
<code>TSupSetDes</code> and <code>TSupSetMax</code>. Parameters suggested for the
trim and respond logic are shown in the table below. They require adjustment
during the commissioning and tuning phase.
</p>

<table summary=\"summary\" border=\"1\">
<tr><th> Variable </th> <th> Value </th> <th> Definition </th> </tr>
<tr><td>Device</td><td>AHU Supply Fan</td> <td>Associated device</td></tr>
<tr><td>SP0</td><td><code>iniSet</code></td><td>Initial setpoint</td></tr>
<tr><td>SPmin</td><td><code>TSupSetDes</code></td><td>Minimum setpoint</td></tr>
<tr><td>SPmax</td><td><code>TSupSetMax</code></td><td>Maximum setpoint</td></tr>
<tr><td>Td</td><td><code>delTim</code></td><td>Delay timer</td></tr>
<tr><td>T</td><td><code>samplePeriod</code></td><td>Time step</td></tr>
<tr><td>I</td><td><code>numIgnReq</code></td><td>Number of ignored requests</td></tr>
<tr><td>R</td><td><code>uZonTemResReq</code></td><td>Number of requests</td></tr>
<tr><td>SPtrim</td><td><code>triAmo</code></td><td>Trim amount</td></tr>
<tr><td>SPres</td><td><code>resAmo</code></td><td>Respond amount</td></tr>
<tr><td>SPres_max</td><td><code>maxRes</code></td><td>Maximum response per time interval</td></tr>
</table>
<br/>

<p align=\"center\">
<img alt=\"Image of set point reset\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAVSupTempSet.png\"/>
</p>

<h4>During Setup and Cool-down modes (<code>uOpeMod=2</code>, <code>uOpeMod=3</code>)</h4>
<p>
Supply air temperature setpoint <code>TSupSet</code> shall be <code>TSupSetMin</code>.
</p>
<h4>During Setback and Warmup modes (<code>uOpeMod=4</code>, <code>uOpeMod=5</code>)</h4>
<p>
Supply air temperature setpoint <code>TSupSet</code> shall be <code>TSupWarUpSetBac</code>.
</p>

<h4>Valves control</h4>
<p>
Supply air temperature shall be controlled to setpoint using a control loop whose
output is mapped to sequence the hot water valve or modulating electric heating
coil (if applicable) or chilled water valves.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 12, 2020, by Jianjun Hu:<br/>
Propagated supply temperature setpoint of warmup and setback mode.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 11, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end SupplyTemperature;

                  package OutdoorAirFlow
                  "Package of sequences for calculating minimum outdoor airflow rate"

                    block AHU "Output outdoor airflow related calculations at the AHU level"

                      parameter Real VPriSysMax_flow(unit="m3/s")
                        "Maximum expected system primary airflow at design stage"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Real peaSysPop(final unit="1")
                        "Peak system population"
                        annotation(Dialog(group="Nominal condition"));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput sumDesZonPop(
                        final min=0,
                        final unit="1")
                        "Sum of the design population of the zones in the group"
                        annotation (Placement(transformation(extent={{-260,180},{-220,220}}),
                            iconTransformation(extent={{-140,70},{-100,110}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumDesPopBreZon_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of the population component design breathing zone flow rate"
                        annotation (Placement(transformation(extent={{-260,140},{-220,180}}),
                            iconTransformation(extent={{-140,50},{-100,90}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumDesAreBreZon_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of the area component design breathing zone flow rate"
                        annotation (Placement(transformation(extent={{-260,100},{-220,140}}),
                            iconTransformation(extent={{-140,30},{-100,70}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uDesSysVenEff(
                        final min=0,
                        final unit="1")
                        "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                        annotation (Placement(transformation(extent={{-260,60},{-220,100}}),
                            iconTransformation(extent={{-140,10},{-100,50}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumUncOutAir_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of all zones required uncorrected outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-260,-44},{-220,-4}}),
                            iconTransformation(extent={{-140,-10},{-100,30}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VSumSysPriAir_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")
                        "System primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                        annotation (Placement(transformation(extent={{-260,-80},{-220,-40}}),
                            iconTransformation(extent={{-140,-30},{-100,10}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uOutAirFra_max(
                        final min=0,
                        final unit="1")
                        "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                        annotation (Placement(transformation(extent={{-260,-120},{-220,-80}}),
                            iconTransformation(extent={{-140,-50},{-100,-10}})));

                      Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSupFan
                        "Supply fan status, true if on, false if off"
                        annotation (Placement(transformation(extent={{-260,-160},{-220,-120}}),
                          iconTransformation(extent={{-140,-90},{-100,-50}})));

                      Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                        "AHU operation mode status signal"
                        annotation (Placement(transformation(extent={{-260,-200},{-220,-160}}),
                          iconTransformation(extent={{-140,-110},{-100,-70}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDesUncOutAir_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")
                        "Design uncorrected minimum outdoor airflow rate"
                        annotation (Placement(transformation(extent={{240,160},{280,200}}),
                            iconTransformation(extent={{100,60},{140,100}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yAveOutAirFraPlu(
                        final min=0,
                        final unit="1")
                        "Average outdoor air flow fraction plus 1"
                        annotation (Placement(transformation(extent={{240,110},{280,150}}),
                            iconTransformation(extent={{100,30},{140,70}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDesOutAir_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate") "Design minimum outdoor airflow rate"
                        annotation (Placement(transformation(extent={{240,60},{280,100}}),
                            iconTransformation(extent={{100,0},{140,40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VEffOutAir_flow(
                        final min=0,
                        final unit="m3/s",
                        final quantity="VolumeFlowRate") "Effective minimum outdoor airflow setpoint"
                        annotation (Placement(transformation(extent={{240,10},{280,50}}),
                            iconTransformation(extent={{100,-40},{140,0}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput effOutAir_normalized(
                        final unit="1")
                        "Effective minimum outdoor airflow setpoint, normalized by VDesOutMin_flow_nominal"
                        annotation (Placement(transformation(extent={{240,-70},{280,-30}}),
                            iconTransformation(extent={{100,-70},{140,-30}})));

                      Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yReqOutAir
                        "True if the AHU supply fan is on and the zone is in occupied mode"
                        annotation (Placement(transformation(extent={{240,-160},{280,-120}}),
                            iconTransformation(extent={{100,-100},{140,-60}})));

                  protected
                      Buildings.Controls.OBC.CDL.Continuous.Division outAirFra
                        "System outdoor air fraction"
                        annotation (Placement(transformation(extent={{-120,-20},{-100,0}})));

                      Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar(
                        final p=1,
                        final k=1)
                        "System outdoor air flow fraction plus 1"
                        annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add sysVenEff(
                        final k2=-1)
                        "Current system ventilation efficiency"
                        annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division effMinOutAirInt
                        "Effective minimum outdoor air setpoint"
                        annotation (Placement(transformation(extent={{100,10},{120,30}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division occDivFra
                        "Occupant diversity fraction"
                        annotation (Placement(transformation(extent={{-120,180},{-100,200}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add unCorOutAirInk
                        "Uncorrected outdoor air intake"
                        annotation (Placement(transformation(extent={{0,140},{20,160}})));

                      Buildings.Controls.OBC.CDL.Continuous.Product pro
                        "Product of inputs"
                        annotation (Placement(transformation(extent={{-60,160},{-40,180}})));

                      Buildings.Controls.OBC.CDL.Continuous.Gain aveOutAirFra(
                        final k=1/VPriSysMax_flow)
                        "Average outdoor air fraction"
                        annotation (Placement(transformation(extent={{60,120},{80,140}})));

                      Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar1(
                        final p=1,
                        final k=1)
                        "Average outdoor air flow fraction plus 1"
                        annotation (Placement(transformation(extent={{120,120},{140,140}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division desOutAirInt
                        "Design system outdoor air intake"
                        annotation (Placement(transformation(extent={{60,70},{80,90}})));

                      Buildings.Controls.OBC.CDL.Continuous.Min min
                        "Minimum outdoor airflow rate should not be more than designed outdoor airflow rate"
                        annotation (Placement(transformation(extent={{180,20},{200,40}})));

                      Buildings.Controls.OBC.CDL.Continuous.Min sysUncOutAir
                        "Uncorrected outdoor air rate should not be higher than its design value"
                        annotation (Placement(transformation(extent={{-180,0},{-160,20}})));

                      Buildings.Controls.OBC.CDL.Integers.Sources.Constant occMod(
                        final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "Occupied mode index"
                        annotation (Placement(transformation(extent={{-180,-230},{-160,-210}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant peaSysPopulation(
                        final k=peaSysPop)
                        "Peak system population"
                        annotation (Placement(transformation(extent={{-180,210},{-160,230}})));

                      Buildings.Controls.OBC.CDL.Integers.Equal intEqu1
                        "Check if operation mode is occupied"
                        annotation (Placement(transformation(extent={{-100,-190},{-80,-170}})));

                      Buildings.Controls.OBC.CDL.Logical.And and1 "Logical and"
                        annotation (Placement(transformation(extent={{120,-150},{140,-130}})));

                      Buildings.Controls.OBC.CDL.Logical.Switch swi4
                        "Ensuring the system efficiency will not be negative"
                        annotation (Placement(transformation(extent={{60,-70},{80,-50}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conOne(
                        final k=1)
                        "Set system ventilation efficiency to 1"
                        annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division norVOutMin
                        "Normalization for minimum outdoor air flow rate"
                        annotation (Placement(transformation(extent={{180,-60},{200,-40}})));

                      Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys1(
                        final uLow=1E-4,
                        final uHigh=1E-3)
                        "Check if system ventilation efficiency is greater than 0 (using 1E-4 tolerance)"
                        annotation (Placement(transformation(extent={{22,-40},{42,-20}})));

                    equation
                      connect(peaSysPopulation.y, occDivFra.u1)
                        annotation (Line(points={{-158,220},{-140,220},{-140,196},{-122,196}},
                          color={0,0,127}));
                      connect(pro.y, unCorOutAirInk.u1)
                        annotation (Line(points={{-38,170},{-20,170},{-20,156},{-2,156}},
                          color={0,0,127}));
                      connect(aveOutAirFra.y, addPar1.u)
                        annotation (Line(points={{82,130},{118,130}},color={0,0,127}));
                      connect(unCorOutAirInk.y, desOutAirInt.u1)
                        annotation (Line(points={{22,150},{40,150},{40,86},{58,86}},    color={0,0,127}));
                      connect(sysUncOutAir.y, effMinOutAirInt.u1) annotation (Line(points={{-158,10},
                              {-140,10},{-140,26},{98,26}}, color={0,0,127}));
                      connect(sysUncOutAir.y, outAirFra.u1) annotation (Line(points={{-158,10},{-140,
                              10},{-140,-4},{-122,-4}}, color={0,0,127}));
                      connect(unCorOutAirInk.y, sysUncOutAir.u1) annotation (Line(points={{22,150},{
                              40,150},{40,50},{-200,50},{-200,16},{-182,16}}, color={0,0,127}));
                      connect(desOutAirInt.y, min.u1)
                        annotation (Line(points={{82,80},{140,80},{140,36},{178,36}},
                          color={0,0,127}));
                      connect(unCorOutAirInk.y, VDesUncOutAir_flow)
                        annotation (Line(points={{22,150},{40,150},{40,180},{260,180}},
                          color={0,0,127}));
                      connect(desOutAirInt.y, VDesOutAir_flow)
                        annotation (Line(points={{82,80},{260,80}}, color={0,0,127}));
                      connect(occDivFra.y, pro.u1)
                        annotation (Line(points={{-98,190},{-80,190},{-80,176},{-62,176}},
                          color={0,0,127}));
                      connect(uOpeMod, intEqu1.u1)
                        annotation (Line(points={{-240,-180},{-102,-180}},color={255,127,0}));
                      connect(occMod.y, intEqu1.u2)
                        annotation (Line(points={{-158,-220},{-140,-220},{-140,-188},{-102,-188}},
                          color={255,127,0}));
                      connect(intEqu1.y, and1.u2)
                        annotation (Line(points={{-78,-180},{20,-180},{20,-148},{118,-148}},
                          color={255,0,255}));
                      connect(sysVenEff.y, swi4.u1)
                        annotation (Line(points={{-18,-30},{0,-30},{0,-52},{58,-52}},
                          color={0,0,127}));
                      connect(swi4.y, effMinOutAirInt.u2)
                        annotation (Line(points={{82,-60},{90,-60},{90,14},{98,14}},
                          color={0,0,127}));
                      connect(outAirFra.y, addPar.u)
                        annotation (Line(points={{-98,-10},{-82,-10}}, color={0,0,127}));
                      connect(addPar.y, sysVenEff.u1)
                        annotation (Line(points={{-58,-10},{-50,-10},{-50,-24},{-42,-24}},
                          color={0,0,127}));
                      connect(conOne.y, swi4.u3)
                        annotation (Line(points={{42,-70},{50,-70},{50,-68},{58,-68}},
                          color={0,0,127}));
                      connect(VEffOutAir_flow, min.y)
                        annotation (Line(points={{260,30},{202,30}}, color={0,0,127}));
                      connect(effMinOutAirInt.y, min.u2)
                        annotation (Line(points={{122,20},{160,20},{160,24},{178,24}},
                          color={0,0,127}));
                      connect(norVOutMin.u1, min.y)
                        annotation (Line(points={{178,-44},{160,-44},{160,-10},{220,-10},
                          {220,30},{202,30}}, color={0,0,127}));
                      connect(desOutAirInt.y, norVOutMin.u2)
                        annotation (Line(points={{82,80},{140,80},{140,-56},{178,-56}},
                          color={0,0,127}));
                      connect(norVOutMin.y, effOutAir_normalized)
                        annotation (Line(points={{202,-50},{260,-50}}, color={0,0,127}));
                      connect(uSupFan, and1.u1)
                        annotation (Line(points={{-240,-140},{118,-140}},
                          color={255,0,255}));
                      connect(sysVenEff.y, hys1.u)
                        annotation (Line(points={{-18,-30},{20,-30}}, color={0,0,127}));
                      connect(hys1.y, swi4.u2)
                        annotation (Line(points={{44,-30},{50,-30},{50,-60},{58,-60}},
                          color={255,0,255}));
                      connect(addPar1.y, yAveOutAirFraPlu)
                        annotation (Line(points={{142,130},{260,130}},color={0,0,127}));
                      connect(occDivFra.u2, sumDesZonPop)
                        annotation (Line(points={{-122,184},{-200,184},{-200,200},{-240,200}},
                          color={0,0,127}));
                      connect(pro.u2, VSumDesPopBreZon_flow) annotation (Line(points={{-62,164},{-200,
                              164},{-200,160},{-240,160}}, color={0,0,127}));
                      connect(unCorOutAirInk.u2, VSumDesAreBreZon_flow) annotation (Line(points={{-2,144},
                              {-200,144},{-200,120},{-240,120}},      color={0,0,127}));
                      connect(desOutAirInt.u2, uDesSysVenEff) annotation (Line(points={{58,74},{-80,
                              74},{-80,80},{-240,80}}, color={0,0,127}));
                      connect(sysUncOutAir.u2, VSumUncOutAir_flow) annotation (Line(points={{-182,4},
                              {-200,4},{-200,-24},{-240,-24}}, color={0,0,127}));
                      connect(outAirFra.u2, VSumSysPriAir_flow) annotation (Line(points={{-122,-16},
                              {-140,-16},{-140,-60},{-240,-60}}, color={0,0,127}));
                      connect(sysVenEff.u2, uOutAirFra_max)
                        annotation (Line(points={{-42,-36},{-60,-36},{-60,-100},{-240,-100}},
                          color={0,0,127}));

                      connect(and1.y, yReqOutAir)
                        annotation (Line(points={{142,-140},{260,-140}}, color={255,0,255}));
                      connect(aveOutAirFra.u, unCorOutAirInk.y) annotation (Line(points={{58,130},{40,
                              130},{40,150},{22,150}}, color={0,0,127}));
                    annotation (
                      defaultComponentName="ahuOutAirSet",
                      Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                           graphics={Rectangle(
                              extent={{-100,100},{100,-100}},
                              lineColor={0,0,0},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-100,158},{100,118}},
                              lineColor={0,0,255},
                              textString="%name"),
                            Text(
                              extent={{-98,98},{-34,86}},
                              lineColor={0,0,0},
                              textString="sumDesZonPop"),
                            Text(
                              extent={{-96,-62},{-52,-76}},
                              lineColor={255,0,255},
                              textString="uSupFan"),
                            Text(
                              extent={{-96,-82},{-50,-96}},
                              lineColor={255,127,0},
                              textString="uOpeMod"),
                            Text(
                              extent={{-98,78},{-12,62}},
                              lineColor={0,0,0},
                              textString="VDesPopBreZon_flow"),
                            Text(
                              extent={{-98,58},{-12,42}},
                              lineColor={0,0,0},
                              textString="VDesAreBreZon_flow"),
                            Text(
                              extent={{-98,38},{-34,26}},
                              lineColor={0,0,0},
                              textString="desSysVenEff"),
                            Text(
                              extent={{-98,18},{-30,4}},
                              lineColor={0,0,0},
                              textString="VUncOutAir_flow"),
                            Text(
                              extent={{-98,-2},{-34,-18}},
                              lineColor={0,0,0},
                              textString="VSysPriAir_flow"),
                            Text(
                              extent={{-98,-22},{-28,-38}},
                              lineColor={0,0,0},
                              textString="uOutAirFra_max"),
                            Text(
                              extent={{42,-74},{102,-86}},
                              lineColor={255,0,255},
                              textString="yReqOutAir"),
                            Text(
                              extent={{20,88},{96,72}},
                              lineColor={0,0,0},
                              textString="VDesUncOutAir_flow"),
                            Text(
                              extent={{30,60},{98,44}},
                              lineColor={0,0,0},
                              textString="yAveOutAirFraPlu"),
                            Text(
                              extent={{34,30},{98,12}},
                              lineColor={0,0,0},
                              textString="VDesOutAir_flow"),
                            Text(
                              extent={{38,-10},{98,-26}},
                              lineColor={0,0,0},
                              textString="VEffOutAir_flow"),
                            Text(
                              extent={{18,-40},{98,-56}},
                              lineColor={0,0,0},
                              textString="effOutAir_normalized")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,-240},{240,240}})),
                    Documentation(info="<html>
<p>
This sequence outputs AHU level design minimum outdoor airflow rate
<code>VDesOutAir_flow</code> and effective minimum outdoor airflow rate
<code>VEffOutAir_flow</code>.
</p>
<p>
It requires following inputs which are sum, maximum or minimum of the outputs from
the zone level calculation:
</p>
<ol>
<li>
Sum of the design population of the zones in the group, <code>sumDesZonPop</code>.
</li>
<li>
Sum of the population component design breathing zone flow rate,
<code>VSumDesPopBreZon_flow</code>.
</li>
<li>
Sum of the area component design breathing zone flow rate,
<code>VSumDesAreBreZon_flow</code>.
</li>
<li>
Minimum of all zones ventilation efficiency, <code>uDesSysVenEff</code>.
</li>
<li>
Sum of all zones required uncorrected outdoor airflow rate, <code>VSumUncOutAir_flow</code>.
</li>
<li>
Sum of the measured discharged flow rate of all terminal units,
<code>VSumSysPriAir_flow</code>.
</li>
<li>
Maximum of primary outdoor air fraction of all zones, <code>uOutAirFra_max</code>.
</li>
</ol>
<p>
The calculation is done using the steps below.
</p>
<ol>
<li>
<p>
Compute the occupancy diversity fraction <code>occDivFra</code>.
During system operation, the system population equals the sum of the zone population,
so <code>occDivFra=1</code>. It has no impact on the calculation of the uncorrected
outdoor airflow <code>sysUncOutAir</code>.
For design purpose, compute for all zones
</p>
<pre>
    occDivFra = peaSysPop/sumDesZonPop
</pre>
<p>
where <code>peaSysPop</code> is the peak system population and
<code>sumDesZonPop</code> is the sum of the design population.
</p>
</li>
<li>
<p>
Compute the design uncorrected outdoor airflow rate <code>VDesUncOutAir_flow</code> as
</p>
<pre>
    VDesUncOutAir_flow = occDivFra*VSumDesPopBreZon_flow+VSumDesAreBreZon_flow.
</pre>
</li>
<li>
<p>
Compute the uncorrected outdoor airflow rate <code>sysUncOutAir</code> as
</p>
<pre>
    sysUncOutAir = min(VDesUncOutAir_flow, VSumUncOutAir_flow)
</pre>
<p>
where <code>VSumUncOutAir_flow</code> is sum of all zones required uncorrected
outdoor airflow rate
</p>
</li>
<li>
<p>
Compute the outdoor air fraction as
</p>
<pre>
    outAirFra = sysUncOutAir/VSumSysPriAir_flow.
</pre>
<p>
For design purpose, use
</p>
<pre>
    aveOutAirFra = sysUncOutAir/VPriSysMax_flow.
</pre>
<p>
where <code>VPriSysMax_flow</code> is the maximum expected system primary airflow
at design stage.
</p>
</li>
<li>
<p>
Compute the system ventilation efficiency <code>sysVenEff</code>. During system
operation, the efficiency is
</p>
<pre>
    sysVenEff = 1 + outAirFra - uOutAirFra_max
</pre> 
</li>
<li>
<p>
Compute the minimum required AHU outdoor air intake flow rate.
The minimum required system outdoor air intake flow should be the uncorrected
outdoor air intake <code>sysUncOutAir</code> divided by the system ventilation
efficiency <code>sysVenEff</code>, but it should not be larger than the design
outdoor air rate <code>desOutAirInt</code>. Hence,
</p>
<pre>
    effMinOutAirInt = min(sysUncOutAir/sysVenEff, desOutAirInt),
</pre>
<p>
where the design outdoor air rate <code>desOutAirInt</code> is
</p>
<pre>
    desOutAirInt = VDesUncOutAir_flow/uDesSysVenEff.
</pre>
</li>
</ol>
</html>",                     revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Applied hysteresis for checking ventilation efficiency.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1787\">#1787</a>.
</li>
<li>
January 30, 2020, by Michael Wetter:<br/>
Removed the use of <code>fill</code> when assigning the <code>unit</code> attribute.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1728\">#1728</a>.
</li>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end AHU;

                    block SumZone
                      "Output the sum, maximum and minimum from the zone level calculation"

                      parameter Integer numZon(min=2)
                        "Total number of zones that the system serves";

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uDesZonPeaOcc[numZon](
                        final min = fill(0, numZon),
                        final unit = fill("1", numZon))
                        "Design zone peak occupancy"
                        annotation (Placement(transformation(extent={{-140,100},{-100,140}}),
                            iconTransformation(extent={{-140,60},{-100,100}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VDesPopBreZon_flow[numZon](
                        final min = fill(0, numZon),
                        final unit = fill("m3/s", numZon),
                        final quantity=fill("VolumeFlowRate", numZon))
                        "Population component breathing zone design outdoor airflow"
                        annotation (Placement(transformation(extent={{-140,70},{-100,110}}),
                            iconTransformation(extent={{-140,40},{-100,80}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VDesAreBreZon_flow[numZon](
                        final min = fill(0, numZon),
                        final unit = fill("m3/s", numZon),
                        final quantity=fill("VolumeFlowRate", numZon))
                        "Area component breathing zone design outdoor airflow"
                        annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
                            iconTransformation(extent={{-140,20},{-100,60}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput yAveOutAirFraPlu(
                        final min = 0,
                        final unit = "1")
                        "Average system outdoor air flow fraction plus 1"
                        annotation (Placement(transformation(extent={{-140,0},{-100,40}}),
                            iconTransformation(extent={{-140,0},{-100,40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uDesPriOutAirFra[numZon](
                        final min = fill(0, numZon),
                        final max = fill(1, numZon),
                        final unit = fill("1", numZon))
                        "Design zone primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{-140,-40},{-100,0}}),
                            iconTransformation(extent={{-140,-40},{-100,0}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VUncOutAir_flow[numZon](
                        final min = fill(0, numZon),
                        final unit = fill("m3/s", numZon),
                        final quantity=fill("VolumeFlowRate", numZon))
                        "Uncorrected outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-140,-70},{-100,-30}}),
                            iconTransformation(extent={{-140,-60},{-100,-20}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput uPriOutAirFra[numZon](
                        final min = fill(0, numZon),
                        final max = fill(1, numZon),
                        final unit = fill("1", numZon))
                        "Primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{-140,-100},{-100,-60}}),
                            iconTransformation(extent={{-140,-80},{-100,-40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VPriAir_flow[numZon](
                        final min = fill(0, numZon),
                        final unit = fill("m3/s", numZon),
                        final quantity=fill("VolumeFlowRate", numZon))
                        "Primary airflow rate"
                        annotation (Placement(transformation(extent={{-140,-140},{-100,-100}}),
                            iconTransformation(extent={{-140,-100},{-100,-60}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput ySumDesZonPop(
                        final min = 0,
                        final unit = "1")
                        "Sum of the design population of the zones in the group"
                        annotation (Placement(transformation(extent={{100,100},{140,140}}),
                            iconTransformation(extent={{100,70},{140,110}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VSumDesPopBreZon_flow(
                        final min = 0,
                        final unit = "m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of the population component design breathing zone flow rate"
                        annotation (Placement(transformation(extent={{100,70},{140,110}}),
                            iconTransformation(extent={{100,40},{140,80}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VSumDesAreBreZon_flow(
                        final min = 0,
                        final unit = "m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of the area component design breathing zone flow rate"
                        annotation (Placement(transformation(extent={{100,40},{140,80}}),
                            iconTransformation(extent={{100,10},{140,50}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yDesSysVenEff(
                        final min = 0,
                        final unit = "1")
                        "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                        annotation (Placement(transformation(extent={{100,-20},{140,20}}),
                            iconTransformation(extent={{100,-20},{140,20}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VSumUncOutAir_flow(
                        final min = 0,
                        final unit = "m3/s",
                        final quantity="VolumeFlowRate")
                        "Sum of the required uncorrected outdoor airflow rate"
                        annotation (Placement(transformation(extent={{100,-70},{140,-30}}),
                            iconTransformation(extent={{100,-50},{140,-10}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput uOutAirFra_max(
                        final min = 0,
                        final max = 1,
                        final unit = "1")
                        "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                        annotation (Placement(transformation(extent={{100,-100},{140,-60}}),
                            iconTransformation(extent={{100,-80},{140,-40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VSumSysPriAir_flow(
                        final min = 0,
                        final unit = "m3/s",
                        final quantity="VolumeFlowRate")
                        "AHU level primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                        annotation (Placement(transformation(extent={{100,-140},{140,-100}}),
                            iconTransformation(extent={{100,-110},{140,-70}})));

                  protected
                      Buildings.Controls.OBC.CDL.Continuous.MultiSum sysUncOutAir(
                        final nin=numZon)
                        "Uncorrected outdoor airflow"
                        annotation (Placement(transformation(extent={{-10,-60},{10,-40}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiSum sysPriAirRate(
                        final nin=numZon)
                        "System primary airflow rate"
                        annotation (Placement(transformation(extent={{-10,-130},{10,-110}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiSum sumDesZonPop(
                        final nin=numZon)
                        "Sum of the design zone population for all zones"
                        annotation (Placement(transformation(extent={{-10,110},{10,130}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiSum sumDesBreZonPop(
                        final nin=numZon)
                        "Sum of the design breathing zone flow rate for population component"
                        annotation (Placement(transformation(extent={{-10,80},{10,100}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiSum sumDesBreZonAre(
                        final nin=numZon)
                        "Sum of the design breathing zone flow rate for area component"
                        annotation (Placement(transformation(extent={{-10,50},{10,70}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add zonVenEff[numZon](
                        final k2=fill(-1,numZon))
                        "Zone ventilation efficiency"
                        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiMin desSysVenEff(
                        final nin=numZon)
                        "Design system ventilation efficiency"
                        annotation (Placement(transformation(extent={{20,-10},{40,10}})));

                      Buildings.Controls.OBC.CDL.Continuous.MultiMax maxPriOutAirFra(
                        final nin=numZon)
                        "Maximum zone outdoor air fraction"
                        annotation (Placement(transformation(extent={{-10,-90},{10,-70}})));

                      Buildings.Controls.OBC.CDL.Routing.RealScalarReplicator reaRep(
                        final nout=numZon)
                        "Replicate Real input signal"
                        annotation (Placement(transformation(extent={{-80,10},{-60,30}})));

                    equation
                      connect(zonVenEff.y, desSysVenEff.u)
                        annotation (Line(points={{12,0},{18,0}},color={0,0,127}));
                      connect(reaRep.y, zonVenEff.u1)
                        annotation (Line(points={{-58,20},{-40,20},{-40,6},{-12,6}},
                          color={0,0,127}));
                      connect(sumDesZonPop.y, ySumDesZonPop)
                        annotation (Line(points={{12,120},{120,120}},  color={0,0,127}));
                      connect(sumDesBreZonPop.y, VSumDesPopBreZon_flow)
                        annotation (Line(points={{12,90},{120,90}},color={0,0,127}));
                      connect(sumDesBreZonAre.y, VSumDesAreBreZon_flow)
                        annotation (Line(points={{12,60},{120,60}}, color={0,0,127}));
                      connect(desSysVenEff.y, yDesSysVenEff)
                        annotation (Line(points={{42,0},{120,0}}, color={0,0,127}));
                      connect(sysUncOutAir.y, VSumUncOutAir_flow)
                        annotation (Line(points={{12,-50},{120,-50}},  color={0,0,127}));
                      connect(sysPriAirRate.y, VSumSysPriAir_flow)
                        annotation (Line(points={{12,-120},{120,-120}}, color={0,0,127}));
                      connect(maxPriOutAirFra.y, uOutAirFra_max)
                        annotation (Line(points={{12,-80},{120,-80}},color={0,0,127}));
                      connect(yAveOutAirFraPlu, reaRep.u)
                        annotation (Line(points={{-120,20},{-82,20}}, color={0,0,127}));
                      connect(uDesZonPeaOcc, sumDesZonPop.u)
                        annotation (Line(points={{-120,120},{-12,120}}, color={0,0,127}));
                      connect(VDesPopBreZon_flow, sumDesBreZonPop.u)
                        annotation (Line(points={{-120,90},{-12,90}}, color={0,0,127}));
                      connect(VDesAreBreZon_flow, sumDesBreZonAre.u)
                        annotation (Line(points={{-120,60},{-12,60}},color={0,0,127}));
                      connect(uDesPriOutAirFra, zonVenEff.u2)
                        annotation (Line(points={{-120,-20},{-40,-20},{-40,-6},{-12,-6}},
                          color={0,0,127}));
                      connect(VUncOutAir_flow, sysUncOutAir.u)
                        annotation (Line(points={{-120,-50},{-12,-50}}, color={0,0,127}));
                      connect(VPriAir_flow, sysPriAirRate.u)
                        annotation (Line(points={{-120,-120},{-12,-120}},
                                                                        color={0,0,127}));
                      connect(uPriOutAirFra, maxPriOutAirFra.u)
                        annotation (Line(points={{-120,-80},{-12,-80}}, color={0,0,127}));

                    annotation (
                      Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                           graphics={Rectangle(
                              extent={{-100,100},{100,-100}},
                              lineColor={0,0,0},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-100,158},{100,118}},
                              lineColor={0,0,255},
                              textString="%name"),
                            Text(
                              extent={{-98,88},{-34,74}},
                              lineColor={0,0,0},
                              textString="uDesZonPeaOcc"),
                            Text(
                              extent={{-98,68},{-22,54}},
                              lineColor={0,0,0},
                              textString="VDesPopBreZon_flow"),
                            Text(
                              extent={{-98,26},{-30,14}},
                              lineColor={0,0,0},
                              textString="yAveOutAirFraPlu"),
                            Text(
                              extent={{-98,48},{-24,32}},
                              lineColor={0,0,0},
                              textString="VDesAreBreZon_flow"),
                            Text(
                              extent={{-98,-52},{-44,-66}},
                              lineColor={0,0,0},
                              textString="uPriOutAirFra"),
                            Text(
                              extent={{-98,-74},{-50,-86}},
                              lineColor={0,0,0},
                              textString="VPriAir_flow"),
                            Text(
                              extent={{-98,-32},{-30,-46}},
                              lineColor={0,0,0},
                              textString="VUncOutAir_flow"),
                            Text(
                              extent={{-98,-12},{-28,-26}},
                              lineColor={0,0,0},
                              textString="uDesPriOutAirFra"),
                            Text(
                              extent={{42,8},{96,-6}},
                              lineColor={0,0,0},
                              textString="yDesSysVenEff"),
                            Text(
                              extent={{12,40},{96,24}},
                              lineColor={0,0,0},
                              textString="VSumDesAreBreZon_flow"),
                            Text(
                              extent={{12,70},{96,54}},
                              lineColor={0,0,0},
                              textString="VSumDesPopBreZon_flow"),
                            Text(
                              extent={{36,98},{96,82}},
                              lineColor={0,0,0},
                              textString="ySumDesZonPop"),
                            Text(
                              extent={{36,-50},{96,-66}},
                              lineColor={0,0,0},
                              textString="uOutAirFra_max"),
                            Text(
                              extent={{26,-20},{96,-36}},
                              lineColor={0,0,0},
                              textString="VSumUncOutAir_flow"),
                            Text(
                              extent={{24,-80},{96,-96}},
                              lineColor={0,0,0},
                              textString="VSumSysPriAir_flow")}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-140},{100,140}})),
                      defaultComponentName="zonToSys",
                      Documentation(info="<html>
<p>
This sequence sums up the zone level minimum outdoor airflow setpoints, finds the
maximum zone outdoor air fraction and the minimum zone ventilation efficiency. It
collects zone level outputs and prepares inputs for specifying AHU level minimum
outdoor air setpoint.
</p>
<p>
It requires following inputs from zone level calculation,
</p>
<ul>
<li>
Design zone peak occupancy, <code>uDesZonPeaOcc</code>,
</li>
<li>
Population component of the breathing zone design outdoor airflow, <code>VDesPopBreZon_flow</code>,
</li>
<li>
Area component of the breathing zone design outdoor airflow, <code>VDesAreBreZon_flow</code>,
</li>
<li>
Design zone primary outdoor air fraction, <code>uDesPriOutAirFra</code>,
</li>
<li>
Uncorrected outdoor airflow rate, <code>VUncOutAir_flow</code>, 
</li>
<li>
Primary outdoor air fraction, <code>uPriOutAirFra</code>,
</li>
<li>
Primary airflow rate, <code>VPriAir_flow</code>,
</li>
</ul>
<p>
and following input from AHU level calculation,
</p>
<ul>
<li>
Average AHU level outdoor air flow fraction plus 1, <code>yAveOutAirFraPlu</code>.
</li>
</ul>
<p>
The sequence gives following outputs for AHU level calculation:
</p>
<ul>
<li>
Sum of the design population of the zones, <code>ySumDesZonPop</code>,
</li>
<li>
Sum of the population component of the design breathing zone flow rate, <code>VSumDesPopBreZon_flow</code>,
</li>
<li>
Sum of the area component of the design breathing zone flow rate, <code>VSumDesAreBreZon_flow</code>,
</li>
<li>
Design system ventilation efficiency, <code>yDesSysVenEff</code>,
<p>
First, compute the zone ventilation efficiency <code>zonVenEff</code>, for design purpose, as
</p>
<pre>
    zonVenEff[i] = yAveOutAirFraPlu - uDesPriOutAirFra[i]
</pre>
<p>
where the <code>uDesPriOutAirFra</code> is the design zone outdoor airflow fraction.
Then the design system ventilation efficiency <code>yDesSysVenEff</code> is
</p>
<pre>
    yDesSysVenEff = min(zonVenEff[i]).
</pre>
</li>
<li>
Sum of the required uncorrected outdoor airflow rate, <code>VSumUncOutAir_flow</code>,
</li>
<li>
Maximum zone outdoor air fraction, <code>uOutAirFra_max</code>,
</li>
<li>
AHU level primary airflow rate, <code>VSumSysPriAir_flow</code>.
</li>
</ul>
</html>",                     revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
</ul>
</html>"));
                    end SumZone;

                    block Zone
                      "Output outdoor airflow related calculations at the zone level"

                      parameter Real VOutPerAre_flow(
                        final unit = "m3/(s.m2)")=3e-4
                        "Outdoor air rate per unit area"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Real VOutPerPer_flow(unit="m3/s")=2.5e-3
                        "Outdoor air rate per person"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Real AFlo(unit="m2")
                        "Floor area of each zone"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Boolean have_occSen=true
                        "Set to true if zones have occupancy sensor";

                      parameter Boolean have_winSen=true
                        "Set to true if zones have window status sensor";

                      parameter Real occDen(final unit = "1/m2") = 0.05
                        "Default number of person in unit area";

                      parameter Real zonDisEffHea(final unit = "1") = 0.8
                        "Zone air distribution effectiveness during heating";

                      parameter Real zonDisEffCoo(final unit = "1") = 1.0
                        "Zone air distribution effectiveness during cooling";

                      parameter Real desZonDisEff(final unit = "1") = 1.0
                        "Design zone air distribution effectiveness"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Real desZonPop(
                        min=0,
                        final unit = "1") = occDen*AFlo
                        "Design zone population during peak occupancy"
                        annotation(Dialog(group="Nominal condition"));

                      parameter Real uLow(
                        final unit="K",
                        final displayUnit="K",
                        final quantity="ThermodynamicTemperature") = -0.5
                        "If zone space temperature minus supply air temperature is less than uLow,
     then it should use heating supply air distribution effectiveness"
                        annotation (Dialog(tab="Advanced"));

                      parameter Real uHig(
                        final unit="K",
                        final displayUnit="K",
                        final quantity="ThermodynamicTemperature") = 0.5
                        "If zone space temperature minus supply air temperature is more than uHig,
     then it should use cooling supply air distribution effectiveness"
                        annotation (Dialog(tab="Advanced"));

                      parameter Real minZonPriFlo(unit="m3/s")
                        "Minimum expected zone primary flow rate"
                        annotation(Dialog(group="Nominal condition"));

                      Buildings.Controls.OBC.CDL.Interfaces.IntegerInput nOcc if have_occSen
                        "Number of occupants"
                        annotation (Placement(transformation(extent={{-200,20},{-160,60}}),
                            iconTransformation(extent={{-140,70},{-100,110}})));

                      Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWin if have_winSen
                        "Window status, true if open, false if closed"
                        annotation (Placement(transformation(extent={{-200,-70},{-160,-30}}),
                          iconTransformation(extent={{-140,40},{-100,80}})));

                      Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uReqOutAir
                        "True if the AHU supply fan is on and the zone is in occupied mode"
                        annotation (Placement(transformation(extent={{-200,-110},{-160,-70}}),
                            iconTransformation(extent={{-140,10},{-100,50}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity="ThermodynamicTemperature") "Measured zone air temperature"
                        annotation (Placement(transformation(extent={{-200,-150},{-160,-110}}),
                            iconTransformation(extent={{-140,-20},{-100,20}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput TDis(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity="ThermodynamicTemperature") "Measured discharge air temperature"
                        annotation (Placement(transformation(extent={{-200,-190},{-160,-150}}),
                          iconTransformation(extent={{-140,-50},{-100,-10}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VDis_flow(
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "Primary airflow rate to the ventilation zone from the air handler, including outdoor air and recirculated air"
                        annotation (Placement(transformation(extent={{-200,-230},{-160,-190}}),
                          iconTransformation(extent={{-140,-80},{-100,-40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealInput VUncOut_flow_nominal(
                        final min=0,
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "AHU level design uncorrected minimum outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-200,-270},{-160,-230}}),
                          iconTransformation(extent={{-140,-110},{-100,-70}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yDesZonPeaOcc(
                        final min=0,
                        final unit="1")
                        "Design zone peak occupancy"
                        annotation (Placement(transformation(extent={{180,220},{220,260}}),
                          iconTransformation(extent={{100,70},{140,110}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDesPopBreZon_flow(
                        final min=0,
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "Population component breathing zone design outdoor airflow"
                        annotation (Placement(transformation(extent={{180,180},{220,220}}),
                          iconTransformation(extent={{100,40},{140,80}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDesAreBreZon_flow(
                        final min=0,
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "Area component breathing zone outdoor airflow"
                        annotation (Placement(transformation(extent={{180,120},{220,160}}),
                          iconTransformation(extent={{100,10},{140,50}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yDesPriOutAirFra(
                        final min=0,
                        final unit="1")
                        "Design zone primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{180,50},{220,90}}),
                          iconTransformation(extent={{100,-20},{140,20}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VUncOutAir_flow(
                        final min=0,
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "Uncorrected outdoor airflow rate"
                        annotation (Placement(transformation(extent={{180,-110},{220,-70}}),
                          iconTransformation(extent={{100,-50},{140,-10}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput yPriOutAirFra(
                        final min=0,
                        final unit="1") "Primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{180,-180},{220,-140}}),
                          iconTransformation(extent={{100,-80},{140,-40}})));

                      Buildings.Controls.OBC.CDL.Interfaces.RealOutput VPriAir_flow(
                        final min=0,
                        final unit = "m3/s",
                        final quantity = "VolumeFlowRate")
                        "Primary airflow rate"
                        annotation (Placement(transformation(extent={{180,-240},{220,-200}}),
                          iconTransformation(extent={{100,-110},{140,-70}})));

                  protected
                      Buildings.Controls.OBC.CDL.Conversions.IntegerToReal intToRea if have_occSen
                        "Type converter"
                        annotation (Placement(transformation(extent={{-140,30},{-120,50}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add breZon "Breathing zone airflow"
                        annotation (Placement(transformation(extent={{20,40},{40,60}})));

                      Buildings.Controls.OBC.CDL.Continuous.Gain gai(
                        final k = VOutPerPer_flow) if have_occSen
                        "Outdoor air per person"
                        annotation (Placement(transformation(extent={{-100,30},{-80,50}})));

                      Buildings.Controls.OBC.CDL.Logical.Switch swi
                        "If there is occupancy sensor, then using the real time occupancy; otherwise, using the default occupancy"
                        annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

                      Buildings.Controls.OBC.CDL.Logical.Switch swi1
                        "Switch between cooling or heating distribution effectiveness"
                        annotation (Placement(transformation(extent={{-20,-160},{0,-140}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division zonOutAirRate
                        "Required zone outdoor airflow rate"
                        annotation (Placement(transformation(extent={{80,10},{100,30}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division priOutAirFra
                        "Primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{120,-170},{140,-150}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add desBreZon "Breathing zone design airflow"
                        annotation (Placement(transformation(extent={{20,190},{40,210}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division desZonOutAirRate
                        "Required design zone outdoor airflow rate"
                        annotation (Placement(transformation(extent={{80,170},{100,190}})));

                      Buildings.Controls.OBC.CDL.Continuous.Division desZonPriOutAirRate
                        "Design zone primary outdoor air fraction"
                        annotation (Placement(transformation(extent={{140,60},{160,80}})));

                      Buildings.Controls.OBC.CDL.Continuous.Add add2(
                        final k2=-1)
                        "Zone space temperature minus supply air temperature"
                        annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));

                      Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys(
                        final uLow=uLow,
                        final uHigh=uHig,
                        final pre_y_start=true)
                        "Check if cooling or heating air distribution effectiveness should be applied, with 1 degC deadband"
                        annotation (Placement(transformation(extent={{-80,-160},{-60,-140}})));

                      Buildings.Controls.OBC.CDL.Logical.Sources.Constant occSen(
                        final k=have_occSen)
                        "Boolean constant to indicate if there is occupancy sensor"
                        annotation (Placement(transformation(extent={{-140,-10},{-120,10}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant desDisEff(
                        final k = desZonDisEff)
                        "Design zone air distribution effectiveness"
                        annotation (Placement(transformation(extent={{20,150},{40,170}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minZonFlo(
                        final k = minZonPriFlo)
                        "Minimum expected zone primary flow rate"
                        annotation (Placement(transformation(extent={{80,60},{100,80}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant disEffHea(
                        final k = zonDisEffHea)
                        "Zone distribution effectiveness for heating"
                        annotation (Placement(transformation(extent={{-80,-200},{-60,-180}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant disEffCoo(
                        final k = zonDisEffCoo)
                        "Zone distribution effectiveness fo cooling"
                        annotation (Placement(transformation(extent={{-80,-120},{-60,-100}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerOutAir(
                        final k=0)
                        "Zero required outdoor airflow rate when window is open or when zone is not in occupied mode"
                        annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerOcc(
                        final k=0) if not have_occSen
                        "Zero occupant when there is no occupancy sensor"
                        annotation (Placement(transformation(extent={{-140,70},{-120,90}})));

                      Buildings.Controls.OBC.CDL.Logical.Sources.Constant cloWin(
                        final k=false) if not have_winSen
                        "Closed window status when there is no window sensor"
                        annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));

                      Buildings.Controls.OBC.CDL.Logical.Switch swi4
                        "If window is open, the required outdoor airflow rate should be zero"
                        annotation (Placement(transformation(extent={{60,-60},{80,-40}})));

                      Buildings.Controls.OBC.CDL.Logical.Switch swi5
                        "If supply fan is off or it is not in occupied mode, then outdoor airflow rate should be zero"
                        annotation (Placement(transformation(extent={{120,-100},{140,-80}})));

                      Buildings.Controls.OBC.CDL.Continuous.Max max
                        "If supply fan is off, giving a small primary airflow rate to avoid division by zero"
                        annotation (Placement(transformation(extent={{-20,-230},{0,-210}})));

                      Buildings.Controls.OBC.CDL.Continuous.Product breZonAre
                        "Area component of the breathing zone outdoor airflow"
                        annotation (Placement(transformation(extent={{-80,130},{-60,150}})));

                      Buildings.Controls.OBC.CDL.Continuous.Product pro
                        "Product of flow rate per person and floor area"
                        annotation (Placement(transformation(extent={{-80,170},{-60,190}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant floPerAre(
                        final k=VOutPerAre_flow)
                        "Flow rate per unit area"
                        annotation (Placement(transformation(extent={{-140,110},{-120,130}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant floAre(
                        final k=AFlo) "Floor area"
                        annotation (Placement(transformation(extent={{-140,150},{-120,170}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant floPerPer(
                        final k=VOutPerPer_flow) "Flow rate per person"
                        annotation (Placement(transformation(extent={{-140,190},{-120,210}})));

                      Buildings.Controls.OBC.CDL.Continuous.Gain breZonPop(
                        final k=occDen)
                        "Default population component of the breathing zone outdoor airflow"
                        annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));

                      Buildings.Controls.OBC.CDL.Continuous.Gain gaiDivZer(
                        final k=1E-3)
                        "Gain, used to avoid division by zero if the flow rate is smaller than 0.1%"
                        annotation (Placement(transformation(extent={{-80,-250},{-60,-230}})));

                      Buildings.Controls.OBC.CDL.Continuous.Sources.Constant desPeaOcc(
                        final k=desZonPop)
                        "Design zone population during peak occupancy"
                        annotation (Placement(transformation(extent={{-140,230},{-120,250}})));

                      Buildings.Controls.OBC.CDL.Continuous.Product desBreZonPer
                        "Population component of the breathing zone design outdoor airflow"
                        annotation (Placement(transformation(extent={{-80,210},{-60,230}})));

                    equation
                      connect(gai.y, swi.u1)
                        annotation (Line(points={{-78,40},{-60,40},{-60,8},{-42,8}},
                          color={0,0,127}));
                     connect(swi.y, breZon.u2)
                        annotation (Line(points={{-18,0},{0,0},{0,44},{18,44}},
                          color={0,0,127}));
                      connect(disEffCoo.y, swi1.u1)
                        annotation (Line(points={{-58,-110},{-40,-110},{-40,-142},{-22,-142}},
                          color={0,0,127}));
                      connect(disEffHea.y, swi1.u3)
                        annotation (Line(points={{-58,-190},{-40,-190},{-40,-158},{-22,-158}},
                          color={0,0,127}));
                      connect(breZon.y, zonOutAirRate.u1)
                        annotation (Line(points={{42,50},{60,50},{60,26},{78,26}},
                          color={0,0,127}));
                      connect(swi1.y, zonOutAirRate.u2)
                        annotation (Line(points={{2,-150},{20,-150},{20,14},{78,14}},
                          color={0,0,127}));
                      connect(desDisEff.y, desZonOutAirRate.u2)
                        annotation (Line(points={{42,160},{60,160},{60,174},{78,174}},
                          color={0,0,127}));
                      connect(desBreZon.y, desZonOutAirRate.u1)
                        annotation (Line(points={{42,200},{60,200},{60,186},{78,186}},
                          color={0,0,127}));
                      connect(desZonOutAirRate.y, desZonPriOutAirRate.u1)
                        annotation (Line(points={{102,180},{120,180},{120,76},{138,76}},
                          color={0,0,127}));
                      connect(minZonFlo.y, desZonPriOutAirRate.u2)
                        annotation (Line(points={{102,70},{120,70},{120,64},{138,64}},
                          color={0,0,127}));
                      connect(swi.u2, occSen.y)
                        annotation (Line(points={{-42,0},{-118,0}},
                          color={255,0,255}));
                      connect(TDis, add2.u2)
                        annotation (Line(points={{-180,-170},{-140,-170},{-140,-156},{-122,-156}},
                          color={0,0,127}));
                      connect(TZon, add2.u1)
                        annotation (Line(points={{-180,-130},{-140,-130},{-140,-144},{-122,-144}},
                          color={0,0,127}));
                      connect(add2.y, hys.u)
                        annotation (Line(points={{-98,-150},{-82,-150}},
                          color={0,0,127}));
                      connect(hys.y, swi1.u2)
                        annotation (Line(points={{-58,-150},{-22,-150}}, color={255,0,255}));
                      connect(zerOcc.y, swi.u1)
                        annotation (Line(points={{-118,80},{-60,80},{-60,8},{-42,8}},
                          color={0,0,127}));
                      connect(intToRea.y, gai.u)
                        annotation (Line(points={{-118,40},{-102,40}}, color={0,0,127}));
                      connect(nOcc, intToRea.u)
                        annotation (Line(points={{-180,40},{-142,40}}, color={255,127,0}));
                      connect(desZonPriOutAirRate.y, yDesPriOutAirFra)
                        annotation (Line(points={{162,70},{200,70}}, color={0,0,127}));
                      connect(priOutAirFra.y, yPriOutAirFra)
                        annotation (Line(points={{142,-160},{200,-160}}, color={0,0,127}));
                      connect(zerOutAir.y, swi4.u1) annotation (Line(points={{-18,-70},{0,-70},{0,-42},
                              {58,-42}}, color={0,0,127}));
                      connect(zonOutAirRate.y, swi4.u3) annotation (Line(points={{102,20},{120,20},{
                              120,-20},{40,-20},{40,-58},{58,-58}},  color={0,0,127}));
                      connect(swi5.y, VUncOutAir_flow)
                        annotation (Line(points={{142,-90},{200,-90}}, color={0,0,127}));
                      connect(swi5.y, priOutAirFra.u1) annotation (Line(points={{142,-90},{160,-90},
                              {160,-120},{100,-120},{100,-154},{118,-154}}, color={0,0,127}));
                      connect(uWin, swi4.u2) annotation (Line(points={{-180,-50},{58,-50}},
                              color={255,0,255}));
                      connect(cloWin.y, swi4.u2) annotation (Line(points={{-78,-70},{-60,-70},{-60,-50},
                              {58,-50}},color={255,0,255}));
                      connect(uReqOutAir, swi5.u2)
                        annotation (Line(points={{-180,-90},{118,-90}}, color={255,0,255}));
                      connect(VDis_flow, max.u1) annotation (Line(points={{-180,-210},{-40,-210},{-40,
                              -214},{-22,-214}}, color={0,0,127}));
                      connect(max.y, priOutAirFra.u2) annotation (Line(points={{2,-220},{100,-220},{
                              100,-166},{118,-166}}, color={0,0,127}));
                      connect(max.y, VPriAir_flow)
                        annotation (Line(points={{2,-220},{200,-220}}, color={0,0,127}));
                      connect(floAre.y, breZonAre.u1) annotation (Line(points={{-118,160},{-100,160},
                              {-100,146},{-82,146}}, color={0,0,127}));
                      connect(floPerAre.y, breZonAre.u2) annotation (Line(points={{-118,120},{-100,120},
                              {-100,134},{-82,134}},color={0,0,127}));
                      connect(breZonAre.y, desBreZon.u2) annotation (Line(points={{-58,140},{0,140},
                              {0,194},{18,194}}, color={0,0,127}));
                      connect(breZonAre.y, breZon.u1) annotation (Line(points={{-58,140},{0,140},{0,
                              56},{18,56}},   color={0,0,127}));
                      connect(floPerPer.y, pro.u1) annotation (Line(points={{-118,200},{-100,200},{-100,
                              186},{-82,186}}, color={0,0,127}));
                      connect(floAre.y, pro.u2) annotation (Line(points={{-118,160},{-100,160},{-100,
                              174},{-82,174}}, color={0,0,127}));
                      connect(breZonPop.y, swi.u3) annotation (Line(points={{-78,-30},{-60,-30},{-60,
                              -8},{-42,-8}}, color={0,0,127}));
                      connect(pro.y, breZonPop.u) annotation (Line(points={{-58,180},{-40,180},{-40,
                              100},{-110,100},{-110,-30},{-102,-30}}, color={0,0,127}));
                      connect(VUncOut_flow_nominal, gaiDivZer.u)
                        annotation (Line(points={{-180,-250},{-100,-250},{-100,-240},{-82,-240}},
                          color={0,0,127}));
                      connect(gaiDivZer.y, max.u2)
                        annotation (Line(points={{-58,-240},{-40,-240},{-40,-226},{-22,-226}},
                          color={0,0,127}));
                      connect(floPerPer.y, desBreZonPer.u2) annotation (Line(points={{-118,200},{-100,
                              200},{-100,214},{-82,214}}, color={0,0,127}));
                      connect(desPeaOcc.y, desBreZonPer.u1) annotation (Line(points={{-118,240},{-100,
                              240},{-100,226},{-82,226}}, color={0,0,127}));
                      connect(desBreZonPer.y, desBreZon.u1) annotation (Line(points={{-58,220},{0,220},
                              {0,206},{18,206}}, color={0,0,127}));
                      connect(desPeaOcc.y, yDesZonPeaOcc)
                        annotation (Line(points={{-118,240},{200,240}}, color={0,0,127}));
                      connect(desBreZonPer.y, VDesPopBreZon_flow) annotation (Line(points={{-58,220},
                              {120,220},{120,200},{200,200}}, color={0,0,127}));
                      connect(breZonAre.y, VDesAreBreZon_flow)
                        annotation (Line(points={{-58,140},{200,140}}, color={0,0,127}));
                      connect(zerOutAir.y, swi5.u3) annotation (Line(points={{-18,-70},{0,-70},{0,-98},
                              {118,-98}}, color={0,0,127}));
                      connect(swi4.y, swi5.u1) annotation (Line(points={{82,-50},{100,-50},{100,-82},
                              {118,-82}}, color={0,0,127}));

                    annotation (
                      defaultComponentName="zonOutAirSet",
                      Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                           graphics={Rectangle(
                              extent={{-100,100},{100,-100}},
                              lineColor={0,0,0},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid),
                            Text(
                              extent={{-98,-82},{-14,-98}},
                              lineColor={0,0,0},
                              textString="VUncOut_flow_nominal"),
                            Text(
                              extent={{-100,158},{100,118}},
                              lineColor={0,0,255},
                              textString="%name"),
                            Text(
                              extent={{-100,-54},{-58,-64}},
                              lineColor={0,0,0},
                              textString="VDis_flow"),
                            Text(
                              extent={{-100,-24},{-72,-36}},
                              lineColor={0,0,0},
                              textString="TDis"),
                            Text(
                              extent={{-100,8},{-70,-4}},
                              lineColor={0,0,0},
                              textString="TZon"),
                            Text(
                              extent={{-100,36},{-40,24}},
                              lineColor={255,0,255},
                              textString="uReqOutAir"),
                            Text(
                              visible=have_winSen,
                              extent={{-100,68},{-72,56}},
                              lineColor={255,0,255},
                              textString="uWin"),
                            Text(
                              visible=have_occSen,
                              extent={{-100,98},{-70,86}},
                              lineColor={255,127,0},
                              textString="nOcc"),
                            Text(
                              extent={{28,98},{98,82}},
                              lineColor={0,0,0},
                              textString="yDesZonPeaOcc"),
                            Text(
                              extent={{12,70},{96,54}},
                              lineColor={0,0,0},
                              textString="VDesPopBreZon_flow"),
                            Text(
                              extent={{14,38},{98,22}},
                              lineColor={0,0,0},
                              textString="VDesAreBreZon_flow"),
                            Text(
                              extent={{28,10},{98,-8}},
                              lineColor={0,0,0},
                              textString="yDesPriOutAirFra"),
                            Text(
                              extent={{28,-20},{98,-36}},
                              lineColor={0,0,0},
                              textString="VUncOutAir_flow"),
                            Text(
                              extent={{40,-50},{96,-66}},
                              lineColor={0,0,0},
                              textString="yPriOutAirFra"),
                            Text(
                              extent={{48,-82},{98,-96}},
                              lineColor={0,0,0},
                              textString="VPriAir_flow")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-260},{180,260}})),
                    Documentation(info="<html>
<p>
This sequence conducts calculations of the minimum outdoor airflow rate at the zone
level. It gives outputs below.
</p>
<ol>
<li>
The population component of the breathing zone outdoor airflow, <code>VDesPopBreZon_flow</code>.
</li>
<li>
The area component of the breathing zone outdoor airflow, <code>VDesAreBreZon_flow</code>.
</li>
<li>
Design zone primary outdoor air fraction, <code>yDesPriOutAirFra</code>.
</li>
<li>
Uncorrected outdoor airflow rate, <code>VUncOutAir_flow</code>. This flow rate
is calculated based on: occupancy (if there is occupancy sensor) or design
occupancy (if there is no occupancy sensor), and air distribution effectiveness
(warm or cool air).
</li>
<li>
Primary outdoor air fraction, <code>yPriOutAirFra</code>.
</li>
<li>
Primary airflow rate, <code>VPriAir_flow</code>.
</li>
</ol>
<p>
The calculation is done using the steps below.
</p>
<ol>
<li>
<p>
Compute the required breathing zone outdoor airflow using the following components.
</p>
<ul>
<li>The area component of the breathing zone outdoor airflow, <code>VDesAreBreZon_flow</code>.
</li>
<li>The population component of the breathing zone outdoor airflow, <code>VDesPopBreZon_flow</code>.
</li>
</ul>
<p>
The number of occupant in the zone can be retrieved directly from occupancy sensor
(<code>nOcc</code>) if the sensor exists, or using the default occupant density
(<code>occDen</code>) and multiplying it with zone area (<code>AFlo</code>).
The occupant density can be found from Table 6.2.2.1 in ASHRAE Standard
62.1-2013. For design purpose, use the design zone population (<code>desZonPop</code>)
to determine the minimum requirement at the ventilation-design condition.
</p>
</li>
<li>
<p>
Compute the zone air-distribution effectiveness.
Table 6.2.2.2 in ASHRAE 62.1-2013 lists some typical values for setting the
effectiveness. Depending on difference between zone space temperature
<code>TZon</code> and discharge air temperature (after the reheat coil) <code>TDis</code>, Warm-air
effectiveness <code>zonDisEffHea</code> or Cool-air effectiveness
<code>zonDisEffCoo</code> should be applied.
</p>
</li>
<li>
<p>
Compute the required zone outdoor airflow <code>zonOutAirRate</code>.
If the zone is in any mode other than occupied mode (<code>uReqOutAir=false</code>)
or if the zone has window switches and the window is open (<code>uWin=true</code>),
set <code>zonOutAirRate = 0</code>.
Otherwise, the required zone outdoor airflow <code>zonOutAirRate</code>
shall be calculated as follows:
</p>
<ul>
<li>
If the zone is populated (<code>nOcc</code> &gt; 0), or if there is no occupancy sensor
(<code>have_occSen = false</code>):
<ul>
<li>
If the discharge air temperature at the terminal unit is less than or equal to
the zone space temperature, set <code>zonOutAirRate = (breZonAre+breZonPop)/disEffCoo</code>.
</li>
<li>
If the discharge air temperature at the terminal unit is greater than zone space
temperature, set <code>zonOutAirRate = (breZonAre+breZonPop)/disEffHea</code>.
</li>
</ul>
</li>
<li>
If the zone has an occupancy sensor and is unpopulated (<code>nOcc=0</code>):
<ul>
<li>
If the discharge air temperature at the terminal unit is less than or equal to
the zone space temperature, set <code>zonOutAirRate = breZonAre/disEffCoo</code>.
</li>
<li>
If the discharge air temperature at the terminal unit is greater than zone
space temperature, set <code>zonOutAirRate = breZonAre/disEffHea</code>.
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
Compute the outdoor air fraction for the zone <code>yPriOutAirFra</code> as follows.
Set the zone outdoor air fraction to
</p>
<pre>
    yPriOutAirFra = zonOutAirRate/VPriAir_flow
</pre>
<p>
where, <code>VPriAir_flow</code> is the maximum between the measured discharge air
flow rate from the zone VAV box <code>VDis_flow</code> and 0.1% of AHU level
design uncorrected minimum outdoor airflow rate <code>VUncOut_flow_nominal</code>.
For design purpose, the design zone outdoor air fraction <code>yDesPriOutAirFra</code>
is
</p>
<pre>
    yDesPriOutAirFra = desZonOutAirRate/minZonPriFlo
</pre>
<p>
where <code>minZonPriFlo</code> is the minimum expected zone primary flow rate and
<code>desZonOutAirRate</code> is the required design zone outdoor airflow rate.
</p>
</li>
</ol>
<h4>References</h4>
<p>
ANSI/ASHRAE Standard 62.1-2013,
<i>Ventilation for Acceptable Indoor Air Quality.</i>
</p>
<p>
Stanke, D., 2010. <i>Dynamic Reset for Multiple-Zone Systems.</i> ASHRAE Journal, March
2010.
</p>
</html>",                     revisions="<html>
<ul>
<li>
December 23, 2020, by Michael Wetter:<br/>
Changed the <code>min</code> attribute of <code>desZonPop</code> to zero, and used
the expression as a default value. This was done because the expression involves the
zone floor area, which is, if obtained from Spawn, a non-literal value.
</li>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Applied hysteresis for checking ventilation efficiency.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1787\">#1787</a>.
</li>
<li>
January 30, 2020, by Michael Wetter:<br/>
Removed the use of <code>fill</code> when assigning the <code>unit</code> attribute.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1728\">#1728</a>.
</li>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
October 28, 2017, by Michael Wetter:<br/>
Corrected bug in guarding against division by zero.
</li>
<li>
September 27, 2017, by Michael Wetter:<br/>
Changed handling of guard against zero division, as the flow rate
can be zero at the instant when the fan switches on.
</li>
<li>
July 6, 2017, by Jianjun Hu:<br/>
Replaced <code>cooCtrlSig</code> input with <code>TZon</code> and <code>TDis</code>
inputs to check if cool or warm air distribution effectiveness should be applied.
Applied hysteresis to avoid rapid change.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Zone;
                  annotation (
                  Documentation(info="<html>
<p>
This package contains sequences to set the minimum outdoor airflow setpoint for 
compliance with the ventilation rate procedure of ASHRAE 62.1-2013. The
implementation is according to ASHRAE Guidline 36 (G36), PART 5.N.3.a, PART 5.B.2.b,
PART3.1-D.2.a.
</p>
<ul>
<li> 
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone</a>
conducts zone level calculations for specifying minimum outdoor airflow rate,
</li>
<li> 
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU</a>
conducts AHU level calculations for specifying minimum outdoor airflow rate,
</li>
<li> 
and <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone</a>
finds the sums, the maximum and the minimum of outputs from zone level calculations.
They become inputs of AHU level calculation.
</li>
</ul>
</html>",                   revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Reimplemented sequence of calculating the outdoor airflow setpoint to separated
vector-valued calculation. This therefore breaks the single sequence to three
subsequences.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 23, 2019, by Michael Wetter:<br/>
Improved documentation.
</li>
</ul>
</html>"),                   Icon(graphics={
                          Rectangle(
                            lineColor={200,200,200},
                            fillColor={248,248,248},
                            fillPattern=FillPattern.HorizontalCylinder,
                            extent={{-100,-100},{100,100}},
                            radius=25.0),
                          Rectangle(
                            lineColor={128,128,128},
                            extent={{-100,-100},{100,100}},
                            radius=25.0),
                          Ellipse(
                            origin={10,10},
                            lineColor={128,128,128},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid,
                            extent={{-80.0,0.0},{-20.0,60.0}}),
                          Ellipse(
                            origin={10,10},
                            fillColor={128,128,128},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{0.0,0.0},{60.0,60.0}}),
                          Ellipse(
                            origin={10,10},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{0.0,-80.0},{60.0,-20.0}}),
                          Ellipse(
                            origin={10,10},
                            fillColor={76,76,76},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                  end OutdoorAirFlow;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences generating setpoints for VAV AHU control.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                      Text(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        textString="S")}));
                end SetPoints;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36, Part 5.N for
multi zone VAV air handling unit control.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={76,76,76},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,-80.0},{-20.0,-20.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,-80.0},{60.0,-20.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={128,128,128},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,0.0},{60.0,60.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        lineColor={128,128,128},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,0.0},{-20.0,60.0}})}));
              end VAV;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36 for multi zone air handling units.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),      Rectangle(
                        extent={{-78,78},{74,-76}},
                        lineColor={0,0,0},
                        lineThickness=0.5),
                                         Rectangle(
                        extent={{-44,44},{40,-42}},
                        lineColor={0,0,0},
                        lineThickness=0.5),
                  Line(
                    points={{-24,44},{-24,78}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{20,44},{20,78}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{22,-76},{22,-42}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-22,-76},{-22,-42}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-78,24},{-44,24}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-78,-24},{-44,-24}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{40,-24},{74,-24}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{40,24},{74,24}},
                    color={0,0,0},
                    thickness=0.5)}));
            end MultiZone;
            annotation (
            Documentation(info="<html>
<p>
This package contains AHU control sequences from ASHRAE Guideline 36.
</p>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),      Rectangle(
                      extent={{-60,60},{60,-60}},
                      lineColor={0,0,127},
                      lineThickness=0.5)}));
          end AHUs;

          package Generic "Generic control sequences"

            block FreezeProtectionMixedAir "Freeze protection based on mixed air temperature"

              parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=
                Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                "Type of controller";
              parameter Real k(final unit="1/K")=0.1 "Gain";

              parameter Real Ti(
                final unit="s",
                final quantity="Time")= 120 "Time constant of integrator block";

              parameter Real Td(
                final unit="s",
                final quantity="Time")= 0.1
                "Time constant of derivative block"
                annotation (Dialog(
                  enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                      or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Real TFreSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")= 279.15
                "Lower limit for mixed air temperature for freeze protection";

              Buildings.Controls.OBC.CDL.Interfaces.RealInput TMix(
                final unit="K",
                final displayUnit="degC",
                final quantity = "ThermodynamicTemperature")
                "Mixed air temperature measurement"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

              Buildings.Controls.OBC.CDL.Interfaces.RealOutput yFrePro(
                final unit="1",
                final min=0,
                final max=1) "Freeze protection control signal, 0 if no frost, 1 if TMix below TFreSet"
                annotation (Placement(transformation(extent={{100,-50},{140,-10}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput yFreProInv(
                final unit="1",
                final min=0,
                final max=1) "Inverse freeze protection control signal, 1 if no frost, 0 if TMix below TFreSet"
                annotation (Placement(transformation(extent={{100,10},{140,50}})));

              Buildings.Controls.OBC.CDL.Continuous.PID con(
                final controllerType=controllerType,
                final k=k,
                final Ti=Ti,
                final Td=Td,
                final yMax=1,
                final yMin=0)
                "Controller for mixed air to track freeze protection set point"
                annotation (Placement(transformation(extent={{-20,20},{0,40}})));

          protected
              Buildings.Controls.OBC.CDL.Continuous.Sources.Constant setPoi(final k=TFreSet)
                "Set point for freeze protection"
                annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
              Buildings.Controls.OBC.CDL.Continuous.AddParameter yOut(final p=1, final k=-1)
                "Freeze protection control signal inverter"
                annotation (Placement(transformation(extent={{60,20},{80,40}})));

            equation
              connect(con.u_s, setPoi.y)
                annotation (Line(points={{-22,30},{-38,30}}, color={0,0,127}));
              connect(yOut.y, yFreProInv)
                annotation (Line(points={{82,30},{120,30}}, color={0,0,127}));
              connect(TMix, con.u_m)
                annotation (Line(points={{-120,0},{-10,0},{-10,18}}, color={0,0,127}));
              connect(con.y, yFrePro) annotation (Line(points={{2,30},{30,30},{30,-30},{120,
                      -30}}, color={0,0,127}));
              connect(con.y, yOut.u) annotation (Line(points={{2,30},{30,30},{30,30},{58,30}},
                    color={0,0,127}));
              annotation (Dialog(
                enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
                defaultComponentName = "freProTMix",
                Icon(graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-164,144},{164,106}},
                      lineColor={0,0,127},
                      textString="%name"),
                    Line(
                      points={{-20,-46},{-20,40},{36,40},{-20,40},{-20,2},{26,2}},
                      color={0,0,127},
                      thickness=0.5)}),
            Documentation(info="<html>
<p>
Block that tracks the mixed air temperature <code>TMix</code>
using a PI controller and outputs
a freeze protection control signal <code>yFrePro</code> and
its inverse <code>yFreProInv</code>.
</p>
</html>",             revisions="<html>
<ul>
<li>
November 2, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
            end FreezeProtectionMixedAir;

            package SetPoints
            "Package with sequences that output control setpoints"

              block GroupStatus "Block that outputs the zone group status"

                parameter Integer numZon(
                  final min=1)=5 "Number of zones in building";
                parameter Integer numZonGro(
                  final min=1)=numZon "Number of zones in group";
                parameter Boolean zonGroMsk[numZon]=fill(true, numZon)
                  "Boolean array mask of zones included in group";

                parameter Real uLow=-0.1
                  "Low limit of the hysteresis for checking temperature difference"
                  annotation (Dialog(tab="Advanced"));
                parameter Real uHigh=0.1
                  "High limit of the hysteresis for checking temperature difference"
                  annotation (Dialog(tab="Advanced"));

                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput zonOcc[numZon]
                  "True when the zone is set to be occupied due to the override"
                  annotation (Placement(transformation(extent={{-180,280},{-140,320}}),
                    iconTransformation(extent={{-140,170},{-100,210}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uOcc[numZon]
                  "True when the zone is occupied according to the occupancy schedule"
                  annotation (Placement(transformation(extent={{-180,240},{-140,280}}),
                      iconTransformation(extent={{-140,150},{-100,190}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput tNexOcc[numZon](
                  final unit=fill("s", numZon),
                  final quantity=fill("Time", numZon)) "Time to next occupied period"
                  annotation (Placement(transformation(extent={{-180,200},{-140,240}}),
                    iconTransformation(extent={{-140,130},{-100,170}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput uCooTim[numZon](
                  final unit=fill("s", numZon),
                  final quantity=fill("Time", numZon)) "Cool down time"
                  annotation (Placement(transformation(extent={{-180,160},{-140,200}}),
                    iconTransformation(extent={{-140,90},{-100,130}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput uWarTim[numZon](
                  final unit=fill("s", numZon),
                  final quantity=fill("Time", numZon)) "Warm-up time"
                  annotation (Placement(transformation(extent={{-180,120},{-140,160}}),
                    iconTransformation(extent={{-140,70},{-100,110}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uOccHeaHig[numZon]
                  "True when the zone temperature is lower than the occupied heating setpoint"
                  annotation (Placement(transformation(extent={{-180,80},{-140,120}}),
                    iconTransformation(extent={{-140,30},{-100,70}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uHigOccCoo[numZon]
                  "True when the zone temperature is higher than the occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-180,40},{-140,80}}),
                    iconTransformation(extent={{-140,10},{-100,50}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uUnoHeaHig[numZon]
                  "True when the zone temperature is lower than the unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-180,0},{-140,40}}),
                    iconTransformation(extent={{-140,-30},{-100,10}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput THeaSetOff[numZon](
                  final unit=fill("K", numZon),
                  displayUnit=fill("degC", numZon),
                  final quantity=fill("ThermodynamicTemperature", numZon))
                  "Zone unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-180,-40},{-140,0}}),
                    iconTransformation(extent={{-140,-50},{-100,-10}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uEndSetBac[numZon]
                  "True when the zone could end the setback mode"
                  annotation (Placement(transformation(extent={{-180,-80},{-140,-40}}),
                    iconTransformation(extent={{-140,-70},{-100,-30}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uHigUnoCoo[numZon]
                  "True when the zone temperature is higher than its unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-180,-110},{-140,-70}}),
                    iconTransformation(extent={{-140,-110},{-100,-70}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TCooSetOff[numZon](
                  final unit=fill("K", numZon),
                  displayUnit=fill("degC", numZon),
                  final quantity=fill("ThermodynamicTemperature", numZon))
                  "Zone unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-180,-170},{-140,-130}}),
                    iconTransformation(extent={{-140,-130},{-100,-90}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uEndSetUp[numZon]
                  "True when the zone could end the setup mode"
                  annotation (Placement(transformation(extent={{-180,-200},{-140,-160}}),
                    iconTransformation(extent={{-140,-150},{-100,-110}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon[numZon](
                  final unit=fill("K", numZon),
                  displayUnit=fill("degC", numZon),
                  final quantity=fill("ThermodynamicTemperature", numZon)) "Zone temperature"
                  annotation (Placement(transformation(extent={{-180,-240},{-140,-200}}),
                    iconTransformation(extent={{-140,-190},{-100,-150}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWin[numZon]
                  "True when the window is open, false when the window is close or the zone does not have window status sensor"
                  annotation (Placement(transformation(extent={{-180,-320},{-140,-280}}),
                    iconTransformation(extent={{-140,-210},{-100,-170}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput uGroOcc
                  "True when the zone group is in occupied mode"
                  annotation (Placement(transformation(extent={{100,260},{140,300}}),
                    iconTransformation(extent={{100,170},{140,210}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput nexOcc(
                  final quantity="Time",
                  final unit="s") "Time to next occupied period"
                  annotation (Placement(transformation(extent={{100,200},{140,240}}),
                    iconTransformation(extent={{100,150},{140,190}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yCooTim(
                  final unit="s",
                  final quantity="Time") "Cool down time"
                  annotation (Placement(transformation(extent={{100,160},{140,200}}),
                    iconTransformation(extent={{100,110},{140,150}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yWarTim(
                  final unit="s",
                  final quantity="Time") "Warm-up time"
                  annotation (Placement(transformation(extent={{100,120},{140,160}}),
                    iconTransformation(extent={{100,90},{140,130}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yOccHeaHig
                  "True when there is zone with temperature being lower than the occupied heating setpoint"
                  annotation (Placement(transformation(extent={{100,80},{140,120}}),
                    iconTransformation(extent={{100,50},{140,90}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yHigOccCoo
                  "True when there is zone with temperature being higher than the occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{100,40},{140,80}}),
                    iconTransformation(extent={{100,30},{140,70}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yColZon
                  "Total number of cold zones"
                  annotation (Placement(transformation(extent={{100,0},{140,40}}),
                    iconTransformation(extent={{100,0},{140,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySetBac
                  "Run setback mode"
                  annotation (Placement(transformation(extent={{100,-40},{140,0}}),
                    iconTransformation(extent={{100,-20},{140,20}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yEndSetBac
                  "True when the group should end setback mode"
                  annotation (Placement(transformation(extent={{100,-80},{140,-40}}),
                    iconTransformation(extent={{100,-40},{140,0}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yHotZon
                  "Total number of hot zones"
                  annotation (Placement(transformation(extent={{100,-110},{140,-70}}),
                    iconTransformation(extent={{100,-70},{140,-30}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput ySetUp
                  "Run setup mode"
                  annotation (Placement(transformation(extent={{100,-150},{140,-110}}),
                    iconTransformation(extent={{100,-90},{140,-50}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yEndSetUp
                  "True when the group should end setup mode"
                  annotation (Placement(transformation(extent={{100,-200},{140,-160}}),
                    iconTransformation(extent={{100,-110},{140,-70}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TZonMax(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Maximum zone temperature in the zone group"
                  annotation (Placement(transformation(extent={{100,-240},{140,-200}}),
                    iconTransformation(extent={{100,-150},{140,-110}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TZonMin(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Minimum zone temperature in the zone group"
                  annotation (Placement(transformation(extent={{100,-280},{140,-240}}),
                    iconTransformation(extent={{100,-170},{140,-130}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yOpeWin
                  "Total number of open windows"
                  annotation (Placement(transformation(extent={{100,-320},{140,-280}}),
                    iconTransformation(extent={{100,-210},{140,-170}})));

                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hysSetBac(final uLow=uLow,
                    final uHigh=uHigh)
                  "Hysteresis that outputs if the group should run in setback mode"
                  annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hysSetUp(final uLow=uLow,
                    final uHigh=uHigh)
                  "Hysteresis that outputs if the group should run in setup mode"
                  annotation (Placement(transformation(extent={{60,-140},{80,-120}})));

            protected
                  Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter zonOccFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,290},{-100,310}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uOccFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,250},{-100,270}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter tNexOccFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,210},{-100,230}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter uCooTimFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,170},{-100,190}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter uWarTimFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,130},{-100,150}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uOccHeaHigFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,90},{-100,110}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uHigOccCooFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,50},{-100,70}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uUnoHeaHigFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,10},{-100,30}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter THeaSetOffFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-30},{-100,-10}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uEndSetBacFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-70},{-100,-50}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uHigUnoCooFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-100},{-100,-80}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter TCooSetOffFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uEndSetUpFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-190},{-100,-170}})));
                Buildings.Controls.OBC.CDL.Routing.RealVectorFilter TZonFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-230},{-100,-210}})));
                Buildings.Controls.OBC.CDL.Routing.BooleanVectorFilter uWinFil(
                  final nin=numZon,
                  final nout=numZonGro,
                  final msk=zonGroMsk) "Zone group filter"
                  annotation (Placement(transformation(extent={{-120,-310},{-100,-290}})));

                Buildings.Controls.OBC.CDL.Continuous.MultiMax cooDowTim(
                  final nin=numZonGro)
                  "Longest cooldown time"
                  annotation (Placement(transformation(extent={{40,170},{60,190}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiMax warUpTim(
                  final nin=numZonGro)
                  "Longest warm up time"
                  annotation (Placement(transformation(extent={{40,130},{60,150}})));
                Buildings.Controls.OBC.CDL.Logical.MultiOr mulOr(
                  final nin=numZonGro)
                  "Check if there is any zone that the zone temperature is lower than its occupied heating setpoint"
                  annotation (Placement(transformation(extent={{40,90},{60,110}})));
                Buildings.Controls.OBC.CDL.Logical.MultiOr mulOr1(
                  final nin=numZonGro)
                  "Check if there is any zone that the zone temperature is higher than its occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{40,50},{60,70}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiMax maxTem(
                  final nin=numZonGro)
                  "Maximum zone temperature in the zone group"
                  annotation (Placement(transformation(extent={{0,-230},{20,-210}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiMin minTem(
                  final nin=numZonGro)
                  "Minimum zone temperature in the zone group"
                  annotation (Placement(transformation(extent={{0,-270},{20,-250}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger booToInt[numZonGro]
                  "Convert boolean to integer"
                  annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
                Buildings.Controls.OBC.CDL.Integers.MultiSum totColZon(
                  final nin=numZonGro) "Total number of cold zone"
                  annotation (Placement(transformation(extent={{40,10},{60,30}})));
                Buildings.Controls.OBC.CDL.Logical.MultiAnd endSetBac(
                  final nin=numZonGro)
                  "Check if all zones have ended the setback mode"
                  annotation (Placement(transformation(extent={{40,-70},{60,-50}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger booToInt1[numZonGro]
                  "Convert boolean to integer"
                  annotation (Placement(transformation(extent={{-80,-100},{-60,-80}})));
                Buildings.Controls.OBC.CDL.Integers.MultiSum totHotZon(
                  final nin=numZonGro) "Total number of hot zones"
                  annotation (Placement(transformation(extent={{40,-100},{60,-80}})));
                Buildings.Controls.OBC.CDL.Logical.MultiAnd endSetUp(
                  final nin=numZonGro)
                  "Check if all zones have ended the setup mode"
                  annotation (Placement(transformation(extent={{-2,-190},{18,-170}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiSum sumUnoHea(
                  final nin=numZonGro)
                  "Sum of all zones unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
                Buildings.Controls.OBC.CDL.Continuous.Feedback difUnoHea
                  "Difference between unoccupied heating setpoint and zone temperature"
                  annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
                Buildings.Controls.OBC.CDL.Continuous.Division div1 "Average difference"
                  annotation (Placement(transformation(extent={{20,-30},{40,-10}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant totZon(
                  final k=numZonGro) "Total number of zones"
                  annotation (Placement(transformation(extent={{-80,110},{-60,130}})));
                Buildings.Controls.OBC.CDL.Conversions.IntegerToReal intToRea "Convert integer to real"
                  annotation (Placement(transformation(extent={{-40,110},{-20,130}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiSum sumUnoCoo(
                  final nin=numZonGro)
                  "Sum of all zones unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-80,-160},{-60,-140}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiSum sumTem(
                  final nin=numZonGro)
                  "Sum of all zones temperature"
                  annotation (Placement(transformation(extent={{-80,-210},{-60,-190}})));
                Buildings.Controls.OBC.CDL.Continuous.Feedback difUnoCoo
                  "Difference between unoccupied cooling setpoint and zone temperature"
                  annotation (Placement(transformation(extent={{-30,-130},{-10,-110}})));
                Buildings.Controls.OBC.CDL.Continuous.Division div2 "Average difference"
                  annotation (Placement(transformation(extent={{20,-140},{40,-120}})));
                Buildings.Controls.OBC.CDL.Continuous.MultiMin minToNexOcc(
                  final nin=numZonGro)
                  "Minimum time to next occupied period"
                  annotation (Placement(transformation(extent={{-60,210},{-40,230}})));
                Buildings.Controls.OBC.CDL.Logical.MultiOr schOcc(
                  final nin=numZonGro)
                  "Check if the group should be in occupied mode according to the schedule"
                  annotation (Placement(transformation(extent={{-60,250},{-40,270}})));
                Buildings.Controls.OBC.CDL.Logical.MultiOr oveRidOcc(
                  final nin=numZonGro)
                  "Check if the group should be in occupied mode according to the zone override"
                  annotation (Placement(transformation(extent={{-60,290},{-40,310}})));
                Buildings.Controls.OBC.CDL.Logical.Or groOcc
                  "Check if the group should be in occupied mode according to the schedule or the zone override"
                  annotation (Placement(transformation(extent={{40,270},{60,290}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger booToInt2[numZonGro]
                  "Convert boolean to integer"
                  annotation (Placement(transformation(extent={{-60,-310},{-40,-290}})));
                Buildings.Controls.OBC.CDL.Integers.MultiSum totOpeWin(
                  final nin=numZonGro)
                  "Total number of opening windows"
                  annotation (Placement(transformation(extent={{40,-310},{60,-290}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea(
                  final realTrue=0,
                  final realFalse=1)
                  "When any zone becomes occpuied, output zero"
                  annotation (Placement(transformation(extent={{0,230},{20,250}})));
                Buildings.Controls.OBC.CDL.Continuous.Product proOcc
                  "When it is occupied, output zero"
                  annotation (Placement(transformation(extent={{60,210},{80,230}})));

              equation
                connect(maxTem.y, TZonMax)
                  annotation (Line(points={{22,-220},{120,-220}}, color={0,0,127}));
                connect(minTem.y, TZonMin)
                  annotation (Line(points={{22,-260},{120,-260}},color={0,0,127}));
                connect(cooDowTim.y, yCooTim)
                  annotation (Line(points={{62,180},{120,180}}, color={0,0,127}));
                connect(warUpTim.y, yWarTim)
                  annotation (Line(points={{62,140},{120,140}}, color={0,0,127}));
                connect(mulOr.y, yOccHeaHig)
                  annotation (Line(points={{62,100},{120,100}}, color={255,0,255}));
                connect(mulOr1.y, yHigOccCoo)
                  annotation (Line(points={{62,60},{120,60}},   color={255,0,255}));
                connect(totColZon.y, yColZon)
                  annotation (Line(points={{62,20},{120,20}}, color={255,127,0}));
                connect(endSetBac.y, yEndSetBac)
                  annotation (Line(points={{62,-60},{120,-60}}, color={255,0,255}));
                connect(totHotZon.y, yHotZon)
                  annotation (Line(points={{62,-90},{120,-90}},   color={255,127,0}));
                connect(endSetUp.y, yEndSetUp)
                  annotation (Line(points={{20,-180},{120,-180}}, color={255,0,255}));
                connect(booToInt.y, totColZon.u)
                  annotation (Line(points={{-58,20},{38,20}}, color={255,0,255}));
                connect(booToInt1.y, totHotZon.u)
                  annotation (Line(points={{-58,-90},{38,-90}}, color={255,0,255}));
                connect(totZon.y, intToRea.u)
                  annotation (Line(points={{-58,120},{-42,120}}, color={255,127,0}));
                connect(sumTem.y, difUnoHea.u2)
                  annotation (Line(points={{-58,-200},{-40,-200},{-40,-32}}, color={0,0,127}));
                connect(sumTem.y, difUnoCoo.u1) annotation (Line(points={{-58,-200},{-40,-200},
                        {-40,-120},{-32,-120}}, color={0,0,127}));
                connect(sumUnoCoo.y, difUnoCoo.u2) annotation (Line(points={{-58,-150},{-20,-150},
                        {-20,-132}},color={0,0,127}));
                connect(sumUnoHea.y, difUnoHea.u1)
                  annotation (Line(points={{-58,-20},{-52,-20}}, color={0,0,127}));
                connect(intToRea.y, div1.u2) annotation (Line(points={{-18,120},{0,120},{0,-26},
                        {18,-26}},color={0,0,127}));
                connect(intToRea.y, div2.u2) annotation (Line(points={{-18,120},{0,120},{0,-136},
                        {18,-136}},color={0,0,127}));
                connect(difUnoHea.y, div1.u1) annotation (Line(points={{-28,-20},{-10,-20},{-10,
                        -14},{18,-14}}, color={0,0,127}));
                connect(difUnoCoo.y, div2.u1) annotation (Line(points={{-8,-120},{8,-120},{8,-124},
                        {18,-124}},color={0,0,127}));
                connect(div1.y, hysSetBac.u)
                  annotation (Line(points={{42,-20},{58,-20}}, color={0,0,127}));
                connect(hysSetBac.y, ySetBac)
                  annotation (Line(points={{82,-20},{120,-20}}, color={255,0,255}));
                connect(div2.y, hysSetUp.u)
                  annotation (Line(points={{42,-130},{58,-130}}, color={0,0,127}));
                connect(hysSetUp.y, ySetUp)
                  annotation (Line(points={{82,-130},{120,-130}}, color={255,0,255}));
                connect(groOcc.y, uGroOcc) annotation (Line(points={{62,280},{120,280}},
                        color={255,0,255}));
                connect(oveRidOcc.y, groOcc.u1) annotation (Line(points={{-38,300},{-20,300},{
                        -20,280},{38,280}}, color={255,0,255}));
                connect(schOcc.y, groOcc.u2) annotation (Line(points={{-38,260},{-20,260},{-20,
                        272},{38,272}}, color={255,0,255}));
                connect(totOpeWin.y, yOpeWin)
                  annotation (Line(points={{62,-300},{120,-300}}, color={255,127,0}));
                connect(booToInt2.y, totOpeWin.u)
                  annotation (Line(points={{-38,-300},{38,-300}}, color={255,127,0}));
                connect(schOcc.y, booToRea.u) annotation (Line(points={{-38,260},{-20,260},{-20,
                        240},{-2,240}}, color={255,0,255}));
                connect(minToNexOcc.y, proOcc.u2) annotation (Line(points={{-38,220},{-20,220},
                        {-20,214},{58,214}}, color={0,0,127}));
                connect(booToRea.y, proOcc.u1) annotation (Line(points={{22,240},{40,240},{40,
                        226},{58,226}}, color={0,0,127}));
                connect(proOcc.y, nexOcc) annotation (Line(points={{82,220},{94,220},{94,220},
                        {120,220}}, color={0,0,127}));
                connect(zonOcc, zonOccFil.u)
                  annotation (Line(points={{-160,300},{-122,300}}, color={255,0,255}));
                connect(uOcc, uOccFil.u)
                  annotation (Line(points={{-160,260},{-122,260}}, color={255,0,255}));
                connect(zonOccFil.y, oveRidOcc.u)
                  annotation (Line(points={{-98,300},{-62,300}}, color={255,0,255}));
                connect(uOccFil.y, schOcc.u)
                  annotation (Line(points={{-98,260},{-62,260}}, color={255,0,255}));
                connect(tNexOcc, tNexOccFil.u)
                  annotation (Line(points={{-160,220},{-122,220}}, color={0,0,127}));
                connect(tNexOccFil.y, minToNexOcc.u)
                  annotation (Line(points={{-98,220},{-62,220}}, color={0,0,127}));
                connect(uCooTim, uCooTimFil.u)
                  annotation (Line(points={{-160,180},{-122,180}}, color={0,0,127}));
                connect(uCooTimFil.y, cooDowTim.u)
                  annotation (Line(points={{-98,180},{38,180}}, color={0,0,127}));
                connect(uWarTim, uWarTimFil.u)
                  annotation (Line(points={{-160,140},{-122,140}}, color={0,0,127}));
                connect(uWarTimFil.y, warUpTim.u)
                  annotation (Line(points={{-98,140},{38,140}}, color={0,0,127}));
                connect(uOccHeaHig, uOccHeaHigFil.u)
                  annotation (Line(points={{-160,100},{-122,100}}, color={255,0,255}));
                connect(uOccHeaHigFil.y, mulOr.u)
                  annotation (Line(points={{-98,100},{38,100}}, color={255,0,255}));
                connect(uHigOccCoo, uHigOccCooFil.u)
                  annotation (Line(points={{-160,60},{-122,60}}, color={255,0,255}));
                connect(uHigOccCooFil.y, mulOr1.u)
                  annotation (Line(points={{-98,60},{38,60}}, color={255,0,255}));
                connect(uUnoHeaHig, uUnoHeaHigFil.u)
                  annotation (Line(points={{-160,20},{-122,20}}, color={255,0,255}));
                connect(uUnoHeaHigFil.y, booToInt.u)
                  annotation (Line(points={{-98,20},{-82,20}}, color={255,0,255}));
                connect(THeaSetOff, THeaSetOffFil.u)
                  annotation (Line(points={{-160,-20},{-122,-20}}, color={0,0,127}));
                connect(THeaSetOffFil.y, sumUnoHea.u)
                  annotation (Line(points={{-98,-20},{-82,-20}}, color={0,0,127}));
                connect(uEndSetBac, uEndSetBacFil.u)
                  annotation (Line(points={{-160,-60},{-122,-60}}, color={255,0,255}));
                connect(uEndSetBacFil.y, endSetBac.u)
                  annotation (Line(points={{-98,-60},{38,-60}}, color={255,0,255}));
                connect(uHigUnoCoo, uHigUnoCooFil.u)
                  annotation (Line(points={{-160,-90},{-122,-90}}, color={255,0,255}));
                connect(uHigUnoCooFil.y, booToInt1.u)
                  annotation (Line(points={{-98,-90},{-82,-90}}, color={255,0,255}));
                connect(TCooSetOff, TCooSetOffFil.u)
                  annotation (Line(points={{-160,-150},{-122,-150}}, color={0,0,127}));
                connect(TCooSetOffFil.y, sumUnoCoo.u)
                  annotation (Line(points={{-98,-150},{-82,-150}}, color={0,0,127}));
                connect(uEndSetUp, uEndSetUpFil.u)
                  annotation (Line(points={{-160,-180},{-122,-180}}, color={255,0,255}));
                connect(uEndSetUpFil.y, endSetUp.u)
                  annotation (Line(points={{-98,-180},{-4,-180}}, color={255,0,255}));
                connect(TZon, TZonFil.u)
                  annotation (Line(points={{-160,-220},{-122,-220}}, color={0,0,127}));
                connect(TZonFil.y, sumTem.u) annotation (Line(points={{-98,-220},{-90,-220},{-90,
                        -200},{-82,-200}}, color={0,0,127}));
                connect(TZonFil.y, maxTem.u)
                  annotation (Line(points={{-98,-220},{-2,-220}}, color={0,0,127}));
                connect(TZonFil.y, minTem.u) annotation (Line(points={{-98,-220},{-90,-220},{-90,
                        -260},{-2,-260}}, color={0,0,127}));
                connect(uWin, uWinFil.u)
                  annotation (Line(points={{-160,-300},{-122,-300}}, color={255,0,255}));
                connect(uWinFil.y, booToInt2.u)
                  annotation (Line(points={{-98,-300},{-62,-300}}, color={255,0,255}));

              annotation (
                defaultComponentName = "groSta",
                Icon(coordinateSystem(extent={{-100,-200},{100,200}}),
                     graphics={
                      Rectangle(extent={{-100,-200},{100,200}},
                                lineColor={0,0,127},
                                fillColor={255,255,255},
                                fillPattern=FillPattern.Solid),
                      Text(extent={{-120,250},{100,212}},
                           lineColor={0,0,255},
                           textString="%name"),
                      Text(
                        extent={{-98,116},{-56,102}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uCooTim"),
                      Text(
                        extent={{62,28},{98,16}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="yColZon"),
                      Text(
                        extent={{-98,96},{-58,84}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uWarTim"),
                      Text(
                        extent={{-96,58},{-46,42}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uOccHeaHig"),
                      Text(
                        extent={{-96,38},{-46,24}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uHigOccCoo"),
                      Text(
                        extent={{-96,-82},{-44,-98}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uHigUnoCoo"),
                      Text(
                        extent={{-96,-42},{-46,-56}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uEndSetBac"),
                      Text(
                        extent={{-96,-124},{-48,-138}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uEndSetUp"),
                      Text(
                        extent={{-96,-4},{-46,-18}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uUnoHeaHig"),
                      Text(
                        extent={{-96,-164},{-74,-176}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZon"),
                      Text(
                        extent={{64,-142},{98,-156}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonMin"),
                      Text(
                        extent={{62,-122},{98,-136}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonMax"),
                      Text(
                        extent={{54,-82},{98,-98}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yEndSetUp"),
                      Text(
                        extent={{46,-10},{98,-26}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yEndSetBac"),
                      Text(
                        extent={{46,60},{98,44}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yHigOccCoo"),
                      Text(
                        extent={{46,78},{98,64}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yOccHeaHig"),
                      Text(
                        extent={{64,138},{98,126}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="yCooTim"),
                      Text(
                        extent={{62,116},{98,106}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="yWarTim"),
                      Text(
                        extent={{64,-42},{98,-56}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="yHotZon"),
                      Text(
                        extent={{-98,-104},{-48,-120}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TCooSetOff"),
                      Text(
                        extent={{-98,-24},{-50,-38}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="THeaSetOff"),
                      Text(
                        extent={{58,8},{100,-4}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="ySetBac"),
                      Text(
                        extent={{62,-66},{102,-76}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="ySetUp"),
                      Text(
                        extent={{-98,156},{-56,142}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="tNexOcc"),
                      Text(
                        extent={{-98,198},{-62,186}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="ZonOcc"),
                      Text(
                        extent={{-98,178},{-72,164}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uOcc"),
                      Text(
                        extent={{64,178},{98,166}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="nexOcc"),
                      Text(
                        extent={{58,200},{98,186}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uGroOcc"),
                      Text(
                        extent={{-100,-184},{-70,-196}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uWin"),
                      Text(
                        extent={{64,-182},{98,-196}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="yOpeWin")}),
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-320},{100,320}})),
              Documentation(info="<html>
<p>
This sequence sums up the zone level status calculation to find the outputs that are
needed to define the zone group operation mode.
</p>
<p>
It requires following inputs from zone level controller:
</p>
<ul>
<li>
<code>zonOcc</code>: if the zone-level local override switch indicates the zone is
occupied,
</li>
<li>
<code>uOcc</code>: if the zone is occupied according to its occupancy schedule,
</li>
<li>
<code>tNexOcc</code>: time to next occupied period,
</li>
<li>
<code>uCooTim</code>: required cooldown time,
</li>
<li>
<code>uWarTim</code>: required warm-up time,
</li>
<li>
<code>uOccHeaHig</code>: if the zone temperature is lower than the occupied
heating setpoint,
</li>
<li>
<code>uHigOccCoo</code>: if the zone temperature is higher than the occupied
cooling setpoint,
</li>
<li>
<code>uUnoHeaHig</code>: if the zone temperature is lower than the unoccupied
heating setpoint,
</li>
<li>
<code>THeaSetOff</code>: zone unoccupied heating setpoint,
</li>
<li>
<code>uEndSetBac</code>: if the zone could end the setback mode,
</li>
<li>
<code>uHigUnoCoo</code>: if the zone temperature is higher than its unoccupied 
cooling setpoint,
</li>
<li>
<code>TCooSetOff</code>: zone unoccupied cooling setpoint,
</li>
<li>
<code>uEndSetUp</code>: if the zone could end the setup mode,
</li>
<li>
<code>TZon</code>: zone temperature,
</li>
<li>
<code>uWin</code>: True when the window is open, false when the window is close
or the zone does not have window status sensor.
</li>
</ul>
<p>
The sequence gives following outputs for zone group level calculation:
</p>
<ul>
<li>
<code>uGroOcc</code>: the zone group should be in occupied mode when there is any
zone becoming occupied according its schedule or due to the local override,
</li>
<li>
<code>nexOcc</code>: the shortest time to the next occupied period among all the
zones in the group,
</li>
<li>
<code>yCooTim</code>: longest cooldown time,
</li>
<li>
<code>yWarTim</code>: longest warm-up time,
</li>
<li>
<code>yOccHeaHig</code>: if there is zone with temperature being lower than the
occupied heating setpoint, so the group could be in the warm-up mode,
</li>
<li>
<code>yHigOccCoo</code>: if there is zone with temperature being higher than the
occupied cooling setpoint, so the group could be in the cooldown mode,
</li>
<li>
<code>yColZon</code>: total number of zones that the temperature is lower than the
unoccupied heating setpoint,
</li>
<li>
<code>ySetBac</code>: check if the group could be into setback mode due to that
the average zone temperature is lower than the average unoccupied heating setpoint,
</li>
<li>
<code>yEndSetBac</code>: check if the group should end setback mode due to that
all the zone temperature are above their unoccupied heating setpoint by a limited
value,
</li>
<li>
<code>yHotZon</code>: total number of zones that the temperature is higher than the
unoccupied cooling setpoint,
</li>
<li>
<code>ySetUp</code>: check if the group could be into setup mode due to that
the average zone temperature is higher than the average unoccupied cooling setpoint,
</li>
<li>
<code>yEndSetUp</code>: check if the group should end setup mode due to that
all the zone temperature are below their unoccupied cooling setpoint by a limited
value,
</li>
<li>
<code>TZonMax</code>: maximum zone temperature in the zone group,
</li>
<li>
<code>TZonMin</code>: minimum zone temperature in the zone group,
</li>
<li>
<code>yOpeWin</code>: total number of opening windows.
</li>
</ul>
</html>",              revisions="<html>
<ul>
<li>
June 25, 2021, by Baptiste Ravache:<br/>
Add filters to select which zones are used in group.
</li>
<li>
June 15, 2020, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end GroupStatus;

              block OperationMode "Block that outputs the operation mode"

                parameter Integer numZon(min=1) "Number of zones";
                parameter Real preWarCooTim(
                  final unit="s",
                  final quantity="Time") = 10800
                  "Maximum cool-down or warm-up time";
                parameter Real TZonFreProOn(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=277.15
                  "Threshold temperature to activate the freeze protection mode";
                parameter Real TZonFreProOff(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=280.15
                  "Threshold temperature to end the freeze protection mode";

                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uOcc
                  "Zone occupancy status: true=occupied, false=unoccupied"
                  annotation (Placement(transformation(extent={{-400,350},{-360,390}}),
                    iconTransformation(extent={{-140,120},{-100,160}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput tNexOcc(
                  final unit="s",
                  final quantity="Time")
                  "Time to next occupied period"
                  annotation (Placement(transformation(extent={{-400,310},{-360,350}}),
                    iconTransformation(extent={{-140,100},{-100,140}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput maxCooDowTim(
                  final unit="s",
                  final quantity="Time") "Maximum cool-down time among all the zones"
                  annotation (Placement(transformation(extent={{-400,260},{-360,300}}),
                    iconTransformation(extent={{-140,80},{-100,120}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uHigOccCoo
                  "True when there is zone with the temperature being higher than the occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-400,210},{-360,250}}),
                    iconTransformation(extent={{-140,60},{-100,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput maxWarUpTim(
                  final unit="s",
                  final quantity="Time") "Maximum warm-up time among all the zones"
                  annotation (Placement(transformation(extent={{-400,160},{-360,200}}),
                    iconTransformation(extent={{-140,40},{-100,80}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uOccHeaHig
                  "True when there is zone with the temperature being lower than the occupied heating setpoint"
                  annotation (Placement(transformation(extent={{-400,110},{-360,150}}),
                    iconTransformation(extent={{-140,20},{-100,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeWin
                  "Total number of zones with opening window"
                  annotation (Placement(transformation(extent={{-400,70},{-360,110}}),
                    iconTransformation(extent={{-140,0},{-100,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput totColZon
                  "Total number of cold zone"
                  annotation (Placement(transformation(extent={{-400,10},{-360,50}}),
                    iconTransformation(extent={{-140,-20},{-100,20}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSetBac
                  "True when the average zone temperature falls below the average unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-400,-40},{-360,0}}),
                    iconTransformation(extent={{-140,-40},{-100,0}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uEndSetBac
                  "True when the setback mode could end"
                  annotation (Placement(transformation(extent={{-400,-70},{-360,-30}}),
                    iconTransformation(extent={{-140,-60},{-100,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonMax(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Maximum zone temperature"
                  annotation (Placement(transformation(extent={{-400,-100},{-360,-60}}),
                    iconTransformation(extent={{-140,-80},{-100,-40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonMin(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Minimum zone temperature"
                  annotation (Placement(transformation(extent={{-400,-140},{-360,-100}}),
                    iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput totHotZon
                  "Total number of hot zone"
                  annotation (Placement(transformation(extent={{-400,-210},{-360,-170}}),
                    iconTransformation(extent={{-140,-120},{-100,-80}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uSetUp
                  "True when the average zone temperature rises above the average unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-400,-260},{-360,-220}}),
                    iconTransformation(extent={{-140,-140},{-100,-100}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uEndSetUp
                  "True when the setup mode could end"
                  annotation (Placement(transformation(extent={{-400,-290},{-360,-250}}),
                    iconTransformation(extent={{-140,-160},{-100,-120}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yOpeMod
                  "Operation mode"
                  annotation (Placement(transformation(extent={{360,-18},{400,22}}),
                    iconTransformation(extent={{100,-20},{140,20}})));

            protected
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant occModInd(
                  final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                  "Occupied mode "
                  annotation (Placement(transformation(extent={{100,340},{120,360}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant unoPerInd(
                  final k=0)
                  "Index to indicate unoccupied period"
                  annotation (Placement(transformation(extent={{0,340},{20,360}})));
                Buildings.Controls.OBC.CDL.Logical.Switch corCooDowTim "Corrected cool down period"
                  annotation (Placement(transformation(extent={{-220,240},{-200,260}})));
                Buildings.Controls.OBC.CDL.Logical.Switch corWarUpTim "Corrected warm-up period"
                  annotation (Placement(transformation(extent={{-200,140},{-180,160}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr(
                  final t=4) "Check if the number of cold zones is not less than than 5"
                  annotation (Placement(transformation(extent={{-280,20},{-260,40}})));
                Buildings.Controls.OBC.CDL.Logical.Latch lat
                  "If all zone temperature are higher than unoccupied heating setpoint by a given limit, then the setback mode should be off"
                  annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
                Buildings.Controls.OBC.CDL.Logical.Latch lat1
                  "If all zone temperature are higher than threshold temperature of ending freeze protection, then freeze protection setback mode should be off"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
                Buildings.Controls.OBC.CDL.Logical.Latch lat2
                  "If all zone temperature are lower than unoccupied cooling setpoint by a given limit, then the setup mode should be off"
                  annotation (Placement(transformation(extent={{-100,-200},{-80,-180}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys2(
                  final pre_y_start=true,
                  final uHigh=0,
                  final uLow=-60)
                  "Hysteresis that outputs if the maximum cool-down time is more than the allowed cool-down time"
                  annotation (Placement(transformation(extent={{-260,240},{-240,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys3(
                  final pre_y_start=true,
                  final uHigh=0,
                  final uLow=-60)
                  "Hysteresis that outputs if the maximum warm-up time is more than allowed warm-up time"
                  annotation (Placement(transformation(extent={{-260,140},{-240,160}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add5(
                  final k1=-1)
                  "Calculate differential between time-to-next-occupancy and the cool-down time"
                  annotation (Placement(transformation(extent={{-160,240},{-140,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys4(
                  final pre_y_start=false,
                  final uHigh=0,
                  final uLow=-60)
                  "Hysteresis to check if the cooldown mode could be activated"
                  annotation (Placement(transformation(extent={{-120,240},{-100,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys5(
                  final pre_y_start=false,
                  final uHigh=0,
                  final uLow=-60)
                  "Hysteresis to activate the warm-up model"
                  annotation (Placement(transformation(extent={{-120,150},{-100,170}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add6(
                  final k1=-1)
                  "Calculate differential between time-to-next-occupancy and the warm-up time"
                  annotation (Placement(transformation(extent={{-160,150},{-140,170}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys9(
                  final pre_y_start=false,
                  final uLow=-0.1,
                  final uHigh=0.1)
                  "Hysteresis that outputs if any zone temperature is lower than freeze protection threshold temperature"
                  annotation (Placement(transformation(extent={{-180,-100},{-160,-80}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys10(
                  final pre_y_start=false,
                  final uLow=-0.1,
                  final uHigh=0.1)
                  "Hysteresis that outputs if all zone temperature are higher than threshold temperature of ending freeze protection"
                  annotation (Placement(transformation(extent={{-180,-140},{-160,-120}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxWarCooTime(
                  final k=preWarCooTim)
                  "Allowed maximum warm-up or cool-down time"
                  annotation (Placement(transformation(extent={{-340,190},{-320,210}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr2(
                  final t=4) "Check if the number of hot zones is not less than than 5"
                  annotation (Placement(transformation(extent={{-280,-200},{-260,-180}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{240,280},{260,300}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt1 "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{276,304},{296,324}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt2 "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{140,-50},{160,-30}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt3 "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{200,-180},{220,-160}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt4 "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{260,-320},{280,-300}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt5 "Sum of two integer inputs"
                  annotation (Placement(transformation(extent={{320,-8},{340,12}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger occMod
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{200,310},{220,330}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger setBacMod
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{100,20},{120,40}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger freProSetBacMod
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{100,-100},{120,-80}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger setUpMod
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{100,-200},{120,-180}})));
                Buildings.Controls.OBC.CDL.Logical.Edge edg
                  "Get the moment when the warm up time starts "
                  annotation (Placement(transformation(extent={{-50,150},{-30,170}})));
                Buildings.Controls.OBC.CDL.Logical.TrueFalseHold truFalHol(
                  final trueHoldDuration=preWarCooTim)
                  "Hold the start time true signal"
                  annotation (Placement(transformation(extent={{-20,240},{0,260}})));
                Buildings.Controls.OBC.CDL.Logical.Edge edg1
                  "Get the moment when cool down time starts"
                  annotation (Placement(transformation(extent={{-48,240},{-28,260}})));
                Buildings.Controls.OBC.CDL.Logical.TrueFalseHold truFalHol1(
                  final trueHoldDuration=preWarCooTim)
                  "Hold the start time true signal"
                  annotation (Placement(transformation(extent={{-20,150},{0,170}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea1(
                  final realTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                  "Convert Boolean to Integer number"
                  annotation (Placement(transformation(extent={{80,170},{100,190}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea(
                  final realTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                  "Convert Boolean to Integer number"
                  annotation (Placement(transformation(extent={{80,260},{100,280}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger booToInt3(
                  final integerTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                  "Convert Boolean to Integer "
                  annotation (Placement(transformation(extent={{120,-370},{140,-350}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea6(
                  final realTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                  "Convert Boolean to Real "
                  annotation (Placement(transformation(extent={{-20,-200},{0,-180}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea4(
                  final realTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.freezeProtection)
                  "Convert Boolean to Real "
                  annotation (Placement(transformation(extent={{-20,-100},{0,-80}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea3(
                  final realTrue=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                  "Convert Boolean to Real "
                  annotation (Placement(transformation(extent={{-20,20},{0,40}})));
                Buildings.Controls.OBC.CDL.Utilities.Assert assMes(
                  final message="Level 3 alarm: freeze protection setback")
                  "Generate alarm message"
                  annotation (Placement(transformation(extent={{100,-140},{120,-120}})));
                Buildings.Controls.OBC.CDL.Logical.Not not2 "Logical not"
                 annotation (Placement(transformation(extent={{80,-370},{100,-350}})));
                Buildings.Controls.OBC.CDL.Logical.And and1 "Warm-up period"
                  annotation (Placement(transformation(extent={{20,170},{40,190}})));
                Buildings.Controls.OBC.CDL.Logical.And and2
                  "Get the start of the cool-down time"
                  annotation (Placement(transformation(extent={{-80,240},{-60,260}})));
                Buildings.Controls.OBC.CDL.Logical.Or or1
                  "Check if the number of cold zone is more than 5 or all zones are cold"
                  annotation (Placement(transformation(extent={{-220,20},{-200,40}})));
                Buildings.Controls.OBC.CDL.Logical.Or3 or3
                  "Check if it is in occupied, cooldown, or warm-up mode"
                  annotation (Placement(transformation(extent={{-140,60},{-120,80}})));
                Buildings.Controls.OBC.CDL.Logical.Or or4
                  "Check if the number of hot zone is more than 5 or all zones are hot"
                  annotation (Placement(transformation(extent={{-220,-200},{-200,-180}})));
                Buildings.Controls.OBC.CDL.Logical.Or3 or5
                  "Check if it is in Setback, Setback_freezeProtection, or Setup mode"
                  annotation (Placement(transformation(extent={{-20,-350},{0,-330}})));
                Buildings.Controls.OBC.CDL.Logical.Or or6
                  "Check if it is in any of the 6 modes except unoccupied mode"
                  annotation (Placement(transformation(extent={{40,-370},{60,-350}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi
                  "Switch between occupied mode index and unoccupied period index"
                  annotation (Placement(transformation(extent={{160,310},{180,330}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi3
                  "If the Cool-down, warm-up, or Occupied mode is on, then setback mode should not be activated."
                  annotation (Placement(transformation(extent={{60,20},{80,40}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi4
                  "If the Cool-down, warm-up, or Occupied mode is on, then freeze protection setback mode should not be activated."
                  annotation (Placement(transformation(extent={{60,-100},{80,-80}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi5
                  "If the Cool-down, warm-up, or Occupied mode is on, then setup mode should not be activated."
                  annotation (Placement(transformation(extent={{60,-200},{80,-180}})));
                Buildings.Controls.OBC.CDL.Logical.Not not5 "Logical not"
                  annotation (Placement(transformation(extent={{-20,-140},{0,-120}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold notOcc(
                  final t=1)
                  "Check if the operation mode is other than occupied mode"
                  annotation (Placement(transformation(extent={{100,60},{120,80}})));
                Buildings.Controls.OBC.CDL.Logical.And and3
                  "True if window open during modes other than occupied mode"
                  annotation (Placement(transformation(extent={{160,80},{180,100}})));
                Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not"
                  annotation (Placement(transformation(extent={{200,80},{220,100}})));
                Buildings.Controls.OBC.CDL.Utilities.Assert winOpe(
                  final message="Level 4 alarm: window open during modes other than occupied mode")
                  "Generate alarm message when window open during modes other than occupied mode"
                  annotation (Placement(transformation(extent={{240,80},{260,100}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi1
                  "If occupied mode is on, then cool down mode should not be activated"
                  annotation (Placement(transformation(extent={{140,270},{160,290}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger setBacMod1
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{180,270},{200,290}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi2
                  "If occupied mode is on, then warm-up mode should not be activated."
                  annotation (Placement(transformation(extent={{140,180},{160,200}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger setBacMod2
                  "Convert Real number to Integer number"
                  annotation (Placement(transformation(extent={{180,180},{200,200}})));
                Buildings.Controls.OBC.CDL.Logical.And and4 "Cool-down period"
                  annotation (Placement(transformation(extent={{20,260},{40,280}})));
                Buildings.Controls.OBC.CDL.Logical.And and5
                  "Get the start of the warm-up time"
                  annotation (Placement(transformation(extent={{-80,150},{-60,170}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant totZon(
                  final k=numZon) "Total number of zones"
                  annotation (Placement(transformation(extent={{-340,-340},{-320,-320}})));
                Buildings.Controls.OBC.CDL.Integers.Equal allCol
                  "Check if all zones are cold zone"
                  annotation (Placement(transformation(extent={{-280,-10},{-260,10}})));
                Buildings.Controls.OBC.CDL.Integers.Equal allHot
                  "Check if all zones are hot zone"
                  annotation (Placement(transformation(extent={{-280,-230},{-260,-210}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant actFreProTem(
                  final k=TZonFreProOn)
                  "Threshold temperature to activate the freeze protection mode"
                  annotation (Placement(transformation(extent={{-280,-110},{-260,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant endFreProTem(
                  final k=TZonFreProOff)
                  "Threshold temperature to end the freeze protection mode"
                  annotation (Placement(transformation(extent={{-280,-150},{-260,-130}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2(
                  final k1=-1)
                  "Calculate differential between minimum zone temperature and freeze protection threshold temperature"
                  annotation (Placement(transformation(extent={{-220,-100},{-200,-80}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1(
                  final k2=-1)
                  "Calculate differential between maximum zone temperature and threshold temperature of ending freeze protection"
                  annotation (Placement(transformation(extent={{-220,-140},{-200,-120}})));
                Buildings.Controls.OBC.CDL.Logical.Or or2
                  "Enough cold zone or the low average zone temperature"
                  annotation (Placement(transformation(extent={{-160,20},{-140,40}})));
                Buildings.Controls.OBC.CDL.Logical.Or or7
                  "Enough hot zone or the high average zone temperature"
                  annotation (Placement(transformation(extent={{-160,-200},{-140,-180}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add3(
                  final k1=-1)
                  "Calculate the difference between maximum cool down time and the allowed maximum cool down time"
                  annotation (Placement(transformation(extent={{-300,240},{-280,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add4(
                  final k2=-1)
                  "Calculate the differential between maximum warm-up time and the allowed maximum warm-up time"
                  annotation (Placement(transformation(extent={{-300,140},{-280,160}})));
                Buildings.Controls.OBC.CDL.Logical.Edge endSetBac
                  "End setback mode when the input becomes true"
                  annotation (Placement(transformation(extent={{-160,-60},{-140,-40}})));
                Buildings.Controls.OBC.CDL.Logical.Edge endSetUp
                  "End setup mode when the input becomes true"
                  annotation (Placement(transformation(extent={{-160,-280},{-140,-260}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr1(
                  final  t=1) "Check if there is any zone with opening window"
                  annotation (Placement(transformation(extent={{-260,80},{-240,100}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt6
                  "Total cold zone and zones with opening window"
                  annotation (Placement(transformation(extent={{-330,-10},{-310,10}})));
                Buildings.Controls.OBC.CDL.Integers.Add addInt7
                  "Total hot zone and zones with opening window"
                  annotation (Placement(transformation(extent={{-330,-230},{-310,-210}})));

              equation
                connect(swi.y, occMod.u)
                  annotation (Line(points={{182,320},{198,320}},
                    color={0,0,127}));
                connect(occModInd.y, swi.u1)
                  annotation (Line(points={{122,350},{140,350},{140,328},{158,328}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(unoPerInd.y, swi.u3)
                  annotation (Line(points={{22,350},{50,350},{50,312},{158,312}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(intGreThr.y, or1.u1)
                  annotation (Line(points={{-258,30},{-222,30}},
                    color={255,0,255}));
                connect(lat.y, booToRea3.u)
                  annotation (Line(points={{-78,30},{-22,30}},
                    color={255,0,255}));
                connect(unoPerInd.y, swi3.u1)
                  annotation (Line(points={{22,350},{50,350},{50,38},{58,38}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(or3.y, swi3.u2)
                  annotation (Line(points={{-118,70},{40,70},{40,30},{58,30}},
                    color={255,0,255}));
                connect(lat1.y, booToRea4.u)
                  annotation (Line(points={{-78,-90},{-22,-90}},   color={255,0,255}));
                connect(or3.y, swi4.u2)
                  annotation (Line(points={{-118,70},{40,70},{40,-90},{58,-90}},
                    color={255,0,255}));
                connect(unoPerInd.y, swi4.u1)
                  annotation (Line(points={{22,350},{50,350},{50,-82},{58,-82}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(lat2.y, booToRea6.u)
                  annotation (Line(points={{-78,-190},{-22,-190}},
                    color={255,0,255}));
                connect(or3.y, swi5.u2)
                  annotation (Line(points={{-118,70},{40,70},{40,-190},{58,-190}},
                    color={255,0,255}));
                connect(unoPerInd.y, swi5.u1)
                  annotation (Line(points={{22,350},{50,350},{50,-182},{58,-182}},
                    color={0,0,127},  pattern=LinePattern.Dash));
                connect(swi3.y, setBacMod.u)
                  annotation (Line(points={{82,30},{98,30}},
                    color={0,0,127}));
                connect(swi4.y, freProSetBacMod.u)
                  annotation (Line(points={{82,-90},{98,-90}}, color={0,0,127}));
                connect(swi5.y, setUpMod.u)
                  annotation (Line(points={{82,-190},{98,-190}},
                    color={0,0,127}));
                connect(or5.y, or6.u1)
                  annotation (Line(points={{2,-340},{20,-340},{20,-360},{38,-360}},
                    color={255,0,255}));
                connect(or6.y, not2.u)
                  annotation (Line(points={{62,-360},{78,-360}},
                    color={255,0,255}));
                connect(not2.y,booToInt3. u)
                  annotation (Line(points={{102,-360},{118,-360}},
                    color={255,0,255}));
                connect(and1.y,booToRea1. u)
                  annotation (Line(points={{42,180},{78,180}}, color={255,0,255}));
                connect(and1.y, or3.u1)
                  annotation (Line(points={{42,180},{68,180},{68,112},{-190,112},{-190,78},
                    {-142,78}}, color={255,0,255}));
                connect(uOcc, swi.u2)
                  annotation (Line(points={{-380,370},{-350,370},{-350,320},{158,320}},
                    color={255,0,255}));
                connect(uOcc, or3.u3)
                  annotation (Line(points={{-380,370},{-350,370},{-350,62},{-142,62}},
                    color={255,0,255}));
                connect(hys2.y, corCooDowTim.u2)
                  annotation (Line(points={{-238,250},{-222,250}}, color={255,0,255}));
                connect(hys3.y, corWarUpTim.u2)
                  annotation (Line(points={{-238,150},{-202,150}}, color={255,0,255}));
                connect(add5.y, hys4.u)
                  annotation (Line(points={{-138,250},{-122,250}}, color={0,0,127}));
                connect(tNexOcc, add5.u1)
                  annotation (Line(points={{-380,330},{-170,330},{-170,256},{-162,256}},
                    color={0,0,127}));
                connect(corCooDowTim.y, add5.u2)
                  annotation (Line(points={{-198,250},{-180,250},{-180,244},{-162,244}},
                    color={0,0,127}));
                connect(tNexOcc, add6.u1)
                  annotation (Line(points={{-380,330},{-170,330},{-170,166},{-162,166}},
                    color={0,0,127}));
                connect(corWarUpTim.y, add6.u2)
                  annotation (Line(points={{-178,150},{-170,150},{-170,154},{-162,154}},
                    color={0,0,127}));
                connect(add6.y, hys5.u)
                  annotation (Line(points={{-138,160},{-122,160}}, color={0,0,127}));
                connect(hys9.y, lat1.u)
                  annotation (Line(points={{-158,-90},{-102,-90}},  color={255,0,255}));
                connect(hys10.y, lat1.clr)
                  annotation (Line(points={{-158,-130},{-120,-130},{-120,-96},{-102,-96}},
                    color={255,0,255}));
                connect(maxWarCooTime.y, corCooDowTim.u3)
                  annotation (Line(points={{-318,200},{-230,200},{-230,242},{-222,242}},
                    color={0,0,127}));
                connect(maxWarCooTime.y, corWarUpTim.u3)
                  annotation (Line(points={{-318,200},{-230,200},{-230,142},{-202,142}},
                    color={0,0,127}));
                connect(booToRea3.y, swi3.u3)
                  annotation (Line(points={{2,30},{30,30},{30,22},{58,22}},
                    color={0,0,127}));
                connect(booToRea4.y, swi4.u3)
                  annotation (Line(points={{2,-90},{20,-90},{20,-98},{58,-98}},
                    color={0,0,127}));
                connect(booToRea6.y, swi5.u3)
                  annotation (Line(points={{2,-190},{20,-190},{20,-198},{58,-198}},
                    color={0,0,127}));
                connect(lat1.y, not5.u)
                  annotation (Line(points={{-78,-90},{-50,-90},{-50,-130},{-22,-130}},
                    color={255,0,255}));
                connect(not5.y, assMes.u)
                  annotation (Line(points={{2,-130},{98,-130}},  color={255,0,255}));
                connect(maxCooDowTim, corCooDowTim.u1) annotation (Line(points={{-380,280},{
                        -230,280},{-230,258},{-222,258}}, color={0,0,127}));
                connect(maxWarUpTim, corWarUpTim.u1) annotation (Line(points={{-380,180},{
                        -220,180},{-220,158},{-202,158}}, color={0,0,127}));
                connect(totColZon, intGreThr.u)
                  annotation (Line(points={{-380,30},{-282,30}},   color={255,127,0}));
                connect(totHotZon, intGreThr2.u)
                  annotation (Line(points={{-380,-190},{-282,-190}}, color={255,127,0}));
                connect(intGreThr2.y, or4.u1)
                  annotation (Line(points={{-258,-190},{-222,-190}}, color={255,0,255}));
                connect(setBacMod.y, addInt2.u1) annotation (Line(points={{122,30},{130,30},{
                        130,-34},{138,-34}},  color={255,127,0}));
                connect(freProSetBacMod.y, addInt2.u2) annotation (Line(points={{122,-90},{
                        130,-90},{130,-46},{138,-46}}, color={255,127,0}));
                connect(setUpMod.y, addInt3.u2) annotation (Line(points={{122,-190},{180,-190},
                        {180,-176},{198,-176}}, color={255,127,0}));
                connect(addInt2.y, addInt3.u1) annotation (Line(points={{162,-40},{180,-40},{
                        180,-164},{198,-164}}, color={255,127,0}));
                connect(addInt3.y, addInt4.u1) annotation (Line(points={{222,-170},{240,-170},
                        {240,-304},{258,-304}}, color={255,127,0}));
                connect(booToInt3.y, addInt4.u2) annotation (Line(points={{142,-360},{200,
                        -360},{200,-316},{258,-316}}, color={255,127,0}));
                connect(addInt5.y, yOpeMod)
                  annotation (Line(points={{342,2},{380,2}}, color={255,127,0}));
                connect(notOcc.y, and3.u2) annotation (Line(points={{122,70},{140,70},{140,82},
                        {158,82}}, color={255,0,255}));
                connect(and3.y, not1.u)
                  annotation (Line(points={{182,90},{198,90}}, color={255,0,255}));
                connect(addInt5.y, notOcc.u) annotation (Line(points={{342,2},{350,2},{350,50},
                        {80,50},{80,70},{98,70}},        color={255,127,0}));
                connect(not1.y, winOpe.u)
                  annotation (Line(points={{222,90},{238,90}}, color={255,0,255}));
                connect(booToRea.y, swi1.u3) annotation (Line(points={{102,270},{110,270},{
                        110,272},{138,272}}, color={0,0,127}));
                connect(uOcc, swi1.u2) annotation (Line(points={{-380,370},{-350,370},{-350,
                        320},{120,320},{120,280},{138,280}}, color={255,0,255}));
                connect(swi1.y, setBacMod1.u)
                  annotation (Line(points={{162,280},{178,280}}, color={0,0,127}));
                connect(setBacMod1.y, addInt.u1) annotation (Line(points={{202,280},{220,280},
                        {220,296},{238,296}}, color={255,127,0}));
                connect(addInt.y, addInt1.u2) annotation (Line(points={{262,290},{268,290},{
                        268,308},{274,308}}, color={255,127,0}));
                connect(occMod.y, addInt1.u1)
                  annotation (Line(points={{222,320},{274,320}}, color={255,127,0}));
                connect(addInt1.y, addInt5.u1) annotation (Line(points={{298,314},{306,314},{
                        306,8},{318,8}}, color={255,127,0}));
                connect(addInt4.y, addInt5.u2) annotation (Line(points={{282,-310},{306,-310},
                        {306,-4},{318,-4}}, color={255,127,0}));
                connect(booToRea1.y, swi2.u3) annotation (Line(points={{102,180},{110,180},{
                        110,182},{138,182}}, color={0,0,127}));
                connect(unoPerInd.y, swi1.u1)
                  annotation (Line( points={{22,350},{50,350},{50,288},{138,288}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(unoPerInd.y, swi2.u1)
                  annotation (Line(points={{22,350},{50,350},{50,198},{138,198}},
                    color={0,0,127}, pattern=LinePattern.Dash));
                connect(swi2.y, setBacMod2.u)
                  annotation (Line(points={{162,190},{178,190}}, color={0,0,127}));
                connect(setBacMod2.y, addInt.u2) annotation (Line(points={{202,190},{230,190},
                        {230,284},{238,284}}, color={255,127,0}));
                connect(and4.y, booToRea.u)
                  annotation (Line(points={{42,270},{78,270}},   color={255,0,255}));
                connect(and4.y, or3.u2) annotation (Line(points={{42,270},{60,270},{60,120},{
                        -200,120},{-200,70},{-142,70}},color={255,0,255}));
                connect(hys4.y, and2.u1)
                  annotation (Line(points={{-98,250},{-82,250}}, color={255,0,255}));
                connect(uOccHeaHig, and5.u2) annotation (Line(points={{-380,130},{-90,130},{
                        -90,152},{-82,152}}, color={255,0,255}));
                connect(hys5.y, and5.u1)
                  annotation (Line(points={{-98,160},{-82,160}}, color={255,0,255}));
                connect(truFalHol1.u, edg.y)
                  annotation (Line(points={{-22,160},{-28,160}}, color={255,0,255}));
                connect(and5.y, edg.u)
                  annotation (Line(points={{-58,160},{-52,160}}, color={255,0,255}));
                connect(and2.y, edg1.u)
                  annotation (Line(points={{-58,250},{-50,250}}, color={255,0,255}));
                connect(edg1.y, truFalHol.u)
                  annotation (Line(points={{-26,250},{-22,250}},color={255,0,255}));
                connect(lat2.y, or5.u1) annotation (Line(points={{-78,-190},{-40,-190},{-40,
                        -332},{-22,-332}}, color={255,0,255}));
                connect(lat1.y, or5.u2) annotation (Line(points={{-78,-90},{-50,-90},{-50,
                        -340},{-22,-340}}, color={255,0,255}));
                connect(lat.y, or5.u3) annotation (Line(points={{-78,30},{-60,30},{-60,-348},
                        {-22,-348}}, color={255,0,255}));
                connect(or3.y, or6.u2) annotation (Line(points={{-118,70},{-70,70},{-70,-368},
                        {38,-368}}, color={255,0,255}));
                connect(allCol.y, or1.u2) annotation (Line(points={{-258,0},{-240,0},{-240,22},
                        {-222,22}}, color={255,0,255}));
                connect(allHot.y, or4.u2) annotation (Line(points={{-258,-220},{-240,-220},{
                        -240,-198},{-222,-198}}, color={255,0,255}));
                connect(totZon.y, allCol.u2) annotation (Line(points={{-318,-330},{-300,-330},
                        {-300,-8},{-282,-8}},   color={255,127,0}));
                connect(totZon.y, allHot.u2) annotation (Line(points={{-318,-330},{-300,-330},
                        {-300,-228},{-282,-228}}, color={255,127,0}));
                connect(add2.y, hys9.u)
                  annotation (Line(points={{-198,-90},{-182,-90}},   color={0,0,127}));
                connect(add1.y, hys10.u)
                  annotation (Line(points={{-198,-130},{-182,-130}}, color={0,0,127}));
                connect(actFreProTem.y, add2.u2) annotation (Line(points={{-258,-100},{-240,-100},
                        {-240,-96},{-222,-96}},       color={0,0,127}));
                connect(TZonMax, add2.u1) annotation (Line(points={{-380,-80},{-240,-80},{
                        -240,-84},{-222,-84}}, color={0,0,127}));
                connect(TZonMin, add1.u1) annotation (Line(points={{-380,-120},{-240,-120},{
                        -240,-124},{-222,-124}}, color={0,0,127}));
                connect(endFreProTem.y, add1.u2) annotation (Line(points={{-258,-140},{-240,-140},
                        {-240,-136},{-222,-136}},       color={0,0,127}));
                connect(or1.y, or2.u1)
                  annotation (Line(points={{-198,30},{-162,30}}, color={255,0,255}));
                connect(or2.y, lat.u)
                  annotation (Line(points={{-138,30},{-102,30}}, color={255,0,255}));
                connect(uSetBac, or2.u2)
                  annotation (Line(points={{-380,-20},{-180,-20},{-180,22},{-162,22}},
                    color={255,0,255}));
                connect(or4.y, or7.u1)
                  annotation (Line(points={{-198,-190},{-162,-190}}, color={255,0,255}));
                connect(or7.y, lat2.u)
                  annotation (Line(points={{-138,-190},{-102,-190}}, color={255,0,255}));
                connect(uSetUp, or7.u2)
                  annotation (Line(points={{-380,-240},{-180,-240},{-180,-198},{-162,-198}},
                    color={255,0,255}));
                connect(uOcc, swi2.u2)
                  annotation (Line(points={{-380,370},{-350,370},{-350,320},{120,320},{120,190},
                    {138,190}}, color={255,0,255}));
                connect(truFalHol.y, and4.u2)
                  annotation (Line(points={{2,250},{10,250},{10,262},{18,262}}, color={255,0,255}));
                connect(hys4.y, and4.u1)
                  annotation (Line(points={{-98,250},{-90,250},{-90,270},{18,270}},
                    color={255,0,255}));
                connect(truFalHol1.y, and1.u2)
                  annotation (Line(points={{2,160},{10,160},{10,172},{18,172}}, color={255,0,255}));
                connect(hys5.y, and1.u1)
                  annotation (Line(points={{-98,160},{-90,160},{-90,180},{18,180}},
                    color={255,0,255}));
                connect(uHigOccCoo, and2.u2)
                  annotation (Line(points={{-380,230},{-90,230},{-90,242},{-82,242}},
                    color={255,0,255}));
                connect(maxWarCooTime.y, add3.u2)
                  annotation (Line(points={{-318,200},{-310,200},{-310,244},{-302,244}},
                    color={0,0,127}));
                connect(maxWarCooTime.y, add4.u1)
                  annotation (Line(points={{-318,200},{-310,200},{-310,156},{-302,156}},
                    color={0,0,127}));
                connect(maxWarUpTim, add4.u2)
                  annotation (Line(points={{-380,180},{-340,180},{-340,144},{-302,144}},
                    color={0,0,127}));
                connect(maxCooDowTim, add3.u1)
                  annotation (Line(points={{-380,280},{-340,280},{-340,256},{-302,256}},
                    color={0,0,127}));
                connect(add3.y, hys2.u)
                  annotation (Line(points={{-278,250},{-262,250}}, color={0,0,127}));
                connect(add4.y, hys3.u)
                  annotation (Line(points={{-278,150},{-262,150}}, color={0,0,127}));
                connect(uEndSetBac, endSetBac.u)
                  annotation (Line(points={{-380,-50},{-162,-50}}, color={255,0,255}));
                connect(endSetBac.y, lat.clr)
                  annotation (Line(points={{-138,-50},{-120,-50},{-120,24},{-102,24}},
                    color={255,0,255}));
                connect(uEndSetUp, endSetUp.u)
                  annotation (Line(points={{-380,-270},{-162,-270}}, color={255,0,255}));
                connect(endSetUp.y, lat2.clr)
                  annotation (Line(points={{-138,-270},{-120,-270},{-120,-196},{-102,-196}},
                    color={255,0,255}));
                connect(uOpeWin, intGreThr1.u)
                  annotation (Line(points={{-380,90},{-262,90}}, color={255,127,0}));
                connect(intGreThr1.y, and3.u1)
                  annotation (Line(points={{-238,90},{158,90}}, color={255,0,255}));
                connect(totColZon, addInt6.u2)
                  annotation (Line(points={{-380,30},{-350,30},{-350,-6},{-332,-6}}, color={255,127,0}));
                connect(uOpeWin, addInt6.u1)
                  annotation (Line(points={{-380,90},{-340,90},{-340,6},{-332,6}}, color={255,127,0}));
                connect(addInt6.y, allCol.u1)
                  annotation (Line(points={{-308,0},{-282,0}}, color={255,127,0}));
                connect(totHotZon, addInt7.u2)
                  annotation (Line(points={{-380,-190},{-350,-190},{-350,-226},{-332,-226}}, color={255,127,0}));
                connect(uOpeWin, addInt7.u1)
                  annotation (Line(points={{-380,90},{-340,90},{-340,-214},{-332,-214}}, color={255,127,0}));
                connect(addInt7.y, allHot.u1)
                  annotation (Line(points={{-308,-220},{-282,-220}}, color={255,127,0}));

              annotation (
                defaultComponentName = "opeModSel",
                Diagram(
                      coordinateSystem(preserveAspectRatio=false, extent={{-360,-380},{360,380}}),
                      graphics={
                      Rectangle(
                        extent={{-358,-282},{358,-378}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,-182},{358,-278}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,-82},{358,-158}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,38},{358,-58}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,198},{358,122}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,298},{358,222}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-358,378},{358,312}},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{236,372},{326,354}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Occupied mode"),
                      Text(
                        extent={{158,10},{242,-12}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Setback mode"),
                      Text(
                        extent={{150,-226},{222,-248}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Setup mode"),
                      Text(
                        extent={{214,-338},{318,-368}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Unoccupied mode"),
                      Text(
                        extent={{180,-94},{352,-122}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Freeze protection setback mode"),
                      Text(
                        extent={{164,174},{252,150}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Warm-up mode"),
                      Text(
                        extent={{248,258},{336,230}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Cool-down mode")}),
                 Icon(coordinateSystem(extent={{-100,-160},{100,160}}),
                      graphics={
                      Rectangle(
                      extent={{-100,-160},{100,160}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-98,108},{-44,96}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="maxCooDowTim"),
                      Text(
                        extent={{-98,66},{-50,56}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="maxWarUpTim"),
                      Text(
                        extent={{58,12},{96,-10}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="yOpeMod"),
                      Text(
                        extent={{-120,200},{100,160}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Text(
                        extent={{-100,128},{-68,112}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="tNexOcc"),
                      Text(
                        extent={{-100,144},{-82,136}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uOcc"),
                      Text(
                        extent={{-98,88},{-50,76}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uHigOccCoo"),
                      Text(
                        extent={{-98,46},{-48,34}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uOccHeaHig"),
                      Text(
                        extent={{-98,6},{-60,-4}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="totColZon"),
                      Text(
                        extent={{-98,-34},{-52,-46}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uEndSetBac"),
                      Text(
                        extent={{-98,-54},{-64,-64}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonMax"),
                      Text(
                        extent={{-98,-74},{-64,-84}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonMin"),
                      Text(
                        extent={{-98,-94},{-62,-104}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="totHotZon"),
                      Text(
                        extent={{-98,-134},{-52,-146}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uEndSetUp"),
                      Text(
                        extent={{-98,-14},{-66,-26}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uSetBac"),
                      Text(
                        extent={{-98,-114},{-66,-126}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uSetUp"),
                      Text(
                        extent={{-100,26},{-62,16}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="uOpeWin")}),
                 Documentation(info="<html>
<p>
This block outputs VAV system operating mode. It is implemented according to
ASHRAE guideline G36, section 5.4.3, section 5.4.4, section 5.4.5 and section 5.4.6.
</p>
<p>
Note that, from the user's point of view, schedules can be a set for individual zones,
or they can be set for an entire zone group, depending on how the user interface is
implemented. From the point of view of the BAS, individual zone schedules are
superimposed to create a zone-group schedule, which then drives system behavior.
</p>
<ol>
<li>
All zones in each zone group shall be in the same zone-group operating mode. If one
zone in a zone group is placed in any zone-group operating mode other than unoccupied
mode (due to override, sequence logic, or scheduled occupancy), all zones in that
group shall enter that mode.
</li>
<li>
A zone group may be in only one mode at a given time.
</li>
</ol>
<p>
Each zone group shall have the operating modes shown below.
</p>
<h5>Occupied Mode</h5>
<p>
A zone group is in the <i>occupied mode</i> when
occupancy input <code>uOcc</code> is true. This input shall be retrieved from
other sequences that specifies occupancy variation and time remaining to the
next occupied period <code>tNexOcc</code>. A zone group could be in the occupied
mode when any of the following is true:
</p>
<ul>
<li>
The time of day is between the zone group's scheduled occupied start and stop times.
</li>
<li>
The schedules have been overriden by the occupant override system.
</li>
<li>
Any zone local override timer is nonzero.
</li>
</ul>
<h5>Warm-up Mode</h5>
<p>
Warm-up mode shall start based on the zone with the longest calculated warm-up
time <code>maxWarUpTim</code> requirement, but no earlier than 3 hours
(<code>preWarCooTim</code>) before the start of the scheduled occupied period,
and shall end at the scheduled occupied start time. Zones where the window switch
indicates that a window is open shall be ignored. Note that for each zone, 
the optimal warm-up time shall be obtained from an <i>Optimal Start</i> sequences,
computed in a separate block. The figure below shows the sequence.
</p>
<p align=\"center\">
<img alt=\"Image of warm-up mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/Warm-upModeDefinition.png\"/>
</p>
<h5>Cooldown Mode</h5>
<p>
Cooldown mode shall start based on the zone with the longest calculated
cooldown time <code>maxCooDowTim</code> requirement, but no earlier than 3 hours
(<code>preWarCooTim</code>) before the start of the scheduled occupied period,
and shall end at the scheduled occupied start time. Zones where the window switch
indicates that a window is open shall be ignored. Note that for each zone,
the optimal cooldown time shall be obtained from an <i>Optimal Start</i> sequences,
computed in a separate block.
</p>
<p align=\"center\">
<img alt=\"Image of cool-down mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/Cool-downModeDefinition.png\"/>
</p>
<h5>Setback Mode</h5>
<p>
During <i>unoccupied mode</i>, if any 5 zones (or all zones, if fewer than 5)
in the zone group fall below their unoccupied heating setpoints, or if the average
zone temperature of the zone group falls below the average unoccupied heating setpoint
(<code>uSetBac</code> becomes true), the zone group shall enter <i>setback mode</i> until
all spaces in the zone group are <i>1</i> &deg;C (<i>2</i> &deg;F) above their
unoccupied setpoints (<code>uEndSetBac</code> becomes true).
</p>
<p align=\"center\">
<img alt=\"Image of setback mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/SetbackModeDefinition.png\"/>
</p>
<h5>Freeze Protection Setback Mode</h5>
<p>
During <i>unoccupied Mode</i>, if any single zone falls below <i>4</i> &deg;C
(<i>40</i> &deg;F), the zone group shall enter <i>setback mode</i> until all zones
are above <i>7</i> &deg;C (<i>45</i> &deg;F), and a Level 3 alarm shall be set.
</p>
<h5>Setup Mode</h5>
<p>
During <i>unoccupied mode</i>, if any 5 zones (or all zones, if fewer than 5)
in the zone group rise above their unoccupied cooling setpoints, or if the average
zone temperature of the zone group rises above the average unoccupied cooling setpoint
(<code>uSetUp</code> becomes true), the zone group shall enter <i>setup mode</i> until
all spaces in the zone group are <i>1</i> &deg;C (<i>2</i> &deg;F) below their
unoccupied setpoints. Zones where the window switch indicates that a window is
open shall be ignored.
</p>
<p align=\"center\">
<img alt=\"Image of setup mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/SetupModeDefinition.png\"/>
</p>
<h5>Unoccupied Mode</h5>
<p>
<i>Unoccupied mode</i> shall be active if the zone group is not in any other mode.
</p>
</html>",              revisions="<html>
<ul>
<li>
June 15, 2020, by Jianjun Hu:<br/>
Upgraded the sequence according to ASHRAE Guideline 36, May 2020 version.
</li>
<li>
April 29, 2020, by Kun Zhang:<br/>
Fixed bug related to activation of warm-up and cool down mode.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1893\">#1893</a>.
</li>
<li>
March 09, 2020, by Jianjun Hu:<br/>
Reimplemented to remove the vector-valued calculations.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">#1709</a>.
</li>
<li>
April 13, 2019, by Michael Wetter:<br/>
Corrected wrong time in the documentation of the parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1409\">#1409</a>.
</li>
<li>
June 19, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end OperationMode;

              block TrimAndRespond "Block to inplement trim and respond logic"
                parameter Real iniSet  "Initial setpoint";
                parameter Real minSet  "Minimum setpoint";
                parameter Real maxSet  "Maximum setpoint";
                parameter Real delTim(
                  final unit="s",
                  final quantity="Time",
                  final min=100*1E-15)  "Delay time";
                parameter Real samplePeriod(
                  final unit="s",
                  final quantity="Time",
                  final min=1E-3)
                  "Sample period of component";
                parameter Integer numIgnReq  "Number of ignored requests";
                parameter Real triAmo  "Trim amount";
                parameter Real resAmo  "Respond amount (must have opposite sign of triAmo)";
                parameter Real maxRes  "Maximum response per time interval (must have same sign as resAmo)";

                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput numOfReq
                  "Number of requests from zones/systems"
                  annotation (Placement(transformation(extent={{-260,-70},{-220,-30}}),
                      iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uDevSta
                  "On/Off status of the associated device"
                  annotation (Placement(transformation(extent={{-260,150},{-220,190}}),
                      iconTransformation(extent={{-140,60},{-100,100}})));

                Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
                  "Setpoint that have been reset"
                  annotation (Placement(transformation(extent={{220,150},{260,190}}),
                      iconTransformation(extent={{100,-20},{140,20}})));

                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim(
                  final delayTime=delTim + samplePeriod,
                  final delayOnInit=true)
                  "Send an on signal after some delay time"
                  annotation (Placement(transformation(extent={{-200,160},{-180,180}})));
                Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr
                  "Check if the real requests is more than ignored requests setting"
                  annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
                Buildings.Controls.OBC.CDL.Logical.Switch netRes "Net setpoint reset value"
                  annotation (Placement(transformation(extent={{160,-20},{180,-40}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant resAmoCon(
                  final k=resAmo)
                  "Respond amount constant"
                  annotation (Placement(transformation(extent={{-200,-140},{-180,-120}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro
                  "Products of net requests and respond amount value"
                  annotation (Placement(transformation(extent={{-20,-110},{0,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro1 "Product of trim and respond amount"
                  annotation (Placement(transformation(extent={{-160,-110},{-140,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro2 "Product of respond and maximum amount"
                  annotation (Placement(transformation(extent={{-160,-180},{-140,-160}})));
                Buildings.Controls.OBC.CDL.Discrete.UnitDelay uniDel(
                  final samplePeriod=samplePeriod,
                  final y_start=iniSet)
                  "Output the input signal with a unit delay"
                  annotation (Placement(transformation(extent={{-100,96},{-80,116}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi
                  "Switch between initial setpoint and reseted setpoint"
                  annotation (Placement(transformation(extent={{160,180},{180,160}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi1
                  "Before instant (device ON + delTim + samplePeriod), the setpoint should not be trimmed"
                  annotation (Placement(transformation(extent={{120,0},{140,20}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi2
                  "Reinitialize setpoint to initial setting when device become OFF"
                  annotation (Placement(transformation(extent={{100,130},{120,150}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi3 "Logical switch"
                  annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
                Buildings.Controls.OBC.CDL.Discrete.Sampler sampler(
                  final samplePeriod=samplePeriod)
                  "Sample number of requests"
                  annotation (Placement(transformation(extent={{-160,-60},{-140,-40}})));
                Buildings.Controls.OBC.CDL.Continuous.LessThreshold lesThr1
                  "Check if trim and response amount have same sign"
                  annotation (Placement(transformation(extent={{-120,-110},{-100,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr2
                  "Check if trim and response amount have opposite sign"
                  annotation (Placement(transformation(extent={{-120,-180},{-100,-160}})));
                Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr1
                  "Check if response amount have positive sign"
                  annotation (Placement(transformation(extent={{20,-160},{40,-140}})));
                Buildings.Controls.OBC.CDL.Continuous.Gain gai(
                  final k=-1) "Convert results back to negative"
                  annotation (Placement(transformation(extent={{80,-190},{100,-170}})));

            protected
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant iniSetCon(k=iniSet)
                  "Initial setpoint"
                  annotation (Placement(transformation(extent={{-100,180},{-80,200}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant numIgnReqCon(k=numIgnReq)
                  "Number of ignored requests"
                  annotation (Placement(transformation(extent={{-160,-20},{-140,0}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant triAmoCon(k=triAmo)
                  "Trim amount constant"
                  annotation (Placement(transformation(extent={{-200,-90},{-180,-70}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxResCon(k=maxRes)
                  "Maximum response per time interval"
                  annotation (Placement(transformation(extent={{-200,-210},{-180,-190}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxSetCon(k=maxSet)
                  "Maximum setpoint constant"
                  annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerTri(k=0)
                  "Zero reset amount during time range from (device ON) to (device ON + delTim + timSet)"
                  annotation (Placement(transformation(extent={{60,-20},{80,0}})));
                Buildings.Controls.OBC.CDL.Conversions.IntegerToReal intToRea
                  "Convert integer input to real output"
                  annotation (Placement(transformation(extent={{-200,-60},{-180,-40}})));
                Buildings.Controls.OBC.CDL.Continuous.Add difReqIgnReq(k1=-1)
                  "Difference between ignored request number and the real request number"
                  annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1
                  "Increase setpoint by amount of value defined from reset logic"
                  annotation (Placement(transformation(extent={{-40,90},{-20,110}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2 "Net reset value"
                  annotation (Placement(transformation(extent={{120,-96},{140,-76}})));
                Buildings.Controls.OBC.CDL.Continuous.Min minInp
                  "Total response should not be more than maximum response"
                  annotation (Placement(transformation(extent={{20,-130},{40,-110}})));
                Buildings.Controls.OBC.CDL.Continuous.Min min1
                  "Reset setpoint should not be higher than the maximum setpoint"
                  annotation (Placement(transformation(extent={{0,90},{20,110}})));
                Buildings.Controls.OBC.CDL.Logical.And and2
                  "After (device ON + delTim + timSta), when request number becomes more than ignored requests number"
                  annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
                Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical Not"
                  annotation (Placement(transformation(extent={{-100,130},{-80,150}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minSetCon(k=minSet)
                  "Minimum setpoint constant"
                  annotation (Placement(transformation(extent={{0,60},{20,80}})));
                Buildings.Controls.OBC.CDL.Continuous.Max maxInp
                  "Reset setpoint should not be lower than the minimum setpoint"
                  annotation (Placement(transformation(extent={{40,90},{60,110}})));
                Buildings.Controls.OBC.CDL.Utilities.Assert assMes(
                  final message="Trim amount 'triAmo' and respond amount 'resAmo' must have opposite signs.")
                  "Generate alarm message"
                  annotation (Placement(transformation(extent={{-80,-110},{-60,-90}})));
                Buildings.Controls.OBC.CDL.Utilities.Assert assMes2(
                  final message="Respond amount 'resAmo' and maximum respond amount 'maxRes' must have same sign.")
                  "Generate alarm message"
                  annotation (Placement(transformation(extent={{-80,-180},{-60,-160}})));
                Buildings.Controls.OBC.CDL.Continuous.Abs abs "Absolute value of real input"
                  annotation (Placement(transformation(extent={{-120,-140},{-100,-120}})));
                Buildings.Controls.OBC.CDL.Continuous.Abs abs1 "Absolute value of real input"
                  annotation (Placement(transformation(extent={{-120,-210},{-100,-190}})));

              equation
                connect(numIgnReqCon.y, difReqIgnReq.u1)
                  annotation (Line(points={{-138,-10},{-120,-10},{-120,-24},{-102,-24}},
                    color={0,0,127}));
                connect(difReqIgnReq.y, greThr.u)
                  annotation (Line(points={{-78,-30},{-40,-30},{-40,-50},{18,-50}},
                    color={0,0,127}));
                connect(pro.y, minInp.u1)
                  annotation (Line(points={{2,-100},{10,-100},{10,-114},{18,-114}},
                    color={0,0,127}));
                connect(triAmoCon.y, add2.u1)
                  annotation (Line(points={{-178,-80},{118,-80}},
                    color={0,0,127}));
                connect(add2.y, netRes.u1)
                  annotation (Line(points={{142,-86},{150,-86},{150,-38},{158,-38}},
                    color={0,0,127}));
                connect(iniSetCon.y, swi.u3)
                  annotation (Line(points={{-78,190},{80,190},{80,178},{158,178}},
                    color={0,0,127}));
                connect(swi.y, y)
                  annotation (Line(points={{182,170},{240,170}},
                    color={0,0,127}));
                connect(maxSetCon.y, min1.u2)
                  annotation (Line(points={{-18,70},{-10,70},{-10,94},{-2,94}},
                    color={0,0,127}));
                connect(add1.y, min1.u1)
                  annotation (Line(points={{-18,100},{-10,100},{-10,106},{-2,106}},
                    color={0,0,127}));
                connect(uniDel.y, add1.u1)
                  annotation (Line(points={{-78,106},{-42,106}},
                    color={0,0,127}));
                connect(sampler.y, difReqIgnReq.u2)
                  annotation (Line(points={{-138,-50},{-120,-50},{-120,-36},{-102,-36}},
                    color={0,0,127}));
                connect(triAmoCon.y, swi1.u1)
                  annotation (Line(points={{-178,-80},{0,-80},{0,18},{118,18}},
                    color={0,0,127}));
                connect(zerTri.y, swi1.u3)
                  annotation (Line(points={{82,-10},{100,-10},{100,2},{118,2}},
                    color={0,0,127}));
                connect(greThr.y, and2.u2)
                  annotation (Line(points={{42,-50},{60,-50},{60,-38},{118,-38}},
                    color={255,0,255}));
                connect(and2.y, netRes.u2)
                  annotation (Line(points={{142,-30},{158,-30}},
                    color={255,0,255}));
                connect(iniSetCon.y, swi2.u1)
                  annotation (Line(points={{-78,190},{80,190},{80,148},{98,148}},
                    color={0,0,127}));
                connect(swi2.y, swi.u1)
                  annotation (Line(points={{122,140},{140,140},{140,162},{158,162}},
                    color={0,0,127}));
                connect(swi2.y, uniDel.u)
                  annotation (Line(points={{122,140},{140,140},{140,160},{-120,160},{-120,106},
                        {-102,106}},        color={0,0,127}));
                connect(uDevSta, not1.u)
                  annotation (Line(points={{-240,170},{-210,170},{-210,140},{-102,140}},
                    color={255,0,255}));
                connect(not1.y, swi2.u2)
                  annotation (Line(points={{-78,140},{98,140}},
                    color={255,0,255}));
                connect(min1.y, maxInp.u1)
                  annotation (Line(points={{22,100},{30,100},{30,106},{38,106}},
                    color={0,0,127}));
                connect(minSetCon.y, maxInp.u2)
                  annotation (Line(points={{22,70},{30,70},{30,94},{38,94}},
                    color={0,0,127}));
                connect(numOfReq, intToRea.u)
                  annotation (Line(points={{-240,-50},{-202,-50}}, color={255,127,0}));
                connect(intToRea.y, sampler.u)
                  annotation (Line(points={{-178,-50},{-162,-50}}, color={0,0,127}));
                connect(difReqIgnReq.y, pro.u1)
                  annotation (Line(points={{-78,-30},{-40,-30},{-40,-94},{-22,-94}},
                    color={0,0,127}));
                connect(uDevSta, tim.u)
                  annotation (Line(points={{-240,170},{-202,170}}, color={255,0,255}));
                connect(tim.y, swi.u2)
                  annotation (Line(points={{-178,170},{158,170}}, color={255,0,255}));
                connect(tim.y, swi1.u2)
                  annotation (Line(points={{-178,170},{-140,170},{-140,10},{118,10}},
                    color={255,0,255}));
                connect(and2.u1, tim.y)
                  annotation (Line(points={{118,-30},{-20,-30},{-20,10},{-140,10},{-140,170},
                    {-178,170}}, color={255,0,255}));
                connect(maxInp.y, swi2.u3)
                  annotation (Line(points={{62,100},{80,100},{80,132},{98,132}}, color={0,0,127}));
                connect(triAmoCon.y, pro1.u1)
                  annotation (Line(points={{-178,-80},{-170,-80},{-170,-94},{-162,-94}},
                    color={0,0,127}));
                connect(resAmoCon.y, pro1.u2)
                  annotation (Line(points={{-178,-130},{-170,-130},{-170,-106},{-162,-106}},
                    color={0,0,127}));
                connect(pro1.y, lesThr1.u)
                  annotation (Line(points={{-138,-100},{-122,-100}}, color={0,0,127}));
                connect(lesThr1.y, assMes.u)
                  annotation (Line(points={{-98,-100},{-82,-100}}, color={255,0,255}));
                connect(resAmoCon.y, pro2.u1)
                  annotation (Line(points={{-178,-130},{-170,-130},{-170,-164},{-162,-164}},
                    color={0,0,127}));
                connect(maxResCon.y, pro2.u2)
                  annotation (Line(points={{-178,-200},{-170,-200},{-170,-176},{-162,-176}},
                    color={0,0,127}));
                connect(pro2.y, greThr2.u)
                  annotation (Line(points={{-138,-170},{-122,-170}}, color={0,0,127}));
                connect(greThr2.y, assMes2.u)
                  annotation (Line(points={{-98,-170},{-82,-170}}, color={255,0,255}));
                connect(resAmoCon.y, abs.u)
                  annotation (Line(points={{-178,-130},{-122,-130}}, color={0,0,127}));
                connect(abs.y, pro.u2)
                  annotation (Line(points={{-98,-130},{-40,-130},{-40,-106},{-22,-106}},
                    color={0,0,127}));
                connect(maxResCon.y, abs1.u)
                  annotation (Line(points={{-178,-200},{-122,-200}}, color={0,0,127}));
                connect(abs1.y, minInp.u2)
                  annotation (Line(points={{-98,-200},{-20,-200},{-20,-126},{18,-126}},
                    color={0,0,127}));
                connect(minInp.y, swi3.u1)
                  annotation (Line(points={{42,-120},{60,-120},{60,-142},{118,-142}},
                    color={0,0,127}));
                connect(resAmoCon.y, greThr1.u) annotation (Line(points={{-178,-130},{-170,-130},
                        {-170,-150},{18,-150}}, color={0,0,127}));
                connect(greThr1.y, swi3.u2)
                  annotation (Line(points={{42,-150},{118,-150}}, color={255,0,255}));
                connect(netRes.y, add1.u2)
                  annotation (Line(points={{182,-30},{200,-30},{200,36},{-60,36},{-60,94},{-42,
                        94}},  color={0,0,127}));
                connect(swi1.y, netRes.u3)
                  annotation (Line(points={{142,10},{150,10},{150,-22},{158,-22}}, color={0,0,127}));
                connect(minInp.y, gai.u)
                  annotation (Line(points={{42,-120},{60,-120},{60,-180},{78,-180}}, color={0,0,127}));
                connect(gai.y, swi3.u3)
                  annotation (Line(points={{102,-180},{110,-180},{110,-158},{118,-158}},
                    color={0,0,127}));
                connect(swi3.y, add2.u2)
                  annotation (Line(points={{142,-150},{160,-150},{160,-120},{100,-120},
                    {100,-92},{118,-92}}, color={0,0,127}));

              annotation (
                defaultComponentName = "triRes",
                Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                     graphics={Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={223,211,169},
                      lineThickness=5.0,
                      borderPattern=BorderPattern.Raised,
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-114,146},{106,108}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Text(
                        extent={{-88,58},{90,-42}},
                        lineColor={192,192,192},
                        textString="Trim & Respond")}),
                 Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,-220},{220,
                          220}}),
                         graphics={
                      Rectangle(
                        extent={{-218,28},{218,-218}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-218,218},{218,42}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{-214,122},{-124,98}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Check device status,
Count time"),               Text(
                        extent={{-216,22},{-110,-6}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Reset setpoint based
on request number")}),
                 Documentation(info="<html>
<p>
This block implements the trim and respond logic according to ASHRAE guideline G36,
PART 5.A.15 (trim and respond setpoint reset logic).
</p>
<p>
The trim and respond logic shall reset setpoint within the range <code>minSet</code> to
<code>maxSet</code>.
When the associated device is off (<code>uDevSta=false</code>), the setpoint
shall be <code>iniSet</code>.
The reset logic shall be active while the associated device is proven
on (<code>uDevSta=true</code>), starting <code>delTim</code> after initial
device start command.
When active, every time step <code>samplePeriod</code>, trim the setpoint by
<code>triAmo</code>.
If there are more than <code>numIgnReq</code> requests, respond by changing
the setpoint by <code>resAmo*(numOfReq-numIgnReq)</code>, i.e., the number of
requests minus the number of ignored requests, but no more than <code>maxRes</code>.
</p>
In other words, every time step <code>samplePeriod</code>:
<ul>
<li>Change setpoint by <code>triAmo</code>; </li>
<li>If <code>numOfReq > numIgnReq</code>, <i>also</i> change setpoint by <code>resAmo*(numOfReq
-numIgnReq)</code> but no more than <code>maxRes</code>.
</li>
</ul>

<p align=\"center\">
<img alt=\"Image of set point reset\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/TrimRespond.png\"/>
</p>
</html>",               revisions="<html>
<ul>
<li>
April 13, 2020, by Jianjun Hu:<br/>
Corrected to delay the true initial device status.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1876\">#1876</a>.
</li>
<li>
August 28, 2019, by Jianjun Hu:<br/>
Added assertions and corrected implementation when response amount is negative.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1530\">#1503</a>.
</li>
<li>
July 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end TrimAndRespond;

              block ZoneStatus "Block that outputs zone temperature status"

                parameter Real THeaSetOcc(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=293.15
                  "Occupied heating setpoint";
                parameter Real THeaSetUno(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=285.15
                  "Unoccupied heating setpoint";
                parameter Real TCooSetOcc(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=297.15
                  "Occupied cooling setpoint";
                parameter Real TCooSetUno(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=303.15
                  "Unoccupied cooling setpoint";
                parameter Real bouLim(
                  final unit="K",
                  displayUnit="K",
                  final quantity="TemperatureDifference",
                  final min=0.5) = 1
                  "Threshold of temperature difference for indicating the end of setback or setup mode";
                parameter Boolean have_winSen=false
                  "Check if the zone has window status sensor";
                parameter Real uLow=-0.1
                  "Low limit of the hysteresis for checking temperature difference"
                  annotation (Dialog(tab="Advanced"));
                parameter Real uHigh=0.1
                  "High limit of the hysteresis for checking temperature difference"
                  annotation (Dialog(tab="Advanced"));

                Buildings.Controls.OBC.CDL.Interfaces.RealInput cooDowTim(
                  final unit="s",
                  final quantity="Time")
                  "Cool-down time retrieved from optimal cool-down block"
                  annotation (Placement(transformation(extent={{-200,200},{-160,240}}),
                      iconTransformation(extent={{-140,60},{-100,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput warUpTim(
                  final unit="s",
                  final quantity="Time")
                  "Warm-up time retrieved from optimal warm-up block"
                  annotation (Placement(transformation(extent={{-200,160},{-160,200}}),
                      iconTransformation(extent={{-140,20},{-100,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWin if have_winSen
                  "Window status: true=open, false=close"
                  annotation (Placement(transformation(extent={{-200,130},{-160,170}}),
                    iconTransformation(extent={{-140,-60},{-100,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") "Single zone temperature"
                  annotation (Placement(transformation(extent={{-200,-70},{-160,-30}}),
                      iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yCooTim(
                  final unit="s",
                  final quantity="Time") "Cool-down time"
                  annotation (Placement(transformation(extent={{160,200},{200,240}}),
                      iconTransformation(extent={{100,110},{140,150}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yWarTim(
                  final unit="s",
                  final quantity="Time") "Warm-up time"
                  annotation (Placement(transformation(extent={{160,160},{200,200}}),
                      iconTransformation(extent={{100,90},{140,130}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput THeaSetOn(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") "Occupied heating setpoint"
                  annotation (Placement(transformation(extent={{160,110},{200,150}}),
                      iconTransformation(extent={{100,60},{140,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yOccHeaHig
                  "True when the zone temperature is lower than the occupied heating setpoint"
                  annotation (Placement(transformation(extent={{160,70},{200,110}}),
                      iconTransformation(extent={{100,40},{140,80}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TCooSetOn(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Occupied cooling setpoint temperature"
                  annotation (Placement(transformation(extent={{160,30},{200,70}}),
                      iconTransformation(extent={{100,10},{140,50}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yHigOccCoo
                  "True when the zone temperature is higher than the occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{160,-10},{200,30}}),
                      iconTransformation(extent={{100,-10},{140,30}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput THeaSetOff(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") "Unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{160,-60},{200,-20}}),
                      iconTransformation(extent={{100,-40},{140,0}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yUnoHeaHig
                  "True when the zone temperature is lower than the unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{160,-100},{200,-60}}),
                      iconTransformation(extent={{100,-60},{140,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yEndSetBac
                  "True when the zone could end setback mode"
                  annotation (Placement(transformation(extent={{160,-140},{200,-100}}),
                      iconTransformation(extent={{100,-80},{140,-40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TCooSetOff(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") "Unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{160,-180},{200,-140}}),
                      iconTransformation(extent={{100,-110},{140,-70}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yHigUnoCoo
                  "True when the zone temperature is higher than the unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{160,-220},{200,-180}}),
                      iconTransformation(extent={{100,-130},{140,-90}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput yEndSetUp
                  "True when the zone could end setup mode"
                  annotation (Placement(transformation(extent={{160,-260},{200,-220}}),
                      iconTransformation(extent={{100,-150},{140,-110}})));

            protected
                Buildings.Controls.OBC.CDL.Continuous.Product pro
                  "Decide if the cool down time of one zone should be ignored: if window is open, 
    then output zero, otherwise, output cool-down time from optimal cool-down block"
                  annotation (Placement(transformation(extent={{120,210},{140,230}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro1
                  "Decide if the warm-up time of one zone should be ignored: if window is open, 
    then output zero, otherwise, output warm-up time from optimal warm-up block"
                  annotation (Placement(transformation(extent={{120,170},{140,190}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add(
                  final k2=-1)
                  "Calculate difference between zone temperature and the occupied heating setpoint"
                  annotation (Placement(transformation(extent={{-40,80},{-20,100}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys(
                  final uLow=uLow,
                  final uHigh=uHigh)
                  "Hysteresis that outputs if the system should run in warm-up mode"
                  annotation (Placement(transformation(extent={{0,80},{20,100}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1(
                  final k1=-1)
                  "Calculate difference between zone temperature and the occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys1(
                  final uLow=uLow,
                  final uHigh=uHigh)
                  "Hysteresis that outputs if the system should run in cool-down mode"
                  annotation (Placement(transformation(extent={{0,0},{20,20}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2(
                  final k2=-1)
                  "Calculate zone temperature difference to unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys2(
                  final uLow=uLow,
                  final uHigh=uHigh)
                  "Hysteresis that outputs if the zone temperature is lower than unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add5(
                  final k1=-1)
                  "Calculate zone temperature difference to unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-40,-200},{-20,-180}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys5(
                  final uLow=uLow,
                  final uHigh=uHigh)
                  "Hysteresis that outputs if the zone temperature is higher than unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{0,-200},{20,-180}})));
                Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not"
                  annotation (Placement(transformation(extent={{-40,140},{-20,160}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea "Convert Boolean to Real number"
                  annotation (Placement(transformation(extent={{60,140},{80,160}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant con(
                  final k=false) if not have_winSen
                  "Constant false"
                  annotation (Placement(transformation(extent={{-140,190},{-120,210}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant occHeaSet(
                  final k=THeaSetOcc)
                  "Occupied heating setpoint"
                  annotation (Placement(transformation(extent={{-120,120},{-100,140}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant unoHeaSet(
                  final k=THeaSetUno)
                  "Unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant occCooSet(
                  final k=TCooSetOcc)
                  "Occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-120,40},{-100,60}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant unoCooSet(
                  final k=TCooSetUno)
                  "Unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-120,-170},{-100,-150}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add3(
                  final k2=-1)
                  "Calculate zone temperature difference to unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-40,-120},{-20,-100}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys3(
                  final uLow=0,
                  final uHigh=bouLim)
                  "Hysteresis that outputs if the zone temperature is higher than its unoccupied heating setpoint by a given limit"
                  annotation (Placement(transformation(extent={{0,-120},{20,-100}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add4(
                  final k1=-1)
                  "Calculate zone temperature difference to unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-40,-240},{-20,-220}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys4(
                  final uLow=0,
                  final uHigh=bouLim)
                  "Hysteresis that outputs if the zone temperature is lower than its unoccupied cooling setpoint by a given limit"
                  annotation (Placement(transformation(extent={{0,-240},{20,-220}})));
                Buildings.Controls.OBC.CDL.Logical.And and2
                  "When window is open, it should output false"
                  annotation (Placement(transformation(extent={{120,80},{140,100}})));
                Buildings.Controls.OBC.CDL.Logical.And and1
                  "When window is open, it should output false"
                  annotation (Placement(transformation(extent={{120,0},{140,20}})));
                Buildings.Controls.OBC.CDL.Logical.And and3
                  "When window is open, it should output false"
                  annotation (Placement(transformation(extent={{120,-90},{140,-70}})));
                Buildings.Controls.OBC.CDL.Logical.Or or2
                  "When window is open, it should output true"
                  annotation (Placement(transformation(extent={{120,-130},{140,-110}})));
                Buildings.Controls.OBC.CDL.Logical.And and5
                  "When window is open, it should output false"
                  annotation (Placement(transformation(extent={{120,-210},{140,-190}})));
                Buildings.Controls.OBC.CDL.Logical.Or or1
                  "When window is open, it should output true"
                  annotation (Placement(transformation(extent={{120,-250},{140,-230}})));

              equation
                connect(cooDowTim, pro.u1) annotation (Line(points={{-180,220},{60,220},{60,226},
                        {118,226}},     color={0,0,127}));
                connect(warUpTim, pro1.u1) annotation (Line(points={{-180,180},{60,180},{60,186},
                        {118,186}},     color={0,0,127}));
                connect(booToRea.y, pro.u2) annotation (Line(points={{82,150},{100,150},{100,214},
                        {118,214}},color={0,0,127}));
                connect(booToRea.y, pro1.u2) annotation (Line(points={{82,150},{100,150},{100,
                        174},{118,174}}, color={0,0,127}));
                connect(add.y, hys.u)
                  annotation (Line(points={{-18,90},{-2,90}},color={0,0,127}));
                connect(add1.y, hys1.u)
                  annotation (Line(points={{-18,10},{-2,10}}, color={0,0,127}));
                connect(uWin, not1.u)
                  annotation (Line(points={{-180,150},{-42,150}},color={255,0,255}));
                connect(add2.y, hys2.u)
                  annotation (Line(points={{-18,-70},{-2,-70}},  color={0,0,127}));
                connect(add5.y, hys5.u)
                  annotation (Line(points={{-18,-190},{-2,-190}},  color={0,0,127}));
                connect(not1.y, booToRea.u)
                  annotation (Line(points={{-18,150},{58,150}}, color={255,0,255}));
                connect(pro.y, yCooTim)
                  annotation (Line(points={{142,220},{180,220}}, color={0,0,127}));
                connect(pro1.y, yWarTim)
                  annotation (Line(points={{142,180},{180,180}}, color={0,0,127}));
                connect(con.y, not1.u) annotation (Line(points={{-118,200},{-80,200},{-80,150},
                        {-42,150}},color={255,0,255}));
                connect(TZon, add1.u2) annotation (Line(points={{-180,-50},{-140,-50},{-140,4},
                        {-42,4}}, color={0,0,127}));
                connect(TZon, add.u2) annotation (Line(points={{-180,-50},{-140,-50},{-140,84},
                        {-42,84}},color={0,0,127}));
                connect(unoCooSet.y, TCooSetOff)
                  annotation (Line(points={{-98,-160},{180,-160}}, color={0,0,127}));
                connect(unoHeaSet.y, THeaSetOff)
                  annotation (Line(points={{-98,-40},{180,-40}}, color={0,0,127}));
                connect(occHeaSet.y, THeaSetOn)
                  annotation (Line(points={{-98,130},{180,130}}, color={0,0,127}));
                connect(occCooSet.y, TCooSetOn)
                  annotation (Line(points={{-98,50},{180,50}}, color={0,0,127}));
                connect(unoHeaSet.y, add2.u1) annotation (Line(points={{-98,-40},{-60,-40},{-60,
                        -64},{-42,-64}},color={0,0,127}));
                connect(unoCooSet.y, add5.u1) annotation (Line(points={{-98,-160},{-60,-160},{
                        -60,-184},{-42,-184}},color={0,0,127}));
                connect(unoHeaSet.y, add3.u2) annotation (Line(points={{-98,-40},{-60,-40},{-60,
                        -116},{-42,-116}},color={0,0,127}));
                connect(add3.y, hys3.u)
                  annotation (Line(points={{-18,-110},{-2,-110}},  color={0,0,127}));
                connect(unoCooSet.y, add4.u2) annotation (Line(points={{-98,-160},{-60,-160},{
                        -60,-236},{-42,-236}},color={0,0,127}));
                connect(add4.y, hys4.u)
                  annotation (Line(points={{-18,-230},{-2,-230}},  color={0,0,127}));
                connect(occHeaSet.y, add.u1) annotation (Line(points={{-98,130},{-60,130},{-60,
                        96},{-42,96}}, color={0,0,127}));
                connect(occCooSet.y, add1.u1) annotation (Line(points={{-98,50},{-60,50},{-60,
                        16},{-42,16}}, color={0,0,127}));
                connect(TZon, add2.u2) annotation (Line(points={{-180,-50},{-140,-50},{-140,-76},
                        {-42,-76}}, color={0,0,127}));
                connect(TZon, add3.u1) annotation (Line(points={{-180,-50},{-140,-50},{-140,-104},
                        {-42,-104}}, color={0,0,127}));
                connect(TZon, add5.u2) annotation (Line(points={{-180,-50},{-140,-50},{-140,-196},
                        {-42,-196}}, color={0,0,127}));
                connect(TZon, add4.u1) annotation (Line(points={{-180,-50},{-140,-50},{-140,-224},
                        {-42,-224}}, color={0,0,127}));
                connect(and2.y, yOccHeaHig)
                  annotation (Line(points={{142,90},{180,90}}, color={255,0,255}));
                connect(hys.y, and2.u1)
                  annotation (Line(points={{22,90},{118,90}}, color={255,0,255}));
                connect(hys1.y, and1.u1)
                  annotation (Line(points={{22,10},{118,10}}, color={255,0,255}));
                connect(hys2.y, and3.u1) annotation (Line(points={{22,-70},{100,-70},{100,-80},
                        {118,-80}}, color={255,0,255}));
                connect(hys3.y, or2.u1) annotation (Line(points={{22,-110},{100,-110},{100,-120},
                        {118,-120}}, color={255,0,255}));
                connect(hys5.y, and5.u1) annotation (Line(points={{22,-190},{100,-190},{100,-200},
                        {118,-200}}, color={255,0,255}));
                connect(hys4.y, or1.u1) annotation (Line(points={{22,-230},{100,-230},{100,-240},
                        {118,-240}}, color={255,0,255}));
                connect(not1.y, and2.u2) annotation (Line(points={{-18,150},{40,150},{40,82},
                        {118,82}},color={255,0,255}));
                connect(not1.y, and1.u2) annotation (Line(points={{-18,150},{40,150},{40,2},{118,
                        2}}, color={255,0,255}));
                connect(and1.y, yHigOccCoo) annotation (Line(points={{142,10},{152,10},{152,10},
                        {180,10}}, color={255,0,255}));
                connect(and3.y, yUnoHeaHig)
                  annotation (Line(points={{142,-80},{180,-80}}, color={255,0,255}));
                connect(or2.y, yEndSetBac) annotation (Line(points={{142,-120},{154,-120},{
                        154,-120},{180,-120}}, color={255,0,255}));
                connect(and5.y, yHigUnoCoo)
                  annotation (Line(points={{142,-200},{180,-200}}, color={255,0,255}));
                connect(or1.y, yEndSetUp)
                  annotation (Line(points={{142,-240},{180,-240}}, color={255,0,255}));
                connect(uWin, or2.u2) annotation (Line(points={{-180,150},{-80,150},{-80,-128},
                        {118,-128}}, color={255,0,255}));
                connect(uWin, or1.u2) annotation (Line(points={{-180,150},{-80,150},{-80,-248},
                        {118,-248}}, color={255,0,255}));
                connect(con.y, or2.u2) annotation (Line(points={{-118,200},{-80,200},{-80,-128},
                        {118,-128}}, color={255,0,255}));
                connect(con.y, or1.u2) annotation (Line(points={{-118,200},{-80,200},{-80,-248},
                        {118,-248}}, color={255,0,255}));
                connect(not1.y, and3.u2) annotation (Line(points={{-18,150},{40,150},{40,-88},
                        {118,-88}}, color={255,0,255}));
                connect(not1.y, and5.u2) annotation (Line(points={{-18,150},{40,150},{40,-208},
                        {118,-208}}, color={255,0,255}));

              annotation (
                defaultComponentName = "zonSta",
                 Icon(coordinateSystem(extent={{-100,-140},{100,140}}),
                      graphics={
                      Rectangle(
                      extent={{-100,-140},{100,140}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-96,88},{-46,72}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="cooDowTim"),
                      Text(
                        extent={{-98,46},{-50,34}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="warUpTim"),
                      Text(
                        extent={{-120,180},{100,140}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Text(
                        extent={{-100,-74},{-74,-84}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZon"),
                      Text(
                        extent={{-100,-32},{-62,-42}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uWinSta"),
                      Text(
                        extent={{60,140},{98,124}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="yCooTim"),
                      Text(
                        extent={{60,120},{98,104}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="yWarTim"),
                      Text(
                        extent={{38,70},{96,54}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yOccHeaHig"),
                      Text(
                        extent={{42,20},{98,2}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yHigOccCoo"),
                      Text(
                        extent={{40,-30},{96,-46}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yUnoHeaHig"),
                      Text(
                        extent={{42,-102},{98,-118}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yHigUnoCoo"),
                      Text(
                        extent={{46,90},{96,74}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="THeaSetOn"),
                      Text(
                        extent={{46,40},{96,24}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TCooSetOn"),
                      Text(
                        extent={{46,-10},{96,-26}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="THeaSetOff"),
                      Text(
                        extent={{46,-80},{96,-96}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TCooSetOff"),
                      Text(
                        extent={{42,-50},{98,-66}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yEndSetBac"),
                      Text(
                        extent={{46,-124},{98,-138}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="yEndSetUp")}),
                 Documentation(info="<html>
<p>
This block outputs single zone status. It includes outputs as following:
</p>
<ul>
<li>
the times for cooling-down (<code>yCooTim</code>) and warm-up (<code>yWarTim</code>) the zone,
</li>
<li>
<code>THeaSetOn</code>: the zone occupied heating setpoint,
</li>
<li>
<code>yOccHeaHig</code>: if the zone temperature is lower than the occupied heating
setpoint,
</li>
<li>
<code>TCooSetOn</code>: the zone occupied cooling setpoint,
</li>
<li>
<code>yHigOccCoo</code>: if the zone temperature is higher than the occupied cooling
setpoint,
</li>
<li>
<code>THeaSetOff</code>: the zone unoccupied heating setpoint,
</li>
<li>
<code>yUnoHeaHig</code>: if the zone temperature is lower than the unoccupied heating
setpoint,
</li>
<li>
<code>yEndSetBac</code>: if the zone temperature is higher than the unoccupied heating
setpoint with the given limit <code>bouLim</code>, then the zone should be out of the
setback mode,
</li>
<li>
<code>TCooSetOff</code>: the zone unoccupied cooling setpoint,
</li>
<li>
<code>yHigUnoCoo</code>: if the zone temperature is higher than the unoccupied cooling
setpoint,
</li>
<li>
<code>yEndSetUp</code>: if the zone temperature is lower than the unoccupied cooling
setpoint with the given limit <code>bouLim</code>, then the zone should be out of the
setup mode.
</li>
</ul>
</html>",              revisions="<html>
<ul>
<li>
June 10 15, 2020, by Jianjun Hu:<br/>
Simplified implementation.
</li>
<li>
January 15, 2020, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Diagram(coordinateSystem(extent={{-160,-260},{160,240}},
                        preserveAspectRatio=false)));
              end ZoneStatus;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic setpoint sequences for
either AHU or terminal units control.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Ellipse(
                      origin={10.0,10.0},
                      lineColor={128,128,128},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,0.0},{-20.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={128,128,128},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,0.0},{60.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,-80.0},{60.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={76,76,76},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,-80.0},{-20.0,-20.0}})}));
            end SetPoints;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic sequences that would be needed for both AHU and
terminal units control.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Ellipse(
                    origin={10.0,10.0},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,0.0},{-20.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,0.0},{60.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,-80.0},{60.0,-20.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={76,76,76},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,-80.0},{-20.0,-20.0}})}));
          end Generic;

          package TerminalUnits "Control sequences for terminal units"

            block Controller "Controller for room VAV box"

              parameter Real samplePeriod(
                final unit="s",
                final quantity="Time")
                "Sample period of component, set to the same value as the trim and respond that process yPreSetReq";
              parameter Real V_flow_nominal(
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Volume flow rate of this thermal zone";
              parameter Real AFlo(
                final unit="m2",
                final quantity="Area") "Area of the zone";

              parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeCoo=
                 Buildings.Controls.OBC.CDL.Types.SimpleController.PI "Type of controller"
                annotation (Dialog(group="Cooling loop signal"));

              parameter Real kCoo(final unit="1/K") = 0.1
                "Gain for cooling control loop signal"
                annotation(Dialog(group="Cooling loop signal"));

              parameter Real TiCoo(
                final unit="s",
                final quantity="Time")=900
                "Time constant of integrator block for cooling control loop signal"
                annotation(Dialog(group="Cooling loop signal",
                  enable=controllerTypeCoo == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      or controllerTypeCoo == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdCoo(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for cooling control loop signal"
                annotation (Dialog(group="Cooling loop signal",
                  enable=controllerTypeCoo == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                      or controllerTypeCoo == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeHea=
                Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                "Type of controller"
                annotation(Dialog(group="Heating loop signal"));
              parameter Real kHea(final unit="1/K")=0.1
                "Gain for heating control loop signal"
                annotation(Dialog(group="Heating loop signal"));

              parameter Real TiHea(
                final unit="s",
                final quantity="Time")=900
                "Time constant of integrator block for heating control loop signal"
                annotation(Dialog(group="Heating loop signal",
                enable=controllerTypeHea == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    or controllerTypeHea == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdHea(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for heating control loop signal"
                annotation (Dialog(group="Heating loop signal",
                  enable=controllerTypeHea == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                      or controllerTypeHea == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeVal=
                Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                "Type of controller"
                annotation (Dialog(group="Valve"));

              parameter Real kVal=0.5
                "Gain of controller for valve control"
                annotation (Dialog(group="Valve"));

              parameter Real TiVal(
                final unit="s",
                final quantity="Time")=300
                "Time constant of integrator block for valve control"
                annotation(Dialog(group="Valve",
                enable=controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                    or controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdVal(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for valve control"
                annotation (Dialog(group="Valve",
                  enable=controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                      or controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeDam=
                Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                "Type of controller"
                annotation (Dialog(group="Damper"));

              parameter Real kDam(final unit="1")=0.5
                "Gain of controller for damper control"
                annotation (Dialog(group="Damper"));

              parameter Real TiDam(
                final unit="s",
                final quantity="Time")=300
                "Time constant of integrator block for damper control"
                annotation (Dialog(group="Damper",
                  enable=controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      or controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdDam(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for damper control"
                annotation (Dialog(group="Damper",
                  enable=controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                      or controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

              parameter Boolean have_occSen=false
                "Set to true if the zone has occupancy sensor"
                annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
              parameter Boolean have_winSen=false
                "Set to true if the zone has window status sensor"
                annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
              parameter Boolean have_CO2Sen=false
                "Set to true if the zone has CO2 sensor"
                annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
              parameter Real VDisCooSetMax_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")=V_flow_nominal
                "Zone maximum cooling airflow setpoint"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real VDisSetMin_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")=0.15*V_flow_nominal
                "Zone minimum airflow setpoint"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real VDisHeaSetMax_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")=0.3*V_flow_nominal
                "Zone maximum heating airflow setpoint"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real VDisConMin_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")=0.1*V_flow_nominal
                "VAV box controllable minimum"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real VOutPerAre_flow(final unit = "m3/(s.m2)")=3e-4
                "Outdoor air rate per unit area"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real VOutPerPer_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")=2.5e-3
                "Outdoor air rate per person"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real CO2Set=894 "CO2 setpoint in ppm"
                annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
              parameter Real dTDisZonSetMax(
                final unit="K",
                displayUnit="K",
                final quantity="TemperatureDifference")=11
                "Zone maximum discharge air temperature above heating setpoint"
                annotation (Dialog(tab="Damper and valve", group="Parameters"));
              parameter Real TDisMin(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")=283.15
                "Lowest discharge air temperature"
                annotation (Dialog(tab="Damper and valve", group="Parameters"));
              parameter Boolean have_heaWatCoi=true
                "Flag, true if there is a hot water coil"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Boolean have_heaPla=false
                "Flag, true if there is a boiler plant"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Real errTZonCoo_1(
                final unit="K",
                displayUnit="K",
                final quantity="TemperatureDifference")=2.8
                "Limit value of difference between zone temperature and cooling setpoint
    for generating 3 cooling SAT reset requests"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Real errTZonCoo_2(
                final unit="K",
                displayUnit="K",
                final quantity="TemperatureDifference")=1.7
                "Limit value of difference between zone temperature and cooling setpoint
    for generating 2 cooling SAT reset requests"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Real errTDis_1(
                final unit="K",
                displayUnit="K",
                final quantity="TemperatureDifference")=17
                "Limit value of difference between discharge air temperature and its setpoint
    for generating 3 hot water reset requests"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Real errTDis_2(
                final unit="K",
                displayUnit="K",
                final quantity="TemperatureDifference")=8.3
                "Limit value of difference between discharge air temperature and its setpoint
    for generating 2 hot water reset requests"
                annotation (Dialog(tab="System requests", group="Parameters"));
              parameter Real durTimTem(
                final unit="s",
                final quantity="Time")=120
                "Duration time of zone temperature exceeds setpoint"
                annotation (Dialog(tab="System requests", group="Duration times"));
              parameter Real durTimFlo(
                final unit="s",
                final quantity="Time")=60
                "Duration time of airflow rate less than setpoint"
                annotation (Dialog(tab="System requests", group="Duration times"));
              parameter Real durTimDisAir(
                final unit="s",
                final quantity="Time")=300
                "Duration time of discharge air temperature is less than setpoint"
                annotation (Dialog(tab="System requests", group="Duration times"));

              Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonHeaSet(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")
                "Setpoint temperature for room for heating"
                annotation (Placement(transformation(extent={{-180,140},{-140,180}}),
                    iconTransformation(extent={{-140,80},{-100,120}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonCooSet(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")
                "Setpoint temperature for room for cooling"
                annotation (Placement(transformation(extent={{-180,100},{-140,140}}),
                    iconTransformation(extent={{-140,60},{-100,100}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")
                "Measured room temperature"
                annotation (Placement(transformation(extent={{-180,-34},{-140,6}}),
                    iconTransformation(extent={{-140,-20},{-100,20}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput TDis(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")
                "Measured supply air temperature after heating coil"
                annotation (Placement(transformation(extent={{-180,-130},{-140,-90}}),
                    iconTransformation(extent={{-140,-80},{-100,-40}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput VDis_flow(
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Measured discharge airflow rate"
                annotation (Placement(transformation(extent={{-180,-70},{-140,-30}}),
                    iconTransformation(extent={{-140,-40},{-100,0}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput TSupAHU(
                final quantity="ThermodynamicTemperature",
                final unit = "K",
                displayUnit = "degC")
                "AHU supply air temperature"
                annotation (Placement(transformation(extent={{-180,-160},{-140,-120}}),
                    iconTransformation(extent={{-140,-100},{-100,-60}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput ppmCO2 if have_CO2Sen
                "Measured CO2 concentration"
                annotation (Placement(transformation(extent={{-180,60},{-140,100}}),
                    iconTransformation(extent={{-140,40},{-100,80}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput nOcc if have_occSen
                "Number of occupants"
                annotation (Placement(transformation(extent={{-180,30},{-140,70}}),
                    iconTransformation(extent={{-140,20},{-100,60}})));
              Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWin if have_winSen
                "Window status, true if open, false if closed"
                annotation (Placement(transformation(extent={{-180,0},{-140,40}}),
                    iconTransformation(extent={{-140,0},{-100,40}})));
              Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                "Zone operation mode"
                annotation (Placement(transformation(extent={{-180,-190},{-140,-150}}),
                    iconTransformation(extent={{-140,-120},{-100,-80}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealInput yDam_actual
                "Actual VAV damper position"
                annotation (Placement(transformation(extent={{-180,-100},{-140,-60}}),
                    iconTransformation(extent={{-140,-60},{-100,-20}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput yVal(
                final min=0,
                final max=1,
                final unit="1")
                "Signal for heating coil valve"
                annotation (Placement(transformation(extent={{140,-40},{180,0}}),
                    iconTransformation(extent={{100,-10},{140,30}})));
              Buildings.Controls.OBC.CDL.Interfaces.RealOutput yDam(
                final min=0,
                final max=1,
                final unit="1")
                "Signal for VAV damper"
                annotation (Placement(transformation(extent={{140,60},{180,100}}),
                    iconTransformation(extent={{100,40},{140,80}})));
              Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yZonTemResReq
                "Zone cooling supply air temperature reset request"
                annotation (Placement(transformation(extent={{140,-100},{180,-60}}),
                    iconTransformation(extent={{100,-60},{140,-20}})));
              Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yZonPreResReq
                "Zone static pressure reset requests"
                annotation (Placement(transformation(extent={{140,-140},{180,-100}}),
                    iconTransformation(extent={{100,-100},{140,-60}})));

              Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow
                actAirSet(
                final AFlo=AFlo,
                final have_occSen=have_occSen,
                final have_winSen=have_winSen,
                final have_CO2Sen=have_CO2Sen,
                final VDisCooSetMax_flow=VDisCooSetMax_flow,
                final VDisSetMin_flow=VDisSetMin_flow,
                final VDisHeaSetMax_flow=VDisHeaSetMax_flow,
                final VDisConMin_flow=VDisConMin_flow,
                final VOutPerAre_flow=VOutPerAre_flow,
                final VOutPerPer_flow=VOutPerPer_flow,
                final CO2Set=CO2Set)
                "Active airflow rate setpoint"
                annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
              Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves damVal(
                final controllerTypeVal=controllerTypeVal,
                final kVal=kVal,
                final TiVal=TiVal,
                final TdVal=TdVal,
                final controllerTypeDam=controllerTypeDam,
                final kDam=kDam,
                final TiDam=TiDam,
                final TdDam=TdDam,
                final dTDisZonSetMax=dTDisZonSetMax,
                final TDisMin=TDisMin,
                V_flow_nominal=max(VDisCooSetMax_flow, VDisHeaSetMax_flow))
                                       "Damper and valve controller"
                annotation (Placement(transformation(extent={{20,-20},{40,0}})));
              Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests sysReq(
                final samplePeriod=samplePeriod,
                final have_heaWatCoi=have_heaWatCoi,
                final have_heaPla=have_heaPla,
                final errTZonCoo_1=errTZonCoo_1,
                final errTZonCoo_2=errTZonCoo_2,
                final errTDis_1=errTDis_1,
                final errTDis_2=errTDis_2,
                final durTimTem=durTimTem,
                final durTimFlo=durTimFlo,
                final durTimDisAir=durTimDisAir)
                "Number of system requests"
                annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
              Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conHeaLoo(
                final controllerType=controllerTypeHea,
                final k=kHea,
                final Ti=TiHea,
                final Td=TdHea,
                final yMax=1,
                final yMin=0) "Heating loop signal"
                annotation (Placement(transformation(extent={{-110,150},{-90,170}})));
              Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conCooLoo(
                final controllerType=controllerTypeCoo,
                final k=kCoo,
                final Ti=TiCoo,
                final Td=TdCoo,
                final yMax=1,
                final yMin=0,
                reverseActing=false) "Cooling loop signal"
                annotation (Placement(transformation(extent={{-110,110},{-90,130}})));

          protected
              Buildings.Controls.OBC.CDL.Integers.Equal isUnOcc
                "Output true if unoccupied"
                annotation (Placement(transformation(extent={{-18,-160},{2,-140}})));
              Buildings.Controls.OBC.CDL.Integers.Sources.Constant conIntUn(
                final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                "Constant signal for unoccupied mode"
                annotation (Placement(transformation(extent={{-60,-160},{-40,-140}})));
              Buildings.Controls.OBC.CDL.Logical.Not isNotUn
              "Output true if not unoccupied"
                annotation (Placement(transformation(extent={{20,-160},{40,-140}})));

            equation
              connect(sysReq.TZonCooSet, TZonCooSet)
                annotation (Line(points={{78,-82},{-120,-82},{-120,120},{-160,120}},
                  color={0,0,127}));
              connect(sysReq.TZon, TZon)
                annotation (Line(points={{78,-84},{0,-84},{0,-14},{-160,-14}},
                  color={0,0,127}));
              connect(sysReq.VDisSet_flow, damVal.VDisSet_flow)
                annotation (Line(points={{78,-88},{64,-88},{64,-2},{42,-2}},
                  color={0,0,127}));
              connect(sysReq.VDis_flow, VDis_flow)
                annotation (Line(points={{78,-90},{34,-90},{34,-50},{-160,-50}},
                  color={0,0,127}));
              connect(sysReq.TDisHeaSet, damVal.TDisHeaSet)
                annotation (Line(points={{78,-94},{58,-94},{58,-18},{42,-18}},
                  color={0,0,127}));
              connect(damVal.yDam, yDam)
                annotation (Line(points={{42,-6},{120,-6},{120,80},{160,80}},
                  color={0,0,127}));
              connect(damVal.yHeaVal, yVal)
                annotation (Line(points={{42,-14},{120,-14},{120,-20},{160,-20}},
                  color={0,0,127}));
              connect(damVal.VDis_flow, VDis_flow)
                annotation (Line(points={{34,-22},{34,-50},{-160,-50}},color={0,0,127}));
              connect(damVal.TDis, TDis)
                annotation (Line(points={{26,-22},{26,-110},{-160,-110}},
                                                                       color={0,0,127}));
              connect(sysReq.TDis, TDis)
                annotation (Line(points={{78,-96},{26,-96},{26,-110},{-160,-110}},
                  color={0,0,127}));
              connect(damVal.yHeaVal, sysReq.uHeaVal)
                annotation (Line(points={{42,-14},{50,-14},{50,-98},{78,-98}},
                                                                         color={0,0,127}));
              connect(TZon, damVal.TZon) annotation (Line(points={{-160,-14},{18,-14}},
                               color={0,0,127}));
              connect(damVal.TSup, TSupAHU) annotation (Line(points={{18,-8},{-80,-8},{-80,-140},
                      {-160,-140}},color={0,0,127}));
              connect(actAirSet.VActCooMax_flow, damVal.VActCooMax_flow) annotation (Line(points={{-18,78},
                      {0,78},{0,-4},{18,-4}},      color={0,0,127}));
              connect(actAirSet.VActCooMin_flow, damVal.VActCooMin_flow) annotation (Line(points={{-18,75},
                      {-2,75},{-2,-2},{18,-2}},      color={0,0,127}));
              connect(actAirSet.VActMin_flow, damVal.VActMin_flow) annotation (Line(points={{-18,72},
                      {-4,72},{-4,-6},{18,-6}}, color={0,0,127}));
              connect(actAirSet.VActHeaMin_flow, damVal.VActHeaMin_flow) annotation (Line(points={{-18,69},
                      {-6,69},{-6,-16},{18,-16}},  color={0,0,127}));
              connect(actAirSet.VActHeaMax_flow, damVal.VActHeaMax_flow) annotation (Line(points={{-18,66},
                      {-8,66},{-8,-18},{18,-18}},  color={0,0,127}));
              connect(damVal.THeaSet, TZonHeaSet)
                annotation (Line(points={{18,-10},{-124,-10},{-124,160},{-160,160}},
                  color={0,0,127}));
              connect(actAirSet.VActCooMax_flow, damVal.VActCooMax_flow)
                annotation (Line(points={{-18,78},{0,78},{0,-4},{18,-4}},
                  color={0,0,127}));
              connect(actAirSet.VActCooMin_flow, damVal.VActCooMin_flow)
                annotation (Line(points={{-18,75},{-2,75},{-2,-2},{18,-2}},
                  color={0,0,127}));
              connect(actAirSet.VActMin_flow, damVal.VActMin_flow)
                annotation (Line(points={{-18,72},{-4,72},{-4,-6},{18,-6}},
                  color={0,0,127}));
              connect(actAirSet.VActHeaMin_flow, damVal.VActHeaMin_flow)
                annotation (Line(points={{-18,69},{-6,69},{-6,-16},{18,-16}},
                  color={0,0,127}));
              connect(actAirSet.VActHeaMax_flow, damVal.VActHeaMax_flow)
                annotation (Line(points={{-18,66},{-8,66},{-8,-18},{18,-18}},
                  color={0,0,127}));
              connect(actAirSet.uOpeMod, uOpeMod)
                annotation (Line(points={{-42,78},{-112,78},{-112,-170},{-160,-170}},
                  color={255,127,0}));
              connect(sysReq.yZonTemResReq, yZonTemResReq)
                annotation (Line(points={{102,-83},{120,-83},{120,-80},{160,-80}},
                  color={255,127,0}));
              connect(sysReq.yZonPreResReq, yZonPreResReq)
                annotation (Line(points={{102,-88},{120,-88},{120,-120},{160,-120}},
                  color={255,127,0}));
              connect(actAirSet.ppmCO2, ppmCO2)
                annotation (Line(points={{-42,74},{-60,74},{-60,80},{-160,80}},
                  color={0,0,127}));
              connect(actAirSet.nOcc, nOcc)
                annotation (Line(points={{-42,66},{-60,66},{-60,50},{-160,50}},
                  color={0,0,127}));
              connect(actAirSet.uWin, uWin)
                annotation (Line(points={{-42,62},{-56,62},{-56,20},{-160,20}},
                  color={255,0,255}));
              connect(TZonHeaSet, conHeaLoo.u_s)
                annotation (Line(points={{-160,160},{-112,160}}, color={0,0,127}));
              connect(TZonCooSet, conCooLoo.u_s)
                annotation (Line(points={{-160,120},{-112,120}}, color={0,0,127}));
              connect(TZon, conHeaLoo.u_m)
                annotation (Line(points={{-160,-14},{-122,-14},{-122,140},{-100,140},{-100,148}},
                               color={0,0,127}));
              connect(TZon, conCooLoo.u_m)
                annotation (Line(points={{-160,-14},{-122,-14},{-122,100},{-100,100},{-100,108}},
                               color={0,0,127}));
              connect(conCooLoo.y, damVal.uCoo)
                annotation (Line(points={{-88,120},{8,120},{8,0},{18,0}},
                  color={0,0,127}));
              connect(conHeaLoo.y, damVal.uHea)
                annotation (Line(points={{-88,160},{12,160},{12,-12},{18,-12}},
                  color={0,0,127}));
              connect(conCooLoo.y, sysReq.uCoo)
                annotation (Line(points={{-88,120},{8,120},{8,-86},{78,-86}},
                  color={0,0,127}));
              connect(damVal.uOpeMod, uOpeMod) annotation (Line(points={{18,-20},{-112,-20},
                      {-112,-170},{-160,-170}},
                                              color={255,127,0}));
              connect(conIntUn.y, isUnOcc.u1)
                annotation (Line(points={{-38,-150},{-20,-150}}, color={255,127,0}));
              connect(uOpeMod, isUnOcc.u2) annotation (Line(points={{-160,-170},{-32,-170},{
                      -32,-158},{-20,-158}}, color={255,127,0}));
              connect(isUnOcc.y, isNotUn.u)
                annotation (Line(points={{4,-150},{18,-150}},   color={255,0,255}));
              connect(isNotUn.y, conCooLoo.trigger) annotation (Line(points={{42,-150},{60,-150},
                      {60,-120},{-116,-120},{-116,104},{-106,104},{-106,108}}, color={255,0,
                      255}));
              connect(isNotUn.y, conHeaLoo.trigger) annotation (Line(points={{42,-150},{60,-150},
                      {60,-120},{-116,-120},{-116,142},{-106,142},{-106,148}}, color={255,0,
                      255}));
              connect(sysReq.yDam_actual,yDam_actual)  annotation (Line(points={{78,-92},{-124,
                      -92},{-124,-80},{-160,-80}}, color={0,0,127}));

            annotation (defaultComponentName="terUniCon",
              Icon(graphics={Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-100,-54},{-78,-64}},
                      lineColor={0,0,127},
                      textString="TDis"),
                    Text(
                      extent={{-100,-70},{-70,-82}},
                      lineColor={0,0,127},
                      textString="TSup"),
                    Text(
                      extent={{70,18},{98,4}},
                      lineColor={0,0,127},
                      textString="yVal"),
                    Text(
                      extent={{68,70},{96,56}},
                      lineColor={0,0,127},
                      textString="yDam"),
                    Text(
                      extent={{-98,100},{-46,88}},
                      lineColor={0,0,127},
                      textString="TZonHeaSet"),
                    Text(
                      extent={{-98,-14},{-68,-26}},
                      lineColor={0,0,127},
                      textString="VDis_flow"),
                    Text(
                      extent={{-120,160},{114,108}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-96,6},{-74,-8}},
                      lineColor={0,0,127},
                      textString="TZon"),
                    Text(
                      extent={{-100,84},{-46,74}},
                      lineColor={0,0,127},
                      textString="TZonCooSet"),
                    Text(
                      extent={{-100,-86},{-52,-98}},
                      lineColor={0,0,127},
                      textString="uOpeMod"),
                    Text(
                      visible=have_occSen,
                      extent={{-100,36},{-74,26}},
                      lineColor={0,0,127},
                      textString="nOcc"),
                    Text(
                      visible=have_CO2Sen,
                      extent={{-96,60},{-58,42}},
                      lineColor={0,0,127},
                      textString="ppmCO2"),
                    Text(
                      visible=have_winSen,
                      extent={{-100,14},{-72,4}},
                      lineColor={0,0,127},
                      textString="uWin"),
                    Text(
                      extent={{22,-20},{96,-58}},
                      lineColor={0,0,127},
                      textString="yZonTemResReq"),
                    Text(
                      extent={{24,-62},{96,-96}},
                      lineColor={0,0,127},
                      textString="yZonPreResReq"),
                    Text(
                      extent={{-98,-34},{-50,-44}},
                      lineColor={0,0,127},
                      textString="uDam_actual")}),
                Diagram(coordinateSystem(extent={{-140,-180},{140,180}})),
            Documentation(info="<html>
<p>
Controller for terminal box of VAV system with reheat according to ASHRAE
Guideline 36, Part 5.E. It outputs damper position <code>yDam</code>,
hot water valve position <code>yVal</code>, AHU cooling supply temperature
setpoint reset request <code>yZonTemResReq</code>, and static pressure setpoint
reset request <code>yZonPreResReq</code>.
</p>
<p>The sequence consists of four subsequences. </p>
<h4>a. Heating and cooling control loop</h4>
<p>
The subsequence is implementd according to Part 5.B.5. The measured zone
temperature <code>TZon</code>, zone setpoints temperatures <code>TZonHeaSet</code> and
<code>TZonCooSet</code> are inputs to the block <code>conHeaLoo</code> and
<code>conCooLoo</code> to generate the control loop signal.
</p>
<h4>b. Active airflow setpoint calculation</h4>
<p>
This sequence sets the active maximum and minimum airflow according to
Part 5.E.3-5. Depending on operation modes <code>uOpeMod</code>, it sets the
airflow rate limits for cooling and heating supply. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow</a>.
</p>
<h4>c. Damper and valve control</h4>
<p>
This sequence sets the damper and valve position for VAV reheat terminal unit.
The implementation is according to Part 5.E.6. According to heating and cooling
control loop signal, it calculates the discharge air temperature setpoint
<code>TDisHeaSet</code>. Along with the defined maximum and minimum airflow, measured
zone temperature, the sequence outputs <code>yDam</code>, <code>yVal</code>,
<code>TDisHeaSet</code> and discharge airflow rate setpoint <code>VDisSet_flow</code>.
See <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves</a>.
</p>
<h4>d. System reset requests generation</h4>
<p>
According to Part 5.E.9, this sequence outputs the system reset requests, i.e.
cooling supply air temperature reset requests <code>yZonTemResReq</code>,
static pressure reset requests <code>yZonPreResReq</code>, hot water reset
requests <code>yHeaValResReq</code>, and the boiler plant reset requests
<code>yHeaPlaReq</code>. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
October 9, 2020, by Jianjun Hu:<br/>
Changed the default heating maximum airflow setpoint to 30% of the zone nominal airflow.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2172\">issue 2172</a>.
</li>
<li>
April 18, 2020, by Jianjun Hu:<br/>
Added actual VAV damper position as the input for generating system request.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1873\">issue 1873</a>.
</li>
<li>
March 06, 2020, by Jianjun Hu:<br/>
Added default component name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1809\">issue 1809</a>.
</li>
<li>
November 15, 2017, by Michael Wetter:<br/>
Added integrator reset.
</li>
<li>
October 27, 2017, by Jianjun Hu:<br/>
Moved it from example package.
</li>
<li>
September 25, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Controller;

            package Reheat "Sequences for VAV reheat terminal unit"

              block DamperValves
                "Output signals for controlling VAV reheat box damper and valve position"

                parameter Real dTDisZonSetMax(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=11
                  "Zone maximum discharge air temperature above heating setpoint";
                parameter Real TDisMin(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=283.15
                  "Lowest discharge air temperature";

                parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeVal=
                  Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation(Dialog(group="Valve"));

                parameter Real kVal(final unit="1/K")=0.5
                  "Gain of controller for valve control"
                  annotation(Dialog(group="Valve"));

                parameter Real TiVal(
                  final unit="s",
                  final quantity="Time")=300
                  "Time constant of integrator block for valve control"
                  annotation(Dialog(group="Valve",
                  enable=controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      or controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                parameter Real TdVal(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for valve control"
                  annotation (Dialog(group="Valve",
                    enable=controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                        or controllerTypeVal == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                parameter Boolean have_pressureIndependentDamper = true
                  "True: the VAV damper is pressure independent (with built-in flow controller)"
                  annotation(Dialog(group="Damper"));

                parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerTypeDam=
                  Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation(Dialog(group="Damper"));

                parameter Real kDam(final unit="1")=0.5
                  "Gain of controller for damper control"
                  annotation(Dialog(group="Damper"));

                parameter Real TiDam(
                  final unit="s",
                  final quantity="Time")=300
                  "Time constant of integrator block for damper control"
                  annotation(Dialog(group="Damper",
                  enable=controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                      or controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                parameter Real TdDam(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for damper control"
                  annotation (Dialog(group="Damper",
                    enable=controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PD
                        or controllerTypeDam == Buildings.Controls.OBC.CDL.Types.SimpleController.PID));

                parameter Real V_flow_nominal(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate",
                  final min=1E-10)
                  "Nominal volume flow rate, used to normalize control error"
                  annotation(Dialog(group="Damper"));

                Buildings.Controls.OBC.CDL.Interfaces.RealInput uHea(
                  final min=0,
                  final max=1,
                  final unit="1")
                  "Heating control signal"
                  annotation (Placement(transformation(extent={{-360,-160},{-320,-120}}),
                      iconTransformation(extent={{-140,-40},{-100,0}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput uCoo(
                  final min=0,
                  final max=1,
                  final unit="1")
                  "Cooling control signal"
                  annotation (Placement(transformation(extent={{-360,260},{-320,300}}),
                      iconTransformation(extent={{-140,80},{-100,120}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VActCooMax_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Active cooling maximum airflow rate"
                  annotation (Placement(transformation(extent={{-360,180},{-320,220}}),
                      iconTransformation(extent={{-140,40},{-100,80}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VActCooMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Active cooling minimum airflow rate"
                  annotation (Placement(transformation(extent={{-360,220},{-320,260}}),
                      iconTransformation(extent={{-140,60},{-100,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VActMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Active minimum airflow rate"
                  annotation (Placement(transformation(extent={{-360,50},{-320,90}}),
                      iconTransformation(extent={{-140,20},{-100,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VActHeaMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Active heating minimum airflow rate"
                  annotation (Placement(transformation(extent={{-360,-300},{-320,-260}}),
                      iconTransformation(extent={{-140,-80},{-100,-40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VActHeaMax_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Active heating maximum airflow rate"
                  annotation (Placement(transformation(extent={{-360,-330},{-320,-290}}),
                      iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VDis_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") if not have_pressureIndependentDamper
                  "Measured discharge airflow rate airflow rate"
                  annotation (Placement(transformation(extent={{-360,320},{-320,360}}),
                    iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={40,-120})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TSup(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Supply air temperature from central air handler"
                  annotation (Placement(transformation(extent={{-360,-50},{-320,-10}}),
                      iconTransformation(extent={{-140,0},{-100,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput THeaSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone heating setpoint temperature"
                  annotation (Placement(transformation(extent={{-360,-80},{-320,-40}}),
                      iconTransformation(extent={{-140,-20},{-100,20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Measured zone temperature"
                  annotation (Placement(transformation(extent={{-360,-270},{-320,-230}}),
                      iconTransformation(extent={{-140,-60},{-100,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TDis(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Measured discharge air temperature"
                  annotation (Placement(transformation(extent={{-360,110},{-320,150}}),
                    iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={-40,-120})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                  "Zone operation mode"
                  annotation (Placement(transformation(extent={{-360,-370},{-320,-330}}),
                      iconTransformation(extent={{-140,-120},{-100,-80}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yDam(
                  final min=0,
                  final max=1,
                  final unit="1") "Signal for VAV damper"
                  annotation (Placement(transformation(extent={{320,20},{360,60}}),
                      iconTransformation(extent={{100,20},{140,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput yHeaVal(
                  final min=0,
                  final max=1,
                  final unit="1")
                  "Reheater valve position"
                  annotation (Placement(transformation(extent={{320,-40},{360,0}}),
                      iconTransformation(extent={{100,-60},{140,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput VDisSet_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Discharge airflow setpoint"
                  annotation (Placement(transformation(extent={{320,240},{360,280}}),
                      iconTransformation(extent={{100,60},{140,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TDisHeaSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Discharge airflow setpoint temperature for heating"
                  annotation (Placement(transformation(extent={{320,-160},{360,-120}}),
                      iconTransformation(extent={{100,-100},{140,-60}})));

                Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not"
                  annotation (Placement(transformation(extent={{-220,40},{-200,60}})));
                Buildings.Controls.OBC.CDL.Logical.Not not2 "Logical not"
                  annotation (Placement(transformation(extent={{-220,0},{-200,20}})));
                Buildings.Controls.OBC.CDL.Logical.Not not4 "Logical not"
                  annotation (Placement(transformation(extent={{-202,120},{-182,140}})));
                Buildings.Controls.OBC.CDL.Logical.And and2
                  "Check if current zone state is deadband"
                  annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
                Buildings.Controls.OBC.CDL.Logical.And and4 "Logical and"
                  annotation (Placement(transformation(extent={{-60,200},{-40,220}})));
                Buildings.Controls.OBC.CDL.Continuous.Line lin
                  "Active airflow setpoint for cooling"
                  annotation (Placement(transformation(extent={{-160,270},{-140,290}})));
                Buildings.Controls.OBC.CDL.Continuous.Line conTDisHeaSet
                  "Discharge air temperature for heating"
                  annotation (Placement(transformation(extent={{-120,-82},{-100,-62}})));
                Buildings.Controls.OBC.CDL.Continuous.Line lin3
                  "Active airflow setpoint for heating"
                  annotation (Placement(transformation(extent={{-80,-310},{-60,-290}})));
                Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conVal(
                  final controllerType=controllerTypeVal,
                  final k=kVal,
                  final Ti=TiVal,
                  final Td=TdVal,
                  final yMax=1,
                  final yMin=0,
                  u_s(final unit="K", displayUnit="degC"),
                  u_m(final unit="K", displayUnit="degC"))
                  "Hot water valve controller"
                  annotation (Placement(transformation(extent={{34,-90},{54,-70}})));
                Buildings.Controls.OBC.CDL.Continuous.PIDWithReset conDam(
                  final controllerType=controllerTypeDam,
                  final k=kDam,
                  final Ti=TiDam,
                  final Td=TdDam,
                  final yMax=1,
                  final yMin=0,
                  final y_reset=0) if not have_pressureIndependentDamper
                  "Damper position controller"
                  annotation (Placement(transformation(extent={{280,220},{300,240}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi
                  "Output active cooling airflow according to cooling control signal"
                  annotation (Placement(transformation(extent={{140,260},{160,280}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi1 "Output active airflow when it is in deadband state"
                  annotation (Placement(transformation(extent={{132,40},{152,60}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi2 "Acitive heating airflow rate"
                  annotation (Placement(transformation(extent={{80,-260},{100,-240}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi4
                  "Output active heating airflow according to heating control signal"
                  annotation (Placement(transformation(extent={{140,-260},{160,-240}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi5 "Output active cooling airflow "
                  annotation (Placement(transformation(extent={{60,200},{80,220}})));

            protected
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{-280,300},{-260,320}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer1(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{100,240},{120,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer2(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{-80,-2},{-60,18}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer3(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{-260,-110},{-240,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer6(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{80,-310},{100,-290}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conOne(
                  final k=1) "Constant one"
                  annotation (Placement(transformation(extent={{-220,300},{-200,320}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conOne2(
                  final k=1) "Constant real value"
                  annotation (Placement(transformation(extent={{-180,-340},{-160,-320}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conHal(
                  final k=0.5) "Constant real value"
                  annotation (Placement(transformation(extent={{-200,-110},{-180,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conHal1(
                  final k=0.5) "Constant real value"
                  annotation (Placement(transformation(extent={{-260,-340},{-240,-320}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar(
                  final p=dTDisZonSetMax,
                  final k=1)
                  "Maximum heating discharge temperature"
                  annotation (Placement(transformation(extent={{-260,-70},{-240,-50}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar1(
                  final k=1,
                  final p=2.8)
                  "Zone temperature pluTZonSets 2.8 degC"
                  annotation (Placement(transformation(extent={{-260,-260},{-240,-240}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys2(
                  final uHigh=0.05,
                  final uLow=0.01)
                  "Check if cooling control signal is greater than zero"
                  annotation (Placement(transformation(extent={{-280,220},{-260,240}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys3(
                  final uHigh=0.05,
                  final uLow=0.01)
                  "Check if heating control signal is greater than 0"
                  annotation (Placement(transformation(extent={{-260,-220},{-240,-200}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys4(
                  final uLow=TDisMin - 0.1,
                  final uHigh=TDisMin + 0.1)
                  "Check if discharge air temperature is greater than lowest discharge air temperature"
                  annotation (Placement(transformation(extent={{-240,120},{-220,140}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys6(
                  final uLow=-0.1,
                  final uHigh=0.1)
                  "Check if supply air temperature is greater than room temperature"
                  annotation (Placement(transformation(extent={{-120,190},{-100,210}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys7(
                  final uLow=-0.1,
                  final uHigh=0.1)
                  "Check if discharge air temperature is greater than room temperature plus 2.8 degC"
                  annotation (Placement(transformation(extent={{-80,-260},{-60,-240}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1(final k2=-1)
                  "Calculate temperature difference between discharge air and room plus 2.8 degC"
                  annotation (Placement(transformation(extent={{-120,-260},{-100,-240}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2(final k2=-1)
                  "Calculate temperature difference between AHU supply air and room "
                  annotation (Placement(transformation(extent={{-160,190},{-140,210}})));
                Buildings.Controls.OBC.CDL.Logical.TrueHoldWithReset truHol2(duration=600)
                  "Check if the true input holds for certain time"
                  annotation (Placement(transformation(extent={{-222,-220},{-202,-200}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay truDel3(delayTime=600)
                  "Check if the true input holds for certain time"
                  annotation (Placement(transformation(extent={{-160,120},{-140,140}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay truDel4(delayTime=600)
                  "Check if the true input holds for certain time"
                  annotation (Placement(transformation(extent={{-240,220},{-220,240}})));
                Buildings.Controls.OBC.CDL.Integers.Equal isUno "Output true if the operation mode is unoccupied"
                  annotation (Placement(transformation(extent={{220,-322},{240,-302}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant unOcc(
                  final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                  "Constant signal for unoccupied mode"
                  annotation (Placement(transformation(extent={{170,-322},{190,-302}})));
                Buildings.Controls.OBC.CDL.Logical.Switch watValPosUno "Output hot water valve position"
                  annotation (Placement(transformation(extent={{280,-30},{300,-10}})));
                Buildings.Controls.OBC.CDL.Logical.Switch damPosUno "Output damper position"
                  annotation (Placement(transformation(extent={{280,60},{300,80}})));
                Buildings.Controls.OBC.CDL.Logical.Not not5 "Negation of input signal"
                  annotation (Placement(transformation(extent={{200,-260},{220,-240}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant lowDisAirTem(
                  final k=TDisMin)
                  "Lowest allowed discharge air temperature"
                  annotation (Placement(transformation(extent={{-68,-108},{-48,-88}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi6
                  "Output hot water valve position in case of low discharge air temperature"
                  annotation (Placement(transformation(extent={{-30,-90},{-10,-70}})));
                Buildings.Controls.OBC.CDL.Logical.Or or2 "Logical not"
                  annotation (Placement(transformation(extent={{-68,-64},{-48,-44}})));
                Buildings.Controls.OBC.CDL.Logical.Not not3 "Logical not"
                  annotation (Placement(transformation(extent={{-120,120},{-100,140}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi3
                  "Output hot water valve position in case of low discharge air temperature"
                  annotation (Placement(transformation(extent={{104,-82},{124,-62}})));
                Buildings.Controls.OBC.CDL.Logical.Not not6 "Negation of input signal"
                  annotation (Placement(transformation(extent={{-40,-192},{-20,-172}})));
                Buildings.Controls.OBC.CDL.Logical.And and1
                  "Check if it is not in heating mode and the discharge temperature is not too low"
                  annotation (Placement(transformation(extent={{20,-56},{40,-36}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add3 "Active airflow setpoint"
                  annotation (Placement(transformation(extent={{200,250},{220,270}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add4 "Active airflow set point"
                  annotation (Placement(transformation(extent={{180,40},{200,60}})));
                Buildings.Controls.OBC.CDL.Continuous.Division VDis_flowNor if
                     not have_pressureIndependentDamper
                  "Normalized discharge volume flow rate"
                  annotation (Placement(transformation(extent={{240,150},{260,170}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant nomFlow(
                  final k=V_flow_nominal)
                  "Nominal volume flow rate"
                  annotation (Placement(transformation(extent={{200,200},{220,220}})));
                Buildings.Controls.OBC.CDL.Continuous.Division VDisSet_flowNor
                  "Normalized setpoint for discharge volume flow rate"
                  annotation (Placement(transformation(extent={{240,220},{260,240}})));
                Buildings.Controls.OBC.CDL.Continuous.Gain gai(
                  final k=1) if have_pressureIndependentDamper
                  "Block that can be disabled so remove the connection"
                  annotation (Placement(transformation(extent={{240,120},{260,140}})));

              equation
                connect(uCoo, lin.u)
                  annotation (Line(points={{-340,280},{-162,280}}, color={0,0,127}));
                connect(conZer.y, lin.x1)
                  annotation (Line(points={{-258,310},{-240,310},{-240,288},{-162,288}},
                    color={0,0,127}));
                connect(VActCooMin_flow, lin.f1)
                  annotation (Line(points={{-340,240},{-300,240},{-300,284},{-162,284}},
                    color={0,0,127}));
                connect(conOne.y, lin.x2)
                  annotation (Line(points={{-198,310},{-180,310},{-180,276},{-162,276}},
                    color={0,0,127}));
                connect(VActCooMax_flow, lin.f2)
                  annotation (Line(points={{-340,200},{-180,200},{-180,272},{-162,272}},
                    color={0,0,127}));
                connect(uCoo, hys2.u)
                  annotation (Line(points={{-340,280},{-290,280},{-290,230},{-282,230}},
                    color={0,0,127}));
                connect(conZer1.y, swi.u3)
                  annotation (Line(points={{122,250},{130,250},{130,262},{138,262}},
                    color={0,0,127}));
                connect(VActMin_flow, swi1.u1)
                  annotation (Line(points={{-340,70},{30,70},{30,58},{130,58}},
                    color={0,0,127}));
                connect(and2.y, swi1.u2)
                  annotation (Line(points={{-58,50},{130,50}}, color={255,0,255}));
                connect(conZer2.y, swi1.u3)
                  annotation (Line(points={{-58,8},{-20,8},{-20,42},{130,42}},
                    color={0,0,127}));
                connect(uHea, hys3.u)
                  annotation (Line(points={{-340,-140},{-280,-140},{-280,-210},{-262,-210}},
                    color={0,0,127}));
                connect(conZer3.y, conTDisHeaSet.x1)
                  annotation (Line(points={{-238,-100},{-220,-100},{-220,-64},{-122,-64}},
                    color={0,0,127}));
                connect(TSup, conTDisHeaSet.f1)
                  annotation (Line(points={{-340,-30},{-160,-30},{-160,-68},{-122,-68}},
                    color={0,0,127}));
                connect(uHea, conTDisHeaSet.u)
                  annotation (Line(points={{-340,-140},{-140,-140},{-140,-72},{-122,-72}},
                    color={0,0,127}));
                connect(conHal.y, conTDisHeaSet.x2)
                  annotation (Line(points={{-178,-100},{-160,-100},{-160,-76},{-122,-76}},
                    color={0,0,127}));
                connect(addPar.y, conTDisHeaSet.f2)
                  annotation (Line(points={{-238,-60},{-136,-60},{-136,-80},{-122,-80}},
                    color={0,0,127}));
                connect(THeaSet, addPar.u)
                  annotation (Line(points={{-340,-60},{-262,-60}}, color={0,0,127}));
                connect(uHea, lin3.u)
                  annotation (Line(points={{-340,-140},{-280,-140},{-280,-300},{-82,-300}},
                    color={0,0,127}));
                connect(conHal1.y, lin3.x1)
                  annotation (Line(points={{-238,-330},{-200,-330},{-200,-292},{-82,-292}},
                    color={0,0,127}));
                connect(conOne2.y, lin3.x2)
                  annotation (Line(points={{-158,-330},{-140,-330},{-140,-304},{-82,-304}},
                    color={0,0,127}));
                connect(VActHeaMax_flow, lin3.f2)
                  annotation (Line(points={{-340,-310},{-120,-310},{-120,-308},{-82,-308}},
                    color={0,0,127}));
                connect(VActHeaMin_flow, lin3.f1)
                  annotation (Line(points={{-340,-280},{-120,-280},{-120,-296},{-82,-296}},
                    color={0,0,127}));
                connect(TZon, addPar1.u)
                  annotation (Line(points={{-340,-250},{-262,-250}}, color={0,0,127}));
                connect(lin3.y, swi2.u1)
                  annotation (Line(points={{-58,-300},{40,-300},{40,-242},{78,-242}},
                    color={0,0,127}));
                connect(VActHeaMin_flow, swi2.u3)
                  annotation (Line(points={{-340,-280},{60,-280},{60,-258},{78,-258}},
                    color={0,0,127}));
                connect(TDis, hys4.u)
                  annotation (Line(points={{-340,130},{-242,130}},
                    color={0,0,127}));
                connect(swi2.y, swi4.u1)
                  annotation (Line(points={{102,-250},{112,-250},{112,-242},{138,-242}},
                    color={0,0,127}));
                connect(conZer6.y, swi4.u3)
                  annotation (Line(points={{102,-300},{120,-300},{120,-258},{138,-258}},
                    color={0,0,127}));
                connect(VActMin_flow, swi5.u1)
                  annotation (Line(points={{-340,70},{30,70},{30,218},{58,218}},
                    color={0,0,127}));
                connect(and4.y, swi5.u2)
                  annotation (Line(points={{-38,210},{58,210}},color={255,0,255}));
                connect(lin.y, swi5.u3)
                  annotation (Line(points={{-138,280},{40,280},{40,202},{58,202}},
                    color={0,0,127}));
                connect(swi5.y, swi.u1)
                  annotation (Line(points={{82,210},{94,210},{94,278},{138,278}},
                    color={0,0,127}));
                connect(hys4.y, not4.u)
                  annotation (Line(points={{-218,130},{-204,130}}, color={255,0,255}));
                connect(TSup, add2.u1)
                  annotation (Line(points={{-340,-30},{-300,-30},{-300,180},{-176,180},{-176,206},
                        {-162,206}},        color={0,0,127}));
                connect(TZon, add2.u2)
                  annotation (Line(points={{-340,-250},{-296,-250},{-296,176},{-172,176},{-172,
                        194},{-162,194}},   color={0,0,127}));
                connect(add2.y, hys6.u)
                  annotation (Line(points={{-138,200},{-122,200}}, color={0,0,127}));
                connect(hys6.y, and4.u2)
                  annotation (Line(points={{-98,200},{-80,200},{-80,202},{-62,202}},
                    color={255,0,255}));
                connect(conTDisHeaSet.y, add1.u1)
                  annotation (Line(points={{-98,-72},{-80,-72},{-80,-220},{-140,-220},{-140,-244},
                        {-122,-244}},          color={0,0,127}));
                connect(addPar1.y, add1.u2)
                  annotation (Line(points={{-238,-250},{-140,-250},{-140,-256},{-122,-256}},
                    color={0,0,127}));
                connect(add1.y, hys7.u)
                  annotation (Line(points={{-98,-250},{-82,-250}},
                    color={0,0,127}));
                connect(conTDisHeaSet.y, TDisHeaSet)
                  annotation (Line(points={{-98,-72},{-80,-72},{-80,-140},{340,-140}},
                    color={0,0,127}));
                connect(hys3.y, truHol2.u)
                  annotation (Line(points={{-238,-210},{-224,-210}}, color={255,0,255}));
                connect(truHol2.y, swi4.u2)
                  annotation (Line(points={{-200,-210},{120,-210},{120,-250},{138,-250}},
                    color={255,0,255}));
                connect(hys2.y, truDel4.u)
                  annotation (Line(points={{-258,230},{-242,230}}, color={255,0,255}));
                connect(truDel4.y, and4.u1)
                  annotation (Line(points={{-218,230},{-80,230},{-80,210},{-62,210}},
                    color={255,0,255}));
                connect(truDel4.y, swi.u2)
                  annotation (Line(points={{-218,230},{-20,230},{-20,270},{138,270}},
                    color={255,0,255}));
                connect(truHol2.y, not2.u)
                  annotation (Line(points={{-200,-210},{-180,-210},{-180,-128},{-280,-128},{-280,
                        10},{-222,10}}, color={255,0,255}));
                connect(truDel4.y, not1.u)
                  annotation (Line(points={{-218,230},{-200,230},{-200,184},{-304,184},{-304,50},
                        {-222,50}}, color={255,0,255}));
                connect(not1.y, and2.u1)
                  annotation (Line(points={{-198,50},{-82,50}}, color={255,0,255}));
                connect(not2.y, and2.u2)
                  annotation (Line(points={{-198,10},{-180,10},{-180,42},{-82,42}},
                    color={255,0,255}));
                connect(conVal.u_m, TDis) annotation (Line(points={{44,-92},{44,-124},{-308,-124},
                        {-308,130},{-340,130}}, color={0,0,127}));
                connect(hys7.y, swi2.u2)
                  annotation (Line(points={{-58,-250},{78,-250}}, color={255,0,255}));
                connect(unOcc.y, isUno.u1)
                  annotation (Line(points={{192,-312},{218,-312}}, color={255,127,0}));
                connect(isUno.u2, uOpeMod) annotation (Line(points={{218,-320},{200,-320},{200,
                        -350},{-340,-350}}, color={255,127,0}));
                connect(isUno.y, watValPosUno.u2) annotation (Line(points={{242,-312},{266,-312},
                        {266,-20},{278,-20}}, color={255,0,255}));
                connect(conZer2.y, watValPosUno.u1) annotation (Line(points={{-58,8},{-20,8},{
                        -20,-12},{278,-12}},  color={0,0,127}));
                connect(watValPosUno.y, yHeaVal)
                  annotation (Line(points={{302,-20},{340,-20}}, color={0,0,127}));
                connect(conZer2.y, damPosUno.u1) annotation (Line(points={{-58,8},{-20,8},{-20,
                        -12},{250,-12},{250,78},{278,78}}, color={0,0,127}));
                connect(conDam.y, damPosUno.u3) annotation (Line(points={{302,230},{310,230},{
                        310,100},{272,100},{272,62},{278,62}}, color={0,0,127}));
                connect(damPosUno.y, yDam) annotation (Line(points={{302,70},{308,70},{308,40},
                        {340,40}}, color={0,0,127}));
                connect(isUno.y, damPosUno.u2) annotation (Line(points={{242,-312},{266,-312},
                        {266,70},{278,70}}, color={255,0,255}));
                connect(isUno.y, not5.u) annotation (Line(points={{242,-312},{266,-312},{266,-280},
                        {180,-280},{180,-250},{198,-250}}, color={255,0,255}));
                connect(not5.y, conDam.trigger) annotation (Line(points={{222,-250},{232,-250},
                        {232,176},{284,176},{284,218}}, color={255,0,255}));
                connect(truHol2.y, or2.u2) annotation (Line(points={{-200,-210},{-88,-210},{-88,
                        -62},{-70,-62}},     color={255,0,255}));
                connect(truDel3.y, not3.u)
                  annotation (Line(points={{-138,130},{-122,130}}, color={255,0,255}));
                connect(not3.y, or2.u1) annotation (Line(points={{-98,130},{-88,130},{-88,-54},
                        {-70,-54}}, color={255,0,255}));
                connect(or2.y, swi6.u2) annotation (Line(points={{-46,-54},{-40,-54},{-40,-80},
                        {-32,-80}}, color={255,0,255}));
                connect(conTDisHeaSet.y, swi6.u1)
                  annotation (Line(points={{-98,-72},{-32,-72}}, color={0,0,127}));
                connect(swi6.u3, lowDisAirTem.y) annotation (Line(points={{-32,-88},{-40,-88},
                        {-40,-98},{-46,-98}}, color={0,0,127}));
                connect(swi3.y, watValPosUno.u3) annotation (Line(points={{126,-72},{200,-72},
                        {200,-28},{278,-28}}, color={0,0,127}));
                connect(truHol2.y, not6.u) annotation (Line(points={{-200,-210},{-60,-210},{-60,
                        -182},{-42,-182}}, color={255,0,255}));
                connect(not6.y, and1.u2) annotation (Line(points={{-18,-182},{0,-182},{0,-54},
                        {18,-54}},color={255,0,255}));
                connect(and1.y, swi3.u2) annotation (Line(points={{42,-46},{64,-46},{64,-72},{
                        102,-72}}, color={255,0,255}));
                connect(conVal.y, swi3.u3)
                  annotation (Line(points={{56,-80},{102,-80}},   color={0,0,127}));
                connect(swi3.u1, conZer2.y) annotation (Line(points={{102,-64},{76,-64},{76,-12},
                        {-20,-12},{-20,8},{-58,8}}, color={0,0,127}));
                connect(not3.y, and1.u1) annotation (Line(points={{-98,130},{0,130},{0,-46},{18,
                        -46}}, color={255,0,255}));
                connect(not4.y, truDel3.u)
                  annotation (Line(points={{-180,130},{-162,130}}, color={255,0,255}));
                connect(not5.y, conVal.trigger) annotation (Line(points={{222,-250},{232,-250},
                        {232,-132},{38,-132},{38,-92}},  color={255,0,255}));
                connect(swi6.y, conVal.u_s)
                  annotation (Line(points={{-8,-80},{32,-80}},   color={0,0,127}));
                connect(swi1.y, add4.u1) annotation (Line(points={{154,50},{168,50},{168,56},{
                        178,56}}, color={0,0,127}));
                connect(swi4.y, add4.u2) annotation (Line(points={{162,-250},{170,-250},{170,44},
                        {178,44}}, color={0,0,127}));
                connect(swi.y, add3.u1) annotation (Line(points={{162,270},{180,270},{180,266},
                        {198,266}}, color={0,0,127}));
                connect(add4.y, add3.u2) annotation (Line(points={{202,50},{220,50},{220,80},{
                        180,80},{180,254},{198,254}}, color={0,0,127}));
                connect(add3.y, VDisSet_flow)
                  annotation (Line(points={{222,260},{340,260}}, color={0,0,127}));
                connect(VDis_flow, VDis_flowNor.u1) annotation (Line(points={{-340,340},{190,340},
                        {190,166},{238,166}}, color={0,0,127}));
                connect(nomFlow.y, VDis_flowNor.u2) annotation (Line(points={{222,210},{230,210},
                        {230,154},{238,154}}, color={0,0,127}));
                connect(VDis_flowNor.y, conDam.u_m)
                  annotation (Line(points={{262,160},{290,160},{290,218}}, color={0,0,127}));
                connect(nomFlow.y, VDisSet_flowNor.u2) annotation (Line(points={{222,210},{230,
                        210},{230,224},{238,224}},                     color={0,0,127}));
                connect(add3.y, VDisSet_flowNor.u1) annotation (Line(points={{222,260},{230,260},
                        {230,236},{238,236}}, color={0,0,127}));
                connect(VDisSet_flowNor.y, conDam.u_s)
                  annotation (Line(points={{262,230},{278,230}}, color={0,0,127}));
                connect(VDisSet_flowNor.y, gai.u) annotation (Line(points={{262,230},{270,230},
                        {270,180},{210,180},{210,130},{238,130}}, color={0,0,127}));
                connect(gai.y, damPosUno.u3) annotation (Line(points={{262,130},{272,130},{
                        272,62},{278,62}},
                                       color={0,0,127}));

              annotation (
                defaultComponentName="damVal",
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-320,-360},{320,360}}),
                      graphics={
                      Rectangle(
                        extent={{-298,318},{158,182}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-298,-22},{158,-118}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-298,158},{158,102}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-298,72},{158,-4}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-298,-162},{158,-338}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{-40,318},{154,280}},
                        lineColor={0,0,127},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Active airflow setpoint
in cooling state"),   Text(
                        extent={{32,136},{216,104}},
                        lineColor={0,0,127},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Left,
                        textString="Override if TDis is lower than TDisMin
(e.g., AHU overcools)"),
                      Text(
                        extent={{-52,42},{154,0}},
                        lineColor={0,0,127},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Active airflow setpoint
in deadband state"),  Text(
                        extent={{88,-26},{150,-44}},
                        lineColor={0,0,127},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Valve control"),
                      Text(
                        extent={{-44,-164},{154,-200}},
                        lineColor={0,0,127},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Active airflow setpoint
in heating state")}),
                Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                     graphics={
                      Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-100,140},{100,100}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Text(
                        extent={{-98,68},{-62,54}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActCooMax_flow"),
                      Text(
                        extent={{-98,88},{-62,74}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActCooMin_flow"),
                      Text(
                        extent={{-98,-76},{-60,-90}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActHeaMax_flow"),
                      Text(
                        extent={{-98,-54},{-62,-66}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActHeaMin_flow"),
                      Text(
                        extent={{-98,44},{-70,38}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActMin_flow"),
                      Text(
                        extent={{-100,102},{-80,96}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uCoo"),
                      Text(
                        extent={{-100,-18},{-80,-24}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uHea"),
                      Text(
                        extent={{-100,2},{-76,-4}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="THeaSet"),
                      Text(
                        extent={{-100,24},{-80,16}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TSup"),
                      Text(
                        extent={{-11.5,3.5},{11.5,-3.5}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TDis",
                        origin={-41.5,-89.5},
                        rotation=90),
                      Text(
                        extent={{-100,-36},{-80,-42}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZon"),
                      Text(
                        visible=not have_pressureIndependentDamper,
                        extent={{-11.5,4.5},{11.5,-4.5}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        origin={39.5,-85.5},
                        rotation=90,
                        textString="VDis_flow"),
                      Text(
                        extent={{72,44},{98,34}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="yDam",
                        horizontalAlignment=TextAlignment.Right),
                      Text(
                        extent={{66,-34},{98,-48}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        textString="yHeaVal"),
                      Line(points={{-50,64},{-50,-48},{62,-48}}, color={95,95,95}),
                      Line(
                        points={{-50,14},{-26,-18},{-2,-18},{-2,-22},{14,-22},{14,-16},{62,48}},
                        color={0,0,255},
                        thickness=0.5),
                      Line(
                        points={{-2,-22},{-2,-48}},
                        color={215,215,215},
                        pattern=LinePattern.Dash),
                      Line(
                        points={{-26,-18},{-26,36}},
                        color={215,215,215},
                        pattern=LinePattern.Dash),
                      Line(
                        points={{-26,36},{-50,36}},
                        color={95,95,95},
                        thickness=0.5),
                      Line(
                        points={{-26,36},{-2,-48}},
                        color={95,95,95},
                        thickness=0.5),
                  Polygon(
                    points={{-64,-58},{-42,-52},{-42,-64},{-64,-58}},
                    lineColor={95,95,95},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-2,-58},{-60,-58}}, color={95,95,95}),
                  Line(points={{16,-58},{78,-58}},  color={95,95,95}),
                  Polygon(
                    points={{80,-58},{58,-52},{58,-64},{80,-58}},
                    lineColor={95,95,95},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                      Text(
                        extent={{60,88},{98,76}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        textString="VDisSet_flow"),
                      Text(
                        extent={{60,-74},{98,-86}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        textString="TDisHeaSet"),
                      Text(
                        extent={{-98,-96},{-78,-102}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uOpeMod")}),
                Documentation(info="<html>
<p>
This sequence sets the damper and valve position for VAV reheat terminal unit.
The implementation is according to ASHRAE Guideline 36 (G36), PART 5.E.6. The
calculation is done following the steps below.
</p>
<ol>
<li>
<p>
When the zone state is cooling (<code>uCoo>0</code>), then the cooling loop output
<code>uCoo</code> shall be mapped to the airflow
setpoint from the cooling minimum <code>VActCooMin_flow</code> to the cooling maximum
<code>VActCooMax_flow</code> airflow setpoints. The hot water valve is closed (<code>yHeaVal=0</code>)
unless the discharge air temperature <code>TDis</code> is below the minimum
setpoint (10 &deg;C).</p>
</li>
<li>
<p>If supply air temperature <code>TSup</code> from the AHU is greater than
room temperature <code>TZon</code>, cooling supply airflow setpoint shall be
no higher than the minimum.
</p>
</li>
<li>
<p>
When the zone state is Deadband (<code>uCoo=0</code> and <code>uHea=0</code>), then
the active airflow setpoint shall be the minimum airflow setpoint <code>VActMin_flow</code>.
Hot water valve is closed unless the discharge air temperature is below the minimum
setpoint (10 &deg;C).
</p>
</li>
<li>
<p>
When the zone state is Heating (<code>uHea>0</code>), then
the heating loop shall maintain space temperature at the heating setpoint
as follows:</p>
<ul>
<li>From 0-50%, the heating loop output <code>uHea</code> shall reset the
discharge temperature setpoint from current AHU SAT setpoint <code>TSup</code>
to a maximum of <code>dTDisZonSetMax</code> above space temperature setpoint. The airflow
setpoint shall be the heating minimum <code>VActHeaMin_flow</code>.</li>
<li>From 50-100%, if the discharge air temperature <code>TDis</code> is
greater than room temperature plus 2.8 Kelvin, the heating loop output <code>uHea</code>
shall reset the airflow setpoint from the heating minimum airflow setpoint
<code>VActHeaMin_flow</code> to the heating maximum airflow setpoint
<code>VActHeaMax_flow</code>.</li>
</ul>
</li>
<li>
<p>The hot water valve (or modulating electric heating coil) shall be modulated
to maintain the discharge temperature at setpoint.
</p>
</li>
<li>
<p>
The VAV damper shall be modulated by a control loop to maintain the measured
airflow at the active setpoint.
</p>
</li>
</ol>

<p>The sequences of controlling damper and valve position for VAV reheat terminal
unit are described in the following figure below.</p>
<p align=\"center\">
<img alt=\"Image of damper and valve control for VAV reheat terminal unit\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Reheat/DamperValves.png\"/>
</p>
</html>",               revisions="<html>
<ul>
<li>
April 18, 2020, by Jianjun Hu:<br/>
Added option to check if the VAV damper is pressure independent.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1873\">#1873</a>.
</li>
<li>
March 11, 2020, by Jianjun Hu:<br/>
Replaced multisum block with add blocks, replaced gain block used for normalization
with division block.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1830\">#1830</a>.
</li>
<li>
September 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end DamperValves;

              block SystemRequests
                "Output system requests for VAV reheat terminal unit control"

                parameter Real samplePeriod(
                  final unit="s",
                  final quantity="Time")=120
                  "Sample period of component, set to the same value as the trim and respond that process yPreSetReq";

                parameter Boolean have_heaWatCoi
                  "Flag, true if there is a hot water coil";
                parameter Boolean have_heaPla "Flag, true if there is a boiler plant";

                parameter Real errTZonCoo_1(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=2.8
                  "Limit value of difference between zone temperature and cooling setpoint
    for generating 3 cooling SAT reset requests";
                parameter Real errTZonCoo_2(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=1.7
                  "Limit value of difference between zone temperature and cooling setpoint
    for generating 2 cooling SAT reset requests";
                parameter Real errTDis_1(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=17
                  "Limit value of difference between discharge air temperature and its setpoint
    for generating 3 hot water reset requests";
                parameter Real errTDis_2(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=8.3
                  "Limit value of difference between discharge air temperature and its setpoint
    for generating 2 hot water reset requests";

                parameter Real durTimTem(
                  final unit="s",
                  final quantity="Time")=120
                  "Duration time of zone temperature exceeds setpoint"
                  annotation(Dialog(group="Duration times"));
                parameter Real durTimFlo(
                  final unit="s",
                  final quantity="Time")=60
                  "Duration time of airflow rate less than setpoint"
                  annotation(Dialog(group="Duration times"));
                parameter Real durTimDisAir(
                  final unit="s",
                  final quantity="Time")=300
                  "Duration time of discharge air temperature is less than setpoint"
                  annotation(Dialog(group="Duration times"));

                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZon(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone temperature"
                  annotation (Placement(transformation(extent={{-220,150},{-180,190}}),
                      iconTransformation(extent={{-140,40},{-100,80}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonCooSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone cooling setpoint temperature"
                  annotation (Placement(transformation(extent={{-220,420},{-180,460}}),
                      iconTransformation(extent={{-140,60},{-100,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput uCoo(
                  final min=0,
                  final max=1,
                  final unit="1")
                  "Cooling loop signal"
                  annotation (Placement(transformation(extent={{-220,70},{-180,110}}),
                      iconTransformation(extent={{-140,20},{-100,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VDis_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Measured discharge airflow rate"
                  annotation (Placement(transformation(extent={{-220,-90},{-180,-50}}),
                      iconTransformation(extent={{-140,-20},{-100,20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput VDisSet_flow(
                  final min=0,
                  final unit="m3/s",
                  quantity="VolumeFlowRate")
                  "Discharge airflow rate setpoint"
                  annotation (Placement(transformation(extent={{-220,10},{-180,50}}),
                      iconTransformation(extent={{-140,0},{-100,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput yDam_actual(
                  final min=0,
                  final max=1,
                  final unit="1") "Actual damper position"
                  annotation (Placement(transformation(extent={{-220,-170},{-180,-130}}),
                      iconTransformation(extent={{-140,-40},{-100,0}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TDisHeaSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if have_heaWatCoi
                  "Discharge airflow setpoint temperature for heating"
                  annotation (Placement(transformation(extent={{-220,-230},{-180,-190}}),
                      iconTransformation(extent={{-140,-60},{-100,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TDis(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if have_heaWatCoi
                  "Measured discharge airflow temperature"
                  annotation (Placement(transformation(extent={{-220,-310},{-180,-270}}),
                      iconTransformation(extent={{-140,-80},{-100,-40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput uHeaVal(
                  final min=0,
                  final max=1,
                  final unit="1") if have_heaWatCoi "Heating valve position"
                  annotation (Placement(transformation(extent={{-220,-370},{-180,-330}}),
                      iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yZonPreResReq
                  "Zone static pressure reset requests"
                  annotation (Placement(transformation(extent={{180,-60},{220,-20}}),
                      iconTransformation(extent={{100,0},{140,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yZonTemResReq
                  "Zone cooling supply air temperature reset request"
                  annotation (Placement(transformation(extent={{180,180},{220,220}}),
                      iconTransformation(extent={{100,50},{140,90}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yHeaValResReq if have_heaWatCoi
                  "Hot water reset requests"
                  annotation (Placement(transformation(extent={{180,-260},{220,-220}}),
                      iconTransformation(extent={{100,-60},{140,-20}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yHeaPlaReq if (have_heaWatCoi and have_heaPla)
                  "Heating plant request"
                  annotation (Placement(transformation(extent={{180,-450},{220,-410}}),
                      iconTransformation(extent={{100,-110},{140,-70}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys(
                  final uLow=errTZonCoo_1 - 0.1,
                  final uHigh=errTZonCoo_1 + 0.1)
                  "Check if zone temperature is greater than cooling setpoint by errTZonCoo_1"
                  annotation (Placement(transformation(extent={{-60,190},{-40,210}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys3(
                  final uLow=errTZonCoo_2 - 0.1,
                  final uHigh=errTZonCoo_2 + 0.1)
                  "Check if zone temperature is greater than cooling setpoint by errTZonCoo_2"
                  annotation (Placement(transformation(extent={{-60,130},{-40,150}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys4(
                  final uLow=0.85,
                  final uHigh=0.95)
                  "Check if damper position is greater than 0.95"
                  annotation (Placement(transformation(extent={{-60,-160},{-40,-140}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys5(
                  final uLow=0.85,
                  final uHigh=0.95)
                  "Check if cooling loop signal is greater than 0.95"
                  annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys7(
                  final uHigh=0.01,
                  final uLow=0.005)
                  "Check if discharge airflow setpoint is greater than 0"
                  annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys8(
                  final uLow=-0.1,
                  final uHigh=0.1) if have_heaWatCoi
                  "Check if discharge air temperature is errTDis_1 less than setpoint"
                  annotation (Placement(transformation(extent={{-40,-250},{-20,-230}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys9(
                  final uLow=-0.1,
                  final uHigh=0.1) if have_heaWatCoi
                  "Check if discharge air temperature is errTDis_2 less than setpoint"
                  annotation (Placement(transformation(extent={{-40,-310},{-20,-290}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys10(
                  final uLow=0.85,
                  final uHigh=0.95) if have_heaWatCoi
                  "Check if valve position is greater than 0.95"
                  annotation (Placement(transformation(extent={{-140,-360},{-120,-340}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys11(
                  final uHigh=0.95,
                  final uLow=0.1) if (have_heaWatCoi and have_heaPla)
                  "Check if valve position is greater than 0.95"
                  annotation (Placement(transformation(extent={{-140,-440},{-120,-420}})));

            protected
                Buildings.Controls.OBC.CDL.Discrete.Sampler samTZonCooSet(
                  final samplePeriod=samplePeriod)
                  "Sample current cooling setpoint"
                  annotation (Placement(transformation(extent={{-160,430},{-140,450}})));
                Buildings.Controls.OBC.CDL.Discrete.UnitDelay uniDel(
                  final samplePeriod=samplePeriod)
                  "Delay value to record input value"
                  annotation (Placement(transformation(extent={{-80,450},{-60,470}})));
                Buildings.Controls.OBC.CDL.Continuous.Abs abs "Absolute change of the setpoint temperature"
                  annotation (Placement(transformation(extent={{100,400},{120,420}})));
                Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler triSam
                  "Sample the setpoint changed value when there is change"
                  annotation (Placement(transformation(extent={{-120,270},{-100,290}})));
                Buildings.Controls.OBC.CDL.Logical.Edge edg "Instants when input becomes true"
                  annotation (Placement(transformation(extent={{-60,290},{-40,310}})));
                Buildings.Controls.OBC.CDL.Logical.Latch lat "Maintains an on signal until conditions changes"
                  annotation (Placement(transformation(extent={{-60,330},{-40,350}})));
                Buildings.Controls.OBC.CDL.Logical.Latch lat1 "Maintains an on signal until conditions changes"
                  annotation (Placement(transformation(extent={{60,260},{80,280}})));
                Buildings.Controls.OBC.CDL.Logical.Timer tim "Calculate time"
                  annotation (Placement(transformation(extent={{0,330},{20,350}})));
                Buildings.Controls.OBC.CDL.Continuous.Greater gre1
                  "Check if current model time is greater than the sample period"
                  annotation (Placement(transformation(extent={{-80,400},{-60,420}})));
                Buildings.Controls.OBC.CDL.Continuous.Hysteresis hys2(
                  final uLow=0.05,
                  final uHigh=0.15)
                  "Check if there is setpoint change"
                  annotation (Placement(transformation(extent={{-120,330},{-100,350}})));
                Buildings.Controls.OBC.CDL.Continuous.Min supTim "Suppression time"
                  annotation (Placement(transformation(extent={{0,270},{20,290}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.ModelTime modTim "Time of the model"
                  annotation (Placement(transformation(extent={{-140,400},{-120,420}})));
                Buildings.Controls.OBC.CDL.Continuous.Gain gai(final k=540)
                  "Convert change of degC to change of degF and find out suppression time (5 min/degF))"
                  annotation (Placement(transformation(extent={{-80,270},{-60,290}})));
                Buildings.Controls.OBC.CDL.Continuous.Gain gai1(final k=0.5) "50% of setpoint"
                  annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
                Buildings.Controls.OBC.CDL.Continuous.Gain gai2(final k=0.7) "70% of setpoint"
                  annotation (Placement(transformation(extent={{-100,-98},{-80,-78}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1(final k1=-1)
                  "Calculate difference of previous and current setpoints"
                  annotation (Placement(transformation(extent={{-20,430},{0,450}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2(final k1=-1)
                  "Calculate difference between zone temperature and cooling setpoint"
                  annotation (Placement(transformation(extent={{-100,190},{-80,210}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add3(final k1=-1)
                  "Calculate difference between zone temperature and cooling setpoint"
                  annotation (Placement(transformation(extent={{-100,130},{-80,150}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add6(final k2=-1) if have_heaWatCoi
                  "Calculate difference of discharge temperature (plus errTDis_1) and its setpoint"
                  annotation (Placement(transformation(extent={{-80,-250},{-60,-230}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add7(final k2=-1) if have_heaWatCoi
                  "Calculate difference of discharge temperature (plus errTDis_2) and its setpoint"
                  annotation (Placement(transformation(extent={{-80,-310},{-60,-290}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar(
                  final k=1,
                  final p=errTDis_1) if have_heaWatCoi
                  "Discharge temperature plus errTDis_1"
                  annotation (Placement(transformation(extent={{-140,-272},{-120,-252}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar1(
                  final k=1,
                  final p=errTDis_2) if have_heaWatCoi
                  "Discharge temperature plus errTDis_2"
                  annotation (Placement(transformation(extent={{-140,-330},{-120,-310}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger reaToInt "Convert real to integer value"
                  annotation (Placement(transformation(extent={{140,190},{160,210}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger reaToInt1 "Convert real to integer value"
                  annotation (Placement(transformation(extent={{140,-50},{160,-30}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger reaToInt2 if have_heaWatCoi
                  "Convert real to integer value"
                  annotation (Placement(transformation(extent={{140,-250},{160,-230}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger reaToInt3 if (have_heaWatCoi and
                  have_heaPla)
                  "Convert real to integer value"
                  annotation (Placement(transformation(extent={{140,-440},{160,-420}})));
                Buildings.Controls.OBC.CDL.Logical.And and1 "Logical and"
                  annotation (Placement(transformation(extent={{40,130},{60,150}})));
                Buildings.Controls.OBC.CDL.Logical.And and2 "Logical and"
                  annotation (Placement(transformation(extent={{40,190},{60,210}})));
                Buildings.Controls.OBC.CDL.Logical.And and3 "Logical and"
                  annotation (Placement(transformation(extent={{40,-50},{60,-30}})));
                Buildings.Controls.OBC.CDL.Logical.And and4 "Logical and"
                  annotation (Placement(transformation(extent={{40,-110},{60,-90}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con(
                  final k=samplePeriod) "Sample period time"
                  annotation (Placement(transformation(extent={{-140,370},{-120,390}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conZer(
                  final k=0) "Constant zero"
                  annotation (Placement(transformation(extent={{-20,370},{0,390}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant thrCooResReq(
                  final k=3) "Constant 3"
                  annotation (Placement(transformation(extent={{40,220},{60,240}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant twoCooResReq(
                  final k=2) "Constant 2"
                  annotation (Placement(transformation(extent={{40,160},{60,180}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant oneCooResReq(
                  final k=1) "Constant 1"
                  annotation (Placement(transformation(extent={{40,100},{60,120}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCooReq(
                  final k=0) "Constant 0"
                  annotation (Placement(transformation(extent={{40,60},{60,80}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant thrPreResReq(
                  final k=3) "Constant 3"
                  annotation (Placement(transformation(extent={{40,-20},{60,0}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant twoPreResReq(
                  final k=2) "Constant 2"
                  annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerPreResReq(
                  final k=0) "Constant 0"
                  annotation (Placement(transformation(extent={{40,-180},{60,-160}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant onePreResReq(
                  final k=1) "Constant 1"
                  annotation (Placement(transformation(extent={{40,-140},{60,-120}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant thrHeaResReq(
                  final k=3) if have_heaWatCoi
                  "Constant 3"
                  annotation (Placement(transformation(extent={{40,-220},{60,-200}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant twoHeaResReq(
                  final k=2) if have_heaWatCoi
                  "Constant 2"
                  annotation (Placement(transformation(extent={{40,-280},{60,-260}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant oneHeaResReq(
                  final k=1) if have_heaWatCoi
                  "Constant 1"
                  annotation (Placement(transformation(extent={{40,-340},{60,-320}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerHeaResReq(
                  final k=0) if have_heaWatCoi
                  "Constant 0"
                  annotation (Placement(transformation(extent={{40,-380},{60,-360}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerBoiPlaReq(
                  final k=0) if (have_heaWatCoi
                   and have_heaPla)
                  "Constant 0"
                  annotation (Placement(transformation(extent={{40,-460},{60,-440}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant oneBoiPlaReq(
                  final k=1) if (have_heaWatCoi and have_heaPla)
                  "Constant 1"
                  annotation (Placement(transformation(extent={{40,-420},{60,-400}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxSupTim(k=1800)
                  "Maximum suppression time 30 minutes"
                  annotation (Placement(transformation(extent={{-80,240},{-60,260}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant con5(k=true) "Constant true"
                  annotation (Placement(transformation(extent={{60,290},{80,310}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi
                  "Use setpoint different value when half sample period time has passed"
                  annotation (Placement(transformation(extent={{40,400},{60,420}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi1 "Output 3 or other request "
                  annotation (Placement(transformation(extent={{100,190},{120,210}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi2 "Output 2 or other request "
                  annotation (Placement(transformation(extent={{100,130},{120,150}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi3 "Output 0 or 1 request "
                  annotation (Placement(transformation(extent={{100,80},{120,100}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi4 "Output 3 or other request "
                  annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi5 "Output 2 or other request "
                  annotation (Placement(transformation(extent={{100,-110},{120,-90}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi6 "Output 0 or 1 request "
                  annotation (Placement(transformation(extent={{100,-160},{120,-140}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi7 if have_heaWatCoi
                  "Output 3 or other request "
                  annotation (Placement(transformation(extent={{100,-250},{120,-230}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi8 if have_heaWatCoi
                  "Output 2 or other request "
                  annotation (Placement(transformation(extent={{100,-310},{120,-290}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi9 if have_heaWatCoi
                  "Output 0 or 1 request "
                  annotation (Placement(transformation(extent={{100,-360},{120,-340}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi10 if (have_heaWatCoi and
                  have_heaPla)
                  "Output 0 or 1 request "
                  annotation (Placement(transformation(extent={{100,-440},{120,-420}})));
                Buildings.Controls.OBC.CDL.Logical.TrueHoldWithReset truHol(duration=samplePeriod)
                  "Hold true signal for sample period of time"
                  annotation (Placement(transformation(extent={{120,330},{140,350}})));
                Buildings.Controls.OBC.CDL.Logical.LogicalSwitch logSwi "Logical switch"
                  annotation (Placement(transformation(extent={{120,300},{140,280}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim1(delayTime=durTimTem)
                  "Check if it is more than durTimTem"
                  annotation (Placement(transformation(extent={{-20,190},{0,210}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim2(delayTime=durTimTem)
                  "Check if it is more than durTimTem"
                  annotation (Placement(transformation(extent={{-20,130},{0,150}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim3(delayTime=durTimFlo)
                  "Check if it is more than durTimFlo"
                  annotation (Placement(transformation(extent={{-20,20},{0,40}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim4(delayTime=durTimDisAir) if have_heaWatCoi
                  "Check if it is more than durTimDisAir"
                  annotation (Placement(transformation(extent={{0,-250},{20,-230}})));
                Buildings.Controls.OBC.CDL.Logical.TrueDelay tim5(delayTime=durTimDisAir) if have_heaWatCoi
                  "Check if it is more than durTimDisAir"
                  annotation (Placement(transformation(extent={{0,-310},{20,-290}})));
                Buildings.Controls.OBC.CDL.Discrete.Sampler sampler(
                  final samplePeriod=samplePeriod)
                  "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                  annotation (Placement(transformation(extent={{-160,-50},{-140,-30}})));
                Buildings.Controls.OBC.CDL.Discrete.Sampler sampler1(
                  final samplePeriod=samplePeriod)
                  "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                  annotation (Placement(transformation(extent={{-160,-80},{-140,-60}})));
                Buildings.Controls.OBC.CDL.Discrete.Sampler sampler2(
                  final samplePeriod=samplePeriod)
                  "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                  annotation (Placement(transformation(extent={{-160,-160},{-140,-140}})));
                Buildings.Controls.OBC.CDL.Discrete.Sampler sampler4(
                  final samplePeriod=samplePeriod)
                  "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                  annotation (Placement(transformation(extent={{-160,80},{-140,100}})));
                Buildings.Controls.OBC.CDL.Continuous.Greater greVDis50
                  "Check if discharge airflow is less than 50% of setpoint"
                  annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
                Buildings.Controls.OBC.CDL.Continuous.Greater greVDis70
                  "Check if discharge airflow is less than 70% of setpoint"
                  annotation (Placement(transformation(extent={{-60,-110},{-40,-90}})));

                CDL.Continuous.Less les "Check if the suppression time has not yet passed"
                  annotation (Placement(transformation(extent={{38,330},{58,350}})));
                CDL.Logical.Not notLes "Inversion of output signal"
                  annotation (Placement(transformation(extent={{76,330},{96,350}})));
              equation
                connect(add2.y, hys.u)
                  annotation (Line(points={{-78,200},{-62,200}},   color={0,0,127}));
                connect(TZonCooSet, samTZonCooSet.u)
                  annotation (Line(points={{-200,440},{-162,440}}, color={0,0,127}));
                connect(samTZonCooSet.y, uniDel.u)
                  annotation (Line(points={{-138,440},{-100,440},{-100,460},{-82,460}},
                    color={0,0,127}));
                connect(triSam.y, gai.u)
                  annotation (Line(points={{-98,280},{-82,280}},color={0,0,127}));
                connect(hys2.y, lat.u)
                  annotation (Line(points={{-98,340},{-62,340}}, color={255,0,255}));
                connect(lat.y, tim.u)
                  annotation (Line(points={{-38,340},{-2,340}}, color={255,0,255}));
                connect(edg.y, triSam.trigger)
                  annotation (Line(points={{-38,300},{-20,300},{-20,264},{-110,264},{-110,268.2}},
                    color={255,0,255}));
                connect(lat.y, edg.u)
                  annotation (Line(points={{-38,340},{-20,340},{-20,318},{-80,318},{-80,300},
                    {-62,300}}, color={255,0,255}));
                connect(edg.y, lat1.clr)
                  annotation (Line(points={{-38,300},{-20,300},{-20,264},{58,264}}, color={255,0,255}));
                connect(modTim.y, gre1.u1)
                  annotation (Line(points={{-118,410},{-82,410}},  color={0,0,127}));
                connect(con.y, gre1.u2)
                  annotation (Line(points={{-118,380},{-100,380},{-100,402},{-82,402}},
                    color={0,0,127}));
                connect(uniDel.y, add1.u1)
                  annotation (Line(points={{-58,460},{-40,460},{-40,446},{-22,446}},
                    color={0,0,127}));
                connect(samTZonCooSet.y, add1.u2)
                  annotation (Line(points={{-138,440},{-40,440},{-40,434},{-22,434}},
                    color={0,0,127}));
                connect(gre1.y, swi.u2)
                  annotation (Line(points={{-58,410},{38,410}}, color={255,0,255}));
                connect(add1.y, swi.u1)
                  annotation (Line(points={{2,440},{20,440},{20,418},{38,418}},
                    color={0,0,127}));
                connect(conZer.y, swi.u3)
                  annotation (Line(points={{2,380},{20,380},{20,402},{38,402}}, color={0,0,127}));
                connect(swi.y, abs.u)
                  annotation (Line(points={{62,410},{98,410}},
                    color={0,0,127}));
                connect(abs.y, triSam.u)
                  annotation (Line(points={{122,410},{140,410},{140,360},{-140,360},{-140,280},
                        {-122,280}}, color={0,0,127}));
                connect(abs.y, hys2.u)
                  annotation (Line(points={{122,410},{140,410},{140,360},{-140,360},{-140,340},
                        {-122,340}}, color={0,0,127}));
                connect(and2.y, swi1.u2)
                  annotation (Line(points={{62,200},{98,200}}, color={255,0,255}));
                connect(thrCooResReq.y, swi1.u1)
                  annotation (Line(points={{62,230},{80,230},{80,208},{98,208}}, color={0,0,127}));
                connect(add3.y, hys3.u)
                  annotation (Line(points={{-78,140},{-62,140}}, color={0,0,127}));
                connect(twoCooResReq.y, swi2.u1)
                  annotation (Line(points={{62,170},{80,170},{80,148},{98,148}},
                    color={0,0,127}));
                connect(swi2.y, swi1.u3)
                  annotation (Line(points={{122,140},{140,140},{140,180},{80,180},{80,192},{98,
                        192}}, color={0,0,127}));
                connect(and1.y, swi2.u2)
                  annotation (Line(points={{62,140},{98,140}}, color={255,0,255}));
                connect(hys5.y, swi3.u2)
                  annotation (Line(points={{-38,90},{98,90}}, color={255,0,255}));
                connect(oneCooResReq.y, swi3.u1)
                  annotation (Line(points={{62,110},{80,110},{80,98},{98,98}},
                    color={0,0,127}));
                connect(swi3.y, swi2.u3)
                  annotation (Line(points={{122,90},{140,90},{140,120},{80,120},{80,132},{98,132}},
                               color={0,0,127}));
                connect(zerCooReq.y, swi3.u3)
                  annotation (Line(points={{62,70},{80,70},{80,82},{98,82}},
                    color={0,0,127}));
                connect(swi1.y, reaToInt.u)
                  annotation (Line(points={{122,200},{138,200}}, color={0,0,127}));
                connect(reaToInt.y, yZonTemResReq)
                  annotation (Line(points={{162,200},{200,200}}, color={255,127,0}));
                connect(and3.y, swi4.u2)
                  annotation (Line(points={{62,-40},{98,-40}}, color={255,0,255}));
                connect(thrPreResReq.y, swi4.u1)
                  annotation (Line(points={{62,-10},{80,-10},{80,-32},{98,-32}},
                    color={0,0,127}));
                connect(and4.y, swi5.u2)
                  annotation (Line(points={{62,-100},{98,-100}}, color={255,0,255}));
                connect(twoPreResReq.y, swi5.u1)
                  annotation (Line(points={{62,-70},{80,-70},{80,-92},{98,-92}},
                    color={0,0,127}));
                connect(swi5.y, swi4.u3)
                  annotation (Line(points={{122,-100},{140,-100},{140,-60},{80,-60},{80,-48},{
                        98,-48}},
                               color={0,0,127}));
                connect(hys4.y, swi6.u2)
                  annotation (Line(points={{-38,-150},{98,-150}},  color={255,0,255}));
                connect(onePreResReq.y, swi6.u1)
                  annotation (Line(points={{62,-130},{80,-130},{80,-142},{98,-142}},
                    color={0,0,127}));
                connect(zerPreResReq.y, swi6.u3)
                  annotation (Line(points={{62,-170},{80,-170},{80,-158},{98,-158}},
                    color={0,0,127}));
                connect(swi6.y, swi5.u3)
                  annotation (Line(points={{122,-150},{140,-150},{140,-120},{80,-120},{80,-108},
                        {98,-108}},
                                color={0,0,127}));
                connect(swi4.y, reaToInt1.u)
                  annotation (Line(points={{122,-40},{138,-40}}, color={0,0,127}));
                connect(reaToInt1.y, yZonPreResReq)
                  annotation (Line(points={{162,-40},{200,-40}}, color={255,127,0}));
                connect(TDis, addPar.u)
                  annotation (Line(points={{-200,-290},{-160,-290},{-160,-262},{-142,-262}},
                    color={0,0,127}));
                connect(addPar.y, add6.u2)
                  annotation (Line(points={{-118,-262},{-108,-262},{-108,-246},{-82,-246}},
                    color={0,0,127}));
                connect(TDisHeaSet, add6.u1)
                  annotation (Line(points={{-200,-210},{-100,-210},{-100,-234},{-82,-234}},
                    color={0,0,127}));
                connect(add6.y, hys8.u)
                  annotation (Line(points={{-58,-240},{-42,-240}}, color={0,0,127}));
                connect(addPar1.y, add7.u2)
                  annotation (Line(points={{-118,-320},{-108,-320},{-108,-306},{-82,-306}},
                    color={0,0,127}));
                connect(add7.y, hys9.u)
                  annotation (Line(points={{-58,-300},{-42,-300}}, color={0,0,127}));
                connect(hys9.y, tim5.u)
                  annotation (Line(points={{-18,-300},{-2,-300}}, color={255,0,255}));
                connect(thrHeaResReq.y, swi7.u1)
                  annotation (Line(points={{62,-210},{80,-210},{80,-232},{98,-232}},
                    color={0,0,127}));
                connect(twoHeaResReq.y, swi8.u1)
                  annotation (Line(points={{62,-270},{80,-270},{80,-292},{98,-292}},
                    color={0,0,127}));
                connect(swi8.y, swi7.u3)
                  annotation (Line(points={{122,-300},{140,-300},{140,-260},{80,-260},{80,-248},
                        {98,-248}},
                                color={0,0,127}));
                connect(TDis, addPar1.u)
                  annotation (Line(points={{-200,-290},{-160,-290},{-160,-320},{-142,-320}},
                    color={0,0,127}));
                connect(TDisHeaSet, add7.u1)
                  annotation (Line(points={{-200,-210},{-100,-210},{-100,-294},{-82,-294}},
                    color={0,0,127}));
                connect(uHeaVal, hys10.u)
                  annotation (Line(points={{-200,-350},{-142,-350}}, color={0,0,127}));
                connect(hys10.y, swi9.u2)
                  annotation (Line(points={{-118,-350},{98,-350}}, color={255,0,255}));
                connect(oneHeaResReq.y, swi9.u1)
                  annotation (Line(points={{62,-330},{80,-330},{80,-342},{98,-342}},
                    color={0,0,127}));
                connect(zerHeaResReq.y, swi9.u3)
                  annotation (Line(points={{62,-370},{80,-370},{80,-358},{98,-358}},
                    color={0,0,127}));
                connect(swi9.y, swi8.u3)
                  annotation (Line(points={{122,-350},{140,-350},{140,-320},{80,-320},{80,-308},
                        {98,-308}},
                                color={0,0,127}));
                connect(swi7.y, reaToInt2.u)
                  annotation (Line(points={{122,-240},{138,-240}}, color={0,0,127}));
                connect(reaToInt2.y, yHeaValResReq)
                  annotation (Line(points={{162,-240},{200,-240}}, color={255,127,0}));
                connect(uHeaVal, hys11.u)
                  annotation (Line(points={{-200,-350},{-160,-350},{-160,-430},{-142,-430}},
                    color={0,0,127}));
                connect(hys11.y, swi10.u2)
                  annotation (Line(points={{-118,-430},{98,-430}}, color={255,0,255}));
                connect(oneBoiPlaReq.y, swi10.u1)
                  annotation (Line(points={{62,-410},{80,-410},{80,-422},{98,-422}},
                    color={0,0,127}));
                connect(zerBoiPlaReq.y, swi10.u3)
                  annotation (Line(points={{62,-450},{80,-450},{80,-438},{98,-438}},
                    color={0,0,127}));
                connect(swi10.y, reaToInt3.u)
                  annotation (Line(points={{122,-430},{138,-430}}, color={0,0,127}));
                connect(reaToInt3.y,yHeaPlaReq)
                  annotation (Line(points={{162,-430},{200,-430}}, color={255,127,0}));
                connect(truHol.y, lat.clr)
                  annotation (Line(points={{142,340},{160,340},{160,320},{-80,320},{-80,334},{
                        -62,334}},        color={255,0,255}));
                connect(lat.y, logSwi.u2)
                  annotation (Line(points={{-38,340},{-20,340},{-20,318},{100,318},{100,290},{
                        118,290}},
                                color={255,0,255}));
                connect(con5.y, logSwi.u3)
                  annotation (Line(points={{82,300},{104,300},{104,298},{118,298}},
                    color={255,0,255}));
                connect(lat1.y, logSwi.u1)
                  annotation (Line(points={{82,270},{100,270},{100,282},{118,282}},
                    color={255,0,255}));
                connect(logSwi.y, and2.u1)
                  annotation (Line(points={{142,290},{160,290},{160,258},{20,258},{20,200},{38,
                        200}}, color={255,0,255}));
                connect(logSwi.y, and1.u1)
                  annotation (Line(points={{142,290},{160,290},{160,258},{20,258},{20,140},{38,
                        140}}, color={255,0,255}));
                connect(gai.y, supTim.u1)
                  annotation (Line(points={{-58,280},{-40,280},{-40,286},{-2,286}},
                    color={0,0,127}));
                connect(maxSupTim.y, supTim.u2)
                  annotation (Line(points={{-58,250},{-40,250},{-40,274},{-2,274}},
                    color={0,0,127}));
                connect(tim5.y, swi8.u2)
                  annotation (Line(points={{22,-300},{98,-300}}, color={255,0,255}));
                connect(hys8.y, tim4.u)
                  annotation (Line(points={{-18,-240},{-2,-240}}, color={255,0,255}));
                connect(tim4.y, swi7.u2)
                  annotation (Line(points={{22,-240},{98,-240}}, color={255,0,255}));
                connect(hys7.y, tim3.u)
                  annotation (Line(points={{-38,30},{-22,30}},  color={255,0,255}));
                connect(tim3.y, and3.u1)
                  annotation (Line(points={{2,30},{20,30},{20,-40},{38,-40}},
                    color={255,0,255}));
                connect(tim3.y, and4.u1)
                  annotation (Line(points={{2,30},{20,30},{20,-100},{38,-100}},
                    color={255,0,255}));
                connect(hys3.y, tim2.u)
                  annotation (Line(points={{-38,140},{-22,140}}, color={255,0,255}));
                connect(tim2.y, and1.u2)
                  annotation (Line(points={{2,140},{12,140},{12,132},{38,132}},
                    color={255,0,255}));
                connect(hys.y, tim1.u)
                  annotation (Line(points={{-38,200},{-22,200}}, color={255,0,255}));
                connect(tim1.y, and2.u2)
                  annotation (Line(points={{2,200},{10,200},{10,192},{38,192}},
                    color={255,0,255}));
                connect(sampler.u, VDisSet_flow)
                  annotation (Line(points={{-162,-40},{-170,-40},{-170,30},{-200,30}},
                    color={0,0,127}));
                connect(sampler.y, gai1.u)
                  annotation (Line(points={{-138,-40},{-102,-40}}, color={0,0,127}));
                connect(sampler.y, gai2.u)
                  annotation (Line(points={{-138,-40},{-128,-40},{-128,-88},{-102,-88}},
                    color={0,0,127}));
                connect(sampler1.u, VDis_flow)
                  annotation (Line(points={{-162,-70},{-200,-70}}, color={0,0,127}));
                connect(yDam_actual, sampler2.u)
                  annotation (Line(points={{-200,-150},{-162,-150}}, color={0,0,127}));
                connect(sampler2.y, hys4.u)
                  annotation (Line(points={{-138,-150},{-62,-150}},  color={0,0,127}));
                connect(uCoo, sampler4.u)
                  annotation (Line(points={{-200,90},{-162,90}}, color={0,0,127}));
                connect(sampler4.y, hys5.u)
                  annotation (Line(points={{-138,90},{-62,90}}, color={0,0,127}));
                connect(samTZonCooSet.y, add2.u1)
                  annotation (Line(points={{-138,440},{-128,440},{-128,426},{-150,426},{-150,206},
                        {-102,206}},        color={0,0,127}));
                connect(samTZonCooSet.y, add3.u1)
                  annotation (Line(points={{-138,440},{-128,440},{-128,426},{-150,426},{-150,206},
                        {-112,206},{-112,146},{-102,146}},        color={0,0,127}));
                connect(hys7.u, VDisSet_flow)
                  annotation (Line(points={{-62,30},{-200,30}}, color={0,0,127}));
                connect(add2.u2, TZon)
                  annotation (Line(points={{-102,194},{-150,194},{-150,170},{-200,170}},
                    color={0,0,127}));
                connect(add3.u2, TZon)
                  annotation (Line(points={{-102,134},{-150,134},{-150,170},{-200,170}},
                    color={0,0,127}));
                connect(greVDis50.u1, gai1.y)
                  annotation (Line(points={{-62,-40},{-78,-40}}, color={0,0,127}));
                connect(greVDis50.u2, sampler1.y) annotation (Line(points={{-62,-48},{-72,-48},
                        {-72,-70},{-138,-70}}, color={0,0,127}));
                connect(greVDis50.y, and3.u2) annotation (Line(points={{-38,-40},{0,-40},{0,-48},
                        {38,-48}}, color={255,0,255}));
                connect(gai2.y, greVDis70.u1) annotation (Line(points={{-78,-88},{-76,-88},{-76,
                        -100},{-62,-100}}, color={0,0,127}));
                connect(sampler1.y, greVDis70.u2) annotation (Line(points={{-138,-70},{-132,-70},
                        {-132,-108},{-62,-108}}, color={0,0,127}));
                connect(greVDis70.y, and4.u2) annotation (Line(points={{-38,-100},{0,-100},{0,
                        -108},{38,-108}}, color={255,0,255}));

                connect(tim.y, les.u1)
                  annotation (Line(points={{22,340},{36,340}}, color={0,0,127}));
                connect(supTim.y, les.u2) annotation (Line(points={{22,280},{32,280},{32,332},
                        {36,332}}, color={0,0,127}));
                connect(notLes.y, truHol.u)
                  annotation (Line(points={{98,340},{118,340}}, color={255,0,255}));
                connect(lat1.u, notLes.y) annotation (Line(points={{58,270},{46,270},{46,326},
                        {108,326},{108,340},{98,340}}, color={255,0,255}));
                connect(les.y, notLes.u)
                  annotation (Line(points={{60,340},{74,340}}, color={255,0,255}));
              annotation (
                defaultComponentName="sysReqRehBox",
                Diagram(coordinateSystem(preserveAspectRatio=
                          false, extent={{-180,-460},{180,480}}),
                    graphics={
                      Rectangle(
                        extent={{-158,478},{158,262}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-158,238},{158,62}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-158,38},{158,-178}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-158,-202},{158,-378}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-158,-402},{158,-458}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{18,480},{140,456}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Time-based suppression"),
                      Text(
                        extent={{-150,82},{-28,58}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Cooling SAT reset requests"),
                      Text(
                        extent={{-152,-156},{-8,-184}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Static pressure reset requests"),
                      Text(
                        extent={{-152,-360},{-26,-380}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Hot water reset requests"),
                      Text(
                        extent={{-150,-440},{-12,-462}},
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Boiler plant reset requests")}),
                   Icon(graphics={
                      Text(
                        extent={{-100,140},{100,100}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-98,90},{-62,76}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonCooSet"),
                      Text(
                        extent={{-100,66},{-72,56}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZon"),
                      Text(
                        extent={{-100,46},{-72,36}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uCoo"),
                      Text(
                        extent={{-98,30},{-52,14}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VDisSet_flow"),
                      Text(
                        extent={{-98,6},{-64,-4}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VDis_flow"),
                      Text(
                        extent={{-98,-14},{-70,-24}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="uDam"),
                      Text(
                        extent={{-98,-32},{-52,-48}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        visible = (have_heaWatCoi or have_heaPla),
                        textString="TDisHeaSet"),
                      Text(
                        extent={{-98,-56},{-64,-66}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        visible = (have_heaWatCoi or have_heaPla),
                        textString="TDis"),
                      Text(
                        extent={{-98,-76},{-64,-86}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        visible = (have_heaWatCoi or have_heaPla),
                        textString="uHeaVal"),
                      Text(
                        extent={{42,82},{98,62}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        textString="yZonTemResReq"),
                      Text(
                        extent={{42,32},{98,12}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        textString="yZonPreResReq"),
                      Text(
                        extent={{42,-28},{98,-48}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        visible = have_heaWatCoi,
                        textString="yHeaValResReq"),
                      Text(
                        extent={{58,-84},{98,-100}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        horizontalAlignment=TextAlignment.Right,
                        visible = (have_heaWatCoi or have_heaPla),
                        textString="yHeaPlaReq")}),
                Documentation(info="<html>
<p>
This sequence outputs the system reset requests, i.e.,
</p>
<ul>
<li>
the cooling supply air temperature
reset requests <code>yZonTemResReq</code>,
</li>
<li>
the static pressure reset requests
<code>yZonPreResReq</code>,
</li>
<li>
the hot water reset requests <code>yHeaValResReq</code>, and
</li>
<li>
the boiler plant reset requests <code>yHeaPlaReq</code>.
</li>
</ul>
<p>
The calculations are according to ASHRAE
Guideline 36 (G36), PART 5.E.9, in the steps shown below.
</p>
<h4>a. Cooling SAT reset requests <code>yZonTemResReq</code></h4>
<ol>
<li>
If the zone temperature <code>TZon</code> exceeds the zone cooling setpoint
<code>TZonCooSet</code> by 2.8 &deg;C (5 &deg;F)) for 2 minutes and after suppression
period due to setpoint change per G36 Part 5.A.20, send 3 requests
(<code>yZonTemResReq=3</code>).
</li>
<li>
Else if the zone temperature <code>TZon</code> exceeds the zone cooling setpoint
<code>TZonCooSet</code> by 1.7 &deg;C (3 &deg;F) for 2 minutes and after suppression
period due to setpoint change per G36 Part 5.A.20, send 2 requests
(<code>yZonTemResReq=3</code>).
</li>
<li>
Else if the cooling loop <code>uCoo</code> is greater than 95%, send 1 request
(<code>yZonTemResReq=1</code>) until <code>uCoo</code> is less than 85%.
</li>
<li>
Else if <code>uCoo</code> is less than 95%, send 0 request (<code>yZonTemResReq=0</code>).
</li>
</ol>
<h4>b. Static pressure reset requests <code>yZonPreResReq</code></h4>
<ol>
<li>
If the measured airflow <code>VDis_flow</code> is less than 50% of setpoint
<code>VDisSet_flow</code> while it is greater than zero for 1 minute, send 3 requests
(<code>yZonPreResReq=3</code>).
</li>
<li>
Else if the measured airflow <code>VDis_flow</code> is less than 70% of setpoint
<code>VDisSet_flow</code> while it is greater than zero for 1 minute, send 2 requests
(<code>yZonPreResReq=2</code>).
</li>
<li>
Else if the damper position <code>uDam</code> is greater than 95%, send 1 request
(<code>yZonPreResReq=1</code>) until <code>uDam</code> is less than 85%.
</li>
<li>
Else if <code>uDam</code> is less than 95%, send 0 request (<code>yZonPreResReq=0</code>).
</li>
</ol>
<h4>c. If there is a hot water coil (<code>have_heaWatCoi=true</code>),
hot water reset requests <code>yHeaValResReq</code></h4>
<ol>
<li>
If the discharge air temperature <code>TDis</code> is 17 &deg;C (30 &deg;F)
less than the setpoint <code>TDisHeaSet</code> for 5 minutes, send 3 requests
(<code>yHeaValResReq=3</code>).
</li>
<li>
Else if the discharge air temperature <code>TDis</code> is 8.3 &deg;C (15 &deg;F)
less than the setpoint <code>TDisHeaSet</code> for 5 minutes, send 2 requests
(<code>yHeaValResReq=2</code>).
</li>
<li>
Else if the hot water valve position <code>uHeaVal</code> is greater than 95%, send 1 request
(<code>yHeaValResReq=1</code>) until <code>uHeaVal</code> is less than 85%.
</li>
<li>
Else if <code>uHeaVal</code> is less than 95%, send 0 request (<code>yHeaValResReq=0</code>).
</li>
</ol>
<h4>d. If there is hot water coil (<code>have_heaWatCoi=true</code>) and a boiler plant
(<code>have_boiPla=true</code>), send the boiler plant that serves the zone a boiler
plant requests <code>yHeaPlaReq</code> as follows:</h4>
<ol>
<li>
If the hot water valve position <code>uHeaVal</code> is greater than 95%, send 1 request
(<code>yHeaPlaReq=1</code>) until <code>uHeaVal</code> is less than 10%.
</li>
<li>
Else if <code>uHeaVal</code> is less than 95%, send 0 request (<code>yHeaPlaReq=0</code>).
</li>
</ol>
<h4>Implementation</h4>
<p>
Some input signals are time sampled, because the output that is generated
from these inputs are used in the trim and respond logic, which
is also time sampled. However, signals that use a delay are not
sampled, as sampling were to change the dynamic response.
</p>
</html>",               revisions="<html>
<ul>
<li>
September 13, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end SystemRequests;

              package SetPoints "Output setpoints for terminal unit control"

                block ActiveAirFlow
                  "Output the active airflow setpoint for VAV reheat terminal unit"

                  parameter Boolean have_occSen
                    "Set to true if the zone has occupancy sensor"
                    annotation(Dialog(group="Zone sensors"));
                  parameter Boolean have_winSen
                    "Set to true if the zone has window status sensor"
                    annotation(Dialog(group="Zone sensors"));
                  parameter Boolean have_CO2Sen
                    "Set to true if the zone has CO2 sensor"
                    annotation(Dialog(group="Zone sensors"));
                  parameter Real VDisCooSetMax_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Zone maximum cooling airflow setpoint"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VDisSetMin_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Zone minimum airflow setpoint"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VDisHeaSetMax_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Zone maximum heating airflow setpoint"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VDisConMin_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "VAV box controllable minimum"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real AFlo(
                    final unit="m2",
                    final quantity="Area") "Area of the zone"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VOutPerAre_flow(
                    final unit = "m3/(s.m2)")=3e-4
                    "Outdoor air rate per unit area"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VOutPerPer_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")=2.5e-3
                    "Outdoor air rate per person"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real CO2Set = 894 "CO2 setpoint in ppm"
                    annotation(Dialog(group="Nominal condition"));

                  Buildings.Controls.OBC.CDL.Interfaces.RealInput nOcc(final unit="1") if have_occSen
                    "Number of occupants"
                    annotation (Placement(transformation(extent={{-320,-300},{-280,-260}}),
                        iconTransformation(extent={{-140,-60},{-100,-20}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealInput ppmCO2 if have_CO2Sen
                    "Detected CO2 conventration"
                    annotation (Placement(transformation(extent={{-320,-200},{-280,-160}}),
                        iconTransformation(extent={{-140,20},{-100,60}})));
                  Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWin if have_winSen
                    "Window status, true if open, false if closed"
                    annotation (Placement(transformation(extent={{-320,-520},{-280,-480}}),
                        iconTransformation(extent={{-140,-100},{-100,-60}})));
                  Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                    "Zone operation mode"
                    annotation (Placement(transformation(extent={{-320,-130},{-280,-90}}),
                        iconTransformation(extent={{-140,60},{-100,100}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VOccDisMin_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Occupied minimum airflow "
                    annotation (Placement(transformation(extent={{280,-310},{320,-270}}),
                        iconTransformation(extent={{100,-100},{140,-60}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VActCooMax_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Active cooling maximum"
                    annotation (Placement(transformation(extent={{280,150},{320,190}}),
                        iconTransformation(extent={{100,60},{140,100}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VActCooMin_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Active cooling minimum"
                    annotation (Placement(transformation(extent={{280,120},{320,160}}),
                        iconTransformation(extent={{100,30},{140,70}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VActMin_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Active minimum"
                    annotation (Placement(transformation(extent={{280,90},{320,130}}),
                        iconTransformation(extent={{100,0},{140,40}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VActHeaMin_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Active heating minimum"
                    annotation (Placement(transformation(extent={{280,50},{320,90}}),
                        iconTransformation(extent={{100,-30},{140,10}})));
                  Buildings.Controls.OBC.CDL.Interfaces.RealOutput VActHeaMax_flow(
                    final min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate") "Active heating maximum"
                    annotation (Placement(transformation(extent={{280,10},{320,50}}),
                        iconTransformation(extent={{100,-60},{140,-20}})));

                  Buildings.Controls.OBC.CDL.Continuous.Gain gai(
                    final k=VOutPerPer_flow) if have_occSen
                    "Outdoor air per person"
                    annotation (Placement(transformation(extent={{-140,-330},{-120,-310}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add breZon if have_occSen
                  "Breathing zone airflow"
                    annotation (Placement(transformation(extent={{-80,-350},{-60,-330}})));
                  Buildings.Controls.OBC.CDL.Continuous.Line co2ConLoo if have_CO2Sen
                    "Maintain CO2 concentration at setpoint, reset 0% at (setpoint-200) and 100% at setpoint"
                    annotation (Placement(transformation(extent={{-140,-190},{-120,-170}})));
                  Buildings.Controls.OBC.CDL.Continuous.Line lin1 if have_CO2Sen
                    "Reset occupied minimum airflow setpoint from 0% at VDisSetMin_flow and 100% at VDisCooSetMax_flow"
                    annotation (Placement(transformation(extent={{20,-130},{40,-110}})));
                  Buildings.Controls.OBC.CDL.Continuous.Greater gre
                    "Check if zone minimum airflow setpoint Vmin is less than the allowed controllable VDisConMin_flow"
                    annotation (Placement(transformation(extent={{-20,-460},{0,-440}})));
                  Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr1
                    "Check if zone minimum airflow setpoint VDisSetMin_flow is non-zero"
                    annotation (Placement(transformation(extent={{-80,-410},{-60,-390}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi
                    "Reset occupied minimum airflow according to occupancy"
                    annotation (Placement(transformation(extent={{80,-290},{100,-270}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi1
                    "Reset occupied minimum airflow according to window status"
                    annotation (Placement(transformation(extent={{200,-510},{220,-490}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi2
                    "Reset occupied minimum airflow setpoint according to minimum controllable airflow"
                    annotation (Placement(transformation(extent={{140,-410},{160,-390}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi3 if have_CO2Sen
                    "Switch between zero signal and CO2 control loop signal depending on the operation mode"
                    annotation (Placement(transformation(extent={{-80,-100},{-60,-120}})));
                  Buildings.Controls.OBC.CDL.Logical.And and1 "Logical and"
                    annotation (Placement(transformation(extent={{40,-410},{60,-390}})));
                  Buildings.Controls.OBC.CDL.Logical.Not not1 "Logical not"
                    annotation (Placement(transformation(extent={{80,-410},{100,-390}})));
                  Buildings.Controls.OBC.CDL.Logical.Not not2 if have_winSen "Logical not"
                    annotation (Placement(transformation(extent={{-240,-510},{-220,-490}})));
                  CDL.Continuous.GreaterThreshold greThr(t=0.75, h=0.5) if have_occSen
                    "Check if the zone becomes unpopulated"
                    annotation (Placement(transformation(extent={{-140,-290},{-120,-270}})));

              protected
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minZonAir1(
                    final k=VDisSetMin_flow) if not have_CO2Sen
                    "Zone minimum airflow setpoint"
                    annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant maxZonCooAir(
                    final k=VDisCooSetMax_flow) if have_CO2Sen
                    "Zone maximum cooling airflow setpoint"
                    annotation (Placement(transformation(extent={{-80,-190},{-60,-170}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant breZonAre(
                    final k=VOutPerAre_flow*AFlo) if have_occSen
                    "Area component of the breathing zone outdoor airflow"
                    annotation (Placement(transformation(extent={{-140,-370},{-120,-350}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant conVolMin(
                    final k=VDisConMin_flow)
                    "VAV box controllable minimum"
                    annotation (Placement(transformation(extent={{-80,-440},{-60,-420}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant minZonAir(
                    final k=VDisSetMin_flow)
                    "Zone minimum airflow setpoint"
                    annotation (Placement(transformation(extent={{-240,-60},{-220,-40}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant setCO1(
                    final k=CO2Set - 200) if have_CO2Sen
                    "CO2 setpoints minus 200"
                    annotation (Placement(transformation(extent={{-240,-140},{-220,-120}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant setCO2(
                    final k=CO2Set) if have_CO2Sen
                    "CO2 setpoints"
                    annotation (Placement(transformation(extent={{-240,-210},{-220,-190}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerFlo(final k=0)
                    "Zero airflow when window is open"
                    annotation (Placement(transformation(extent={{140,-540},{160,-520}})));
                  Buildings.Controls.OBC.CDL.Logical.Sources.Constant con(
                    final k=true) if not have_occSen "Constant true"
                    annotation (Placement(transformation(extent={{-80,-270},{-60,-250}})));
                  Buildings.Controls.OBC.CDL.Logical.Sources.Constant con1(
                    final k=true) if not have_winSen "Constant true"
                    annotation (Placement(transformation(extent={{40,-490},{60,-470}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCon(
                    final k=0) "Output zero"
                    annotation (Placement(transformation(extent={{-240,-170},{-220,-150}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCon1(
                    final k=0) if have_CO2Sen
                    "Output zero"
                    annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCon2(
                    final k=0) if have_CO2Sen
                    "Output zero"
                    annotation (Placement(transformation(extent={{-140,-90},{-120,-70}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCon3(
                    final k=0) if not have_occSen
                    "Output zero"
                    annotation (Placement(transformation(extent={{0,-350},{20,-330}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant oneCon(
                    final k=1) if have_CO2Sen
                    "Output one"
                    annotation (Placement(transformation(extent={{-240,-240},{-220,-220}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant oneCon1(
                    final k=1) if have_CO2Sen "Output one"
                    annotation (Placement(transformation(extent={{-80,-160},{-60,-140}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cooMaxAir(
                    final k=VDisCooSetMax_flow)
                    "Cooling maximum airflow"
                    annotation (Placement(transformation(extent={{-240,-20},{-220,0}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant heaMaxAir(
                    final k=VDisHeaSetMax_flow)
                    "Heat maximum airflow"
                    annotation (Placement(transformation(extent={{-180,-20},{-160,0}})));
                  Buildings.Controls.OBC.CDL.Continuous.Sources.Constant zerCon6(
                    final k=0)
                    "Output zero"
                    annotation (Placement(transformation(extent={{-240,170},{-220,190}})));
                  Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt(
                    final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                    "Occupied mode"
                    annotation (Placement(transformation(extent={{-240,-100},{-220,-80}})));
                  Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt1(
                    final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                    "Cool down mode"
                    annotation (Placement(transformation(extent={{-240,290},{-220,310}})));
                  Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt2(
                    final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                    "Setup mode"
                    annotation (Placement(transformation(extent={{-240,220},{-220,240}})));
                  Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt3(
                    final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                    "Warm up mode"
                    annotation (Placement(transformation(extent={{-20,290},{0,310}})));
                  Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt4(
                    final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                    "Setback mode"
                    annotation (Placement(transformation(extent={{-20,220},{0,240}})));
                  Buildings.Controls.OBC.CDL.Integers.Equal intEqu
                    "Check if current operation mode is occupied mode"
                    annotation (Placement(transformation(extent={{-140,-120},{-120,-100}})));
                  Buildings.Controls.OBC.CDL.Integers.Equal intEqu1
                    "Check if current operation mode is cool-down mode"
                    annotation (Placement(transformation(extent={{-180,290},{-160,310}})));
                  Buildings.Controls.OBC.CDL.Integers.Equal intEqu2
                    "Check if current operation mode is setup mode"
                    annotation (Placement(transformation(extent={{-180,220},{-160,240}})));
                  Buildings.Controls.OBC.CDL.Integers.Equal intEqu3
                    "Check if current operation mode is warmup mode"
                    annotation (Placement(transformation(extent={{40,290},{60,310}})));
                  Buildings.Controls.OBC.CDL.Integers.Equal intEqu4
                    "Check if current operation mode is setback mode"
                    annotation (Placement(transformation(extent={{40,220},{60,240}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi4
                    "Select cooling maximum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,290},{-80,310}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi8
                    "Select heating maximum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,260},{-80,280}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi9
                    "Select cooling maximum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,220},{-80,240}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi17
                    "Select heating minimum based on operation mode"
                    annotation (Placement(transformation(extent={{120,290},{140,310}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi18
                    "Select heating maximum based on operation mode"
                    annotation (Placement(transformation(extent={{120,260},{140,280}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi22
                    "Select heating minimum based on operation mode"
                    annotation (Placement(transformation(extent={{120,220},{140,240}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi23
                    "Select heating maximum based on operation mode"
                    annotation (Placement(transformation(extent={{120,190},{140,210}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi24
                    "Select cooling maximum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,150},{-80,170}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi25
                    "Select cooling minimum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,120},{-80,140}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi26
                    "Select minimum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,90},{-80,110}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi27
                    "Select heating minimum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
                  Buildings.Controls.OBC.CDL.Logical.Switch swi28
                    "Select heating maximum based on operation mode"
                    annotation (Placement(transformation(extent={{-100,30},{-80,50}})));
                  Buildings.Controls.OBC.CDL.Continuous.Max maxInp "Find greater input"
                    annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add add2 "Add real input"
                    annotation (Placement(transformation(extent={{200,170},{220,190}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add actCooMaxAir
                    "Active cooling maximum airflow"
                    annotation (Placement(transformation(extent={{240,160},{260,180}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add add1 "Add real input"
                    annotation (Placement(transformation(extent={{200,80},{220,100}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add actHeaMinAir
                    "Active heating minimum airflow"
                    annotation (Placement(transformation(extent={{240,60},{260,80}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add add3 "Add real input"
                    annotation (Placement(transformation(extent={{180,40},{200,60}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add actHeaMaxAir1
                    "Active heating maximum airflow"
                    annotation (Placement(transformation(extent={{240,20},{260,40}})));
                  Buildings.Controls.OBC.CDL.Continuous.Add add4 "Add real input"
                    annotation (Placement(transformation(extent={{180,0},{200,20}})));

                equation
                  connect(conVolMin.y, gre.u1)
                    annotation (Line(points={{-58,-430},{-40,-430},{-40,-450},{-22,-450}},
                      color={0,0,127}));
                  connect(setCO1.y, co2ConLoo.x1)
                    annotation (Line(points={{-218,-130},{-160,-130},{-160,-172},{-142,-172}},
                      color={0,0,127}));
                  connect(zerCon.y, co2ConLoo.f1)
                    annotation (Line(points={{-218,-160},{-180,-160},{-180,-176},{-142,-176}},
                      color={0,0,127}));
                  connect(ppmCO2, co2ConLoo.u)
                    annotation (Line(points={{-300,-180},{-142,-180}},
                      color={0,0,127}));
                  connect(setCO2.y, co2ConLoo.x2)
                    annotation (Line(points={{-218,-200},{-180,-200},{-180,-184},{-142,-184}},
                      color={0,0,127}));
                  connect(oneCon.y, co2ConLoo.f2)
                    annotation (Line(points={{-218,-230},{-160,-230},{-160,-188},{-142,-188}},
                      color={0,0,127}));
                  connect(zerCon1.y, lin1.x1)
                    annotation (Line(points={{-58,-80},{0,-80},{0,-112},{18,-112}},
                      color={0,0,127}));
                  connect(oneCon1.y, lin1.x2)
                    annotation (Line(points={{-58,-150},{-20,-150},{-20,-124},{18,-124}},
                      color={0,0,127}));
                  connect(maxZonCooAir.y, lin1.f2)
                    annotation (Line(points={{-58,-180},{0,-180},{0,-128},{18,-128}},
                      color={0,0,127}));
                  connect(minZonAir.y, lin1.f1)
                    annotation (Line(points={{-218,-50},{-20,-50},{-20,-116},{18,-116}},
                      color={0,0,127}));
                  connect(intEqu.y, swi3.u2)
                    annotation (Line(points={{-118,-110},{-82,-110}},
                      color={255,0,255}));
                  connect(co2ConLoo.y, swi3.u1)
                    annotation (Line(points={{-118,-180},{-100,-180},{-100,-118},{-82,-118}},
                      color={0,0,127}));
                  connect(swi3.y, lin1.u)
                    annotation (Line(points={{-58,-110},{-40,-110},{-40,-120},{18,-120}},
                      color={0,0,127}));
                  connect(zerCon2.y, swi3.u3)
                    annotation (Line(points={{-118,-80},{-100,-80},{-100,-102},{-82,-102}},
                      color={0,0,127}));
                  connect(uOpeMod, intEqu.u2)
                    annotation (Line(points={{-300,-110},{-180,-110},{-180,-118},{-142,-118}},
                      color={255,127,0}));
                  connect(conInt.y, intEqu.u1)
                    annotation (Line(points={{-218,-90},{-160,-90},{-160,-110},{-142,-110}},
                      color={255,127,0}));
                  connect(nOcc, gai.u)
                    annotation (Line(points={{-300,-280},{-160,-280},{-160,-320},{-142,-320}},
                      color={0,0,127}));
                  connect(breZonAre.y, breZon.u2)
                    annotation (Line(points={{-118,-360},{-100,-360},{-100,-346},{-82,-346}},
                      color={0,0,127}));
                  connect(gai.y, breZon.u1)
                    annotation (Line(points={{-118,-320},{-100,-320},{-100,-334},{-82,-334}},
                      color={0,0,127}));
                  connect(breZon.y, swi.u3)
                    annotation (Line(points={{-58,-340},{-20,-340},{-20,-288},{78,-288}},
                      color={0,0,127}));
                  connect(lin1.y, swi.u1)
                    annotation (Line(points={{42,-120},{60,-120},{60,-272},{78,-272}},
                      color={0,0,127}));
                  connect(minZonAir.y, greThr1.u)
                    annotation (Line(points={{-218,-50},{-200,-50},{-200,-400},{-82,-400}},
                      color={0,0,127}));
                  connect(minZonAir.y, gre.u2)
                    annotation (Line(points={{-218,-50},{-200,-50},{-200,-458},{-22,-458}},
                      color={0,0,127}));
                  connect(gre.y,and1. u2)
                    annotation (Line(points={{2,-450},{20,-450},{20,-408},{38,-408}},
                      color={255,0,255}));
                  connect(greThr1.y,and1. u1)
                    annotation (Line(points={{-58,-400},{38,-400}}, color={255,0,255}));
                  connect(and1.y, not1.u)
                    annotation (Line(points={{62,-400},{78,-400}}, color={255,0,255}));
                  connect(not1.y, swi2.u2)
                    annotation (Line(points={{102,-400},{138,-400}}, color={255,0,255}));
                  connect(conVolMin.y, swi2.u3)
                    annotation (Line(points={{-58,-430},{120,-430},{120,-408},{138,-408}},
                      color={0,0,127}));
                  connect(swi.y, swi2.u1)
                    annotation (Line(points={{102,-280},{120,-280},{120,-392},{138,-392}},
                      color={0,0,127}));
                  connect(uWin, not2.u)
                    annotation (Line(points={{-300,-500},{-242,-500}}, color={255,0,255}));
                  connect(not2.y, swi1.u2)
                    annotation (Line(points={{-218,-500},{198,-500}}, color={255,0,255}));
                  connect(zerFlo.y, swi1.u3)
                    annotation (Line(points={{162,-530},{180,-530},{180,-508},{198,-508}},
                      color={0,0,127}));
                  connect(swi2.y, swi1.u1)
                    annotation (Line(points={{162,-400},{180,-400},{180,-492},{198,-492}},
                      color={0,0,127}));
                  connect(swi1.y, VOccDisMin_flow)
                    annotation (Line(points={{222,-500},{240,-500},{240,-290},{300,-290}},
                      color={0,0,127}));
                  connect(con.y, swi.u2)
                    annotation (Line(points={{-58,-260},{-40,-260},{-40,-280},{78,-280}},
                      color={255,0,255}));
                  connect(minZonAir1.y, swi.u1)
                    annotation (Line(points={{42,-50},{60,-50},{60,-272},{78,-272}},
                      color={0,0,127}));
                  connect(con1.y, swi1.u2)
                    annotation (Line(points={{62,-480},{80,-480},{80,-500},{198,-500}},
                      color={255,0,255}));
                  connect(zerCon3.y, swi.u3)
                    annotation (Line(points={{22,-340},{40,-340},{40,-288},{78,-288}},
                      color={0,0,127}));
                  connect(intEqu.y, swi24.u2)
                    annotation (Line(points={{-118,-110},{-110,-110},{-110,160},{-102,160}},
                      color={255,0,255}));
                  connect(intEqu.y, swi25.u2)
                    annotation (Line(points={{-118,-110},{-110,-110},{-110,130},{-102,130}},
                      color={255,0,255}));
                  connect(intEqu.y, swi26.u2)
                    annotation (Line(points={{-118,-110},{-110,-110},{-110,100},{-102,100}},
                      color={255,0,255}));
                  connect(intEqu.y, swi27.u2)
                    annotation (Line(points={{-118,-110},{-110,-110},{-110,70},{-102,70}},
                      color={255,0,255}));
                  connect(intEqu.y, swi28.u2)
                    annotation (Line(points={{-118,-110},{-110,-110},{-110,40},{-102,40}},
                      color={255,0,255}));
                  connect(cooMaxAir.y, swi24.u1)
                    annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,168},
                      {-102,168}}, color={0,0,127}));
                  connect(heaMaxAir.y, maxInp.u2)
                    annotation (Line(points={{-158,-10},{-120,-10},{-120,-16},{-102,-16}},
                      color={0,0,127}));
                  connect(maxInp.y, swi28.u1)
                    annotation (Line(points={{-78,-10},{-60,-10},{-60,22},{-124,22},{-124,48},
                      {-102,48}},   color={0,0,127}));
                  connect(zerCon6.y, swi24.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,152},{-102,152}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi25.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,122},{-102,122}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi26.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,92},{-102,92}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi27.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,62},{-102,62}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi28.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,32},{-102,32}},
                      color={0,0,127}));
                  connect(uOpeMod, intEqu1.u2)
                    annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{-200,-32},
                      {-200,292},{-182,292}}, color={255,127,0}));
                  connect(uOpeMod, intEqu2.u2)
                    annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{-200,-32},
                      {-200,222},{-182,222}}, color={255,127,0}));
                  connect(uOpeMod, intEqu4.u2)
                    annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{20,-32},
                      {20,222},{38,222}}, color={255,127,0}));
                  connect(uOpeMod, intEqu3.u2)
                    annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{20,-32},
                      {20,292},{38,292}}, color={255,127,0}));
                  connect(conInt1.y, intEqu1.u1)
                    annotation (Line(points={{-218,300},{-182,300}}, color={255,127,0}));
                  connect(conInt2.y, intEqu2.u1)
                    annotation (Line(points={{-218,230},{-182,230}}, color={255,127,0}));
                  connect(conInt4.y, intEqu4.u1)
                    annotation (Line(points={{2,230},{38,230}}, color={255,127,0}));
                  connect(conInt3.y, intEqu3.u1)
                    annotation (Line(points={{2,300},{38,300}}, color={255,127,0}));
                  connect(cooMaxAir.y, swi4.u1)
                    annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,308},
                          {-102,308}}, color={0,0,127}));
                  connect(heaMaxAir.y, swi8.u1)
                    annotation (Line(points={{-158,-10},{-134,-10},{-134,278},{-102,278}},
                      color={0,0,127}));
                  connect(intEqu1.y, swi4.u2)
                    annotation (Line(points={{-158,300},{-102,300}}, color={255,0,255}));
                  connect(intEqu1.y, swi8.u2)
                    annotation (Line(points={{-158,300},{-112,300},{-112,270},{-102,270}},
                      color={255,0,255}));
                  connect(zerCon6.y, swi4.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,292},{-102,292}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi8.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,262},{-102,262}},
                      color={0,0,127}));
                  connect(cooMaxAir.y, swi9.u1)
                    annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,238},
                          {-102,238}}, color={0,0,127}));
                  connect(intEqu2.y, swi9.u2)
                    annotation (Line(points={{-158,230},{-102,230}}, color={255,0,255}));
                  connect(zerCon6.y, swi9.u3)
                    annotation (Line(points={{-218,180},{-120,180},{-120,222},{-102,222}},
                      color={0,0,127}));
                  connect(intEqu3.y, swi17.u2)
                    annotation (Line(points={{62,300},{118,300}},
                      color={255,0,255}));
                  connect(intEqu3.y, swi18.u2)
                    annotation (Line(points={{62,300},{108,300},{108,270},{118,270}},
                      color={255,0,255}));
                  connect(intEqu4.y, swi22.u2)
                    annotation (Line(points={{62,230},{118,230}},
                      color={255,0,255}));
                  connect(intEqu4.y, swi23.u2)
                    annotation (Line(points={{62,230},{108,230},{108,200},{118,200}},
                      color={255,0,255}));
                  connect(heaMaxAir.y, swi17.u1)
                    annotation (Line(points={{-158,-10},{-134,-10},{-134,10},{86,10},{86,308},{118,
                          308}},  color={0,0,127}));
                  connect(cooMaxAir.y, swi18.u1)
                    annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{80,16},{80,278},{118,
                          278}},  color={0,0,127}));
                  connect(zerCon6.y, swi17.u3)
                    annotation (Line(points={{-218,180},{100,180},{100,292},{118,292}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi18.u3)
                    annotation (Line(points={{-218,180},{100,180},{100,262},{118,262}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi22.u3)
                    annotation (Line(points={{-218,180},{100,180},{100,222},{118,222}},
                      color={0,0,127}));
                  connect(zerCon6.y, swi23.u3)
                    annotation (Line(points={{-218,180},{100,180},{100,192},{118,192}},
                      color={0,0,127}));
                  connect(heaMaxAir.y, swi22.u1)
                    annotation (Line(points={{-158,-10},{-134,-10},{-134,10},{86,10},{86,238},{118,
                          238}},  color={0,0,127}));
                  connect(cooMaxAir.y, swi23.u1)
                    annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{80,16},{80,208},{118,
                          208}},  color={0,0,127}));
                  connect(swi1.y, swi25.u1)
                    annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,138},
                          {-102,138}}, color={0,0,127}));
                  connect(swi1.y, swi26.u1)
                    annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,108},
                          {-102,108}}, color={0,0,127}));
                  connect(swi1.y, swi27.u1)
                    annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,78},
                          {-102,78}}, color={0,0,127}));
                  connect(swi1.y, maxInp.u1)
                    annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,-4},
                          {-102,-4}}, color={0,0,127}));
                  connect(nOcc, greThr.u)
                    annotation (Line(points={{-300,-280},{-142,-280}}, color={0,0,127}));
                  connect(greThr.y, swi.u2)
                    annotation (Line(points={{-118,-280},{78,-280}}, color={255,0,255}));
                  connect(add2.y, actCooMaxAir.u1) annotation (Line(points={{222,180},{230,180},
                          {230,176},{238,176}}, color={0,0,127}));
                  connect(swi4.y, add2.u1) annotation (Line(points={{-78,300},{-40,300},{-40,186},
                          {198,186}}, color={0,0,127}));
                  connect(swi9.y, add2.u2) annotation (Line(points={{-78,230},{-60,230},{-60,174},
                          {198,174}}, color={0,0,127}));
                  connect(swi24.y, actCooMaxAir.u2) annotation (Line(points={{-78,160},{100,160},
                          {100,164},{238,164}}, color={0,0,127}));
                  connect(actCooMaxAir.y, VActCooMax_flow)
                    annotation (Line(points={{262,170},{300,170}}, color={0,0,127}));
                  connect(swi25.y, VActCooMin_flow) annotation (Line(points={{-78,130},{100,130},
                          {100,140},{300,140}}, color={0,0,127}));
                  connect(swi26.y, VActMin_flow) annotation (Line(points={{-78,100},{100,100},{100,
                          110},{300,110}}, color={0,0,127}));
                  connect(swi17.y, add1.u1) annotation (Line(points={{142,300},{178,300},{178,96},
                          {198,96}}, color={0,0,127}));
                  connect(swi22.y, add1.u2) annotation (Line(points={{142,230},{166,230},{166,84},
                          {198,84}}, color={0,0,127}));
                  connect(swi27.y, actHeaMinAir.u2) annotation (Line(points={{-78,70},{220,70},{
                          220,64},{238,64}}, color={0,0,127}));
                  connect(add1.y, actHeaMinAir.u1) annotation (Line(points={{222,90},{230,90},{230,
                          76},{238,76}}, color={0,0,127}));
                  connect(actHeaMinAir.y, VActHeaMin_flow)
                    annotation (Line(points={{262,70},{300,70}}, color={0,0,127}));
                  connect(swi8.y, add3.u1) annotation (Line(points={{-78,270},{-50,270},{-50,56},
                          {178,56}}, color={0,0,127}));
                  connect(swi28.y, add3.u2) annotation (Line(points={{-78,40},{-50,40},{-50,44},
                          {178,44}}, color={0,0,127}));
                  connect(swi18.y, add4.u1) annotation (Line(points={{142,270},{172,270},{172,16},
                          {178,16}}, color={0,0,127}));
                  connect(swi23.y, add4.u2) annotation (Line(points={{142,200},{160,200},{160,4},
                          {178,4}}, color={0,0,127}));
                  connect(actHeaMaxAir1.y, VActHeaMax_flow)
                    annotation (Line(points={{262,30},{300,30}}, color={0,0,127}));
                  connect(add3.y, actHeaMaxAir1.u1) annotation (Line(points={{202,50},{220,50},{
                          220,36},{238,36}}, color={0,0,127}));
                  connect(add4.y, actHeaMaxAir1.u2) annotation (Line(points={{202,10},{220,10},{
                          220,24},{238,24}}, color={0,0,127}));

                annotation (
                  defaultComponentName="actAirSet_RehBox",
                  Diagram(
                        coordinateSystem(preserveAspectRatio=false, extent={{-280,-560},{280,340}}),
                        graphics={                   Rectangle(
                          extent={{-258,-62},{258,-238}},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None), Rectangle(
                          extent={{-258,-250},{258,-374}},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None), Rectangle(
                          extent={{-258,-380},{258,-462}},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None), Text(
                          extent={{92,-58},{290,-94}},
                          pattern=LinePattern.None,
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          lineColor={0,0,255},
                          horizontalAlignment=TextAlignment.Left,
                          textString="Occupied min airflow:
reset based on CO2 control"),
                       Text(extent={{116,-234},{332,-294}},
                          pattern=LinePattern.None,
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          lineColor={0,0,255},
                          textString="Occupied min airflow:
reset based on occupancy",horizontalAlignment=TextAlignment.Left),
                        Text(extent={{-252,-422},{28,-454}},
                          pattern=LinePattern.None,
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          lineColor={0,0,255},
                          horizontalAlignment=TextAlignment.Left,
                          textString="Occupied min airflow:
define based on controllable minimum"),              Rectangle(
                          extent={{-256,-484},{260,-552}},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None),
                        Text(extent={{-190,-492},{32,-564}},
                          pattern=LinePattern.None,
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          lineColor={0,0,255},
                          horizontalAlignment=TextAlignment.Left,
                          textString="Occupied min airflow:
reset based on window status"),                      Rectangle(
                          extent={{-258,318},{258,-18}},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None), Text(
                          extent={{32,18},{254,-26}},
                          pattern=LinePattern.None,
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid,
                          lineColor={0,0,255},
                          horizontalAlignment=TextAlignment.Left,
                          textString="Define active setpoints
according to operation modes")}),
                     Icon(
                        graphics={Rectangle(
                          extent={{-100,100},{100,-100}},
                          lineColor={0,0,0},
                          fillColor={210,210,210},
                          fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-100,140},{100,100}},
                          lineColor={0,0,255},
                          textString="%name"),
                        Text(
                          extent={{-62,66},{58,-56}},
                          lineColor={0,0,0},
                          textString="actAirSet"),
                        Text(
                          visible=have_CO2Sen,
                          extent={{-98,48},{-70,36}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="CO2"),
                        Text(
                          visible=have_occSen,
                          extent={{-98,-32},{-70,-44}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="nOcc"),
                        Text(
                          extent={{-94,90},{-48,72}},
                          lineColor={255,127,0},
                          pattern=LinePattern.Dash,
                          textString="uOpeMod"),
                        Text(
                          visible=have_winSen,
                          extent={{-98,-74},{-72,-84}},
                          lineColor={255,0,255},
                          pattern=LinePattern.Dash,
                          textString="uWin"),
                        Text(
                          extent={{62,88},{98,74}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VActCooMax_flow"),
                        Text(
                          extent={{62,58},{98,44}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VActCooMin_flow"),
                        Text(
                          extent={{72,24},{98,14}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VActMin_flow"),
                        Text(
                          extent={{62,-2},{98,-16}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VActHeaMin_flow"),
                        Text(
                          extent={{62,-32},{98,-46}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VActHeaMax_flow"),
                        Text(
                          extent={{62,-72},{98,-86}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="VOccDisMin_flow")}),
                Documentation(info="<html>
<p>
This atomic sequence sets the active maximum and minimum setpoints <code>VActCooMax_flow</code>,
<code>VActCooMin_flow</code>, <code>VActMin_flow</code>, <code>VActHeaMin_flow</code>,
<code>VActHeaMax_flow</code> for VAV reheat terminal unit according to ASHRAE
Guideline 36 (G36), PART 5.E.3-5.
</p>
<h4>1. Information provided by designer</h4>
<p>According to G36 PART 3.1.B.2, following VAV box design information should be
provided:</p>
<ul>
<li>Zone maximum cooling airflow setpoint <code>VDisCooSetMax_flow</code></li>
<li>Zone minimum airflow setpoint <code>VDisSetMin_flow</code></li>
<li>Zone maximum heating airflow setpoint <code>VDisHeaSetMax_flow</code></li>
</ul>

<h4>2. Occupied minimum airflow <code>VOccDisMin_flow</code></h4>
<p>The <code>VOccDisMin_flow</code> shall be equal to zone minimum airflow setpoint
<code>VDisSetMin_flow</code> except as follows:</p>
<ul>
<li>
If the zone has an occupancy sensor, <code>VOccDisMin_flow</code> shall be equal to
minimum breathing zone outdoor airflow (if ventilation is according to ASHRAE
Standard 62.1-2013) or zone minimum outdoor airflow for building area
(if ventilation is according to California Title 24) when the room is unpopulated.
</li>
<li>
If the zone has a window switch, <code>VOccDisMin_flow</code> shall be zero when the
window is open.
</li>
<li>
If <code>VDisSetMin_flow</code> is non-zero and less than the lowest possible airflow setpoint
allowed by the controls <code>VDisConMin_flow</code>, <code>VOccDisMin_flow</code> shall be set
equal to <code>VDisConMin_flow</code>.
</li>
<li>
If the zone has a CO2 sensor, then following steps are applied for calculating
<code>VOccDisMin_flow</code>. (1) During occupied mode, a P-only loop shall maintain
CO2 concentration at setpoint, reset 0% at (CO2 setpoint <code>CO2Set</code> -
200 ppm) and 100% at <code>CO2Set</code>. If ventilation outdoor airflow is controlled
in accordance with ASHRAE Standard 62.1-2013, the loop output shall reset the
<code>VOccDisMin_flow</code> from <code>VDisSetMin_flow</code> at 0% loop output up to <code>VDisCooSetMax_flow</code>
at 100% loop output; (2) Loop is diabled and output set to zero when the zone is
not in occupied mode.
</li>
</ul>

<h4>3. Active maximum and minimum setpoints</h4>
<p>The setpoints shall vary depending on the mode of the zone group.</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Setpoint</th> <th>Occupied</th><th>Cool-down</th>
<th>Setup</th><th>Warmup</th><th>Setback</th><th>Unoccupied</th></tr>
<tr><td>Cooling maximum (<code>VActCooMax_flow</code>)</td><td><code>VDisCooSetMax_flow</code></td>
<td><code>VDisCooSetMax_flow</code></td><td><code>VDisCooSetMax_flow</code></td>
<td>0</td><td>0</td><td>0</td></tr>
<tr><td>Cooling minimum (<code>VActCooMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td>
<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Minimum (<code>VActMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Heating minimum (<code>VActHeaMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td>
<td>0</td><td>0</td><td><code>VDisHeaSetMax_flow</code></td><td><code>VDisHeaSetMax_flow</code></td>
<td>0</td></tr>
<tr><td>Heating maximum (<code>VActHeaMax_flow</code>)</td><td>max(<code>VDisHeaSetMax_flow,VOccDisMin_flow</code>)</td>
<td><code>VDisHeaSetMax_flow</code></td><td>0</td><td><code>VDisCooSetMax_flow</code></td><td><code>VDisCooSetMax_flow</code></td>
<td>0</td></tr>
</table>
<br/>
</html>",                 revisions="<html>
<ul>
<li>
March 11, 2020, by Jianjun Hu:<br/>
Replaced multisum block with add blocks.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1830\">#1830</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Used hysteresis to check occupancy.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1788\">#1788</a>.
</li>
<li>
September 7, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end ActiveAirFlow;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences generating setpoints for terminal units.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                    Text(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      textString="S")}));
              end SetPoints;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences for VAV reheat terminal unit. They are created
according to ASHRAE Guideline 36, Part 5.E.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Ellipse(
                      origin={10.0,10.0},
                      lineColor={128,128,128},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,0.0},{-20.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={128,128,128},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,0.0},{60.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,-80.0},{60.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={76,76,76},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,-80.0},{-20.0,-20.0}})}));
            end Reheat;

            package SetPoints
            "Generic sequences of generating setpoints for terminal units control"

              block ZoneTemperatures
                "Block outputs thermal zone cooling and heating setpoint"

                parameter Boolean have_occSen "Check if the zone has occupancy sensor"
                  annotation(Dialog(group="Sensors"));
                parameter Boolean have_winSen
                  "Check if the zone has window status sensor"
                  annotation(Dialog(group="Sensors"));

                parameter Boolean cooAdj=false
                  "Flag, set to true if both cooling and heating setpoint are adjustable separately"
                  annotation(Dialog(group="Setpoint adjustable setting"));
                parameter Boolean heaAdj=false
                  "Flag, set to true if heating setpoint is adjustable"
                  annotation(Dialog(group="Setpoint adjustable setting"));
                parameter Boolean sinAdj = false
                  "Flag, set to true if both cooling and heating setpoint are adjustable through a single common knob"
                  annotation(Dialog(group="Setpoint adjustable setting",enable=not (cooAdj or heaAdj)));
                parameter Boolean ignDemLim = true
                  "Flag, set to true to exempt individual zone from demand limit setpoint adjustment"
                  annotation(Dialog(group="Setpoint adjustable setting"));

                parameter Real TZonCooOnMax(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=300.15
                  "Maximum cooling setpoint during on"
                  annotation(Dialog(group="Setpoints limits setting"));
                parameter Real TZonCooOnMin(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=295.15
                  "Minimum cooling setpoint during on"
                  annotation(Dialog(group="Setpoints limits setting"));
                parameter Real TZonHeaOnMax(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=295.15
                  "Maximum heating setpoint during on"
                  annotation(Dialog(group="Setpoints limits setting"));
                parameter Real TZonHeaOnMin(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=291.15
                  "Minimum heating setpoint during on"
                  annotation(Dialog(group="Setpoints limits setting"));
                parameter Real TZonCooSetWinOpe(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=322.15
                  "Cooling setpoint when window is open"
                  annotation(Dialog(group="Setpoints limits setting", enable=have_winSen));
                parameter Real TZonHeaSetWinOpe(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=277.15
                  "Heating setpoint when window is open"
                  annotation(Dialog(group="Setpoints limits setting", enable=have_winSen));

                parameter Real incTSetDem_1=0.56
                  "Cooling setpoint increase value (degC) when cooling demand limit level 1 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
                parameter Real incTSetDem_2=1.1
                  "Cooling setpoint increase value (degC) when cooling demand limit level 2 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
                parameter Real incTSetDem_3=2.2
                  "Cooling setpoint increase value (degC) when cooling demand limit level 3 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
                parameter Real decTSetDem_1=0.56
                  "Heating setpoint decrease value (degC) when heating demand limit level 1 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
                parameter Real decTSetDem_2=1.1
                  "Heating setpoint decrease value (degC) when heating demand limit level 2 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
                parameter Real decTSetDem_3=2.2
                  "Heating setpoint decrease value (degC) when heating demand limit level 3 is imposed"
                  annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));

                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonCooSetOcc(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Occupied zone cooling setpoint"
                  annotation (Placement(transformation(extent={{-460,510},{-420,550}}),
                      iconTransformation(extent={{-140,70},{-100,110}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonHeaSetOcc(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Occupied zone heating setpoint"
                  annotation (Placement(transformation(extent={{-460,430},{-420,470}}),
                      iconTransformation(extent={{-140,20},{-100,60}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonCooSetUno(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Unoccupied zone cooling setpoint"
                  annotation (Placement(transformation(extent={{-460,470},{-420,510}}),
                      iconTransformation(extent={{-140,50},{-100,90}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput TZonHeaSetUno(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Unoccupied zone heating setpoint"
                  annotation (Placement(transformation(extent={{-460,390},{-420,430}}),
                      iconTransformation(extent={{-140,0},{-100,40}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput setAdj(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if (cooAdj or sinAdj)
                  "Setpoint adjustment value"
                  annotation (Placement(transformation(extent={{-460,330},{-420,370}}),
                      iconTransformation(extent={{-140,-30},{-100,10}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealInput heaSetAdj(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if heaAdj
                  "Heating setpoint adjustment value"
                  annotation (Placement(transformation(extent={{-460,250},{-420,290}}),
                      iconTransformation(extent={{-140,-50},{-100,-10}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uOpeMod
                  "AHU operation mode status signal"
                  annotation (Placement(transformation(extent={{-460,610},{-420,650}}),
                      iconTransformation(extent={{-140,110},{-100,150}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uCooDemLimLev
                  "Cooling demand limit level"
                  annotation (Placement(transformation(extent={{-460,110},{-420,150}}),
                      iconTransformation(extent={{-140,-80},{-100,-40}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerInput uHeaDemLimLev
                  "Heating demand limit level"
                  annotation (Placement(transformation(extent={{-460,-110},{-420,-70}}),
                      iconTransformation(extent={{-140,-100},{-100,-60}})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uOccSen if have_occSen
                  "Occupancy sensor (occupied=true, unoccupied=false)"
                  annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                    origin={-440,-270}),iconTransformation(
                    extent={{-20,-20},{20,20}},origin={-120,-110})));
                Buildings.Controls.OBC.CDL.Interfaces.BooleanInput uWinSta if have_winSen
                  "Window status (open=true, close=false)"
                  annotation (Placement(transformation(extent={{-460,-430},{-420,-390}}),
                    iconTransformation(extent={{-20,-20},{20,20}},origin={-120,-130})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TZonCooSet(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")  "Cooling setpoint temperature"
                  annotation (Placement(transformation(extent={{340,-20},{380,20}}),
                      iconTransformation(extent={{100,60},{140,100}})));
                Buildings.Controls.OBC.CDL.Interfaces.RealOutput TZonHeaSet(
                  final unit="K",
                  displayUnit="degC",
                  final quantity="ThermodynamicTemperature")  "Heating setpoint temperature"
                  annotation (Placement(transformation(extent={{340,-120},{380,-80}}),
                      iconTransformation(extent={{100,-20},{140,20}})));
                Buildings.Controls.OBC.CDL.Interfaces.IntegerOutput yAla "Alarm level"
                  annotation (Placement(transformation(extent={{340,-410},{380,-370}}),
                      iconTransformation(extent={{100,-100},{140,-60}})));

                Buildings.Controls.OBC.CDL.Logical.Or or2
                  "Check if there is cooling/heating demand limit being imposed"
                  annotation (Placement(transformation(extent={{-280,-40},{-260,-20}})));
                Buildings.Controls.OBC.CDL.Logical.Edge edg "If demand limit is imposed"
                  annotation (Placement(transformation(extent={{-220,-10},{-200,10}})));
                Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler cooSetFre
                  "Freeze current cooling setpoint when demand limit is imposed"
                  annotation (Placement(transformation(extent={{-160,140},{-140,160}})));
                Buildings.Controls.OBC.CDL.Logical.Not not3 "Logical not"
                  annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
                Buildings.Controls.OBC.CDL.Logical.Or or5
                  "Check if demand limit should be ignored or if there is no demand limit"
                  annotation (Placement(transformation(extent={{160,-20},{180,0}})));
                Buildings.Controls.OBC.CDL.Logical.Or3 or1
                  "Check if cooling demand limit level is imposed"
                  annotation (Placement(transformation(extent={{-40,140},{-20,160}})));
                Buildings.Controls.OBC.CDL.Logical.Not not1 "Logic not"
                  annotation (Placement(transformation(extent={{0,140},{20,160}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar3(
                  final p=incTSetDem_3,
                  final k=1)
                  "Increase setpoint by 2.2 degC"
                  annotation (Placement(transformation(extent={{40,20},{60,40}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar1(
                  final p=incTSetDem_2,
                  final k=1)
                  "Increase setpoint by 1.1 degC"
                  annotation (Placement(transformation(extent={{40,60},{60,80}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar2(
                  final p=incTSetDem_1,
                  final k=1)
                  "Increase setpoint by 0.56 degC"
                  annotation (Placement(transformation(extent={{40,100},{60,120}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro6
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,140},{100,160}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,100},{100,120}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro1
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,60},{100,80}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro2
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,20},{100,40}})));
                Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler heaSetFre
                  "Freeze current heating setpoint when demand limit is imposed"
                  annotation (Placement(transformation(extent={{-160,-80},{-140,-60}})));
                Buildings.Controls.OBC.CDL.Logical.Or3 or4 "Check if heating demand limit level is imposed"
                  annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
                Buildings.Controls.OBC.CDL.Logical.Not not2 "Logical not"
                  annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro7
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,-80},{100,-60}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar6(
                  final k=1,
                  final p=-decTSetDem_1)
                  "Decrease setpoint by 0.56 degC"
                  annotation (Placement(transformation(extent={{40,-120},{60,-100}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar5(
                  final k=1,
                  final p=-decTSetDem_2)
                  "Decrease setpoint by 1.1 degC"
                  annotation (Placement(transformation(extent={{40,-160},{60,-140}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar4(
                  final k=1,
                  final p=-decTSetDem_3)
                  "Decrease setpoint by 2.2 degC"
                  annotation (Placement(transformation(extent={{40,-200},{60,-180}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro5
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,-200},{100,-180}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro4
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,-160},{100,-140}})));
                Buildings.Controls.OBC.CDL.Continuous.Product pro3
                  "Output product of the two inputs"
                  annotation (Placement(transformation(extent={{80,-120},{100,-100}})));
                Buildings.Controls.OBC.CDL.Logical.Timer tim(final t=300)
                  "Check whether the zone has been unpopulated for 5 minutes continuously during occupied mode"
                  annotation (Placement(transformation(extent={{-220,-280},{-200,-260}})));
                Buildings.Controls.OBC.CDL.Logical.TrueHoldWithReset truHol(duration=60)
                  "When the zone is unpopulated by more than 5 minute and then becomes populated, hold the change by 1 minute"
                  annotation (Placement(transformation(extent={{-100,-280},{-80,-260}})));
                Buildings.Controls.OBC.CDL.Logical.Edge edg1
                  "Instant when the zone becomes more than 5 minutes"
                  annotation (Placement(transformation(extent={{-40,-280},{-20,-260}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter heaSetDec(
                  p=-1.1,
                  final k=1)
                  "Heating setpoint decrease due to the 5 minutes unpopulation under occupied mode"
                  annotation (Placement(transformation(extent={{100,-320},{120,-300}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter cooSetInc(
                  p=1.1,
                  final k=1)
                  "Heating setpoint increase due to the 5 minutes unpopulation under occupied mode"
                  annotation (Placement(transformation(extent={{100,-280},{120,-260}})));
                Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler cooSetSam
                  "Sample current cooling setpoint when zone becomes unpopulated by 5 minutes"
                  annotation (Placement(transformation(extent={{40,-280},{60,-260}})));
                Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler heaSetSam
                  "Sample current heating setpoint when zone becomes unpopulated by 5 minutes"
                  annotation (Placement(transformation(extent={{40,-320},{60,-300}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add1 "Adjust heating setpoint"
                  annotation (Placement(transformation(extent={{140,240},{160,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add2 "Adjust cooling setpoint"
                  annotation (Placement(transformation(extent={{-200,340},{-180,360}})));
                Buildings.Controls.OBC.CDL.Continuous.Limiter cooSetLim(
                  final uMax=TZonCooOnMax,
                  final uMin=TZonCooOnMin)
                  "Limit occupied zone cooling setpoint"
                  annotation (Placement(transformation(extent={{-240,-530},{-220,-510}})));
                Buildings.Controls.OBC.CDL.Continuous.Limiter heaSetLim(
                  final uMax=TZonHeaOnMax,
                  final uMin=TZonHeaOnMin)
                  "Limit occupied zone heating setpoint"
                  annotation (Placement(transformation(extent={{-240,-590},{-220,-570}})));
                Buildings.Controls.OBC.CDL.Continuous.AddParameter addPar(
                  p=-0.56,
                  final k=1)
                  "Cooling setpoint minus 0.56 degC"
                  annotation (Placement(transformation(extent={{160,-590},{180,-570}})));

            protected
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu "Check if current operation mode is warm-up mode"
                  annotation (Placement(transformation(extent={{-300,600},{-280,620}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu1
                  "Check if current operation mode is cool-down mode"
                  annotation (Placement(transformation(extent={{-200,600},{-180,620}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu2 "Check if current operation mode is occupied mode"
                  annotation (Placement(transformation(extent={{-98,600},{-78,620}})));
                Buildings.Controls.OBC.CDL.Logical.Or3 or3
                  "Current operation mode is occupied, warm-up, or cool-down mode"
                  annotation (Placement(transformation(extent={{-20,600},{0,620}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt(
                  final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                  "Warm-up mode"
                  annotation (Placement(transformation(extent={{-340,570},{-320,590}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt1(
                  final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                  "Cool-down mode"
                  annotation (Placement(transformation(extent={{-240,570},{-220,590}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt2(
                  final k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                  "Occupied mode"
                  annotation (Placement(transformation(extent={{-140,570},{-120,590}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant cooSetAdjCon(k=(cooAdj or sinAdj))
                  "Cooling setpoint adjustable"
                  annotation (Placement(transformation(extent={{-340,320},{-320,340}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con(final k=0) "Zero adjustment"
                  annotation (Placement(transformation(extent={{-340,280},{-320,300}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con3(final k=0) if not (cooAdj or sinAdj)
                  "Zero adjustment"
                  annotation (Placement(transformation(extent={{-340,360},{-320,380}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con4(final k=0) if not heaAdj
                  "Zero adjustment"
                  annotation (Placement(transformation(extent={{-340,240},{-320,260}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant heaSetAdjCon(final k=heaAdj)
                  "Heating setpoint adjustable"
                  annotation (Placement(transformation(extent={{-60,240},{-40,260}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con1(final k=0) "Zero adjustment"
                  annotation (Placement(transformation(extent={{-60,200},{-40,220}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant sinSetAdjCon(final k=sinAdj)
                  "Single common setpoint adjustable"
                  annotation (Placement(transformation(extent={{20,200},{40,220}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant con2(final k=ignDemLim)
                  "Check whether the zone should exempt from setpoint adjustment due to the demand limit"
                  annotation (Placement(transformation(extent={{-160,-20},{-140,0}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant conTru(
                  final k=true) if not have_occSen
                  "Constant true"
                  annotation (Placement(transformation(extent={{-380,-360},{-360,-340}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant conFal(
                  final k=false) if not have_winSen
                  "Constant false"
                  annotation (Placement(transformation(extent={{-380,-480},{-360,-460}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant winSenCon(final k=have_winSen)
                  "Check if there is window status sensor"
                  annotation (Placement(transformation(extent={{40,-480},{60,-460}})));
                Buildings.Controls.OBC.CDL.Logical.Sources.Constant have_occSenCon(final k=have_occSen)
                  "Check if there is occupancy sensor"
                  annotation (Placement(transformation(extent={{160,-360},{180,-340}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cooSetWinOpe(final k=TZonCooSetWinOpe)
                  "Cooling setpoint when window is open"
                  annotation (Placement(transformation(extent={{-240,-480},{-220,-460}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant heaSetWinOpe(final k=TZonHeaSetWinOpe)
                  "Heating setpoint when window is open"
                  annotation (Placement(transformation(extent={{-120,-480},{-100,-460}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant alaZer(k=-0.2)
                  "Alarm level 0"
                  annotation (Placement(transformation(extent={{-180,-400},{-160,-380}})));
                Buildings.Controls.OBC.CDL.Continuous.Sources.Constant alaFou(k=3.8)
                  "Alarm level 4"
                  annotation (Placement(transformation(extent={{-140,-400},{-120,-380}})));
                Buildings.Controls.OBC.CDL.Conversions.RealToInteger reaToInt
                  "Convert real input to integer output"
                  annotation (Placement(transformation(extent={{160,-400},{180,-380}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,100},{-20,120}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea1 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea6 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{40,140},{60,160}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea2 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea3 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,-120},{-20,-100}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea4 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,-160},{-20,-140}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea5 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{-40,-200},{-20,-180}})));
                Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea7 "Convert boolean to real value"
                  annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
                Buildings.Controls.OBC.CDL.Logical.And and11
                  "Check if window is open during operation modes other than occupied"
                  annotation (Placement(transformation(extent={{-220,-420},{-200,-400}})));
                Buildings.Controls.OBC.CDL.Logical.Not not5  "Other than occupied mode"
                  annotation (Placement(transformation(extent={{-280,-400},{-260,-380}})));
                Buildings.Controls.OBC.CDL.Continuous.Less les
                  "Check if occupied cooling setpoint is less than unoccupied one"
                  annotation (Placement(transformation(extent={{20,-550},{40,-530}})));
                Buildings.Controls.OBC.CDL.Continuous.Greater gre
                  "Check if occupied heating setpoint is greater than unoccupied one"
                  annotation (Placement(transformation(extent={{20,-610},{40,-590}})));
                Buildings.Controls.OBC.CDL.Continuous.Greater gre2
                  "Check whether heating setpoint exceeds cooling setpoint minus 0.56 degC"
                  annotation (Placement(transformation(extent={{220,-590},{240,-570}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi
                  "Switch between occupied and unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-300,520},{-280,540}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi1
                  "Switch between occupied and unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-300,440},{-280,460}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi2
                  "Setpoint can only be adjusted in occupied mode"
                  annotation (Placement(transformation(extent={{-120,360},{-100,340}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi3
                  "Setpoint can only be adjusted in occupied mode"
                  annotation (Placement(transformation(extent={{220,260},{240,240}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi4
                  "If there is no cooling adjustment, zero adjust"
                  annotation (Placement(transformation(extent={{-280,320},{-260,340}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi5
                  "If there is no heating adjustment, zero adjust"
                  annotation (Placement(transformation(extent={{0,240},{20,260}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi6
                  "If there is only one common adjust for both heating and cooling, use the adjust value from cooling one"
                  annotation (Placement(transformation(extent={{80,240},{100,260}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi7
                  "Ensure heating setpoint being not higher than cooling setpoint minus 0.56 degC"
                  annotation (Placement(transformation(extent={{280,-590},{300,-570}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi8
                  "Ensure unoccupied heating setppint being lower than occupied one"
                  annotation (Placement(transformation(extent={{100,-610},{120,-590}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi9
                  "Ensure unoccupied cooling setppint being higher than occupied one"
                  annotation (Placement(transformation(extent={{100,-550},{120,-530}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi10
                  "Switch between occupied and unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{220,80},{240,100}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi11
                  "Switch between occupied and unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{220,-140},{240,-120}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi12
                  "Increase cooling setpoint when the zone is unpopulated by more than 5 minutes"
                  annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi13
                  "Decrease heating setpoint when the zone is unpopulated by more than 5 minutes"
                  annotation (Placement(transformation(extent={{160,-320},{180,-300}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi14
                  "Switch to TZonCooSetWinOpe when window is open"
                  annotation (Placement(transformation(extent={{-180,-460},{-160,-440}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi15
                  "Switch to TZonHeaSetWinOpe when window is open"
                  annotation (Placement(transformation(extent={{-60,-460},{-40,-440}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi16
                  "Generate level 4 alarm when window is open during modes other than occupied"
                  annotation (Placement(transformation(extent={{-100,-420},{-80,-400}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi17
                  "If it is occupied mode, cooling setpoint should be limited"
                  annotation (Placement(transformation(extent={{-180,-550},{-160,-530}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi18
                  "If it is occupied mode, heating setpoint should be limited"
                  annotation (Placement(transformation(extent={{-180,-610},{-160,-590}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi19
                  "If there is occupancy sensor, update heating setpoint according to the occupancy"
                  annotation (Placement(transformation(extent={{220,-320},{240,-300}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi20
                  "If there is occupancy sensor, update cooling setpoint according to the occupancy"
                  annotation (Placement(transformation(extent={{220,-280},{240,-260}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi21
                  "If there is window status sensor, update heating setpoint according to the window status"
                  annotation (Placement(transformation(extent={{160,-480},{180,-460}})));
                Buildings.Controls.OBC.CDL.Logical.Switch swi22
                  "If there is window status sensor, update cooling setpoint according to the window status"
                  annotation (Placement(transformation(extent={{100,-460},{120,-440}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu7
                  "Check if the heating demand limit level is level 2"
                  annotation (Placement(transformation(extent={{-100,-160},{-80,-140}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt8(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating3)
                  "Heat demand limit level 3"
                  annotation (Placement(transformation(extent={{-160,-200},{-140,-180}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu8
                  "Check if the heating demand limit level is level 3"
                  annotation (Placement(transformation(extent={{-100,-200},{-80,-180}})));
                Buildings.Controls.OBC.CDL.Logical.Not not4 "Logical not"
                  annotation (Placement(transformation(extent={{-340,-280},{-320,-260}})));
                Buildings.Controls.OBC.CDL.Logical.And and10
                  "Check if the zone becomes unpopulated during occupied mode"
                  annotation (Placement(transformation(extent={{-280,-280},{-260,-260}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt6(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating1)
                  "Heat demand limit level 1"
                  annotation (Placement(transformation(extent={{-160,-120},{-140,-100}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu6
                  "Check if the heating demand limit level is level 1"
                  annotation (Placement(transformation(extent={{-100,-120},{-80,-100}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt7(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating2)
                  "Heat demand limit level 2"
                  annotation (Placement(transformation(extent={{-160,-160},{-140,-140}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr
                  "Check if cooling demand limit level is higher than level zero"
                  annotation (Placement(transformation(extent={{-340,-20},{-320,0}})));
                Buildings.Controls.OBC.CDL.Integers.GreaterThreshold intGreThr1
                  "Check if heating demand limit level is higher than level zero"
                  annotation (Placement(transformation(extent={{-340,-60},{-320,-40}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt3(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling1)
                  "Cool demand limit level 1"
                  annotation (Placement(transformation(extent={{-160,100},{-140,120}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu3
                  "Check if the cooling demand limit level is level 1"
                  annotation (Placement(transformation(extent={{-100,100},{-80,120}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt4(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling2)
                  "Cool demand limit level 2"
                  annotation (Placement(transformation(extent={{-160,62},{-140,82}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu4
                  "Check if the cooling demand limit level is level 2"
                  annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
                Buildings.Controls.OBC.CDL.Integers.Sources.Constant conInt5(
                  k=Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling3)
                  "Cool demand limit level 3"
                  annotation (Placement(transformation(extent={{-160,20},{-140,40}})));
                Buildings.Controls.OBC.CDL.Integers.Equal intEqu5
                  "Check if the cooling demand limit level is level 3"
                  annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add3 "Add real inputs"
                  annotation (Placement(transformation(extent={{120,118},{140,138}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add4 "Add real inputs"
                  annotation (Placement(transformation(extent={{120,40},{140,60}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add5 "Add real inputs"
                  annotation (Placement(transformation(extent={{160,80},{180,100}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add6 "Add real inputs"
                  annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add7 "Add real inputs"
                  annotation (Placement(transformation(extent={{120,-180},{140,-160}})));
                Buildings.Controls.OBC.CDL.Continuous.Add add8 "Add real inputs"
                  annotation (Placement(transformation(extent={{160,-140},{180,-120}})));

              equation
                connect(uOpeMod, intEqu.u1)
                  annotation (Line(points={{-440,630},{-320,630},{-320,610},{-302,610}},
                    color={255,127,0}));
                connect(uOpeMod, intEqu1.u1)
                  annotation (Line(points={{-440,630},{-220,630},{-220,610},{-202,610}},
                    color={255,127,0}));
                connect(uOpeMod, intEqu2.u1)
                  annotation (Line(points={{-440,630},{-120,630},{-120,610},{-100,610}},
                    color={255,127,0}));
                connect(conInt.y, intEqu.u2)
                  annotation (Line(points={{-318,580},{-310,580},{-310,602},{-302,602}},
                    color={255,127,0}));
                connect(conInt1.y, intEqu1.u2)
                  annotation (Line(points={{-218,580},{-210,580},{-210,602},{-202,602}},
                    color={255,127,0}));
                connect(conInt2.y, intEqu2.u2)
                  annotation (Line(points={{-118,580},{-110,580},{-110,602},{-100,602}},
                    color={255,127,0}));
                connect(intEqu.y, or3.u1)
                  annotation (Line(points={{-278,610},{-260,610},{-260,640},{-34,640},{-34,618},
                        {-22,618}},
                                color={255,0,255}));
                connect(intEqu1.y, or3.u2)
                  annotation (Line(points={{-178,610},{-160,610},{-160,634},{-40,634},{-40,610},
                        {-22,610}},
                                color={255,0,255}));
                connect(intEqu2.y, or3.u3)
                  annotation (Line(points={{-76,610},{-60,610},{-60,602},{-22,602}},
                    color={255,0,255}));
                connect(TZonCooSetOcc, swi.u1)
                  annotation (Line(points={{-440,530},{-360,530},{-360,538},{-302,538}},
                    color={0,0,127}));
                connect(TZonCooSetUno, swi.u3)
                  annotation (Line(points={{-440,490},{-360,490},{-360,522},{-302,522}},
                    color={0,0,127}));
                connect(TZonHeaSetOcc, swi1.u1)
                  annotation (Line(points={{-440,450},{-360,450},{-360,458},{-302,458}},
                    color={0,0,127}));
                connect(TZonHeaSetUno, swi1.u3)
                  annotation (Line(points={{-440,410},{-360,410},{-360,442},{-302,442}},
                    color={0,0,127}));
                connect(or3.y, swi.u2)
                  annotation (Line(points={{2,610},{20,610},{20,560},{-320,560},{-320,530},{-302,
                        530}},   color={255,0,255}));
                connect(or3.y, swi1.u2)
                  annotation (Line(points={{2,610},{20,610},{20,560},{-320,560},{-320,450},{-302,
                        450}},   color={255,0,255}));
                connect(cooSetAdjCon.y, swi4.u2)
                  annotation (Line(points={{-318,330},{-282,330}}, color={255,0,255}));
                connect(setAdj, swi4.u1)
                  annotation (Line(points={{-440,350},{-300,350},{-300,338},{-282,338}},
                    color={0,0,127}));
                connect(con3.y, swi4.u1)
                  annotation (Line(points={{-318,370},{-300,370},{-300,338},{-282,338}},
                    color={0,0,127}));
                connect(con.y, swi4.u3)
                  annotation (Line(points={{-318,290},{-300,290},{-300,322},{-282,322}},
                    color={0,0,127}));
                connect(swi4.y, add2.u2)
                  annotation (Line(points={{-258,330},{-220,330},{-220,344},{-202,344}},
                    color={0,0,127}));
                connect(swi.y, add2.u1)
                  annotation (Line(points={{-278,530},{-220,530},{-220,356},{-202,356}},
                    color={0,0,127}));
                connect(add2.y, swi2.u1)
                  annotation (Line(points={{-178,350},{-160,350},{-160,342},{-122,342}},
                    color={0,0,127}));
                connect(swi.y, swi2.u3)
                  annotation (Line(points={{-278,530},{-220,530},{-220,380},{-160,380},{-160,358},
                        {-122,358}},
                                 color={0,0,127}));
                connect(intEqu2.y, swi2.u2)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{-140,380},{-140,350},
                        {-122,350}},
                                 color={255,0,255}));
                connect(heaSetAdjCon.y, swi5.u2)
                  annotation (Line(points={{-38,250},{-2,250}}, color={255,0,255}));
                connect(con1.y, swi5.u3)
                  annotation (Line(points={{-38,210},{-20,210},{-20,242},{-2,242}},
                    color={0,0,127}));
                connect(swi5.y, swi6.u3)
                  annotation (Line(points={{22,250},{40,250},{40,242},{78,242}},
                    color={0,0,127}));
                connect(sinSetAdjCon.y, swi6.u2)
                  annotation (Line(points={{42,210},{60,210},{60,250},{78,250}},
                    color={255,0,255}));
                connect(swi6.y, add1.u2)
                  annotation (Line(points={{102,250},{120,250},{120,244},{138,244}},
                    color={0,0,127}));
                connect(add1.y, swi3.u1)
                  annotation (Line(points={{162,250},{180,250},{180,242},{218,242}},
                    color={0,0,127}));
                connect(heaSetAdj, swi5.u1)
                  annotation (Line(points={{-440,270},{-20,270},{-20,258},{-2,258}},
                    color={0,0,127}));
                connect(con4.y, swi5.u1)
                  annotation (Line(points={{-318,250},{-300,250},{-300,270},{-20,270},{-20,258},
                        {-2,258}},
                               color={0,0,127}));
                connect(swi4.y, swi6.u1)
                  annotation (Line(points={{-258,330},{-220,330},{-220,280},{60,280},{60,258},
                        {78,258}},
                               color={0,0,127}));
                connect(swi1.y, add1.u1)
                  annotation (Line(points={{-278,450},{120,450},{120,256},{138,256}},
                    color={0,0,127}));
                connect(swi1.y, swi3.u3)
                  annotation (Line(points={{-278,450},{120,450},{120,280},{180,280},{180,258},
                        {218,258}},
                                color={0,0,127}));
                connect(intEqu2.y, swi3.u2)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{200,380},{200,250},{
                        218,250}},
                                color={255,0,255}));
                connect(uCooDemLimLev, intGreThr.u)
                  annotation (Line(points={{-440,130},{-360,130},{-360,-10},{-342,-10}},
                    color={255,127,0}));
                connect(uHeaDemLimLev, intGreThr1.u)
                  annotation (Line(points={{-440,-90},{-360,-90},{-360,-50},{-342,-50}},
                    color={255,127,0}));
                connect(intGreThr1.y, or2.u2)
                  annotation (Line(points={{-318,-50},{-300,-50},{-300,-38},{-282,-38}},
                    color={255,0,255}));
                connect(intGreThr.y, or2.u1)
                  annotation (Line(points={{-318,-10},{-300,-10},{-300,-30},{-282,-30}},
                    color={255,0,255}));
                connect(or2.y, edg.u)
                  annotation (Line(points={{-258,-30},{-240,-30},{-240,0},{-222,0}},
                    color={255,0,255}));
                connect(intEqu3.y, booToRea.u)
                  annotation (Line(points={{-78,110},{-42,110}}, color={255,0,255}));
                connect(intEqu4.y, booToRea1.u)
                  annotation (Line(points={{-78,70},{-42,70}}, color={255,0,255}));
                connect(intEqu5.y, booToRea2.u)
                  annotation (Line(points={{-78,30},{-42,30}}, color={255,0,255}));
                connect(uCooDemLimLev, intEqu3.u1)
                  annotation (Line(points={{-440,130},{-120,130},{-120,110},{-102,110}},
                    color={255,127,0}));
                connect(uCooDemLimLev, intEqu4.u1)
                  annotation (Line(points={{-440,130},{-120,130},{-120,70},{-102,70}},
                    color={255,127,0}));
                connect(uCooDemLimLev, intEqu5.u1)
                  annotation (Line(points={{-440,130},{-120,130},{-120,30},{-102,30}},
                    color={255,127,0}));
                connect(conInt3.y, intEqu3.u2)
                  annotation (Line(points={{-138,110},{-128,110},{-128,102},{-102,102}},
                    color={255,127,0}));
                connect(conInt4.y, intEqu4.u2)
                  annotation (Line(points={{-138,72},{-128,72},{-128,62},{-102,62}},
                    color={255,127,0}));
                connect(conInt5.y, intEqu5.u2)
                  annotation (Line(points={{-138,30},{-128,30},{-128,22},{-102,22}},
                    color={255,127,0}));
                connect(intEqu3.y, or1.u1)
                  annotation (Line(points={{-78,110},{-66,110},{-66,158},{-42,158}},
                    color={255,0,255}));
                connect(intEqu4.y, or1.u2)
                  annotation (Line(points={{-78,70},{-60,70},{-60,150},{-42,150}},
                    color={255,0,255}));
                connect(intEqu5.y, or1.u3)
                  annotation (Line(points={{-78,30},{-54,30},{-54,142},{-42,142}},
                    color={255,0,255}));
                connect(or1.y, not1.u)
                  annotation (Line(points={{-18,150},{-2,150}}, color={255,0,255}));
                connect(not1.y, booToRea6.u)
                  annotation (Line(points={{22,150},{38,150}}, color={255,0,255}));
                connect(booToRea.y, pro.u2)
                  annotation (Line(points={{-18,110},{0,110},{0,92},{70,92},{70,104},{78,104}},
                    color={0,0,127}));
                connect(cooSetFre.y, addPar2.u)
                  annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,110},
                        {38,110}},
                               color={0,0,127}));
                connect(cooSetFre.y, addPar1.u)
                  annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,70},{
                        38,70}},
                              color={0,0,127}));
                connect(cooSetFre.y, addPar3.u)
                  annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,30},{
                        38,30}},
                              color={0,0,127}));
                connect(booToRea1.y, pro1.u2)
                  annotation (Line(points={{-18,70},{0,70},{0,52},{72,52},{72,64},{78,64}},
                    color={0,0,127}));
                connect(booToRea2.y, pro2.u2)
                  annotation (Line(points={{-18,30},{0,30},{0,12},{70,12},{70,24},{78,24}},
                    color={0,0,127}));
                connect(addPar2.y, pro.u1)
                  annotation (Line(points={{62,110},{70,110},{70,116},{78,116}},
                    color={0,0,127}));
                connect(cooSetFre.y, pro6.u2)
                  annotation (Line(points={{-138,150},{-100,150},{-100,132},{70,132},{70,144},
                        {78,144}},
                               color={0,0,127}));
                connect(booToRea6.y, pro6.u1)
                  annotation (Line(points={{62,150},{70,150},{70,156},{78,156}},
                    color={0,0,127}));
                connect(addPar1.y, pro1.u1)
                  annotation (Line(points={{62,70},{72,70},{72,76},{78,76}},
                    color={0,0,127}));
                connect(addPar3.y, pro2.u1)
                  annotation (Line(points={{62,30},{70,30},{70,36},{78,36}},
                    color={0,0,127}));
                connect(or2.y, not3.u)
                  annotation (Line(points={{-258,-30},{-102,-30}}, color={255,0,255}));
                connect(con2.y, or5.u1)
                  annotation (Line(points={{-138,-10},{158,-10}}, color={255,0,255}));
                connect(not3.y, or5.u2)
                  annotation (Line(points={{-78,-30},{-60,-30},{-60,-18},{158,-18}},
                    color={255,0,255}));
                connect(uHeaDemLimLev, intEqu6.u1)
                  annotation (Line(points={{-440,-90},{-120,-90},{-120,-110},{-102,-110}},
                    color={255,127,0}));
                connect(uHeaDemLimLev, intEqu7.u1)
                  annotation (Line(points={{-440,-90},{-120,-90},{-120,-150},{-102,-150}},
                    color={255,127,0}));
                connect(uHeaDemLimLev, intEqu8.u1)
                  annotation (Line(points={{-440,-90},{-120,-90},{-120,-190},{-102,-190}},
                    color={255,127,0}));
                connect(conInt6.y, intEqu6.u2)
                  annotation (Line(points={{-138,-110},{-130,-110},{-130,-118},{-102,-118}},
                    color={255,127,0}));
                connect(conInt7.y, intEqu7.u2)
                  annotation (Line(points={{-138,-150},{-130,-150},{-130,-158},{-102,-158}},
                    color={255,127,0}));
                connect(conInt8.y, intEqu8.u2)
                  annotation (Line(points={{-138,-190},{-130,-190},{-130,-198},{-102,-198}},
                    color={255,127,0}));
                connect(intEqu6.y, booToRea3.u)
                  annotation (Line(points={{-78,-110},{-42,-110}}, color={255,0,255}));
                connect(intEqu7.y, booToRea4.u)
                  annotation (Line(points={{-78,-150},{-42,-150}}, color={255,0,255}));
                connect(intEqu8.y, booToRea5.u)
                  annotation (Line(points={{-78,-190},{-42,-190}}, color={255,0,255}));
                connect(intEqu6.y, or4.u1)
                  annotation (Line(points={{-78,-110},{-66,-110},{-66,-62},{-42,-62}},
                    color={255,0,255}));
                connect(intEqu7.y, or4.u2)
                  annotation (Line(points={{-78,-150},{-60,-150},{-60,-70},{-42,-70}},
                    color={255,0,255}));
                connect(intEqu8.y, or4.u3)
                  annotation (Line(points={{-78,-190},{-54,-190},{-54,-78},{-42,-78}},
                    color={255,0,255}));
                connect(or4.y, not2.u)
                  annotation (Line(points={{-18,-70},{-2,-70}}, color={255,0,255}));
                connect(not2.y, booToRea7.u)
                  annotation (Line(points={{22,-70},{38,-70}}, color={255,0,255}));
                connect(booToRea7.y, pro7.u1)
                  annotation (Line(points={{62,-70},{70,-70},{70,-64},{78,-64}},
                    color={0,0,127}));
                connect(heaSetFre.y, pro7.u2)
                  annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{70,-88},{70,-76},
                        {78,-76}},
                               color={0,0,127}));
                connect(heaSetFre.y, addPar6.u)
                  annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-110},
                        {38,-110}},
                                color={0,0,127}));
                connect(heaSetFre.y, addPar5.u)
                  annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-150},
                        {38,-150}},
                                color={0,0,127}));
                connect(heaSetFre.y, addPar4.u)
                  annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-190},
                        {38,-190}},
                                color={0,0,127}));
                connect(addPar6.y, pro3.u1)
                  annotation (Line(points={{62,-110},{70,-110},{70,-104},{78,-104}},
                    color={0,0,127}));
                connect(addPar5.y, pro4.u1)
                  annotation (Line(points={{62,-150},{70,-150},{70,-144},{78,-144}},
                    color={0,0,127}));
                connect(addPar4.y, pro5.u1)
                  annotation (Line(points={{62,-190},{70,-190},{70,-184},{78,-184}},
                    color={0,0,127}));
                connect(booToRea3.y, pro3.u2)
                  annotation (Line(points={{-18,-110},{0,-110},{0,-126},{70,-126},{70,-116},{
                        78,-116}},
                                color={0,0,127}));
                connect(booToRea4.y, pro4.u2)
                  annotation (Line(points={{-18,-150},{0,-150},{0,-166},{70,-166},{70,-156},{
                        78,-156}},
                                color={0,0,127}));
                connect(booToRea5.y, pro5.u2)
                  annotation (Line(points={{-18,-190},{0,-190},{0,-206},{70,-206},{70,-196},{
                        78,-196}},
                                color={0,0,127}));
                connect(edg.y, cooSetFre.trigger)
                  annotation (Line(points={{-198,0},{-180,0},{-180,134},{-150,134},{-150,138.2}},
                    color={255,0,255}));
                connect(edg.y, heaSetFre.trigger)
                  annotation (Line(points={{-198,0},{-180,0},{-180,-86},{-150,-86},{-150,-81.8}},
                    color={255,0,255}));
                connect(or5.y, swi10.u2)
                  annotation (Line(points={{182,-10},{200,-10},{200,90},{218,90}},
                    color={255,0,255}));
                connect(or5.y, swi11.u2)
                  annotation (Line(points={{182,-10},{200,-10},{200,-130},{218,-130}},
                    color={255,0,255}));
                connect(swi2.y, cooSetFre.u)
                  annotation (Line(points={{-98,350},{-80,350},{-80,180},{-180,180},{-180,150},
                        {-162,150}},
                                 color={0,0,127}));
                connect(swi2.y, swi10.u1)
                  annotation (Line(points={{-98,350},{-80,350},{-80,180},{200,180},{200,98},{218,
                        98}},
                    color={0,0,127}));
                connect(swi3.y, heaSetFre.u)
                  annotation (Line(points={{242,250},{260,250},{260,186},{-186,186},{-186,-70},
                        {-162,-70}},
                                 color={0,0,127}));
                connect(swi3.y, swi11.u1)
                  annotation (Line(points={{242,250},{260,250},{260,186},{-186,186},{-186,-48},
                        {208,-48},{208,-122},{218,-122}},
                                                      color={0,0,127}));
                connect(uOccSen, not4.u)
                  annotation (Line(points={{-440,-270},{-342,-270}}, color={255,0,255}));
                connect(conTru.y, not4.u)
                  annotation (Line(points={{-358,-350},{-350,-350},{-350,-270},{-342,-270}},
                    color={255,0,255}));
                connect(and10.y, tim.u)
                  annotation (Line(points={{-258,-270},{-222,-270}}, color={255,0,255}));
                connect(truHol.y, edg1.u)
                  annotation (Line(points={{-78,-270},{-42,-270}}, color={255,0,255}));
                connect(edg1.y, cooSetSam.trigger)
                  annotation (Line(points={{-18,-270},{0,-270},{0,-288},{50,-288},{50,-281.8}},
                    color={255,0,255}));
                connect(edg1.y, heaSetSam.trigger)
                  annotation (Line(points={{-18,-270},{0,-270},{0,-330},{50,-330},{50,-321.8}},
                    color={255,0,255}));
                connect(cooSetSam.y, cooSetInc.u)
                  annotation (Line(points={{62,-270},{98,-270}}, color={0,0,127}));
                connect(heaSetSam.y, heaSetDec.u)
                  annotation (Line(points={{62,-310},{98,-310}}, color={0,0,127}));
                connect(cooSetInc.y, swi12.u1)
                  annotation (Line(points={{122,-270},{136,-270},{136,-262},{158,-262}},
                    color={0,0,127}));
                connect(heaSetDec.y, swi13.u1)
                  annotation (Line(points={{122,-310},{136,-310},{136,-302},{158,-302}},
                    color={0,0,127}));
                connect(truHol.y, swi12.u2)
                  annotation (Line(points={{-78,-270},{-60,-270},{-60,-250},{140,-250},{140,-270},
                        {158,-270}},
                                 color={255,0,255}));
                connect(truHol.y, swi13.u2)
                  annotation (Line(points={{-78,-270},{-60,-270},{-60,-250},{140,-250},{140,-310},
                        {158,-310}},
                                 color={255,0,255}));
                connect(swi11.y, swi13.u3)
                  annotation (Line(points={{242,-130},{260,-130},{260,-240},{144,-240},{144,-318},
                        {158,-318}},
                                 color={0,0,127}));
                connect(swi10.y, swi12.u3)
                  annotation (Line(points={{242,90},{264,90},{264,-244},{148,-244},{148,-278},
                        {158,-278}},
                                 color={0,0,127}));
                connect(intEqu2.y, and10.u1)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                        {-300,-220},{-300,-270},{-282,-270}},
                                                          color={255,0,255}));
                connect(not4.y, and10.u2)
                  annotation (Line(points={{-318,-270},{-308,-270},{-308,-278},{-282,-278}},
                    color={255,0,255}));
                connect(swi11.y, heaSetSam.u)
                  annotation (Line(points={{242,-130},{260,-130},{260,-240},{20,-240},{20,-310},
                        {38,-310}},
                                color={0,0,127}));
                connect(swi10.y, cooSetSam.u)
                  annotation (Line(points={{242,90},{264,90},{264,-244},{24,-244},{24,-270},{38,
                        -270}}, color={0,0,127}));
                connect(have_occSenCon.y, swi20.u2)
                  annotation (Line(points={{182,-350},{200,-350},{200,-270},{218,-270}},
                    color={255,0,255}));
                connect(have_occSenCon.y, swi19.u2)
                  annotation (Line(points={{182,-350},{200,-350},{200,-310},{218,-310}},
                    color={255,0,255}));
                connect(swi12.y, swi20.u1)
                  annotation (Line(points={{182,-270},{196,-270},{196,-262},{218,-262}},
                    color={0,0,127}));
                connect(swi13.y, swi19.u1)
                  annotation (Line(points={{182,-310},{196,-310},{196,-302},{218,-302}},
                    color={0,0,127}));
                connect(swi10.y, swi20.u3)
                  annotation (Line(points={{242,90},{264,90},{264,-244},{208,-244},{208,-278},
                        {218,-278}},
                                 color={0,0,127}));
                connect(swi11.y, swi19.u3)
                  annotation (Line(points={{242,-130},{260,-130},{260,-240},{204,-240},{204,-318},
                        {218,-318}},
                                 color={0,0,127}));
                connect(intEqu2.y, not5.u)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                        {-300,-220},{-300,-390},{-282,-390}},
                                                          color={255,0,255}));
                connect(uWinSta, and11.u2)
                  annotation (Line(points={{-440,-410},{-260,-410},{-260,-418},{-222,-418}},
                    color={255,0,255}));
                connect(not5.y, and11.u1)
                  annotation (Line(points={{-258,-390},{-240,-390},{-240,-410},{-222,-410}},
                    color={255,0,255}));
                connect(and11.y, swi16.u2)
                  annotation (Line(points={{-198,-410},{-102,-410}}, color={255,0,255}));
                connect(alaFou.y, swi16.u1)
                  annotation (Line(points={{-118,-390},{-112,-390},{-112,-402},{-102,-402}},
                    color={0,0,127}));
                connect(alaZer.y, swi16.u3)
                  annotation (Line(points={{-158,-390},{-150,-390},{-150,-418},{-102,-418}},
                    color={0,0,127}));
                connect(swi16.y, reaToInt.u)
                  annotation (Line(points={{-78,-410},{-64,-410},{-64,-390},{158,-390}},
                    color={0,0,127}));
                connect(uWinSta, swi14.u2)
                  annotation (Line(points={{-440,-410},{-260,-410},{-260,-432},{-200,-432},
                    {-200,-450},{-182,-450}}, color={255,0,255}));
                connect(uWinSta, swi15.u2)
                  annotation (Line(points={{-440,-410},{-260,-410},{-260,-432},{-80,-432},
                    {-80,-450},{-62,-450}}, color={255,0,255}));
                connect(cooSetWinOpe.y, swi14.u1)
                  annotation (Line(points={{-218,-470},{-204,-470},{-204,-442},{-182,-442}},
                    color={0,0,127}));
                connect(heaSetWinOpe.y, swi15.u1)
                  annotation (Line(points={{-98,-470},{-84,-470},{-84,-442},{-62,-442}},
                    color={0,0,127}));
                connect(winSenCon.y, swi22.u2)
                  annotation (Line(points={{62,-470},{80,-470},{80,-450},{98,-450}},
                    color={255,0,255}));
                connect(winSenCon.y, swi21.u2)
                  annotation (Line(points={{62,-470},{158,-470}}, color={255,0,255}));
                connect(swi19.y, swi15.u3)
                  annotation (Line(points={{242,-310},{260,-310},{260,-432},{-76,-432},{-76,-458},
                        {-62,-458}},
                                 color={0,0,127}));
                connect(swi19.y, swi21.u3)
                  annotation (Line(points={{242,-310},{260,-310},{260,-432},{140,-432},{140,-478},
                        {158,-478}},
                                 color={0,0,127}));
                connect(swi20.y, swi14.u3)
                  annotation (Line(points={{242,-270},{256,-270},{256,-428},{-196,-428},{-196,
                        -458},{-182,-458}},
                                  color={0,0,127}));
                connect(swi20.y, swi22.u3)
                  annotation (Line(points={{242,-270},{256,-270},{256,-428},{84,-428},{84,-458},
                        {98,-458}},
                                color={0,0,127}));
                connect(swi14.y, swi22.u1)
                  annotation (Line(points={{-158,-450},{-140,-450},{-140,-424},{88,-424},{88,-442},
                        {98,-442}},
                                color={0,0,127}));
                connect(swi15.y, swi21.u1)
                  annotation (Line(points={{-38,-450},{-20,-450},{-20,-420},{144,-420},{144,-462},
                        {158,-462}},
                                 color={0,0,127}));
                connect(conFal.y, and11.u2)
                  annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                        -418},{-222,-418}},
                                  color={255,0,255}));
                connect(conFal.y, swi14.u2)
                  annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                        -432},{-200,-432},{-200,-450},{-182,-450}},
                                                          color={255,0,255}));
                connect(conFal.y, swi15.u2)
                  annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                        -432},{-80,-432},{-80,-450},{-62,-450}},
                                                       color={255,0,255}));
                connect(swi22.y, cooSetLim.u)
                  annotation (Line(points={{122,-450},{136,-450},{136,-500},{-260,-500},{-260,
                        -520},{-242,-520}},
                                  color={0,0,127}));
                connect(swi21.y, heaSetLim.u)
                  annotation (Line(points={{182,-470},{200,-470},{200,-496},{-264,-496},{-264,
                        -580},{-242,-580}},
                                  color={0,0,127}));
                connect(cooSetLim.y, swi17.u1)
                  annotation (Line(points={{-218,-520},{-192,-520},{-192,-532},{-182,-532}},
                    color={0,0,127}));
                connect(heaSetLim.y, swi18.u1)
                  annotation (Line(points={{-218,-580},{-192,-580},{-192,-592},{-182,-592}},
                    color={0,0,127}));
                connect(swi22.y, swi17.u3)
                  annotation (Line(points={{122,-450},{136,-450},{136,-500},{-198,-500},{-198,
                        -548},{-182,-548}},
                                  color={0,0,127}));
                connect(swi21.y, swi18.u3)
                  annotation (Line(points={{182,-470},{200,-470},{200,-496},{-204,-496},{-204,
                        -608},{-182,-608}},
                                  color={0,0,127}));
                connect(intEqu2.y, swi17.u2)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                        {-300,-220},{-300,-540},{-182,-540}},
                                                          color={255,0,255}));
                connect(intEqu2.y, swi18.u2)
                  annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                        {-300,-220},{-300,-600},{-182,-600}},
                                                          color={255,0,255}));
                connect(swi17.y, les.u1)
                  annotation (Line(points={{-158,-540},{18,-540}}, color={0,0,127}));
                connect(les.y, swi9.u2)
                  annotation (Line(points={{42,-540},{98,-540}}, color={255,0,255}));
                connect(swi18.y, gre.u1)
                  annotation (Line(points={{-158,-600},{18,-600}}, color={0,0,127}));
                connect(gre.y, swi8.u2)
                  annotation (Line(points={{42,-600},{98,-600}}, color={255,0,255}));
                connect(swi17.y, swi9.u1)
                  annotation (Line(points={{-158,-540},{-100,-540},{-100,-520},{80,-520},{80,-532},
                        {98,-532}},       color={0,0,127}));
                connect(swi18.y, swi8.u1)
                  annotation (Line(points={{-158,-600},{-100,-600},{-100,-580},{80,-580},{80,-592},
                        {98,-592}},       color={0,0,127}));
                connect(TZonCooSetUno, les.u2) annotation (Line(points={{-440,490},{-400,490},
                        {-400,-560},{0,-560},{0,-548},{18,-548}}, color={0,0,127}));
                connect(TZonCooSetUno, swi9.u3)
                  annotation (Line(points={{-440,490},{-400,490},{-400,-560},{80,-560},
                    {80,-548},{98,-548}}, color={0,0,127}));
                connect(TZonHeaSetUno, gre.u2) annotation (Line(points={{-440,410},{-406,410},
                        {-406,-620},{0,-620},{0,-608},{18,-608}}, color={0,0,127}));
                connect(TZonHeaSetUno, swi8.u3)
                  annotation (Line(points={{-440,410},{-406,410},{-406,-620},{80,-620},
                    {80,-608},{98,-608}}, color={0,0,127}));
                connect(swi9.y, addPar.u)
                  annotation (Line(points={{122,-540},{140,-540},{140,-580},{158,-580}},
                    color={0,0,127}));
                connect(gre2.y, swi7.u2)
                  annotation (Line(points={{242,-580},{278,-580}}, color={255,0,255}));
                connect(swi8.y, gre2.u1) annotation (Line(points={{122,-600},{206,-600},{206,
                        -580},{218,-580}}, color={0,0,127}));
                connect(addPar.y, gre2.u2) annotation (Line(points={{182,-580},{200,-580},{
                        200,-588},{218,-588}}, color={0,0,127}));
                connect(swi8.y, swi7.u3)
                  annotation (Line(points={{122,-600},{260,-600},{260,-588},{278,-588}},
                    color={0,0,127}));
                connect(addPar.y, swi7.u1)
                  annotation (Line(points={{182,-580},{200,-580},{200,-560},{260,-560},{260,-572},
                        {278,-572}},        color={0,0,127}));
                connect(swi7.y, TZonHeaSet)
                  annotation (Line(points={{302,-580},{320,-580},{320,-100},{360,-100}},
                    color={0,0,127}));
                connect(swi9.y, TZonCooSet)
                  annotation (Line(points={{122,-540},{300,-540},{300,0},{360,0}},
                    color={0,0,127}));
                connect(reaToInt.y, yAla)
                  annotation (Line(points={{182,-390},{360,-390}}, color={255,127,0}));
                connect(pro6.y, add3.u1) annotation (Line(points={{102,150},{110,150},{110,
                        134},{118,134}}, color={0,0,127}));
                connect(pro.y, add3.u2) annotation (Line(points={{102,110},{110,110},{110,122},
                        {118,122}}, color={0,0,127}));
                connect(pro1.y, add4.u1) annotation (Line(points={{102,70},{110,70},{110,56},
                        {118,56}}, color={0,0,127}));
                connect(pro2.y, add4.u2) annotation (Line(points={{102,30},{110,30},{110,44},
                        {118,44}}, color={0,0,127}));
                connect(add3.y, add5.u1) annotation (Line(points={{142,128},{150,128},{150,96},
                        {158,96}}, color={0,0,127}));
                connect(add4.y, add5.u2) annotation (Line(points={{142,50},{150,50},{150,84},
                        {158,84}}, color={0,0,127}));
                connect(add5.y, swi10.u3) annotation (Line(points={{182,90},{190,90},{190,82},
                        {218,82}}, color={0,0,127}));
                connect(pro7.y, add6.u1) annotation (Line(points={{102,-70},{110,-70},{110,
                        -84},{118,-84}}, color={0,0,127}));
                connect(pro3.y, add6.u2) annotation (Line(points={{102,-110},{110,-110},{110,
                        -96},{118,-96}}, color={0,0,127}));
                connect(pro4.y, add7.u1) annotation (Line(points={{102,-150},{110,-150},{110,
                        -164},{118,-164}}, color={0,0,127}));
                connect(pro5.y, add7.u2) annotation (Line(points={{102,-190},{110,-190},{110,
                        -176},{118,-176}}, color={0,0,127}));
                connect(add6.y, add8.u1) annotation (Line(points={{142,-90},{150,-90},{150,
                        -124},{158,-124}}, color={0,0,127}));
                connect(add7.y, add8.u2) annotation (Line(points={{142,-170},{150,-170},{150,
                        -136},{158,-136}}, color={0,0,127}));
                connect(add8.y, swi11.u3) annotation (Line(points={{182,-130},{190,-130},{190,
                        -138},{218,-138}}, color={0,0,127}));
                connect(tim.passed, truHol.u) annotation (Line(points={{-198,-278},{-150,-278},
                        {-150,-270},{-102,-270}}, color={255,0,255}));
              annotation (
                defaultComponentName="TZonSet",
                Icon(coordinateSystem(extent={{-100,-140},{100,140}}),
                     graphics={
                      Rectangle(
                      extent={{-100,-140},{100,140}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-96,100},{-30,82}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonCooSetOcc"),
                      Text(
                        extent={{-96,52},{-28,32}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonHeaSetOcc"),
                      Text(
                        extent={{-96,28},{-30,12}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonHeaSetUno"),
                      Text(
                        extent={{-96,76},{-30,62}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonCooSetUno"),
                      Text(
                        visible=heaAdj,
                        extent={{-100,-24},{-48,-36}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="heaSetAdj"),
                      Text(
                        visible=cooAdj or sinAdj,
                        extent={{-100,0},{-66,-14}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="setAdj"),
                      Text(
                        extent={{-100,138},{-50,126}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="uOpeMod"),
                      Text(
                        extent={{-96,-50},{-20,-68}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="uCooDemLimLev"),
                      Text(
                        extent={{-96,-72},{-24,-88}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="uHeaDemLimLev"),
                      Text(
                        extent={{-19.5,6},{19.5,-6}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        origin={-77.5,-110},
                        textString="uOccSen"),
                      Text(
                        extent={{-19,8.5},{19,-8.5}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        origin={-79,-129.5},
                        textString="uWinSta"),
                      Text(
                        extent={{72,-74},{100,-86}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="yAla"),
                      Text(
                        extent={{50,88},{98,72}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonCooSet"),
                      Text(
                        extent={{46,10},{96,-8}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="TZonHeaSet"),
                      Text(
                        extent={{-120,180},{100,140}},
                        lineColor={0,0,255},
                        textString="%name")}),
                Diagram(coordinateSystem(
                      preserveAspectRatio=false,
                      extent={{-420,-620},{340,640}}), graphics={
                      Rectangle(
                        extent={{-412,636},{330,558}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,548},{330,402}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,390},{330,186}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,174},{332,-212}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,-224},{330,-362}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,-376},{330,-490}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{-412,-502},{-138,-614}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{124,632},{322,596}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Operation mode recognition"),
                      Text(
                        extent={{176,550},{324,506}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Setpoints recognition"),
                      Text(
                        extent={{132,382},{324,332}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        textString="Local setpoints adjustment"),
                      Text(
                        extent={{-254,-290},{-2,-384}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Left,
                        textString="Adjust setpoints due to occupancy"),
                      Text(
                        extent={{-34,-384},{252,-430}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Left,
                        textString="Adjust setpoints due to window status"),
                      Rectangle(
                        extent={{-126,-504},{122,-614}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Rectangle(
                        extent={{134,-504},{330,-614}},
                        lineColor={0,0,0},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(
                        extent={{-394,-540},{-184,-584}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Left,
                        textString="Setpoints limited
in the range"),       Text(
                        extent={{-124,-526},{76,-594}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Left,
                        textString="Limit occupied by
unoccupied"),         Text(
                        extent={{34,-478},{298,-564}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Confine cooling setpoint
by heating one"),     Text(
                        extent={{74,192},{326,98}},
                        lineColor={0,0,255},
                        fillColor={215,215,215},
                        fillPattern=FillPattern.Solid,
                        horizontalAlignment=TextAlignment.Right,
                        textString="Demand limit setpoints
adjustment")}), Documentation(info="<html>
<p>
This sequence sets the thermal zone cooling and heating setpoints. The implementation
is according to the ASHRAE Guideline 36 (G36), PART 5.B.3. The calculation is done
following the steps below.
</p>
<h4>Each zone shall have separate occupied and unoccupied heating and cooling
setpoints.</h4>
<h4>The active setpoints shall be determined by the Operation Mode of the zone
group.</h4>
<ul>
<li>The setpoints shall be the occupied setpoints during Occupied, Warm up, and
Cool-down modes.</li>
<li>The setpoints shall be the unoccupied setpoints during Unoccupied, Setback,
and Setup modes.</li>
</ul>
<h4>The software shall prevent</h4>
<ul>
<li>The heating setpoint from exceeding the cooling setpoint minus 0.56 &deg;C
(1 &deg;F).</li>
<li>The unoccupied heating setpoint from exceeding the occupied heating
setpoint.</li>
<li>The unoccupied cooling setpoint from being less than occupied cooling
setpoint.</li>
</ul>
<h4>Where the zone has a local setpoint adjustment knob/button </h4>
<ul>
<li>The setpoint adjustment offsets established by the occupant shall be software
points that are persistent (e.g. not reset daily), but the actual offset used
in control logic shall be adjusted based on limits and modes as described below.</li>
<li>The adjustment shall be capable of being limited in softare. (a. As a default,
the active occupied cooling setpoint shall be limited between 22 &deg;C
(72 &deg;F) and 27 &deg;C (80 &deg;F); b. As a default, the active occupied
heating setpoint shall be limited between 18 &deg;C (65 &deg;F) and 22 &deg;C
(72 &deg;F);)</li>
<li>The active heating and cooling setpoint shall be independently adjustable,
respecting the limits and anti-overlap logic described above. If zone thermostat
provides only a single setpoint adjustment, then the adjustment shall move both
the same amount, within the limits described above.</li>
<li>The adjustment shall only affect occupied setpoints in Occupied mode, and
shall have no impact on setpoints in all other modes.</li>
<li>At the onset of demand limiting, the local setpoint adjustment value shall
be frozen. Further adjustment of the setpoint by local controls shall be suspended
for the duration of the demand limit event.</li>
</ul>
<h4>Cooling demand limit setpoint adjustment</h4>
<p>The active cooling setpoints for all zones shall be increased when a demand limit
is imposed on the associated zone group. The operator shall have the ability
to exempt individual zones from this adjustment through the normal
Building Automation System (BAS) user interface. Changes due to demand limits
are not cumulative.</p>
<ul>
<li>At Demand Limit Level 1, increase setpoint by 0.56 &deg;C (1 &deg;F).</li>
<li>At Demand Limit Level 2, increase setpoint by 1.1 &deg;C (2 &deg;F).</li>
<li>At Demand Limit Level 1, increase setpoint by 2.2 &deg;C (4 &deg;F).</li>
</ul>
<h4>Heating demand limit setpoint adjustment</h4>
<p>The active heating setpoints for all zones shall be decreased when a demand limit
is imposed on the associated zone group. The operator shall have the ability
to exempt individual zones from this adjustment through the normal BAS user
interface. Changes due to demand limits are not cumulative.</p>
<ul>
<li>At Demand Limit Level 1, decrease setpoint by 0.56 &deg;C (1 &deg;F).</li>
<li>At Demand Limit Level 2, decrease setpoint by 1.1 &deg;C (2 &deg;F).</li>
<li>At Demand Limit Level 1, decrease setpoint by 2.2 &deg;C (4 &deg;F).</li>
</ul>
<h4>Window switches</h4>
<p>For zones that have operable windows with indicator switches, when the window
switch indicates the window is open, the heating setpoint shall be temporarily
set to 4.4 &deg;C (40 &deg;F) and the cooling setpoint shall be temporarily
set to 49 &deg;C (120 &deg;F). When the window switch indicates the window is
open during other than Occupied Mode, a Level 4 alarm shall be generated.</p>
<h4>h. Occupancy sensor</h4>
<ul>
<li>When the switch indicates the space has been unpopulated for 5 minutes
continuously during the Occupied Mode, the active heating setpoint shall be
decreased by 1.1 &deg;C (2 &deg;F) and the cooling setpoint shall be increased
by 1.1 &deg;C (2 &deg;F).</li>
<li>When the switch indicated that the space has been populated for 1 minute
continuously, the active heating and cooling setpoints shall be restored to
their previously values.</li>
</ul>
<p>Hierarchy of setpoint adjustments: the following adjustment restrictions
shall prevail in order from highest to lowest priority.</p>
<ul>
<li>Setpoint overlap restriction</li>
<li>Absolute limits on local setpoint adjustment</li>
<li>Window swtiches</li>
<li>Demand limit (a. Occupancy sensors; b. Local setpoint adjustment)</li>
<li>Scheduled setpoints based on zone group mode</li>
</ul>

</html>",               revisions="<html>
<ul>
<li>
October 11, 2017, by Michael Wetter:<br/>
Removed wrong conditional on <code>yAla</code>.
</li>
<li>
August 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end ZoneTemperatures;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic sequences for generating setpoints for various
terminal units control, according to ASHRAE Guideline 36, Part 5.B.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                  Text(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    textString="S")}));
            end SetPoints;
            annotation (
          Documentation(info="<html>
<p>
This package contains control sequences for terminal units.
</p>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    extent={{-70,60},{-30,20}},
                    lineColor={0,0,127},
                    lineThickness=0.5),
                  Rectangle(
                    extent={{-70,-20},{-30,-60}},
                    lineColor={0,0,127},
                    lineThickness=0.5),
                  Rectangle(
                    extent={{30,20},{70,-20}},
                    lineColor={0,0,127},
                    lineThickness=0.5),
                  Line(
                    points={{-30,40},{0,40},{0,10},{30,10}},
                    color={0,0,127},
                    thickness=0.5),
                  Line(
                    points={{-30,-40},{0,-40},{0,-10},{30,-10}},
                    color={0,0,127},
                    thickness=0.5)}));
          end TerminalUnits;

          package Types "Package with type definitions for control sequences"

            package DemandLimitLevels "Demand limit levels"

              constant Integer cooling1 = 1 "Cooling demand limit level 1";

              constant Integer cooling2 = 2 "Cooling demand limit level 2";

              constant Integer cooling3 = 3 "Cooling demand limit level 3";

              constant Integer heating1 = 1 "Heating demand limit level 1";

              constant Integer heating2 = 2 "Heating demand limit level 2";

              constant Integer heating3 = 3 "Heating demand limit level 3";
              annotation (
              Documentation(info="<html>
<p>
This package provides constants for indicating different cooling or heating
demand limit level for zone setpoint adjustment, PART 5.B.3.
</p>
</html>",             revisions="<html>
<ul>
<li>
August 16, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),             Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0)}));
            end DemandLimitLevels;

            package FreezeProtectionStages
            "Package with constants that indicate the freeze protection stages"

              constant Integer stage0 = 0 "Freeze protection is deactivated";

              constant Integer stage1 = 1 "First stage of freeze protection";
            annotation (
            Documentation(info="<html>
<p>
This package provides constants that indicate the
freeze protection stages.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 14, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),             Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0)}));
            end FreezeProtectionStages;

            package OperationModes "Zone group operating modes"

              constant Integer coolDown = 2 "Cool-down";

              constant Integer freezeProtection = 6 "Freeze protection";

              constant Integer occupied = 1 "Occupied";

              constant Integer setBack = 5 "Set-back";

              constant Integer setUp =  3 "Set-up";

              constant Integer unoccupied = 7 "Unoccupied";

              constant Integer warmUp =  4 "Warm-up";
              annotation (
              Documentation(info="<html>
<p>
This package provides constants for indicating different system operation
modes.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Michael Wetter:<br/>
Reordered constants because the file <code>package.order</code> has
the constants listed alphabetically.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/802\">issue 802</a>.
</li>
<li>
July 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),             Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0)}));
            end OperationModes;
            annotation (Documentation(info="<html>
<p>
This package provides type definitions used in Guideline 36 control sequences.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),                  Polygon(
                    origin={-12.167,-23},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                        {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                        -30},{4.167,20},{12.167,65}},
                    smooth=Smooth.Bezier,
                    lineColor={0,0,0}), Polygon(
                    origin={2.7403,1.6673},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                      10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                      4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
                    smooth=Smooth.Bezier)}));
          end Types;
        annotation (Documentation(info="<html>
<p>
This package contains control sequences from
ASHRAE Guideline 36 (G36).
All sequences are created using blocks from the
<a href=\"modelica://Buildings.Controls.OBC.CDL\">
Buildings.Controls.OBC.CDL</a> library, following the
<a href=\"http://obc.lbl.gov/specification/cdl.html\">
CDL specification</a>.
</p>
<p>
The G36 library is structured as follows:
<ul>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs</a> contains control sequences
for generating controller setpoints such as for the supply air temperature,
and actuation signals for mechanical elements of an AHU such as for the outdoor air damper
position.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types</a> is a library of constants
that are used to indicate the operation mode, such as freeze
protections status and demand response status.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic</a> contains sequences that
are utilized across various parts of an HVAC system,
such as for AHU and for terminal unit control.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits</a> contains control
sequences for terminal units, such as setpoints for the minimal zone airflow rates and
actuator signals for the terminal unit dampers.
</li>
</ul>
<h4>Implementation of PID controllers</h4>
<p>
For the PID controllers, the implementation in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.PID\">
Buildings.Controls.OBC.CDL.Continuous.PID</a>
is used.
Hence, the PID controllers are in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y(t) = k &nbsp; ( e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(s) ds + T<sub>d</sub> de(t)&frasl;dt ),
</p>
<p>
where
<i>y(t)</i> is the control signal,
<i>e(t) = u<sub>s</sub>(t) - u<sub>m</sub>(t)</i> is the control error,
with <i>u<sub>s</sub>(t)</i> being the set point and <i>u<sub>m</sub>(t)</i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term and
<i>T<sub>d</sub></i> is the time constant of the derivative term.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
As the units of flow rates and pressure can vary between orders of magnitude,
for example depening on whether <i>cfm</i>, <i>m<sup>3</sup>&frasl;s</i> or
<i>m<sup>3</sup>&frasl;h</i> are used for flow measurements, the control
error is normalized as follows:
<ul>
<li>
For temperatures, no normalization is used, and the units of <i>k</i> are
<i>1/Kelvin</i>. No normalization is used because <i>1</i> Kelvin is <i>1.8</i>
Fahrenheit, and hence these are of the same order of magnitude.
</li>
<li>
For air flow rate control, the design flow rate is used to normalize the
control error, and hence <i>k</i> is unitless.
This also allows to use the same control gain for flows of different magnitudes,
for example for a VAV box of a large and a small room, provided the rooms
have similar transient response.
</li>
<li>
For pressure control, the pressure difference is used to normalize the
control error, and hence <i>k</i> is unitless.
</li>
</ul>
<p>
Guideline 36 is specific as the where a P or a PI controller should be
used. These recommendations are used as the default control configuration.
However, all controllers can be configured as P, PI or PID controller.
This allows to configure a PI controller as a P controller as part of the
tuning process.
</p>
<h4>References</h4>
<p>
<i>ASHRAE Guideline 36P, High Performance Sequences of Operation for HVAC
systems</i>. First Public Review Draft (June 2016)
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={76,76,76},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,-80.0},{-20.0,-20.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,-80.0},{60.0,-20.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,0.0},{60.0,60.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  lineColor={128,128,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,0.0},{-20.0,60.0}})}));
        end G36_PR1;
      annotation (Documentation(info="<html>
<p>
This package contains control sequences
that are published in ASHRAE reports.
</p>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Ellipse(
                origin={10.0,10.0},
                fillColor={76,76,76},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-80.0,-80.0},{-20.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,-80.0},{60.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,0.0},{60.0,60.0}}),
              Ellipse(
                origin={10.0,10.0},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-80.0,0.0},{-20.0,60.0}})}));
      end ASHRAE;

      package CDL
      "Package with blocks, examples and validation tests for control description language"

        package Constants "Package with constants"

          final constant Real eps=1E-15
            "Biggest number such that 1.0 + eps = 1.0";
          annotation (
            Documentation(
              info="<html>
<p>
This package provides often needed constants.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              coordinateSystem(
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={-9.2597,25.6673},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={-19.9923,-8.3993},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={23.753,-11.5422},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
                  smooth=Smooth.Bezier),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Constants;

        package Continuous "Package with blocks for continuous variables"

          block Abs
            "Output the absolute value of the input"
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=abs(u);
            annotation (
              defaultComponentName="abs",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{92,0},{70,8},{70,-8},{92,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,80},{0,0},{80,80}}),
                  Line(
                    points={{0,-14},{0,68}},
                    color={192,192,192}),
                  Polygon(
                    points={{0,90},{-8,68},{8,68},{0,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-34,-28},{38,-76}},
                    lineColor={192,192,192},
                    textString="abs"),
                  Line(
                    points={{-88,0},{76,0}},
                    color={192,192,192}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = abs(u)</code>,
where
<code>u</code> is an input.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Abs;

          block Add
            "Output the sum of the two inputs"
            parameter Real k1=+1
              "Gain for input u1";
            parameter Real k2=+1
              "Gain for input u2";
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=k1*u1+k2*u2;
            annotation (
              defaultComponentName="add2",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y</code> as the weighted <i>sum</i> of the
two input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = k1*u1 + k2*u2;
</pre>
<p>
where <code>k1</code> and <code>k2</code> are parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-50,-50},{50,50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-100,60},{-74,24},{-44,24}},
                    color={0,0,127}),
                  Line(
                    points={{-100,-60},{-74,-28},{-42,-28}},
                    color={0,0,127}),
                  Line(
                    points={{50,0},{100,0}},
                    color={0,0,127}),
                  Text(
                    extent={{-40,-22},{36,46}},
                    textString="+"),
                  Text(
                    extent={{-100,52},{5,92}},
                    textString="%k1"),
                  Text(
                    extent={{-100,-92},{5,-52}},
                    textString="%k2"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Add;

          block AddParameter
            "Output the sum of an input plus a parameter"
            parameter Real p
              "Value to be added";
            parameter Real k
              "Gain of input";
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=k*u+p;
            annotation (
              defaultComponentName="addPar",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = k u + p</code>,
where <code>k</code> and <code>p</code> are
parameters and <code>u</code> is an input.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Line(
                    points={{-54,66},{-28,30},{2,30}},
                    color={0,0,127}),
                  Line(
                    points={{-100,0},{100,0}},
                    color={0,0,127}),
                  Text(
                    extent={{-122,58},{-17,98}},
                    textString="%p",
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-86,-36},{-86,36},{-34,0},{-86,-36}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-196,-84},{104,-44}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-12,-52},{88,48}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-2,-22},{74,46}},
                    textString="+"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end AddParameter;

          block Average
            "Output the average of its two inputs"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}}),iconTransformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),iconTransformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=0.5*(u1+u2);
            annotation (
              defaultComponentName="ave",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-50,34},{52,-26}},
                    lineColor={192,192,192},
                    textString="avg()"),
                  Line(
                    points={{-8,16}},
                    color={0,0,0}),
                  Line(
                    points={{-100,60}},
                    color={0,0,0},
                    thickness=1),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = avg(u1,u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 15, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Average;

          block Division
            "Output first input divided by second input"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1/u2;
            annotation (
              defaultComponentName="div",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = u1 / u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 9, 2020, by Michael Wetter:<br/>
Reformulated model to avoid stack overflow in OpenModelica.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1819\">issue 1819</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-50,-50},{50,50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{50,0},{100,0}},
                    color={0,0,127}),
                  Line(
                    points={{-30,0},{30,0}}),
                  Ellipse(
                    fillPattern=FillPattern.Solid,
                    extent={{-5,20},{5,30}}),
                  Ellipse(
                    fillPattern=FillPattern.Solid,
                    extent={{-5,-30},{5,-20}}),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Line(
                    points={{-100,60},{-66,60},{-40,30}},
                    color={0,0,127}),
                  Line(
                    points={{-100,-60},{0,-60},{0,-50}},
                    color={0,0,127}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Division;

          block Feedback
            "Output difference between commanded and feedback input"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},rotation=90,origin={0,-120})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1-u2;
            annotation (
              defaultComponentName="feedback",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = u1 - u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Ellipse(
                    lineColor={0,0,127},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    extent={{-20,-20},{20,20}}),
                  Line(
                    points={{-100,0},{-20,0}},
                    color={0,0,127}),
                  Line(
                    points={{20,0},{100,0}},
                    color={0,0,127}),
                  Line(
                    points={{0,-20},{0,-100}},
                    color={0,0,127}),
                  Text(
                    extent={{-14,-112},{74,-38}},
                    textString="-"),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,48},{150,98}},
                    textString="%name"),
                  Text(
                    extent={{-100,-4},{-40,56}},
                    textString="+",
                    lineColor={0,0,0}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Feedback;

          block Gain
            "Output the product of a gain value with the input signal"
            parameter Real k
              "Gain value multiplied with input signal";
            Interfaces.RealInput u
              "Input signal connector"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Output signal connector"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=k*u;
            annotation (
              defaultComponentName="gai",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = k * u</code>,
where
<code>k</code> is a parameter and
<code>u</code> is an input.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Polygon(
                    points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-140},{150,-100}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,144},{150,104}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Gain;

          block Greater
            "Output y is true, if input u1 is greater than input u2"
            parameter Real h(
              final min=0)=0
              "Hysteresis"
              annotation (Evaluate=true);
            parameter Boolean pre_y_start=false
              "Value of pre(y) at initial time"
              annotation (Dialog(tab="Advanced"));
            Interfaces.RealInput u1
              "Input u1"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealInput u2
              "Input u2"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Output y"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            final parameter Boolean have_hysteresis=h >= 1E-10
              "True if the block has no hysteresis"
              annotation (Evaluate=true);
            GreaterWithHysteresis greHys(
              final h=h,
              final pre_y_start=pre_y_start) if have_hysteresis
              "Block with hysteresis"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
            GreaterNoHysteresis greNoHys if not have_hysteresis
              "Block without hysteresis"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            block GreaterNoHysteresis
              "Greater block without hysteresis"
              Interfaces.RealInput u1
                "Input u1"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealInput u2
                "Input u2"
                annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=u1 > u2;
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}));
            end GreaterNoHysteresis;

            block GreaterWithHysteresis
              "Greater block without hysteresis"
              parameter Real h(
                final min=0)=0
                "Hysteresis"
                annotation (Evaluate=true);
              parameter Boolean pre_y_start=false
                "Value of pre(y) at initial time"
                annotation (Dialog(tab="Advanced"));
              Interfaces.RealInput u1
                "Input u1"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealInput u2
                "Input u2"
                annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            initial equation
              assert(
                h >= 0,
                "Hysteresis must not be negative");
              pre(y)=pre_y_start;

            equation
              y=(not pre(y) and u1 > u2 or pre(y) and u1 >= u2-h);
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-64,62},{62,92}},
                      lineColor={0,0,0},
                      textString="h=%h")}));
            end GreaterWithHysteresis;

          equation
            connect(u1,greHys.u1)
              annotation (Line(points={{-120,0},{-66,0},{-66,30},{-12,30}},color={0,0,127}));
            connect(u2,greHys.u2)
              annotation (Line(points={{-120,-80},{-60,-80},{-60,22},{-12,22}},color={0,0,127}));
            connect(greHys.y,y)
              annotation (Line(points={{12,30},{60,30},{60,0},{120,0}},color={255,0,255}));
            connect(u1,greNoHys.u1)
              annotation (Line(points={{-120,0},{-66,0},{-66,-30},{-12,-30}},color={0,0,127}));
            connect(u2,greNoHys.u2)
              annotation (Line(points={{-120,-80},{-60,-80},{-60,-38},{-12,-38}},color={0,0,127}));
            connect(greNoHys.y,y)
              annotation (Line(points={{12,-30},{60,-30},{60,0},{120,0}},color={255,0,255}));
            annotation (
              defaultComponentName="gre",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,-80},{42,-80},{42,-62}},
                    color={0,0,127}),
                  Line(
                    points={{-12,14},{18,2},{-12,-8}},
                    thickness=0.5),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-64,62},{62,92}},
                    lineColor={0,0,0},
                    textString="h=%h"),
                  Text(
                    extent={{-88,-18},{-21,24}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u1,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{-86,-76},{-19,-34}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{20,-56},{87,-14}},
                    lineColor=DynamicSelect({235,235,235},
                      if not y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2-h,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u1</code>
is greater than the Real input <code>u2</code>, optionally within a hysteresis <code>h</code>.
</p>
<p>
The parameter <code>h &ge; 0</code> is used to specify a hysteresis.
If <i>h &ne; 0</i>, then the output switches to <code>true</code> if <i>u<sub>1</sub> &gt; u<sub>2</sub></i>,
and it switches to <code>false</code> if <i>u<sub>1</sub> &lt; u<sub>2</sub> - h</i>.
If <i>h = 0</i>, the output is <i>y=u<sub>1</sub> &gt; u<sub>2</sub></i>.
</p>
<p>
Enabling hysteresis can avoid frequent switching.
Adding hysteresis is recommended in real controllers to guard against sensor noise, and
in simulation to guard against numerical noise. Numerical noise can be present if
an input depends on a state variable or a quantity that requires an iterative solution, such as
a temperature or a mass flow rate of an HVAC system.
To disable hysteresis, set <code>h=0</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 3, 2021, by Antoine Gautier:<br/>
Corrected documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2246\">issue 2246</a>.
</li>
<li>
August 5, 2020, by Michael Wetter:<br/>
Added hysteresis.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2076\">issue 2076</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Greater;

          block GreaterThreshold
            "Output y is true, if input u is greater than threshold"
            parameter Real t=0
              "Threshold for comparison";
            parameter Real h(
              final min=0)=0
              "Hysteresis"
              annotation (Evaluate=true);
            parameter Boolean pre_y_start=false
              "Value of pre(y) at initial time"
              annotation (Dialog(tab="Advanced"));
            Interfaces.RealInput u
              "Input"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Output"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            final parameter Boolean have_hysteresis=h >= 1E-10
              "True if the block has no hysteresis"
              annotation (Evaluate=true);
            GreaterWithHysteresis greHys(
              final h=h,
              final t=t,
              final pre_y_start=pre_y_start) if have_hysteresis
              "Block with hysteresis"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
            GreaterNoHysteresis greNoHys(
              final t=t) if not have_hysteresis
              "Block without hysteresis"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            block GreaterNoHysteresis
              "Greater block without hysteresis"
              parameter Real t=0
                "Threshold for comparison";
              Interfaces.RealInput u
                "Input u"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=u > t;
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}));
            end GreaterNoHysteresis;

            block GreaterWithHysteresis
              "Greater block without hysteresis"
              parameter Real t=0
                "Threshold for comparison";
              parameter Real h(
                final min=0)=0
                "Hysteresis"
                annotation (Evaluate=true);
              parameter Boolean pre_y_start=false
                "Value of pre(y) at initial time"
                annotation (Dialog(tab="Advanced"));
              Interfaces.RealInput u
                "Input u"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            initial equation
              assert(
                h >= 0,
                "Hysteresis must not be negative");
              pre(y)=pre_y_start;

            equation
              y=(not pre(y) and u > t or pre(y) and u >= t-h);
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-64,62},{62,92}},
                      lineColor={0,0,0},
                      textString="h=%h")}));
            end GreaterWithHysteresis;

          equation
            connect(u,greHys.u)
              annotation (Line(points={{-120,0},{-66,0},{-66,30},{-12,30}},color={0,0,127}));
            connect(greHys.y,y)
              annotation (Line(points={{12,30},{60,30},{60,0},{120,0}},color={255,0,255}));
            connect(u,greNoHys.u)
              annotation (Line(points={{-120,0},{-66,0},{-66,-30},{-12,-30}},color={0,0,127}));
            connect(greNoHys.y,y)
              annotation (Line(points={{12,-30},{60,-30},{60,0},{120,0}},color={255,0,255}));
            annotation (
              defaultComponentName="greThr",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-16,10},{2,2},{-16,-8}},
                    thickness=0.5),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-64,62},{62,92}},
                    lineColor={0,0,0},
                    textString="h=%h"),
                  Text(
                    extent={{-88,-18},{-21,24}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{4,-18},{71,24}},
                    lineColor={0,0,0},
                    textString="%t",
                    visible=h < 1E-10),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({0,0,0},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(t,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{20,-56},{87,-14}},
                    lineColor=DynamicSelect({0,0,0},
                      if not y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(t-h,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u</code>
is greater than a threshold <code>t</code>, optionally within a hysteresis <code>h</code>.
</p>
<p>
The parameter <code>h &ge; 0</code> is used to specify a hysteresis.
If <i>h &ne; 0</i>, then the output switches to <code>true</code> if <i>u &gt; t</i>,
where <i>t</i> is the threshold,
and it switches to <code>false</code> if <i>u &lt; t - h</i>.
If <i>h = 0</i>, the output is <i>y = u &gt; t</i>.
</p>
<p>
Enabling hysteresis can avoid frequent switching.
Adding hysteresis is recommended in real controllers to guard against sensor noise, and
in simulation to guard against numerical noise. Numerical noise can be present if
an input depends on a state variable or a quantity that requires an iterative solution, such as
a temperature or a mass flow rate of an HVAC system.
To disable hysteresis, set <code>h=0</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 3, 2021, by Antoine Gautier:<br/>
Corrected documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2246\">issue 2246</a>.
</li>
<li>
August 5, 2020, by Michael Wetter:<br/>
Added hysteresis.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2076\">issue 2076</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end GreaterThreshold;

          block Hysteresis
            "Transform Real to Boolean signal with Hysteresis"
            parameter Real uLow
              "if y=true and u<uLow, switch to y=false";
            parameter Real uHigh
              "if y=false and u>uHigh, switch to y=true";
            parameter Boolean pre_y_start=false
              "Value of pre(y) at initial time";
            Interfaces.RealInput u
              "Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            assert(
              uHigh > uLow,
              "Hysteresis limits wrong. uHigh must be larger than uLow");
            pre(y)=pre_y_start;

          equation
            y=not pre(y) and u > uHigh or pre(y) and u >= uLow;
            annotation (
              defaultComponentName="hys",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,68},{-80,-29}},
                    color={192,192,192}),
                  Polygon(
                    points={{92,-29},{70,-21},{70,-37},{92,-29}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-79,-29},{84,-29}},
                    color={192,192,192}),
                  Line(
                    points={{-79,-29},{41,-29}}),
                  Line(
                    points={{-15,-21},{1,-29},{-15,-36}}),
                  Line(
                    points={{41,51},{41,-29}}),
                  Line(
                    points={{33,3},{41,22},{50,3}}),
                  Line(
                    points={{-49,51},{81,51}}),
                  Line(
                    points={{-4,59},{-19,51},{-4,43}}),
                  Line(
                    points={{-59,29},{-49,11},{-39,29}}),
                  Line(
                    points={{-49,51},{-49,-29}}),
                  Text(
                    extent={{-92,-49},{-9,-92}},
                    lineColor={192,192,192},
                    textString="%uLow"),
                  Text(
                    extent={{2,-49},{91,-92}},
                    lineColor={192,192,192},
                    textString="%uHigh"),
                  Rectangle(
                    extent={{-91,-49},{-8,-92}},
                    lineColor={192,192,192}),
                  Line(
                    points={{-49,-29},{-49,-49}},
                    color={192,192,192}),
                  Rectangle(
                    extent={{2,-49},{91,-92}},
                    lineColor={192,192,192}),
                  Line(
                    points={{41,-29},{41,-49}},
                    color={192,192,192}),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that transforms a <code>Real</code> input signal into a <code>Boolean</code>
output signal:
</p>
<ul>
<li> When the output was <code>false</code> and the input becomes
     greater than the parameter <code>uHigh</code>, the output
     switches to <code>true</code>.
</li>
<li> When the output was <code>true</code> and the input becomes
     less than the parameter <code>uLow</code>, the output
     switches to <code>false</code>.
</li>
</ul>
<p>
The start value of the output is defined via parameter
<code>pre_y_start</code> (= value of <code>pre(y)</code> at initial time).
The default value of this parameter is <code>false</code>.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Hysteresis.png\"
     alt=\"Hysteresis.png\" />
</p>
</html>",       revisions="<html>
<ul>
<li>
October 3, 2017, by Michael Wetter:<br/>
Removed start value for parameters, and moved assertion to <code>initial equation</code>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Hysteresis;

          block IntegratorWithReset
            "Output the integral of the input signal"
            parameter Real k(
              unit="1")=1
              "Integrator gain";
            parameter Real y_start=0
              "Initial or guess value of output (= state)"
              annotation (Dialog(group="Initialization"));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput y_reset_in
              "Input signal for state to which integrator is reset"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput trigger
              "Resets the integrator output when trigger becomes true"
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},rotation=90,origin={0,-120}),iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={0,-120})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            y=y_start;

          equation
            der(y)=k*u;
            when trigger then
              reinit(
                y,
                y_reset_in);
            end when;
            annotation (
              defaultComponentName="intWitRes",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-88,-94},{212,-54}},
                    lineColor={0,0,0},
                    textString="y_reset_in",
                    visible=(reset == Types.Reset.Input),
                    horizontalAlignment=TextAlignment.Left),
                  Bitmap(
                    extent={{-54,-50},{60,50}},
                    fileName="modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/int.png"),
                  Text(
                    extent={{-88,56},{206,92}},
                    lineColor={0,0,0},
                    textString="k=%k",
                    horizontalAlignment=TextAlignment.Left),
                  Text(
                    extent={{-92,-12},{208,28}},
                    lineColor={0,0,0},
                    horizontalAlignment=TextAlignment.Left,
                    textString="u"),
                  Text(
                    extent={{70,-14},{370,26}},
                    lineColor={0,0,0},
                    horizontalAlignment=TextAlignment.Left,
                    textString="y"),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
except that it allows to reset the output <code>y</code>
of the integrator.
</p>
<p>
The output of the integrator can be reset as follows:
</p>
<ul>
<li>
Whenever the input signal <code>trigger</code> changes from <code>false</code>
to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the input signal <code>y_reset_in</code>.
</li>
</ul>
<h4>Implementation</h4>
<p>
To adjust the icon layer, the code of
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
has been copied into this model rather than extended.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 3, 2020, by Jianjun:<br/>
Fixed the input <code>y_reset_in</code>.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed parameter <code>initType</code>.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types from CDL.
</li>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of
<a href=\"modelica://Buildings.Utilities.Math.IntegratorWithReset\">
Buildings.Utilities.Math.IntegratorWithReset</a>.
</li>
</ul>
</html>"));
          end IntegratorWithReset;

          block Less
            "Output y is true, if input u1 is less than input u2"
            parameter Real h(
              final min=0)=0
              "Hysteresis"
              annotation (Evaluate=true);
            parameter Boolean pre_y_start=false
              "Value of pre(y) at initial time"
              annotation (Dialog(tab="Advanced"));
            Interfaces.RealInput u1
              "Input u1"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealInput u2
              "Input u2"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Output y"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            final parameter Boolean have_hysteresis=h >= 1E-10
              "True if the block has no hysteresis"
              annotation (Evaluate=true);
            LessWithHysteresis lesHys(
              final h=h,
              final pre_y_start=pre_y_start) if have_hysteresis
              "Block with hysteresis"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
            LessNoHysteresis lesNoHys if not have_hysteresis
              "Block without hysteresis"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            block LessNoHysteresis
              "Less block without hysteresis"
              Interfaces.RealInput u1
                "Input u1"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealInput u2
                "Input u2"
                annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=u1 < u2;
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}));
            end LessNoHysteresis;

            block LessWithHysteresis
              "Less block without hysteresis"
              parameter Real h(
                final min=0)=0
                "Hysteresis"
                annotation (Evaluate=true);
              parameter Boolean pre_y_start=false
                "Value of pre(y) at initial time"
                annotation (Dialog(tab="Advanced"));
              Interfaces.RealInput u1
                "Input u1"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealInput u2
                "Input u2"
                annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            initial equation
              assert(
                h >= 0,
                "Hysteresis must not be negative");
              pre(y)=pre_y_start;

            equation
              y=(not pre(y) and u1 < u2 or pre(y) and u1 <= u2+h);
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-64,62},{62,92}},
                      lineColor={0,0,0},
                      textString="h=%h")}));
            end LessWithHysteresis;

          equation
            connect(u1,lesHys.u1)
              annotation (Line(points={{-120,0},{-66,0},{-66,30},{-12,30}},color={0,0,127}));
            connect(u2,lesHys.u2)
              annotation (Line(points={{-120,-80},{-60,-80},{-60,22},{-12,22}},color={0,0,127}));
            connect(lesHys.y,y)
              annotation (Line(points={{12,30},{60,30},{60,0},{120,0}},color={255,0,255}));
            connect(u1,lesNoHys.u1)
              annotation (Line(points={{-120,0},{-66,0},{-66,-30},{-12,-30}},color={0,0,127}));
            connect(u2,lesNoHys.u2)
              annotation (Line(points={{-120,-80},{-60,-80},{-60,-38},{-12,-38}},color={0,0,127}));
            connect(lesNoHys.y,y)
              annotation (Line(points={{12,-30},{60,-30},{60,0},{120,0}},color={255,0,255}));
            annotation (
              defaultComponentName="les",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,-80},{42,-80},{42,-62}},
                    color={0,0,127}),
                  Line(
                    points={{18,14},{-12,2},{18,-8}},
                    thickness=0.5),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-64,62},{62,92}},
                    lineColor={0,0,0},
                    textString="h=%h"),
                  Text(
                    extent={{-88,-18},{-21,24}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u1,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{-86,-76},{-19,-34}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{20,-56},{87,-14}},
                    lineColor=DynamicSelect({235,235,235},
                      if not y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(u2+h,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u1</code>
is less than the Real input <code>u2</code>, optionally within a hysteresis <code>h</code>.
</p>
<p>
The parameter <code>h &ge; 0</code> is used to specify a hysteresis.
If <i>h &ne; 0</i>, then the output switches to <code>true</code> if <i>u<sub>1</sub> &lt; u<sub>2</sub></i>,
and it switches to <code>false</code> if <i>u<sub>1</sub> &gt; u<sub>2</sub> + h</i>.
If <i>h = 0</i>, the output is <i>y = u<sub>1</sub> &lt; u<sub>2</sub></i>.
</p>
<p>
Enabling hysteresis can avoid frequent switching.
Adding hysteresis is recommended in real controllers to guard against sensor noise, and
in simulation to guard against numerical noise. Numerical noise can be present if
an input depends on a state variable or a quantity that requires an iterative solution, such as
a temperature or a mass flow rate of an HVAC system.
To disable hysteresis, set <i>h=0</i>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 3, 2021, by Antoine Gautier:<br/>
Corrected documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2246\">issue 2246</a>.
</li>
<li>
August 5, 2020, by Michael Wetter:<br/>
Added hysteresis.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2076\">issue 2076</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Less;

          block LessThreshold
            "Output y is true, if input u is less than threshold"
            parameter Real t=0
              "Threshold for comparison";
            parameter Real h(
              final min=0)=0
              "Hysteresis"
              annotation (Evaluate=true);
            parameter Boolean pre_y_start=false
              "Value of pre(y) at initial time"
              annotation (Dialog(tab="Advanced"));
            Interfaces.RealInput u
              "Input"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Output"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            final parameter Boolean have_hysteresis=h >= 1E-10
              "True if the block has no hysteresis"
              annotation (Evaluate=true);
            LessWithHysteresis lesHys(
              final h=h,
              final t=t,
              final pre_y_start=pre_y_start) if have_hysteresis
              "Block with hysteresis"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
            LessNoHysteresis lesNoHys(
              final t=t) if not have_hysteresis
              "Block without hysteresis"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            block LessNoHysteresis
              "Less block without hysteresis"
              parameter Real t=0
                "Threshold for comparison";
              Interfaces.RealInput u
                "Input u"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=u < t;
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}));
            end LessNoHysteresis;

            block LessWithHysteresis
              "Less block without hysteresis"
              parameter Real t=0
                "Threshold for comparison";
              parameter Real h(
                final min=0)=0
                "Hysteresis"
                annotation (Evaluate=true);
              parameter Boolean pre_y_start=false
                "Value of pre(y) at initial time"
                annotation (Dialog(tab="Advanced"));
              Interfaces.RealInput u
                "Input u"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.BooleanOutput y
                "Output y"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            initial equation
              assert(
                h >= 0,
                "Hysteresis must not be negative");
              pre(y)=pre_y_start;

            equation
              y=(not pre(y) and u < t or pre(y) and u <= t+h);
              annotation (
                Icon(
                  graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      lineThickness=5.0,
                      fillColor={210,210,210},
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{-64,62},{62,92}},
                      lineColor={0,0,0},
                      textString="h=%h")}));
            end LessWithHysteresis;

          equation
            connect(u,lesHys.u)
              annotation (Line(points={{-120,0},{-66,0},{-66,30},{-12,30}},color={0,0,127}));
            connect(lesHys.y,y)
              annotation (Line(points={{12,30},{60,30},{60,0},{120,0}},color={255,0,255}));
            connect(u,lesNoHys.u)
              annotation (Line(points={{-120,0},{-66,0},{-66,-30},{-12,-30}},color={0,0,127}));
            connect(lesNoHys.y,y)
              annotation (Line(points={{12,-30},{60,-30},{60,0},{120,0}},color={255,0,255}));
            annotation (
              defaultComponentName="lesThr",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{2,10},{-16,2},{2,-8}},
                    thickness=0.5),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-64,62},{62,92}},
                    lineColor={0,0,0},
                    textString="h=%h"),
                  Text(
                    extent={{-88,-18},{-21,24}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(u,
                      leftjustified=false,
                      significantDigits=3))),
                  Text(
                    extent={{4,-18},{71,24}},
                    lineColor={0,0,0},
                    textString="%t",
                    visible=h < 1E-10),
                  Text(
                    extent={{22,20},{89,62}},
                    lineColor=DynamicSelect({0,0,0},
                      if y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(t,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10),
                  Text(
                    extent={{20,-56},{87,-14}},
                    lineColor=DynamicSelect({0,0,0},
                      if not y then
                        {135,135,135}
                      else
                        {0,0,0}),
                    textString=DynamicSelect("",String(t+h,
                      leftjustified=false,
                      significantDigits=3)),
                    visible=h >= 1E-10)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u</code>
is less than a threshold <code>t</code>, optionally within a hysteresis <code>h</code>.
</p>
<p>
The parameter <code>h &ge; 0</code> is used to specify a hysteresis.
If <i>h &ne; 0</i>, then the output switches to <code>true</code> if <i>u &lt; t</i>,
where <i>t</i> is the threshold,
and it switches to <code>false</code> if <i>u &gt; t + h</i>.
If <i>h = 0</i>, the output is <i>y = u &lt; t</i>.

</p>
<p>
Enabling hysteresis can avoid frequent switching.
Adding hysteresis is recommended in real controllers to guard against sensor noise, and
in simulation to guard against numerical noise. Numerical noise can be present if
an input depends on a state variable or a quantity that requires an iterative solution, such as
a temperature or a mass flow rate of an HVAC system.
To disable hysteresis, set <i>h=0</i>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 3, 2021, by Antoine Gautier:<br/>
Corrected documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2246\">issue 2246</a>.
</li>
<li>
August 5, 2020, by Michael Wetter:<br/>
Added hysteresis.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2076\">issue 2076</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end LessThreshold;

          block Limiter
            "Limit the range of a signal"
            parameter Real uMax
              "Upper limit of input signal";
            parameter Real uMin
              "Lower limit of input signal";
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            assert(
              uMin < uMax,
              "uMin must be smaller than uMax. Check parameters.");

          equation
            y=homotopy(
              actual=smooth(0,noEvent(
                if u > uMax then
                  uMax
                else
                  if u < uMin then
                    uMin
                  else
                    u)),
              simplified=u);
            annotation (
              defaultComponentName="lim",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = min(uMax, max(uMin, u))</code>,
where
<code>u</code> is an input
and
<code>uMax</code> and <code>uMin</code> are parameters.
</p>
<p>
If <code>uMax &lt; uMin</code>, an error occurs and no output is produced.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
July 17, 2017, by Michael Wetter:<br/>
Removed cyclical definition.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                graphics={
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{0,-90},{0,68}},
                    color={192,192,192}),
                  Polygon(
                    points={{0,90},{-8,68},{8,68},{0,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-90,0},{68,0}},
                    color={192,192,192}),
                  Polygon(
                    points={{90,0},{68,-8},{68,8},{90,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,-70},{-50,-70},{50,70},{80,70}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{50,70},{80,70}}),
                  Line(
                    points={{-80,-70},{-50,-70}}),
                  Text(
                    extent={{12,72},{94,98}},
                    lineColor={0,0,0},
                    textString="%uMax"),
                  Text(
                    extent={{-100,-98},{-18,-72}},
                    lineColor={0,0,0},
                    textString="%uMin"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Limiter;

          block Line
            "Output the value of the input x along a line specified by two points"
            parameter Boolean limitBelow=true
              "If true, limit input u to be no smaller than x1"
              annotation (Evaluate=true);
            parameter Boolean limitAbove=true
              "If true, limit input u to be no larger than x2"
              annotation (Evaluate=true);
            Interfaces.RealInput x1
              "Support point x1, with x1 < x2"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Interfaces.RealInput f1
              "Support point f(x1)"
              annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
            Interfaces.RealInput x2
              "Support point x2, with x2 > x1"
              annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
            Interfaces.RealInput f2
              "Support point f(x2)"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.RealInput u
              "Independent variable"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "f(x) along the line specified by (x1, f1) and (x2, f2)"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            Real a
              "Intercept";
            Real b
              "Slope";
            Real xLim
              "Input value after applying the limits";

          equation
            if limitBelow or limitAbove then
              assert(
                x2 > x1,
                "x2 must be bigger than x1 in "+getInstanceName(),
                AssertionLevel.warning);
            end if;
            b=(f2-f1)/(x2-x1);
            a=f2-b*x2;
            if limitBelow and limitAbove then
              xLim=min(
                x2,
                max(
                  x1,
                  u));
            elseif limitBelow then
              xLim=max(
                x1,
                u);
            elseif limitAbove then
              xLim=min(
                x2,
                u);
            else
              xLim=u;
            end if;
            y=a+b*xLim;
            annotation (
              defaultComponentName="lin",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Polygon(
                    points={{92,-78},{70,-70},{70,-86},{92,-78}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-46,40},{50,-44}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,-80},{-80,72}},
                    color={192,192,192}),
                  Polygon(
                    points={{-80,92},{-88,70},{-72,70},{-80,92}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-88,-78},{76,-78}},
                    color={192,192,192}),
                  Line(
                    points={{-100,80},{-64,80}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-64,80},{-62,-78}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-100,40},{-88,40}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-88,40},{-48,40}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-100,-40},{48,-36}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{48,-36},{50,-78}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-100,-80},{-38,-56}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-38,-56},{48,-44}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-100,0},{-62,0}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{-62,0},{8,-8}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{10,-8},{52,-8}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Line(
                    points={{52,-8},{100,0}},
                    color={28,108,200},
                    smooth=Smooth.Bezier,
                    pattern=LinePattern.Dot),
                  Ellipse(
                    extent={{44,-38},{56,-50}},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{2,-2},{14,-14}},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{50,-44},{80,-70}},
                    color={0,0,0},
                    thickness=0.5,
                    visible=not limitAbove),
                  Line(
                    points={{52,-44},{86,-44}},
                    color={238,46,47},
                    thickness=0.5,
                    visible=limitAbove),
                  Line(
                    points={{-80,68},{-46,40}},
                    color={0,0,0},
                    thickness=0.5,
                    visible=not limitBelow),
                  Line(
                    points={{-80,40},{-46,40}},
                    color={238,46,47},
                    thickness=0.5,
                    visible=limitBelow),
                  Ellipse(
                    extent={{-52,46},{-40,34}},
                    pattern=LinePattern.None,
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = a + b u</code>,
where
<code>u</code> is an input
and the coefficients <code>a</code> and <code>b</code>
are determined so that the line intercepts the two input points
specified by the two points <code>x1</code> and <code>f1</code>,
and <code>x2</code> and <code>f2</code>.
</p>
<p>
The parameters <code>limitBelow</code> and <code>limitAbove</code>
determine whether <code>x1</code> and <code>x2</code> are also used
to limit the input <code>u</code>.
</p>
<p>
If the limits are used, then this block requires <code>x1 &lt; x2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 25, 2018, by Michael Wetter:<br/>
Improved documentation, icon and added warning if the limits are used and
<code>x1 &gt; x2</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1155\">issue 1155</a>.
</li>
<li>
January 11, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Line;

          block Max
            "Pass through the largest signal"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=max(
              u1,
              u2);
            annotation (
              defaultComponentName="max",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = max(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Max;

          block Min
            "Pass through the smallest signal"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=min(
              u1,
              u2);
            annotation (
              defaultComponentName="min",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = min(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Min;

          block MovingMean
            "Block to output moving average"
            parameter Real delta(
              final quantity="Time",
              final unit="s",
              min=1E-5)
              "Time horizon over which the input is averaged";
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Real tStart(
              final quantity="Time",
              final unit="s",
              fixed=false)
              "Start time";
            Real mu
              "Internal integrator variable";
            Real muDel
              "Internal integrator variable with delay";
            Boolean mode(
              start=false,
              fixed=true)
              "Calculation mode";

          initial equation
            tStart=time;
            mu=0;

          equation
            u=der(mu);
            muDel=delay(
              mu,
              delta);
            // Compute the mode so that Dymola generates
            // time and not state events as it would with
            // an if-then construct
            when time >= tStart+delta then
              mode=true;
            end when;
            if mode then
              y=(mu-muDel)/delta;
            else
              y=(mu-muDel)/(time-tStart+1E-3);
            end if;
            annotation (
              defaultComponentName="movMea",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-78,90},{-86,68},{-70,68},{-78,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-78,68},{-78,-80}},
                    color={192,192,192}),
                  Line(
                    points={{-88,0},{70,0}},
                    color={192,192,192}),
                  Polygon(
                    points={{92,0},{70,8},{70,-8},{92,0}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-78,-31},{-64,-31},{-64,-15},{-56,-15},{-56,-63},{-48,-63},{-48,-41},{-40,-41},{-40,43},{-32,43},{-32,11},{-32,11},{-32,-49},{-22,-49},{-22,-31},{-12,-31},{-12,-59},{-2,-59},{-2,23},{4,23},{4,37},{10,37},{10,-19},{20,-19},{20,-7},{26,-7},{26,-37},{36,-37},{36,35},{46,35},{46,1},{54,1},{54,-65},{64,-65}},
                    color={215,215,215}),
                  Line(
                    points={{-78,-24},{68,-24}}),
                  Text(
                    extent={{-140,152},{160,112}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-42,-63},{41,-106}},
                    lineColor={192,192,192},
                    textString="%delta s"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
This block outputs the mean value of its input signal as
</p>
<pre>
      1  t
y =   -  &int;   u(s) ds
      &delta;  t-&delta;
</pre>
<p>
where <i>&delta;</i> is a parameter that determines the time window over
which the input is averaged.
For
<i> t &lt; &delta;</i> seconds, it outputs
</P>
<pre>
           1      t
y =   --------    &int;   u(s) ds
      t-t<sub>0</sub>+10<sup>-10</sup>   t<sub>0</sub>
</pre>
<p>
where <i>t<sub>0</sub></i> is the initial time.
</p>
<p>
This block can for example be used to output the moving
average of a noisy measurement signal.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean</a>
and
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean_nonZeroStart\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean_nonZeroStart</a>
for example.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
October 24, 2017, by Michael Wetter:<br/>
Set initial condition for <code>mu</code>.
</li>
<li>
October 17, 2017, by Michael Wetter:<br/>
Reformulated implementation to avoid direct feedthrough.
</li>
<li>
October 16, 2017, by Michael Wetter:<br/>
Reformulated implementation to handle division by zero as the previous
implementation caused division by zero in the VAV reheat model with the Radau solver.
</li>
<li>
September 27, 2017, by Thierry S. Nouidui:<br/>
Reformulated implementation to handle division by zero.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/978\">issue 978</a>.
</li>
<li>
September 15, 2017, by Thierry S. Nouidui:<br/>
Reformulated implementation to avoid state events.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation to allow non-zero start time.
</li>
<li>
June 29, 2017, by Jianjun Hu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
          end MovingMean;

          block MultiMax
            "Output the maximum element of the input vector"
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            Interfaces.RealInput u[nin]
              "Connector of Real input signals"
              annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
            Interfaces.RealOutput y
              "Connector of Real output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=max(u);
            annotation (
              defaultComponentName="mulMax",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Outputs the maximum element of the input vector.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end MultiMax;

          block MultiMin
            "Output the minimum element of the input vector"
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            Interfaces.RealInput u[nin]
              "Connector of Real input signals"
              annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
            Interfaces.RealOutput y
              "Connector of Real output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=min(u);
            annotation (
              defaultComponentName="mulMin",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Outputs the minimum element of the input vector.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end MultiMin;

          block MultiSum
            "Sum of Reals, y = k[1]*u[1] + k[2]*u[2] + ... + k[n]*u[n]"
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            parameter Real k[nin]=fill(
              1,
              nin)
              "Input gains";
            Interfaces.RealInput u[nin]
              "Connector of Real input signals"
              annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            if size(
              u,
              1) > 0 then
              y=k*u;
            else
              y=0;
            end if;
            annotation (
              defaultComponentName="mulSum",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-200,-110},{200,-140}},
                    lineColor={0,0,0},
                    fillColor={255,213,170},
                    fillPattern=FillPattern.Solid,
                    textString="%k"),
                  Text(
                    extent={{-82,90},{82,-46}},
                    lineColor={0,0,0},
                    fillColor={255,213,170},
                    fillPattern=FillPattern.Solid,
                    textString="+"),
                  Text(
                    extent={{-144,150},{156,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = &sum;<sub>i=1</sub><sup>n</sup> k<sub>i</sub> &nbsp; u<sub>i</sub>,
</p>
<p>
where <i>k</i> is a parameter with <i>n</i> elements and <i>u</i> is
an input of the same length.
The dimension of <i>u</i> can be enlarged by
drawing an additional connection line. The connection is automatically connected
to this new free index.
</p>

<p>
If no connection to the input connector <i>u</i> is present,
the output is <i>y=0</i>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MultiSum\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MultiSum</a>
for an example.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the Modelica Standard
Library. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
          end MultiSum;

          block PID
            "P, PI, PD, and PID controller"
            parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=Buildings.Controls.OBC.CDL.Types.SimpleController.PI
              "Type of controller";
            parameter Real k(
              min=100*Constants.eps)=1
              "Gain of controller"
              annotation (Dialog(group="Control gains"));
            parameter Real Ti(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.5
              "Time constant of integrator block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Td(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.1
              "Time constant of derivative block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real r(
              min=100*Constants.eps)=1
              "Typical range of control error, used for scaling the control error";
            parameter Real yMax=1
              "Upper limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real yMin=0
              "Lower limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real Ni(
              min=100*Constants.eps)=0.9
              "Ni*Ti is time constant of anti-windup compensation"
              annotation (Dialog(tab="Advanced",group="Integrator anti-windup",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Nd(
              min=100*Constants.eps)=10
              "The higher Nd, the more ideal the derivative block"
              annotation (Dialog(tab="Advanced",group="Derivative block",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real xi_start=0
              "Initial value of integrator state"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real yd_start=0
              "Initial value of derivative output"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Boolean reverseActing=true
              "Set to true for reverse acting, or false for direct acting control action";
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_s
              "Connector of setpoint input signal"
              annotation (Placement(transformation(extent={{-260,-20},{-220,20}}),iconTransformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_m
              "Connector of measurement input signal"
              annotation (Placement(transformation(origin={0,-220},extent={{20,-20},{-20,20}},rotation=270),iconTransformation(extent={{20,-20},{-20,20}},rotation=270,origin={0,-120})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of actuator output signal"
              annotation (Placement(transformation(extent={{220,-20},{260,20}}),iconTransformation(extent={{100,-20},{140,20}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback controlError
              "Control error (set point - measurement)"
              annotation (Placement(transformation(extent={{-200,-10},{-180,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain P(final k=k)
              "Gain for proportional control action"
              annotation (Placement(transformation(extent={{-50,130},{-30,150}})));
            Buildings.Controls.OBC.CDL.Continuous.IntegratorWithReset I(
              final k=k/Ti,
              final y_start=xi_start) if with_I
              "Integral term"
              annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
            Derivative D(
              final k=k*Td,
              final T=Td/Nd,
              final y_start=yd_start) if with_D
              "Derivative term"
              annotation (Placement(transformation(extent={{-50,60},{-30,80}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errP
              "P error"
              annotation (Placement(transformation(extent={{-140,130},{-120,150}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errD if with_D
              "D error"
              annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errI1 if with_I
              "I error (before anti-windup compensation)"
              annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errI2 if with_I
              "I error (after anti-windup compensation)"
              annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Limiter lim(
              final uMax=yMax,
              final uMin=yMin)
              "Limiter"
              annotation (Placement(transformation(extent={{120,80},{140,100}})));

        protected
            final parameter Real revAct=
              if reverseActing then
                1
              else
                -1
              "Switch for sign for reverse or direct acting controller";
            final parameter Boolean with_I=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable integral action"
              annotation (Evaluate=true,HideResult=true);
            final parameter Boolean with_D=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable derivative action"
              annotation (Evaluate=true,HideResult=true);
            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant Dzero(
              final k=0) if not with_D
              "Zero input signal"
              annotation (Evaluate=true,HideResult=true,Placement(transformation(extent={{-20,110},
                      {0,130}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain uS_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-200,30},{-180,50}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain uMea_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-180,-50},{-160,-30}})));
            Buildings.Controls.OBC.CDL.Continuous.Add addPD(final k1=1,
              final k2=1)
              "Outputs P and D gains added"
              annotation (Placement(transformation(extent={{20,116},{40,136}})));
            Buildings.Controls.OBC.CDL.Continuous.Add addPID(
              final k1=1,
              final k2=1)
              "Outputs P, I and D gains added"
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback antWinErr if with_I
              "Error for anti-windup compensation"
              annotation (Placement(transformation(extent={{162,50},{182,70}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain antWinGai(
              k=1/(k*Ni)) if with_I
              "Gain for anti-windup compensation"
              annotation (Placement(transformation(extent={{180,-30},{160,-10}})));
            Buildings.Controls.OBC.CDL.Logical.Sources.Constant cheYMinMax(
              final k=yMin < yMax)
              "Check for values of yMin and yMax"
              annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
            Buildings.Controls.OBC.CDL.Utilities.Assert assMesYMinMax(
              message="LimPID: Limits must be yMin < yMax")
              "Assertion on yMin and yMax"
              annotation (Placement(transformation(extent={{160,-160},{180,-140}})));

            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant Izero(
              final k=0) if not with_I
              "Zero input signal"
              annotation (Placement(transformation(extent={{40,74},{60,94}})));
            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con(
              final k=0) if with_I
              "Constant zero"
              annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
            Buildings.Controls.OBC.CDL.Logical.Sources.Constant con1(
              final k=false) if with_I
              "Constant false"
              annotation (Placement(transformation(extent={{-100,-90},{-80,-70}})));

            block Derivative
              "Block that approximates the derivative of the input"
              parameter Real k(
                unit="1")=1
                "Gains";
              parameter Real T(
                final quantity="Time",
                final unit="s",
                min=1E-60)=0.01
                "Time constant (T>0 required)";
              parameter Real y_start=0
                "Initial value of output (= state)"
                annotation (Dialog(group="Initialization"));
              Interfaces.RealInput u
                "Connector of Real input signal"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));
              output Real x
                "State of block";

          protected
              parameter Boolean zeroGain=abs(k) < 1E-17
                "= true, if gain equals to zero";

            initial equation
              if zeroGain then
                x=u;
              else
                x=u-T*y_start/k;
              end if;

            equation
              der(x)=
                if zeroGain then
                  0
                else
                  (u-x)/T;
              y=if zeroGain then
                  0
                else
                  (k/T)*(u-x);
              annotation (
                defaultComponentName="der",
                Documentation(
                  info="<html>
<p>
This blocks defines the transfer function between the
input <code>u</code> and the output <code>y</code>
as <i>approximated derivative</i>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If <code>k=0</code>, the block reduces to <code>y=0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 30, 2021, by Michael Wetter:<br/>
Refactored implementation to have separate blocks that show the P, I and D contribution,
each with the control gain applied.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2475\">issue 2475</a>.
</li>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
August 7, 2020, by Michael Wetter:<br/>
Moved to protected block in PID controller because the derivative block is no longer part of CDL.
</li>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed option to not set the initialization method or to set the initial state.
The new implementation only allows to set the initial output, from which
the initial state is computed.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100.0,-100.0},{100.0,100.0}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80.0,78.0},{-80.0,-90.0}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                    Line(
                      points={{-90.0,-80.0},{82.0,-80.0}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                    Line(
                      origin={-24.667,-27.333},
                      points={{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
                      color={0,0,127},
                      smooth=Smooth.Bezier),
                    Text(
                      extent={{-150.0,-150.0},{150.0,-110.0}},
                      textString="k=%k"),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{226,60},{106,10}},
                      lineColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftjustified=false,
                        significantDigits=3)))}));
            end Derivative;

          equation
            connect(u_s,uS_revAct.u)
              annotation (Line(points={{-240,0},{-212,0},{-212,40},{-202,40}},color={0,0,127}));
            connect(u_m,uMea_revAct.u)
              annotation (Line(points={{0,-220},{0,-160},{-190,-160},{-190,-40},{-182,-40}},color={0,0,127}));
            connect(errP.u2,uMea_revAct.y)
              annotation (Line(points={{-130,128},{-130,-40},{-158,-40}},                    color={0,0,127}));
            connect(errD.u2,uMea_revAct.y)
              annotation (Line(points={{-110,58},{-110,48},{-130,48},{-130,-40},{-158,-40}},
                                                                                          color={0,0,127}));
            connect(D.u,errD.y)
              annotation (Line(points={{-52,70},{-98,70}},color={0,0,127}));
            connect(errI1.u1,uS_revAct.y)
              annotation (Line(points={{-122,0},{-170,0},{-170,40},{-178,40}},color={0,0,127}));
            connect(errI1.u2,uMea_revAct.y)
              annotation (Line(points={{-110,-12},{-110,-40},{-158,-40}},color={0,0,127}));
            connect(addPID.u1,addPD.y)
              annotation (Line(points={{78,96},{70,96},{70,126},{42,126}},color={0,0,127}));
            connect(lim.y,y)
              annotation (Line(points={{142,90},{200,90},{200,0},{240,0}},color={0,0,127}));
            connect(antWinErr.y,antWinGai.u)
              annotation (Line(points={{184,60},{190,60},{190,-20},{182,-20}},color={0,0,127}));
            connect(addPD.u2,Dzero.y)
              annotation (Line(points={{18,120},{2,120}},                      color={0,0,127}));
            connect(D.y,addPD.u2)
              annotation (Line(points={{-28,70},{10,70},{10,120},{18,120}},  color={0,0,127}));
            connect(addPID.u2,I.y)
              annotation (Line(points={{78,84},{72,84},{72,0},{-28,0}},color={0,0,127}));
            connect(antWinErr.u2,lim.y)
              annotation (Line(points={{172,48},{172,40},{148,40},{148,90},{142,90}},color={0,0,127}));
            connect(I.u,errI2.y)
              annotation (Line(points={{-52,0},{-68,0}},color={0,0,127}));
            connect(errI1.y,errI2.u1)
              annotation (Line(points={{-98,0},{-92,0}},color={0,0,127}));
            connect(errI2.u2,antWinGai.y)
              annotation (Line(points={{-80,-12},{-80,-20},{158,-20}},color={0,0,127}));
            connect(controlError.u1,u_s)
              annotation (Line(points={{-202,0},{-240,0}},color={0,0,127}));
            connect(controlError.u2,u_m)
              annotation (Line(points={{-190,-12},{-190,-160},{0,-160},{0,-220}},color={0,0,127}));
            connect(cheYMinMax.y,assMesYMinMax.u)
              annotation (Line(points={{142,-150},{158,-150}},color={255,0,255}));
            connect(Izero.y,addPID.u2)
              annotation (Line(points={{62,84},{78,84}},                color={0,0,127}));
            connect(con.y,I.y_reset_in)
              annotation (Line(points={{-78,-40},{-68,-40},{-68,-8},{-52,-8}},color={0,0,127}));
            connect(con1.y,I.trigger)
              annotation (Line(points={{-78,-80},{-40,-80},{-40,-12}},color={255,0,255}));
            connect(uS_revAct.y,errP.u1)
              annotation (Line(points={{-178,40},{-170,40},{-170,140},{-142,140}},color={0,0,127}));
            connect(errD.u1,uS_revAct.y)
              annotation (Line(points={{-122,70},{-170,70},{-170,40},{-178,40}},color={0,0,127}));
            connect(addPD.u1, P.y)
              annotation (Line(points={{18,132},{10,132},{10,140},{-28,140}},
                                                            color={0,0,127}));
            connect(P.u, errP.y)
              annotation (Line(points={{-52,140},{-118,140}},color={0,0,127}));
            connect(addPID.y, lim.u)
              annotation (Line(points={{102,90},{118,90}},color={0,0,127}));
            connect(addPID.y, antWinErr.u1) annotation (Line(points={{102,90},{110,90},{
                    110,60},{160,60}},
                                   color={0,0,127}));
            annotation (
              defaultComponentName="conPID",
              Icon(
                coordinateSystem(
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-6,-20},{66,-66}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.P),
                    extent={{-32,-22},{68,-62}},
                    lineColor={0,0,0},
                    textString="P",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI),
                    extent={{-26,-22},{74,-62}},
                    lineColor={0,0,0},
                    textString="PI",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD),
                    extent={{-16,-22},{88,-62}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175},
                    textString="P D"),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
                    extent={{-14,-22},{86,-62}},
                    lineColor={0,0,0},
                    textString="PID",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Polygon(
                    points={{-80,82},{-88,60},{-72,60},{-80,82}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,68},{-80,-100}},
                    color={192,192,192}),
                  Line(
                    points={{-90,-80},{70,-80}},
                    color={192,192,192}),
                  Polygon(
                    points={{74,-80},{52,-72},{52,-88},{74,-80}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-80,-80},{-80,-22}},
                    color={0,0,0}),
                  Line(
                    points={{-80,-22},{6,56}},
                    color={0,0,0}),
                  Line(
                    points={{6,56},{68,56}},
                    color={0,0,0}),
                  Rectangle(
                    extent=DynamicSelect({{100,-100},{84,-100}},{{100,-100},{84,-100+(y-yMin)/(yMax-yMin)*200}}),
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0})}),
              Diagram(
                coordinateSystem(
                  extent={{-220,-200},{220,200}}), graphics={Rectangle(
                    extent={{-56,180},{-24,-16}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None), Text(
                    extent={{-52,184},{-28,156}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    textString="PID")}),
              Documentation(
                info="<html>
<p>
PID controller in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k/r &nbsp; (e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(&tau;) d&tau; + T<sub>d</sub> d&frasl;dt e(t)),
</p>
<p>
where
<i>y<sub>u</sub></i> is the control signal before output limitation,
<i>e(t) = u<sub>s</sub>(t) - u<sub>m</sub>(t)</i> is the control error,
with <i>u<sub>s</sub></i> being the set point and <i>u<sub>m</sub></i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term,
<i>T<sub>d</sub></i> is the time constant of the derivative term,
and
<i>r</i> is a scaling factor, with default <i>r=1</i>.
The scaling factor should be set to the typical order of magnitude of the range of the error <i>e</i>.
For example, you may set <i>r=100</i> to <i>r=1000</i>
if the control input is a pressure of a heating water circulation pump in units of Pascal, or
leave <i>r=1</i> if the control input is a room temperature.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
</p>
<p>
The actual control output is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = min( y<sub>max</sub>, max( y<sub>min</sub>, y)),
</p>
<p>
where <i>y<sub>min</sub></i> and <i>y<sub>max</sub></i> are limits for the control signal.
</p>
<h4>P, PI, PD, or PID action</h4>
<p>
Through the parameter <code>controllerType</code>, the controller can be configured
as P, PI, PD or PID controller. The default configuration is PI.
</p>
<h4>Reverse or direct action</h4>
<p>
Through the parameter <code>reverseActing</code>, the controller can be configured to
be reverse or direct acting.
The above standard form is reverse acting, which is the default configuration.
For a reverse acting controller, for a constant set point,
an increase in measurement signal <code>u_m</code> decreases the control output signal <code>y</code>
(Montgomery and McDowall, 2008).
Thus,
</p>
<ul>
  <li>
  for a heating coil with a two-way valve, leave <code>reverseActing = true</code>, but
  </li>
  <li>
  for a cooling coil with a two-way valve, set <code>reverseActing = false</code>.
  </li>
</ul>
<p>
If <code>reverseAction=false</code>, then the error <i>e</i> above is multiplied by <i>-1</i>.
</p>
<h4>Anti-windup compensation</h4>
<p>
The controller anti-windup compensation is as follows:
Instead of the above basic control law, the implementation is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k &nbsp; (e(t) &frasl; r + 1 &frasl; T<sub>i</sub> &nbsp; &int; (-&Delta;y + e(&tau;) &frasl; r) d&tau; + T<sub>d</sub> &frasl; r d&frasl;dt e(t)),
</p>
<p>
where the anti-windup compensation <i>&Delta;y</i> is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Delta;y = (y<sub>u</sub> - y) &frasl; (k N<sub>i</sub>),
</p>
<p>
where
<i>N<sub>i</sub> &gt; 0</i> is the time constant for the anti-windup compensation.
To accelerate the anti-windup, decrease <i>N<sub>i</sub></i>.
</p>
<p>
Note that the anti-windup term <i>(-&Delta;y + e(&tau;) &frasl; r)</i> shows that the range of
the typical control error <i>r</i> should be set to a reasonable value so that
</p>
<p align=\"center\" style=\"font-style:italic;\">
e(&tau;) &frasl; r = (u<sub>s</sub>(&tau;) - u<sub>m</sub>(&tau;)) &frasl; r
</p>
<p>
has order of magnitude one, and hence the anti-windup compensation should work well.
</p>
<h4>Reset of the controller output</h4>
<p>
Note that this controller implements an integrator anti-windup. Therefore,
for most applications, the controller output does not need to be reset.
However, if the controller is used in conjuction with equipment that is being
switched on, better control performance may be achieved by resetting the controller
output when the equipment is switched on. This is in particular the case in situations
where the equipment control input should continuously increase as the equipment is
switched on, such as a light dimmer that may slowly increase the luminance, or
a variable speed drive of a motor that should continuously increase the speed. In
this case, the controller
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.PIDWithReset\">
Buildings.Controls.OBC.CDL.Continuous.PIDWithReset</a>
that can reset the output should be used.
</p>
<h4>Approximation of the derivative term</h4>
<p>
The derivative of the control error <i>d &frasl; dt e(t)</i> is approximated using
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt x(t) = (e(t)-x(t)) T<sub>d</sub> &frasl; N<sub>d</sub>,
</p>
<p>
and
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt e(t) &asymp; N<sub>d</sub> (e(t)-x(t)),
</p>
<p>
where <i>x(t)</i> is an internal state.
</p>
<h4>Guidance for tuning the control gains</h4>
<p>
The parameters of the controller can be manually adjusted by performing
closed loop tests (= controller + plant connected
together) and using the following strategy:
</p>
<ol>
<li> Set very large limits, e.g., set <i>y<sub>max</sub> = 1000</i>.
</li>
<li>
Select a <strong>P</strong>-controller and manually enlarge the parameter <code>k</code>
(the total gain of the controller) until the closed-loop response
cannot be improved any more.
</li>
<li>
Select a <strong>PI</strong>-controller and manually adjust the parameters
<code>k</code> and <code>Ti</code> (the time constant of the integrator).
The first value of <code>Ti</code> can be selected such that it is in the
order of the time constant of the oscillations occurring with
the P-controller. If, e.g., oscillations in the order of <i>100</i> seconds
occur in the previous step, start with <code>Ti=1/100</code> seconds.
</li>
<li>
If you want to make the reaction of the control loop faster
(but probably less robust against disturbances and measurement noise)
select a <strong>PID</strong>-controller and manually adjust parameters
<code>k</code>, <code>Ti</code>, <code>Td</code> (time constant of derivative block).
</li>
<li>
Set the limits <code>yMax</code> and <code>yMin</code> according to your specification.
</li>
<li>
Perform simulations such that the output of the PID controller
goes in its limits. Tune <code>Ni</code> (<i>N<sub>i</sub> T<sub>i</sub></i> is the time constant of
the anti-windup compensation) such that the input to the limiter
block (= <code>lim.u</code>) goes quickly enough back to its limits.
If <code>Ni</code> is decreased, this happens faster. If <code>Ni</code> is very large, the
anti-windup compensation is not effective and the controller works bad.
</li>
</ol>
<h4>References</h4>
<p>
R. Montgomery and R. McDowall (2008).
\"Fundamentals of HVAC Control Systems.\"
American Society of Heating Refrigerating and Air-Conditioning Engineers Inc. Atlanta, GA.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 15, 2020, by Michael Wetter:<br/>
Added scaling factor <code>r</code>, removed set point weights <code>wp</code> and <code>wd</code>.
Revised documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2182\">issue 2182</a>.
</li>
<li>
August 4, 2020, by Jianjun Hu:<br/>
Removed the conditional inputs <code>trigger</code> and <code>y_rest_in</code>.
Refactored to internally implement the derivative block.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
June 1, 2020, by Michael Wetter:<br/>
Corrected wrong convention of reverse and direct action.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1365\">issue 1365</a>.
</li>
<li>
April 23, 2020, by Michael Wetter:<br/>
Changed default parameters for limits <code>yMax</code> from unspecified to <code>1</code>
and <code>yMin</code> from <code>-yMax</code> to <code>0</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1888\">issue 1888</a>.
</li>
<li>
April 7, 2020, by Michael Wetter:<br/>
Reimplemented block using only CDL constructs.
This refactoring removes the no longer use parameters <code>xd_start</code> that was
used to initialize the state of the derivative term. This state is now initialized
based on the requested initial output <code>yd_start</code> which is a new parameter
with a default of <code>0</code>.
Also, removed the parameters <code>y_start</code> and <code>initType</code> because
the initial output of the controller can be set by using <code>xi_start</code>
and <code>yd_start</code>.
This is a non-backward compatible change, made to simplify the controller through
the removal of options that can be realized differently and are hardly ever used.
This refactoring also removes the parameter <code>strict</code> that
was used in the output limiter. The new implementation enforces a strict check by default.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1878\">issue 1878</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Corrected unit declaration for gain <code>k</code>.<br/>
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1821\">issue 1821</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display the output value.
</li>
<li>
October 19, 2019, by Michael Wetter:<br/>
Disabled homotopy to ensure bounded outputs
by copying the implementation from MSL 3.2.3 and by
hardcoding the implementation for <code>homotopyType=NoHomotopy</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1221\">issue 1221</a>.
</li>
<li>
November 13, 2017, by Michael Wetter:<br/>
Changed default controller type from PID to PI.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types and used integrator with reset from CDL.
</li>
<li>
October 22, 2017, by Michael Wetter:<br/>
Added to CDL to have a PI controller with integrator reset.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PID;

          block PIDWithReset
            "P, PI, PD, and PID controller with output reset"
            parameter Buildings.Controls.OBC.CDL.Types.SimpleController controllerType=Buildings.Controls.OBC.CDL.Types.SimpleController.PI
              "Type of controller";
            parameter Real k(
              min=100*Constants.eps)=1
              "Gain of controller"
              annotation (Dialog(group="Control gains"));
            parameter Real Ti(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.5
              "Time constant of integrator block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Td(
              final quantity="Time",
              final unit="s",
              min=100*Constants.eps)=0.1
              "Time constant of derivative block"
              annotation (Dialog(group="Control gains",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real r(
              min=100*Constants.eps)=1
              "Typical range of control error, used for scaling the control error";
            parameter Real yMax=1
              "Upper limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real yMin=0
              "Lower limit of output"
              annotation (Dialog(group="Limits"));
            parameter Real Ni(
              min=100*Constants.eps)=0.9
              "Ni*Ti is time constant of anti-windup compensation"
              annotation (Dialog(tab="Advanced",group="Integrator anti-windup",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real Nd(
              min=100*Constants.eps)=10
              "The higher Nd, the more ideal the derivative block"
              annotation (Dialog(tab="Advanced",group="Derivative block",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Real xi_start=0
              "Initial value of integrator state"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID));
            parameter Real yd_start=0
              "Initial value of derivative output"
              annotation (Dialog(tab="Advanced",group="Initialization",enable=controllerType == CDL.Types.SimpleController.PD or controllerType == CDL.Types.SimpleController.PID));
            parameter Boolean reverseActing=true
              "Set to true for reverse acting, or false for direct acting control action";
            parameter Real y_reset=xi_start
              "Value to which the controller output is reset if the boolean trigger has a rising edge"
              annotation (Dialog(enable=controllerType == CDL.Types.SimpleController.PI or controllerType == CDL.Types.SimpleController.PID,group="Integrator reset"));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_s
              "Connector of setpoint input signal"
              annotation (Placement(transformation(extent={{-260,-20},{-220,20}}),iconTransformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealInput u_m
              "Connector of measurement input signal"
              annotation (Placement(transformation(origin={0,-220},extent={{20,-20},{-20,20}},rotation=270),iconTransformation(extent={{20,-20},{-20,20}},rotation=270,origin={0,-120})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y
              "Connector of actuator output signal"
              annotation (Placement(transformation(extent={{220,-20},{260,20}}),iconTransformation(extent={{100,-20},{140,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput trigger
              "Resets the controller output when trigger becomes true"
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},rotation=90,origin={-160,-220}),iconTransformation(extent={{-20,-20},{20,20}},rotation=90,origin={-60,-120})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback controlError
              "Control error (set point - measurement)"
              annotation (Placement(transformation(extent={{-200,-10},{-180,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain P(final k=k) "Proportional action"
              annotation (Placement(transformation(extent={{-50,130},{-30,150}})));
            Buildings.Controls.OBC.CDL.Continuous.IntegratorWithReset I(
              final k=k/Ti,
              final y_start=xi_start) if with_I
              "Integral term"
              annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
            Derivative D(
              final k=k*Td,
              final T=Td/Nd,
              final y_start=yd_start) if with_D
              "Derivative term"
              annotation (Placement(transformation(extent={{-50,60},{-30,80}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errP
              "P error"
              annotation (Placement(transformation(extent={{-140,130},{-120,150}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errD if with_D
              "D error"
              annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errI1 if with_I
              "I error (before anti-windup compensation)"
              annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback errI2 if with_I
              "I error (after anti-windup compensation)"
              annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
            Buildings.Controls.OBC.CDL.Continuous.Limiter lim(
              final uMax=yMax,
              final uMin=yMin)
              "Limiter"
              annotation (Placement(transformation(extent={{120,80},{140,100}})));
        protected
            final parameter Real revAct=
              if reverseActing then
                1
              else
                -1
              "Switch for sign for reverse or direct acting controller";
            final parameter Boolean with_I=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable integral action"
              annotation (Evaluate=true,HideResult=true);
            final parameter Boolean with_D=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID
              "Boolean flag to enable derivative action"
              annotation (Evaluate=true,HideResult=true);
            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant Dzero(
              final k=0) if not with_D
              "Zero input signal"
              annotation (Evaluate=true,HideResult=true,Placement(transformation(extent={{-20,110},
                      {0,130}})));
            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant Izero(
              final k=0) if not with_I
              "Zero input signal"
              annotation (Placement(transformation(extent={{20,74},{40,94}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain uS_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-200,30},{-180,50}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain uMea_revAct(
              final k=revAct/r)
              "Set point multiplied by reverse action sign"
              annotation (Placement(transformation(extent={{-180,-50},{-160,-30}})));
            Buildings.Controls.OBC.CDL.Continuous.Add addPD(
              final k1=1,
              final k2=1)
              "Outputs P and D gains added"
              annotation (Placement(transformation(extent={{20,116},{40,136}})));
            Buildings.Controls.OBC.CDL.Continuous.Add addPID(
              final k1=1,
              final k2=1)
              "Outputs P, I and D gains added"
              annotation (Placement(transformation(extent={{80,80},{100,100}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback antWinErr if with_I
              "Error for anti-windup compensation"
              annotation (Placement(transformation(extent={{162,50},{182,70}})));
            Buildings.Controls.OBC.CDL.Continuous.Gain antWinGai(
              k=1/(k*Ni)) if with_I
              "Gain for anti-windup compensation"
              annotation (Placement(transformation(extent={{180,-30},{160,-10}})));
            Buildings.Controls.OBC.CDL.Continuous.Sources.Constant yResSig(
              final k=y_reset) if with_I
              "Signal for y_reset"
              annotation (Placement(transformation(extent={{-140,-90},{-120,-70}})));
            Buildings.Controls.OBC.CDL.Continuous.Feedback addRes if with_I
              "Adder for integrator reset"
              annotation (Placement(transformation(extent={{-100,-90},{-80,-70}})));
            Buildings.Controls.OBC.CDL.Logical.Sources.Constant cheYMinMax(
              final k=yMin < yMax)
              "Check for values of yMin and yMax"
              annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
            Buildings.Controls.OBC.CDL.Utilities.Assert assMesYMinMax(
              message="LimPID: Limits must be yMin < yMax")
              "Assertion on yMin and yMax"
              annotation (Placement(transformation(extent={{160,-160},{180,-140}})));

            block Derivative
              "Block that approximates the derivative of the input"
              parameter Real k(
                unit="1")=1
                "Gains";
              parameter Real T(
                final quantity="Time",
                final unit="s",
                min=1E-60)=0.01
                "Time constant (T>0 required)";
              parameter Real y_start=0
                "Initial value of output (= state)"
                annotation (Dialog(group="Initialization"));
              Interfaces.RealInput u
                "Connector of Real input signal"
                annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
              Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));
              output Real x
                "State of block";

          protected
              parameter Boolean zeroGain=abs(k) < 1E-17
                "= true, if gain equals to zero";

            initial equation
              if zeroGain then
                x=u;
              else
                x=u-T*y_start/k;
              end if;

            equation
              der(x)=
                if zeroGain then
                  0
                else
                  (u-x)/T;
              y=if zeroGain then
                  0
                else
                  (k/T)*(u-x);
              annotation (
                defaultComponentName="der",
                Documentation(
                  info="<html>
<p>
This blocks defines the transfer function between the
input <code>u</code> and the output <code>y</code>
as <i>approximated derivative</i>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If <code>k=0</code>, the block reduces to <code>y=0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
August 7, 2020, by Michael Wetter:<br/>
Moved to protected block in PID controller because the derivative block is no longer part of CDL.
</li>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed option to not set the initialization method or to set the initial state.
The new implementation only allows to set the initial output, from which
the initial state is computed.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),      Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100.0,-100.0},{100.0,100.0}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80.0,78.0},{-80.0,-90.0}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                    Line(
                      points={{-90.0,-80.0},{82.0,-80.0}},
                      color={192,192,192}),
                    Polygon(
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid,
                      points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                    Line(
                      origin={-24.667,-27.333},
                      points={{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
                      color={0,0,127},
                      smooth=Smooth.Bezier),
                    Text(
                      extent={{-150.0,-150.0},{150.0,-110.0}},
                      textString="k=%k"),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Text(
                      extent={{226,60},{106,10}},
                      lineColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftjustified=false,
                        significantDigits=3)))}));
            end Derivative;

          equation
            connect(trigger,I.trigger)
              annotation (Line(points={{-160,-220},{-160,-140},{-40,-140},{-40,-12}},color={255,0,255}));
            connect(u_s,uS_revAct.u)
              annotation (Line(points={{-240,0},{-212,0},{-212,40},{-202,40}},color={0,0,127}));
            connect(u_m,uMea_revAct.u)
              annotation (Line(points={{0,-220},{0,-160},{-190,-160},{-190,-40},{-182,-40}},color={0,0,127}));
            connect(errP.u2,uMea_revAct.y)
              annotation (Line(points={{-130,128},{-130,-40},{-158,-40}},                    color={0,0,127}));
            connect(errD.u2,uMea_revAct.y)
              annotation (Line(points={{-110,58},{-110,48},{-130,48},{-130,-40},{-158,-40}},
                                                                                          color={0,0,127}));
            connect(D.u,errD.y)
              annotation (Line(points={{-52,70},{-98,70}},color={0,0,127}));
            connect(errI1.u1,uS_revAct.y)
              annotation (Line(points={{-122,0},{-170,0},{-170,40},{-178,40}},color={0,0,127}));
            connect(errI1.u2,uMea_revAct.y)
              annotation (Line(points={{-110,-12},{-110,-40},{-158,-40}},color={0,0,127}));
            connect(addPID.u1,addPD.y)
              annotation (Line(points={{78,96},{68,96},{68,126},{42,126}},color={0,0,127}));
            connect(lim.y,y)
              annotation (Line(points={{142,90},{200,90},{200,0},{240,0}},color={0,0,127}));
            connect(antWinErr.y,antWinGai.u)
              annotation (Line(points={{184,60},{190,60},{190,-20},{182,-20}},color={0,0,127}));
            connect(addPD.u2,Dzero.y)
              annotation (Line(points={{18,120},{2,120}},                      color={0,0,127}));
            connect(D.y,addPD.u2)
              annotation (Line(points={{-28,70},{10,70},{10,120},{18,120}},  color={0,0,127}));
            connect(addPID.u2,I.y)
              annotation (Line(points={{78,84},{68,84},{68,0},{-28,0}},color={0,0,127}));
            connect(addRes.u2,addPD.y)
              annotation (Line(points={{-90,-92},{-90,-100},{60,-100},{60,126},{42,126}},color={0,0,127}));
            connect(addRes.y,I.y_reset_in)
              annotation (Line(points={{-78,-80},{-66,-80},{-66,-8},{-52,-8}},color={0,0,127}));
            connect(antWinErr.u2,lim.y)
              annotation (Line(points={{172,48},{172,40},{150,40},{150,90},{142,90}},color={0,0,127}));
            connect(I.u,errI2.y)
              annotation (Line(points={{-52,0},{-68,0}},color={0,0,127}));
            connect(errI1.y,errI2.u1)
              annotation (Line(points={{-98,0},{-92,0}},color={0,0,127}));
            connect(errI2.u2,antWinGai.y)
              annotation (Line(points={{-80,-12},{-80,-20},{158,-20}},color={0,0,127}));
            connect(controlError.u1,u_s)
              annotation (Line(points={{-202,0},{-240,0}},color={0,0,127}));
            connect(controlError.u2,u_m)
              annotation (Line(points={{-190,-12},{-190,-160},{0,-160},{0,-220}},color={0,0,127}));
            connect(cheYMinMax.y,assMesYMinMax.u)
              annotation (Line(points={{142,-150},{158,-150}},color={255,0,255}));
            connect(Izero.y,addPID.u2)
              annotation (Line(points={{42,84},{78,84}},                   color={0,0,127}));
            connect(errP.u1,uS_revAct.y)
              annotation (Line(points={{-142,140},{-170,140},{-170,40},{-178,40}},color={0,0,127}));
            connect(errD.u1,uS_revAct.y)
              annotation (Line(points={{-122,70},{-170,70},{-170,40},{-178,40}},color={0,0,127}));
            connect(addPD.u1, P.y)
              annotation (Line(points={{18,132},{10,132},{10,140},{-28,140}},
                                                            color={0,0,127}));
            connect(P.u, errP.y)
              annotation (Line(points={{-52,140},{-118,140}},color={0,0,127}));
            connect(addPID.y, lim.u)
              annotation (Line(points={{102,90},{118,90}},color={0,0,127}));
            connect(addPID.y, antWinErr.u1) annotation (Line(points={{102,90},{110,90},{
                    110,60},{160,60}}, color={0,0,127}));
            connect(addRes.u1, yResSig.y)
              annotation (Line(points={{-102,-80},{-118,-80}},
                                                             color={0,0,127}));
            annotation (
              defaultComponentName="conPID",
              Icon(
                coordinateSystem(
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-6,-20},{66,-66}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.P),
                    extent={{-32,-22},{68,-62}},
                    lineColor={0,0,0},
                    textString="P",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI),
                    extent={{-26,-22},{74,-62}},
                    lineColor={0,0,0},
                    textString="PI",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD),
                    extent={{-16,-22},{88,-62}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175},
                    textString="P D"),
                  Text(
                    visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
                    extent={{-14,-22},{86,-62}},
                    lineColor={0,0,0},
                    textString="PID",
                    fillPattern=FillPattern.Solid,
                    fillColor={175,175,175}),
                  Polygon(
                    points={{-80,82},{-88,60},{-72,60},{-80,82}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-80,68},{-80,-100}},
                    color={192,192,192}),
                  Line(
                    points={{-90,-80},{70,-80}},
                    color={192,192,192}),
                  Polygon(
                    points={{74,-80},{52,-72},{52,-88},{74,-80}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-80,-80},{-80,-22}},
                    color={0,0,0}),
                  Line(
                    points={{-80,-22},{6,56}},
                    color={0,0,0}),
                  Line(
                    points={{6,56},{68,56}},
                    color={0,0,0}),
                  Rectangle(
                    extent=DynamicSelect({{100,-100},{84,-100}},{{100,-100},{84,-100+(y-yMin)/(yMax-yMin)*200}}),
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0})}),
              Diagram(
                coordinateSystem(
                  extent={{-220,-200},{220,200}}), graphics={Rectangle(
                    extent={{-56,180},{-24,-16}},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None), Text(
                    extent={{-52,184},{-28,156}},
                    pattern=LinePattern.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    textString="PID")}),
              Documentation(
                info="<html>
<p>
PID controller in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k/r &nbsp; (e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(&tau;) d&tau; + T<sub>d</sub> d&frasl;dt e(t)),
</p>
<p>
with output reset,
where
<i>y<sub>u</sub></i> is the control signal before output limitation,
<i>e(t) = u<sub>s</sub>(t) - u<sub>m</sub>(t)</i> is the control error,
with <i>u<sub>s</sub></i> being the set point and <i>u<sub>m</sub></i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term,
<i>T<sub>d</sub></i> is the time constant of the derivative term,
and
<i>r</i> is a scaling factor, with default <i>r=1</i>.
The scaling factor should be set to the typical order of magnitude of the range of the error <i>e</i>.
For example, you may set <i>r=100</i> to <i>r=1000</i>
if the control input is a pressure of a heating water circulation pump in units of Pascal, or
leave <i>r=1</i> if the control input is a room temperature.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
</p>
<p>
The actual control output is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = min( y<sub>max</sub>, max( y<sub>min</sub>, y)),
</p>
<p>
where <i>y<sub>min</sub></i> and <i>y<sub>max</sub></i> are limits for the control signal.
</p>
<h4>P, PI, PD, or PID action</h4>
<p>
Through the parameter <code>controllerType</code>, the controller can be configured
as P, PI, PD or PID controller. The default configuration is PI.
</p>
<h4>Reverse or direct action</h4>
<p>
Through the parameter <code>reverseActing</code>, the controller can be configured to
be reverse or direct acting.
The above standard form is reverse acting, which is the default configuration.
For a reverse acting controller, for a constant set point,
an increase in measurement signal <code>u_m</code> decreases the control output signal <code>y</code>
(Montgomery and McDowall, 2008).
Thus,
</p>
<ul>
  <li>
  for a heating coil with a two-way valve, leave <code>reverseActing = true</code>, but
  </li>
  <li>
  for a cooling coil with a two-way valve, set <code>reverseActing = false</code>.
  </li>
</ul>
<p>
If <code>reverseAction=false</code>, then the error <i>e</i> above is multiplied by <i>-1</i>.
</p>
<h4>Anti-windup compensation</h4>
<p>
The controller anti-windup compensation is as follows:
Instead of the above basic control law, the implementation is
</p>
<p align=\"center\" style=\"font-style:italic;\">
y<sub>u</sub> = k &nbsp; (e(t) &frasl; r + 1 &frasl; T<sub>i</sub> &nbsp; &int; (-&Delta;y + e(&tau;) &frasl; r) d&tau; + T<sub>d</sub> &frasl; r d&frasl;dt e(t)),
</p>
<p>
where the anti-windup compensation <i>&Delta;y</i> is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Delta;y = (y<sub>u</sub> - y) &frasl; (k N<sub>i</sub>),
</p>
<p>
where
<i>N<sub>i</sub> &gt; 0</i> is the time constant for the anti-windup compensation.
To accelerate the anti-windup, decrease <i>N<sub>i</sub></i>.
</p>
<p>
Note that the anti-windup term <i>(-&Delta;y + e(&tau;) &frasl; r)</i> shows that the range of
the typical control error <i>r</i> should be set to a reasonable value so that
</p>
<p align=\"center\" style=\"font-style:italic;\">
e(&tau;) &frasl; r = (u<sub>s</sub>(&tau;) - u<sub>m</sub>(&tau;)) &frasl; r
</p>
<p>
has order of magnitude one, and hence the anti-windup compensation should work well.
</p>
<h4>Reset of the controller output</h4>
<p>
Whenever the value of boolean input signal <code>trigger</code> changes from
<code>false</code> to <code>true</code>, the controller output is reset by setting
<code>y</code> to the value of the parameter <code>y_reset</code>.
</p>
<h4>Approximation of the derivative term</h4>
<p>
The derivative of the control error <i>d &frasl; dt e(t)</i> is approximated using
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt x(t) = (e(t)-x(t)) T<sub>d</sub> &frasl; N<sub>d</sub>,
</p>
<p>
and
</p>
<p align=\"center\" style=\"font-style:italic;\">
d&frasl;dt e(t) &asymp; N<sub>d</sub> (e(t)-x(t)),
</p>
<p>
where <i>x(t)</i> is an internal state.
</p>
<h4>Guidance for tuning the control gains</h4>
<p>
The parameters of the controller can be manually adjusted by performing
closed loop tests (= controller + plant connected
together) and using the following strategy:
</p>
<ol>
<li> Set very large limits, e.g., set <i>y<sub>max</sub> = 1000</i>.
</li>
<li>
Select a <strong>P</strong>-controller and manually enlarge the parameter <code>k</code>
(the total gain of the controller) until the closed-loop response
cannot be improved any more.
</li>
<li>
Select a <strong>PI</strong>-controller and manually adjust the parameters
<code>k</code> and <code>Ti</code> (the time constant of the integrator).
The first value of <code>Ti</code> can be selected such that it is in the
order of the time constant of the oscillations occurring with
the P-controller. If, e.g., oscillations in the order of <i>100</i> seconds
occur in the previous step, start with <code>Ti=1/100</code> seconds.
</li>
<li>
If you want to make the reaction of the control loop faster
(but probably less robust against disturbances and measurement noise)
select a <strong>PID</strong>-controller and manually adjust parameters
<code>k</code>, <code>Ti</code>, <code>Td</code> (time constant of derivative block).
</li>
<li>
Set the limits <code>yMax</code> and <code>yMin</code> according to your specification.
</li>
<li>
Perform simulations such that the output of the PID controller
goes in its limits. Tune <code>Ni</code> (<i>N<sub>i</sub> T<sub>i</sub></i> is the time constant of
the anti-windup compensation) such that the input to the limiter
block (= <code>lim.u</code>) goes quickly enough back to its limits.
If <code>Ni</code> is decreased, this happens faster. If <code>Ni</code> is very large, the
anti-windup compensation is not effective and the controller works bad.
</li>
</ol>
<h4>References</h4>
<p>
R. Montgomery and R. McDowall (2008).
\"Fundamentals of HVAC Control Systems.\"
American Society of Heating Refrigerating and Air-Conditioning Engineers Inc. Atlanta, GA.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 30, 2021, by Michael Wetter:<br/>
Corrected error in non-released development version
when reset trigger is <code>true</code>.<br/>
Refactored implementation to have separate blocks that show the P, I and D contribution,
each with the control gain applied.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2475\">issue 2475</a>.
</li>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 15, 2020, by Michael Wetter:<br/>
Added scaling factor <code>r</code>, removed set point weights <code>wp</code> and <code>wd</code>.
Revised documentation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2182\">issue 2182</a>.
</li>
<li>
August 4, 2020, by Jianjun Hu:<br/>
Removed the input <code>y_reset_in</code>.
Refactored to internally implement the derivative block.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
June 1, 2020, by Michael Wetter:<br/>
Corrected wrong convention of reverse and direct action.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1365\">issue 1365</a>.
</li>
<li>
April 23, 2020, by Michael Wetter:<br/>
Changed default parameters for limits <code>yMax</code> from unspecified to <code>1</code>
and <code>yMin</code> from <code>-yMax</code> to <code>0</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1888\">issue 1888</a>.
</li>
<li>
April 7, 2020, by Michael Wetter:<br/>
Reimplemented block using only CDL constructs.
This refactoring removes the no longer use parameters <code>xd_start</code> that was
used to initialize the state of the derivative term. This state is now initialized
based on the requested initial output <code>yd_start</code> which is a new parameter
with a default of <code>0</code>.
Also, removed the parameters <code>y_start</code> and <code>initType</code> because
the initial output of the controller can be set by using <code>xi_start</code>
and <code>yd_start</code>.
This is a non-backward compatible change, made to simplify the controller through
the removal of options that can be realized differently and are hardly ever used.
This refactoring also removes the parameter <code>strict</code> that
was used in the output limiter. The new implementation enforces a strict check by default.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1878\">issue 1878</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Corrected unit declaration for gain <code>k</code>.<br/>
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1821\">issue 1821</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display the output value.
</li>
<li>
October 19, 2019, by Michael Wetter:<br/>
Disabled homotopy to ensure bounded outputs
by copying the implementation from MSL 3.2.3 and by
hardcoding the implementation for <code>homotopyType=NoHomotopy</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1221\">issue 1221</a>.
</li>
<li>
November 13, 2017, by Michael Wetter:<br/>
Changed default controller type from PID to PI.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types and used integrator with reset from CDL.
</li>
<li>
October 22, 2017, by Michael Wetter:<br/>
Added to CDL to have a PI controller with integrator reset.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PIDWithReset;

          block Product
            "Output product of the two inputs"
            Interfaces.RealInput u1
              "Connector of Real input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.RealInput u2
              "Connector of Real input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1*u2;
            annotation (
              defaultComponentName="pro",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = u1 * u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    extent={{-50,-50},{50,50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,60},{-40,60},{-30,40}},
                    color={0,0,127}),
                  Line(
                    points={{-100,-60},{-40,-60},{-30,-40}},
                    color={0,0,127}),
                  Line(
                    points={{50,0},{100,0}},
                    color={0,0,127}),
                  Line(
                    points={{-30,0},{30,0}}),
                  Line(
                    points={{-15,25.99},{15,-25.99}}),
                  Line(
                    points={{-15,-25.99},{15,25.99}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end Product;

          package Sources "Package with blocks that generate source signals"

            block Constant
              "Output constant signal of type Real"
              parameter Real k
                "Constant output value";
              Interfaces.RealOutput y
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k;
              annotation (
                defaultComponentName="con",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      lineColor={0,0,255},
                      extent={{-150,110},{150,150}},
                      textString="%name"),
                    Line(
                      points={{-80,68},{-80,-80}},
                      color={192,192,192}),
                    Polygon(
                      points={{-80,90},{-88,68},{-72,68},{-80,90}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-90,-70},{82,-70}},
                      color={192,192,192}),
                    Polygon(
                      points={{90,-70},{68,-62},{68,-78},{90,-70}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,0},{80,0}}),
                    Text(
                      extent={{-150,-150},{150,-110}},
                      lineColor={0,0,0},
                      textString="k=%k"),
                    Text(
                      extent={{226,60},{106,10}},
                      lineColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftjustified=false,
                        significantDigits=3)))}),
                Documentation(
                  info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a real-valued parameter.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 16, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
            end Constant;

            block ModelTime
              "Standard time"
              Interfaces.RealOutput y(
                final unit="s")
                "Connector of Real output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=time;
              annotation (
                defaultComponentName="modTim",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={1,1}),
                  graphics={
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Ellipse(
                      extent={{-80,80},{80,-80}},
                      lineColor={160,160,164},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{0,80},{0,60}},
                      color={160,160,164}),
                    Line(
                      points={{80,0},{60,0}},
                      color={160,160,164}),
                    Line(
                      points={{0,-80},{0,-60}},
                      color={160,160,164}),
                    Line(
                      points={{-80,0},{-60,0}},
                      color={160,160,164}),
                    Line(
                      points={{37,70},{26,50}},
                      color={160,160,164}),
                    Line(
                      points={{70,38},{49,26}},
                      color={160,160,164}),
                    Line(
                      points={{71,-37},{52,-27}},
                      color={160,160,164}),
                    Line(
                      points={{39,-70},{29,-51}},
                      color={160,160,164}),
                    Line(
                      points={{-39,-70},{-29,-52}},
                      color={160,160,164}),
                    Line(
                      points={{-71,-37},{-50,-26}},
                      color={160,160,164}),
                    Line(
                      points={{-71,37},{-54,28}},
                      color={160,160,164}),
                    Line(
                      points={{-38,70},{-28,51}},
                      color={160,160,164}),
                    Line(
                      points={{0,0},{-50,50}},
                      thickness=0.5),
                    Line(
                      points={{0,0},{40,0}},
                      thickness=0.5),
                    Text(
                      extent={{226,60},{106,10}},
                      lineColor={0,0,0},
                      textString=DynamicSelect("",String(y,
                        leftjustified=false,
                        significantDigits=3)))}),
                Documentation(
                  info="<html>
<p>Block that outputs the standard time.
</p>
<h4>Implementation</h4>
<p>
This block outputs the time of the model.
In the case of a building automation system, the
building automation system synchronizes time, and hence
need to assign a value for the output of this block.
Daylight saving time shall not be taken into account,
e.g, the block always outputs standard time rather than
daylight savings time.
</p>
<p>
If a simulation starts
at <i>t=-1</i>, then this block outputs first <i>t=-1</i>,
and its output is advanced at the same rate as the simulation time.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 14, 2017, by Michael Wetter:<br/>
Revised implemenation.
</li>
<li>
February 23, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>Buildings.Utilities.SimulationTime</code>
to
<code>Buildings.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
            end ModelTime;
            annotation (
              Documentation(
                info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),    Icon(
                graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-70,-4.5},{0,4.5}}),
                  Polygon(
                    origin={23.3333,0.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end Sources;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for elementary mathematical functions
for continuous variables.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Text(
                  extent={{-52,86},{52,-92}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="R"),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Continuous;

        package Conversions "Package with blocks for type conversion"

          block BooleanToInteger
            "Convert Boolean to Integer signal"
            parameter Integer integerTrue=1
              "Output signal for true Boolean input";
            parameter Integer integerFalse=0
              "Output signal for false Boolean input";
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.IntegerOutput y
              "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if u then
                integerTrue
              else
                integerFalse;
            annotation (
              defaultComponentName="booToInt",
              Documentation(
                info="<html>
<p>
Block that outputs the <code>Boolean</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = if u then integerTrue else integerFalse;
</pre>
<p>
where <code>u</code> is of <code>Boolean</code> and <code>y</code>
of <code>Integer</code> type,
and <code>integerTrue</code> and <code>integerFalse</code> are parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-86,78},{-34,26}},
                    lineColor={255,0,255},
                    textString="B"),
                  Polygon(
                    points={{28,48},{8,68},{8,58},{-24,58},{-24,38},{8,38},{8,28},{28,48}},
                    lineColor={255,170,85},
                    fillColor={255,170,85},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{34,82},{86,24}},
                    lineColor={255,170,85},
                    textString="I"),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-74,-28},{64,20}},
                    lineColor={0,0,0},
                    textString="%integerTrue"),
                  Text(
                    extent={{-74,-90},{64,-42}},
                    lineColor={0,0,0},
                    textString="%integerFalse")}));
          end BooleanToInteger;

          block BooleanToReal
            "Convert Boolean to Real signal"
            parameter Real realTrue=1
              "Output signal for true Boolean input";
            parameter Real realFalse=0
              "Output signal for false Boolean input";
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if u then
                realTrue
              else
                realFalse;
            annotation (
              defaultComponentName="booToRea",
              Documentation(
                info="<html>
<p>
Block that outputs the <code>Boolean</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = if u then integerTrue else integerFalse;
</pre>
<p>
where <code>u</code> is of <code>Boolean</code> and <code>y</code>
of <code>Integer</code> type,
and <code>integerTrue</code> and <code>integerFalse</code> are parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-68,-86},{70,-38}},
                    lineColor={0,0,0},
                    textString="%realFalse"),
                  Text(
                    extent={{-68,-26},{70,22}},
                    lineColor={0,0,0},
                    textString="%realTrue"),
                  Text(
                    extent={{-86,78},{-34,26}},
                    lineColor={255,0,255},
                    textString="B"),
                  Polygon(
                    points={{26,48},{6,68},{6,58},{-26,58},{-26,38},{6,38},{6,28},{26,48}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{34,82},{86,24}},
                    lineColor={0,0,127},
                    textString="R")}));
          end BooleanToReal;

          block IntegerToReal
            "Convert Integer to Real signals"
            Interfaces.IntegerInput u
              "Connector of Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u;
            annotation (
              defaultComponentName="intToRea",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={255,127,0},
                    extent={{-120.0,-40.0},{-20.0,40.0}},
                    textString="I"),
                  Text(
                    lineColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,-40.0},{100.0,40.0}},
                    textString="R"),
                  Polygon(
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    points={{10.0,0.0},{-10.0,20.0},{-10.0,10.0},{-40.0,10.0},{-40.0,-10.0},{-10.0,-10.0},{-10.0,-20.0},{10.0,0.0}})}),
              Documentation(
                info="<html>
<p>
Block that outputs the <code>Real</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = u;
</pre>
<p>
where <code>u</code> is of <code>Integer</code> and
<code>y</code> of <code>Real</code> type.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end IntegerToReal;

          block RealToInteger
            "Convert Real to Integer signal"
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.IntegerOutput y
              "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if
                (u > 0) then
                integer(
                  floor(
                    u+0.5))
              else
                integer(
                  ceil(
                    u-0.5));
            annotation (
              defaultComponentName="reaToInt",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,127},
                    extent={{-100.0,-40.0},{0.0,40.0}},
                    textString="R"),
                  Text(
                    lineColor={255,127,0},
                    extent={{20.0,-40.0},{120.0,40.0}},
                    textString="I"),
                  Polygon(
                    lineColor={255,127,0},
                    fillColor={255,127,0},
                    fillPattern=FillPattern.Solid,
                    points={{50.0,0.0},{30.0,20.0},{30.0,10.0},{0.0,10.0},{0.0,-10.0},{30.0,-10.0},{30.0,-20.0},{50.0,0.0}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y</code>
as the nearest integer value of the input <code>u</code>.
</p>
<p>
The block outputs
</p>
<pre>
    y = integer( floor( u + 0.5 ) )  for  u &gt; 0,
    y = integer( ceil ( u - 0.5 ) )  for  u &lt; 0.
</pre>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end RealToInteger;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for type conversions.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Conversions;

        package Discrete "Package with discrete blocks"

          block FirstOrderHold
            "First order hold of a sampled-data system"
            parameter Real samplePeriod(
              final quantity="Time",
              final unit="s",
              min=1E-3)
              "Sample period of component";
            Interfaces.RealInput u
              "Continuous input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Continuous output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Real t0(
              final quantity="Time",
              final unit="s",
              fixed=false)
              "First sample time instant";
            output Boolean sampleTrigger
              "True, if sample time instant";
            output Boolean firstTrigger(
              start=false,
              fixed=true)
              "Rising edge signals first sample instant";
            Real tSample(
              final quantity="Time",
              final unit="s")
              "Time of sample";
            Real uSample
              "Value of sample";
            Real pre_uSample
              "Value of previous sample";
            Real c
              "Slope";

          initial equation
            t0=Buildings.Utilities.Math.Functions.round(
              x=integer(time/samplePeriod)*samplePeriod,
              n=6);
            pre(tSample)=t0;
            pre(uSample)=u;
            pre(pre_uSample)=u;
            pre(c)=0.0;

          equation
            // Declarations that are used for all discrete blocks
            sampleTrigger=sample(
              t0,
              samplePeriod);
            when sampleTrigger then
              firstTrigger=time <= t0+samplePeriod/2;
              tSample=time;
              uSample=u;
              pre_uSample=pre(uSample);
              c=if firstTrigger then
                  0
                else
                  (uSample-pre_uSample)/samplePeriod;
            end when;
            /* Use pre_uSample and pre(c) to break potential algebraic loops by an
       infinitesimal delay if both the continuous and the discrete part
       have direct feedthrough.
    */
                y=pre_uSample+pre(c)*(time-tSample);
            annotation (
              defaultComponentName="firOrdHol",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={223,211,169},
                    lineThickness=5.0,
                    borderPattern=BorderPattern.Raised,
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-79.0,-41.0},{-59.0,-33.0},{-40.0,1.0},{-20.0,9.0},{0.0,63.0},{21.0,20.0},{41.0,10.0},{60.0,20.0}},
                    color={0,0,127}),
                  Line(
                    points={{60.0,20.0},{81.0,10.0}},
                    color={0,0,127}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs the extrapolation through the
values of the last two sampled input signals.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 19, 2020, by Michael Wetter:<br/>
Refactored implementation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2170\">#2170</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end FirstOrderHold;

          block Sampler
            "Ideal sampler of a continuous signal"
            parameter Real samplePeriod(
              final quantity="Time",
              final unit="s",
              min=1E-3)
              "Sample period of component";
            Interfaces.RealInput u
              "Continuous input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Continuous output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Real t0(
              final quantity="Time",
              final unit="s",
              fixed=false)
              "First sample time instant";
            output Boolean sampleTrigger
              "True, if sample time instant";
            output Boolean firstTrigger(
              start=false,
              fixed=true)
              "Rising edge signals first sample instant";

          initial equation
            t0=Buildings.Utilities.Math.Functions.round(
              x=integer(time/samplePeriod)*samplePeriod,
              n=6);

          equation
            // Declarations that are used for all discrete blocks
            sampleTrigger=sample(
              t0,
              samplePeriod);
            when sampleTrigger then
              firstTrigger=time <= t0+samplePeriod/2;
            end when;
            // Declarations specific to this type of discrete block
            when {sampleTrigger,initial()} then
              y=u;
            end when;
            annotation (
              defaultComponentName="sam",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={223,211,169},
                    lineThickness=5.0,
                    borderPattern=BorderPattern.Raised,
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Ellipse(
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{25.0,-10.0},{45.0,10.0}}),
                  Line(
                    points={{-100.0,0.0},{-45.0,0.0}},
                    color={0,0,127}),
                  Line(
                    points={{45.0,0.0},{100.0,0.0}},
                    color={0,0,127}),
                  Line(
                    points={{-35.0,0.0},{30.0,35.0}},
                    color={0,0,127}),
                  Ellipse(
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{-45.0,-10.0},{-25.0,10.0}})}),
              Diagram(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Ellipse(
                    extent={{-25,-10},{-45,10}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{45,-10},{25,10}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,0},{-45,0}},
                    color={0,0,255}),
                  Line(
                    points={{45,0},{100,0}},
                    color={0,0,255}),
                  Line(
                    points={{-35,0},{30,35}},
                    color={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Block that outputs the input signal, sampled at a sampling rate defined
via parameter <code>samplePeriod</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 19, 2020, by Michael Wetter:<br/>
Refactored implementation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2170\">#2170</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Sampler;

          block TriggeredSampler
            "Triggered sampling of continuous signals"
            parameter Real y_start=0
              "Initial value of output signal";
            Interfaces.RealInput u
              "Connector with a Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Connector with a Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
            Interfaces.BooleanInput trigger
              "Signal that triggers the sampler"
              annotation (Placement(transformation(origin={0,-118},extent={{-20,-20},{20,20}},rotation=90)));

          initial equation
            y=y_start;

          equation
            when trigger then
              y=u;
            end when;
            annotation (
              defaultComponentName="triSam",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={223,211,169},
                    lineThickness=5.0,
                    borderPattern=BorderPattern.Raised,
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{25.0,-10.0},{45.0,10.0}}),
                  Line(
                    points={{-100.0,0.0},{-45.0,0.0}},
                    color={0,0,127}),
                  Line(
                    points={{45.0,0.0},{100.0,0.0}},
                    color={0,0,127}),
                  Line(
                    points={{0.0,-100.0},{0.0,-26.0}},
                    color={255,0,255}),
                  Line(
                    points={{-35.0,0.0},{28.0,-48.0}},
                    color={0,0,127}),
                  Ellipse(
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{-45.0,-10.0},{-25.0,10.0}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
Samples the continuous input signal whenever the trigger input
signal is rising (i.e., trigger changes from <code>false</code> to
<code>true</code>) and provides the sampled input signal as output.
Before the first sampling, the output signal is equal to
the initial value defined via parameter <code>y_start</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
May 18, 2017, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
May 17, 2017, by Milica Grahovac:<br/>
First revision, based on the implementation of the
Modelica Standard Library.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end TriggeredSampler;

          block UnitDelay
            "Output the input signal with a unit delay"
            parameter Real samplePeriod(
              final quantity="Time",
              final unit="s",
              min=1E-3)
              "Sample period of component";
            parameter Real y_start=0
              "Initial value of output signal";
            Interfaces.RealInput u
              "Continuous input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y
              "Continuous output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Real t0(
              final quantity="Time",
              final unit="s",
              fixed=false)
              "First sample time instant";
            output Boolean sampleTrigger
              "True, if sample time instant";

          initial equation
            t0=Buildings.Utilities.Math.Functions.round(
              x=integer(time/samplePeriod)*samplePeriod,
              n=6);
            y=y_start;

          equation
            // Declarations that are used for all discrete blocks
            sampleTrigger=sample(
              t0,
              samplePeriod);
            when sampleTrigger then
              y=pre(u);
            end when;
            annotation (
              defaultComponentName="uniDel",
              Documentation(
                info="<html>
<p>
Block that outputs the input signal with a unit delay:
</p>
<pre>
          1
     y = --- * u
          z
</pre>
<p>
that is, the output signal <code>y</code> is the
input signal <code>u</code> of the
previous sample instant. Before the second sample instant,
the output <code>y</code> is identical to parameter <code>y_start</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
October 19, 2020, by Michael Wetter:<br/>
Refactored implementation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2170\">#2170</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={223,211,169},
                    lineThickness=5.0,
                    borderPattern=BorderPattern.Raised,
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-30.0,0.0},{30.0,0.0}},
                    color={0,0,127}),
                  Text(
                    lineColor={0,0,127},
                    extent={{-90.0,10.0},{90.0,90.0}},
                    textString="1"),
                  Text(
                    lineColor={0,0,127},
                    extent={{-90.0,-90.0},{90.0,-10.0}},
                    textString="z"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}));
          end UnitDelay;
          annotation (
            Documentation(
              info="<html>
<p>
This package contains discrete control blocks
with fixed sample period.
Every component of this package is structured in the following way:
</p>
<ol>
<li> A component has continuous Real input and output signals.</li>
<li> The input signals are sampled by the given sample period
     defined via parameter <code>samplePeriod</code>.
     The first sample instant is defined by the parameter <code>startTime</code>.
</li>
<li> The output signals are computed from the sampled input signals.
</li>
</ol>

</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Line(
                  points={{-88,0},{-45,0}},
                  color={95,95,95}),
                Ellipse(
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-45,-10},{-25,10}}),
                Line(
                  points={{-35,0},{24,52}},
                  color={95,95,95}),
                Ellipse(
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{25,-10},{45,10}}),
                Line(
                  points={{45,0},{82,0}},
                  color={95,95,95})}));
        end Discrete;

        package Integers "Package with blocks for integer variables"

          block Add
            "Output the sum of the two inputs"
            parameter Integer k1=+1
              "Gain of upper input";
            parameter Integer k2=+1
              "Gain of lower input";
            Interfaces.IntegerInput u1
              "Connector of Integer input signal 1"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Interfaces.IntegerInput u2
              "Connector of Integer input signal 2"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.IntegerOutput y
              "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=k1*u1+k2*u2;
            annotation (
              defaultComponentName="addInt",
              Documentation(
                info="<html>
<p>
Block that outputs <code>y</code> as the weighted <i>sum</i> of the
two Integer input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = k1*u1 + k2*u2;
</pre>
<p>
where <code>k1</code> and <code>k2</code> are Integer parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,60},{-74,24},{-44,24}},
                    color={255,127,0}),
                  Line(
                    points={{-100,-60},{-74,-28},{-42,-28}},
                    color={255,127,0}),
                  Ellipse(
                    lineColor={255,127,0},
                    extent={{-50,-50},{50,50}}),
                  Line(
                    points={{50,0},{100,0}},
                    color={255,127,0}),
                  Text(
                    extent={{-40,-20},{36,48}},
                    textString="+"),
                  Text(
                    extent={{-100,52},{5,92}},
                    textString="%k1"),
                  Text(
                    extent={{-100,-92},{5,-52}},
                    textString="%k2")}));
          end Add;

          block Equal
            "Output y is true, if input u1 is equal to input u2"
            Interfaces.IntegerInput u1
              "Connector of first Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.IntegerInput u2
              "Connector of second Integer input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 == u2;
            annotation (
              defaultComponentName="intEqu",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{32,10},{52,-10}},
                    lineColor={255,127,0}),
                  Line(
                    points={{-100,-80},{42,-80},{42,0}},
                    color={255,127,0}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-76,-36},{20,54}},
                    lineColor={255,127,0},
                    textString="=")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is equal to the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Equal;

          block GreaterThreshold
            "Output y is true, if input u is greater than a threshold"
            parameter Integer t=0
              "Threshold for comparison";
            Interfaces.IntegerInput u
              "Connector of Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u > t;
            annotation (
              defaultComponentName="intGreThr",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-140},{150,-110}},
                    lineColor={0,0,0},
                    textString="%t"),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Line(
                    points={{-54,22},{-8,2},{-54,-18}},
                    thickness=0.5,
                    color={255,127,0})}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is greater than
the parameter <code>t</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 6, 2020, by Michael Wetter:<br/>
Renamed <code>threshold</code> to <code>t</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2076\">issue 2076</a>.
</li>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end GreaterThreshold;

          block LessEqual
            "Output y is true, if input u1 is less or equal than input u2"
            Interfaces.IntegerInput u1
              "Connector of first Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.IntegerInput u2
              "Connector of second Integer input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 <= u2;
            annotation (
              defaultComponentName="intLesEqu",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{73,7},{87,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{32,10},{52,-10}},
                    lineColor={255,127,0}),
                  Line(
                    points={{-100,-80},{42,-80},{42,0}},
                    color={255,127,0}),
                  Line(
                    points={{-10,20},{-54,0},{-10,-18}},
                    thickness=0.5,
                    color={255,127,0}),
                  Line(
                    points={{-54,-18},{-14,-34}},
                    thickness=0.5,
                    color={255,127,0}),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is less than or equal to the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end LessEqual;

          block LessThreshold
            "Output y is true, if input u is less than a threshold"
            parameter Integer t=0
              "Threshold for comparison";
            Interfaces.IntegerInput u
              "Connector of Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u < t;
            annotation (
              defaultComponentName="intLesThr",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,-140},{150,-110}},
                    lineColor={0,0,0},
                    textString="%t"),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Line(
                    points={{-10,20},{-54,0},{-10,-18}},
                    thickness=0.5,
                    color={255,127,0})}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is less than
the parameter <code>t</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end LessThreshold;

          block MultiSum
            "Sum of Reals, y = k[1]*u[1] + k[2]*u[2] + ... + k[n]*u[n]"
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            parameter Integer k[nin]=fill(
              1,
              nin)
              "Input gains";
            Interfaces.IntegerInput u[nin]
              "Connector of Integer input signals"
              annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));
            Interfaces.IntegerOutput y
              "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            if size(
              u,
              1) > 0 then
              y=k*u;
            else
              y=0;
            end if;
            annotation (
              defaultComponentName="mulSumInt",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-200,-110},{200,-140}},
                    lineColor={0,0,0},
                    fillColor={255,213,170},
                    fillPattern=FillPattern.Solid,
                    textString="%k"),
                  Text(
                    extent={{-82,84},{82,-52}},
                    lineColor={255,127,0},
                    fillColor={255,213,170},
                    fillPattern=FillPattern.Solid,
                    textString="+"),
                  Text(
                    extent={{-144,150},{156,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(
                info="<html>
<p>
Block that outputs
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = &sum;<sub>i=1</sub><sup>n</sup> k<sub>i</sub> &nbsp; u<sub>i</sub>,
</p>
<p>
where <i>k</i> is a parameter with <i>n</i> elements and <i>u</i> is
an input of the same length.
The dimension of <i>u</i> can be enlarged by
drawing an additional connection line. The connection is automatically connected
to this new free index.
</p>

<p>
If no connection to the input connector <i>u</i> is present,
the output is <i>y=0</i>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Validation.MultiSum\">
Buildings.Controls.OBC.CDL.Integers.Validation.MultiSum</a>
for an example.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the Modelica Standard
Library. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/933\">issue 933</a>.
</li>
</ul>
</html>"));
          end MultiSum;

          package Sources "Package with blocks that generate source signals"

            block Constant
              "Output constant signal of type Integer"
              parameter Integer k
                "Constant output value";
              Interfaces.IntegerOutput y
                "Connector of Integer output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k;
              annotation (
                defaultComponentName="conInt",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={255,127,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,68},{-80,-80}},
                      color={192,192,192}),
                    Polygon(
                      points={{-80,90},{-88,68},{-72,68},{-80,90}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-90,-70},{82,-70}},
                      color={192,192,192}),
                    Polygon(
                      points={{90,-70},{68,-62},{68,-78},{90,-70}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,0},{80,0}}),
                    Text(
                      extent={{-150,-150},{150,-110}},
                      lineColor={0,0,0},
                      textString="k=%k")}),
                Documentation(
                  info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is an Integer-valued parameter.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Integers/Sources/Constant.png\"
     alt=\"IntegerConstant.png\" />
</p>
</html>"));
            end Constant;
            annotation (
              Documentation(
                info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),    Icon(
                graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100,-100},{100,100}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100,-100},{100,100}},
                    radius=25.0),
                  Polygon(
                    origin={23.3333,0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                  Rectangle(
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-70,-4.5},{0,4.5}})}));
          end Sources;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for elementary mathematical functions
for integer variables.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Text(
                  extent={{-56,90},{48,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="Z")}));
        end Integers;

        package Logical "Package with logical blocks"

          block And
            "Logical 'and': y = u1 and u2"
            Interfaces.BooleanInput u1
              "Connector of first Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput u2
              "Connector of second Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 and u2;
            annotation (
              defaultComponentName="and2",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-90,40},{90,-40}},
                    lineColor={0,0,0},
                    textString="and"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-6},{-89,8}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-73},{-89,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if all inputs are <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end And;

          block Edge
            "Output y is true, if the input u has a rising edge (y = edge(u))"
            parameter Boolean pre_u_start=false
              "Start value of pre(u) at initial time";
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            pre(u)=pre_u_start;

          equation
            y=edge(u);
            annotation (
              defaultComponentName="edg",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-50,52},{50,-46}},
                    lineColor={0,0,0},
                    textString="edge"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-120,140},{-120,140}},
                    lineColor={28,108,200}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the Boolean input has a rising edge
from <code>false</code> to <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Edge;

          block Latch
            "Maintains a true signal until change condition"
            Interfaces.BooleanInput u
              "Latch input"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput clr
              "Clear input"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
            Interfaces.BooleanOutput y
              "Output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          initial equation
            pre(y)=false;
            pre(u)=false;
            pre(clr)=false;

          equation
            when initial() then
              //scenario = 1;
              y=if clr then
                  false
                else
                  u;
            elsewhen
                    (not clr) and change(u) and
                                               (pre(u) == false) then
              //scenario = 2;
              y=not clr;
            elsewhen
                    (not clr) and change(u) and
                                               (pre(u) == true) then
              //scenario = 3;
              y=if clr then
                  false
                else
                  pre(y);
            elsewhen change(clr) and
                                    (pre(clr) == true) and
                                                          (not u) then
              //scenario = 4;
              y=false;
            elsewhen clr then
              //scenario = 5;
              y=false;
            end when;
            annotation (
              defaultComponentName="lat",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{-73,9},{-87,-5}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{81,7},{95,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-73,-53},{-87,-67}},
                    lineColor=DynamicSelect({235,235,235},
                      if u0 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u0 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-68,-62},{4,-62},{4,-22},{74,-22}},
                    color={255,0,255}),
                  Line(
                    points={{-68,24},{-48,24},{-48,56},{-16,56},{-16,24},{24,24},{24,56},{54,56},{54,24},{74,24}},
                    color={255,0,255}),
                  Text(
                    extent={{-14,-8},{14,-18}},
                    lineColor={0,0,0},
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    textString="Clear"),
                  Text(
                    extent={{-16,72},{24,58}},
                    lineColor={0,0,0},
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    textString="Latch input"),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that generates a <code>true</code> output when the latch input <code>u</code> 
rises from <code>false</code> to <code>true</code>, provided that the clear input 
<code>clr</code> is <code>false</code> or also became at the same time <code>false</code>.
The output remains <code>true</code> until the clear input <code>clr</code> rises 
from <code>false</code> to <code>true</code>.
</p>
<p>
If the clear input <code>clr</code> is <code>true</code>, the output <code>y</code>
switches to <code>false</code> (if it was <code>true</code>) and it remains <code>false</code>,
regardless of the value of the latch input <code>u</code>.
</p>
<p>
At initial time, if <code>clr = false</code>, then the output will be 
<code>y = u</code>. Otherwise it will be <code>y=false</code> 
(because the clear input <code>clr</code> is <code>true</code>).
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Latch.png\"
     alt=\"Latch.png\" />
</p>

</html>",       revisions="<html>
<ul>
<li>
October 13, 2020, by Jianjun Hu:<br/>
Removed the parameter <code>pre_y_start</code>, and made the initial output to be
equal to latch input when the clear input is <code>false</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2177\">issue 2177</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Simplified implementation, and made model work with OpenModelica.
</li>
<li>
April 4, 2019, by Jianjun Hu:<br/>
Corrected implementation that causes wrong output at initial stage. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1402\">issue 1402</a>.
</li>
<li>
December 1, 2017, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>
March 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Latch;

          block LogicalSwitch
            "Switch between two boolean signals"
            Interfaces.BooleanInput u1
              "Boolean input signal"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Interfaces.BooleanInput u2
              "Boolean switch input signal, if true, y=u1, else y=u3"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput u3
              "Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Booelan output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if u2 then
                u1
              else
                u3;
            annotation (
              defaultComponentName="logSwi",
              Documentation(
                info="<html>
<p>
Block that outputs one of two boolean input signals based on a boolean input signal.
</p>
<p>
If the input signal <code>u2</code> is <code>true</code>,
the block outputs <code>y = u1</code>.
Otherwise, it outputs <code>y = u3</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 17, 2020, by Jianjun Hu:<br/>
Changed icon to display dynamically which input signal is being outputted.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2033\"># 2033</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Line(
                    points={{12,0},{100,0}},
                    color={255,0,255}),
                  Line(
                    points={{-100,0},{-40,0}},
                    color={255,0,255}),
                  Line(
                    points={{-100,-80},{-40,-80},{-40,-80}},
                    color={255,0,255}),
                  Line(
                    points={{-40,12},{-40,-10}},
                    color={255,0,255}),
                  Line(
                    points={{-100,80},{-40,80}},
                    color={255,0,255}),
                  Line(
                    points=DynamicSelect({{8,2},{-40,80}},{{8,2},
                      if u2 then
                        {-40,80}
                      else
                        {-40,-80}}),
                    color={255,0,255},
                    thickness=1),
                  Ellipse(
                    lineColor={0,0,127},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{2.0,-6.0},{18.0,8.0}}),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-71,74},{-85,88}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-71,-74},{-85,-88}},
                    lineColor=DynamicSelect({235,235,235},
                      if u3 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u3 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-90,76},{-46,50}},
                    lineColor=DynamicSelect({0,0,0},
                      if u2 then
                        {0,0,0}
                      else
                        {235,235,235}),
                    textString="true"),
                  Text(
                    extent={{-90,-42},{-38,-72}},
                    lineColor=DynamicSelect({0,0,0},
                      if u2 then
                        {235,235,235}
                      else
                        {0,0,0}),
                    textString="false"),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end LogicalSwitch;

          block MultiAnd
            "Logical MultiAnd, y = u[1] and u[2] and u[3] and ..."
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            Interfaces.BooleanInput u[nin]
              "Connector of Boolean input signals"
              annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            Boolean uTemp[nin]
              "Temporary variable";

          equation
            if size(
              u,
              1) > 1 then
              uTemp[1]=u[1];
              for i in 2:size(
                u,
                1) loop
                uTemp[i]=u[i] and uTemp[i-1];
              end for;
              y=uTemp[nin];
            elseif
                  (size(
              u,
              1) == 1) then
              uTemp[1]=u[1];
              y=uTemp[1];
            else
              y=false;
            end if;
            annotation (
              defaultComponentName="mulAnd",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-144,150},{156,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-80,52},{56,-52}},
                    lineColor={0,0,0},
                    textString="AND"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = true</code> if and only if
all elements of the input vector <code>u</code> are <code>true</code>.
If no connection to the input connector <code>u</code> is present,
the output is <code>y=false</code>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Validation.MultiAnd\">
Buildings.Controls.OBC.CDL.Logical.Validation.MultiAnd</a>
for an example.
</p>
</html>", revisions="<html>
<ul>
<li>
July 26, 2021, by Jianjun Hu:<br/>
Renamed parameter <code>nu</code> to <code>nin</code>. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2580\">issue 2580</a>.
</li>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
          end MultiAnd;

          block MultiOr
            "Logical MultiOr, y = u[1] or u[2] or u[3] or ..."
            parameter Integer nin(
              min=0)=0
              "Number of input connections"
              annotation (Dialog(connectorSizing=true),HideResult=true);
            Interfaces.BooleanInput u[nin]
              "Connector of Boolean input signals"
              annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            Boolean uTemp[nin]
              "Temporary variable";

          equation
            if size(
              u,
              1) > 1 then
              uTemp[1]=u[1];
              for i in 2:size(
                u,
                1) loop
                uTemp[i]=u[i] or uTemp[i-1];
              end for;
              y=uTemp[nin];
            elseif
                  (size(
              u,
              1) == 1) then
              uTemp[1]=u[1];
              y=uTemp[1];
            else
              y=false;
            end if;
            annotation (
              defaultComponentName="mulOr",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-144,150},{156,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-80,52},{56,-52}},
                    lineColor={0,0,0},
                    textString="OR"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>y = true</code> if any element in the input 
vector <code>u</code> is <code>true</code>.
If no connection to the input connector <code>u</code> is present,
the output is <code>y=false</code>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Validation.MultiOr\">
Buildings.Controls.OBC.CDL.Logical.Validation.MultiOr</a>
for an example.
</p>
</html>", revisions="<html>
<ul>
<li>
July 26, 2021, by Jianjun Hu:<br/>
Renamed parameter <code>nu</code> to <code>nin</code>. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2580\">issue 2580</a>.
</li>
<li>
June 6, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MultiOr;

          block Nor
            "Logical 'nor': y = not (u1 or u2)"
            Interfaces.BooleanInput u1
              "Connector of first Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput u2
              "Connector of second Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=not
                 (u1 or u2);
            annotation (
              defaultComponentName="nor",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-90,40},{90,-40}},
                    lineColor={0,0,0},
                    textString="nor"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-6},{-89,8}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-73},{-89,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if none of the inputs is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Nor;

          block Not
            "Logical not"
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=not u;
            annotation (
              defaultComponentName="not1",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    lineThickness=5.0,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-56,28},{72,-24}},
                    lineColor={0,0,0},
                    textString="not"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if the input is <code>false</code>,
and <code>false</code> if the input is <code>true</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Not;

          block Or
            "Logical 'or': y = u1 or u2"
            Interfaces.BooleanInput u1
              "Connector of first Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput u2
              "Connector of second Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 or u2;
            annotation (
              defaultComponentName="or2",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-90,40},{90,-40}},
                    lineColor={0,0,0},
                    textString="or"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-6},{-89,8}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-75,-73},{-89,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if at least one input
is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Or;

          block Or3
            "Logical 'or': y = u1 or u2 or u3"
            Interfaces.BooleanInput u1
              "Connector of first Boolean input signal"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Interfaces.BooleanInput u2
              "Connector of second Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanInput u3
              "Connector of third Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=u1 or u2 or u3;
            annotation (
              defaultComponentName="or3",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-90,40},{90,-40}},
                    lineColor={0,0,0},
                    textString="or"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-73,-6},{-87,8}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-73,-73},{-87,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if u3 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u3 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Ellipse(
                    extent={{-75,72},{-89,86}},
                    lineColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u1 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that outputs <code>true</code> if at least one input
is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Or3;

          block Switch
            "Switch between two Real signals"
            Interfaces.RealInput u1
              "Real input signal"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Interfaces.BooleanInput u2
              "Boolean switch input signal, if true, y=u1, else y=u3"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealInput u3
              "Real input signal"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
            Interfaces.RealOutput y
              "Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=if u2 then
                u1
              else
                u3;
            annotation (
              defaultComponentName="swi",
              Documentation(
                info="<html>
<p>
Block that outputs one of two real input signals based on a boolean input signal.
</p>
<p>
If the input signal <code>u2</code> is <code>true</code>,
the block outputs <code>y = u1</code>.
Otherwise, it outputs <code>y = u3</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 17, 2020, by Jianjun Hu:<br/>
Changed icon to display dynamically which input signal is being outputted.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2033\"># 2033</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),    Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Line(
                    points={{12.0,0.0},{100.0,0.0}},
                    color={0,0,127}),
                  Line(
                    points={{-100.0,0.0},{-40.0,0.0}},
                    color={255,0,255}),
                  Line(
                    points={{-100.0,-80.0},{-40.0,-80.0},{-40.0,-80.0}},
                    color={0,0,127}),
                  Line(
                    points={{-40.0,12.0},{-40.0,-12.0}},
                    color={255,0,255}),
                  Line(
                    points={{-100.0,80.0},{-40.0,80.0}},
                    color={0,0,127}),
                  Line(
                    points=DynamicSelect({{10,0},{-40,80}},{{10,0},
                      if u2 then
                        {-40,80}
                      else
                        {-40,-80}}),
                    color={0,0,127},
                    thickness=1.0),
                  Ellipse(
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{2.0,-8.0},{18.0,8.0}}),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u2 then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-90,80},{-46,54}},
                    lineColor=DynamicSelect({0,0,0},
                      if u2 then
                        {0,0,0}
                      else
                        {235,235,235}),
                    textString="true"),
                  Text(
                    extent={{-90,-46},{-38,-76}},
                    lineColor=DynamicSelect({0,0,0},
                      if u2 then
                        {235,235,235}
                      else
                        {0,0,0}),
                    textString="false"),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}));
          end Switch;

          block Timer
            "Timer measuring the time from the time instant where the Boolean input became true"
            parameter Real t(
              final quantity="Time",
              final unit="s")=0
              "Threshold time for comparison";
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u
              "Input that switches timer on if true, and off if false"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.RealOutput y(
              final quantity="Time",
              final unit="s")
              "Elapsed time"
              annotation (Placement(transformation(extent={{100,-20},{140,20}}),iconTransformation(extent={{100,-20},{140,20}})));
            Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput passed
              "True if the elapsed time is greater than threshold"
              annotation (Placement(transformation(extent={{100,-100},{140,-60}}),iconTransformation(extent={{100,-100},{140,-60}})));

        protected
            discrete Real entryTime(
              final quantity="Time",
              final unit="s")
              "Time instant when u became true";

          initial equation
            pre(entryTime)=time;
            pre(passed)=t <= 0;

          equation
            when u then
              entryTime=time;
              // When u becomes true, and t=0, we want passed to be true
              // at the first step (in superdense time).
              passed=t <= 0;
            elsewhen
                    (u and time >= t+pre(entryTime)) then
              passed=true;
              entryTime=pre(entryTime);
            elsewhen not u then
              // Set passed to false.
              // This is the behavior a timer would have if the threshold test is done with a greater block connected to the output of the timer
              passed=false;
              entryTime=pre(entryTime);
            end when;
            y=if u then
                time-entryTime
              else
                0.0;
            annotation (
              defaultComponentName="tim",
              Icon(
                coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Line(
                    points={{-66,-60},{82,-60}},
                    color={192,192,192}),
                  Line(
                    points={{-58,68},{-58,-80}},
                    color={192,192,192}),
                  Polygon(
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    points={{90,-60},{68,-52},{68,-68},{90,-60}}),
                  Polygon(
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid,
                    points={{-58,90},{-66,68},{-50,68},{-58,90}}),
                  Line(
                    points={{-56,-60},{-38,-60},{-38,-16},{40,-16},{40,-60},{68,-60}},
                    color={255,0,255}),
                  Line(
                    points={{-58,0},{-40,0},{40,58},{40,0},{68,0}},
                    color={0,0,127}),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Text(
                    extent={{-64,62},{62,92}},
                    lineColor={0,0,0},
                    textString="t=%t"),
                  Ellipse(
                    extent={{-83,7},{-69,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{71,-73},{85,-87}},
                    lineColor=DynamicSelect({235,235,235},
                      if passed then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if passed then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("",String(y,
                      leftjustified=false,
                      significantDigits=3)))}),
              Documentation(
                info="<html>
<p>
If the Boolean input <code>u</code> is <code>true</code>,
the output <code>y</code> is the time that has elapsed since <code>u</code> became <code>true</code>.
Otherwise, <code>y</code> is <i>0</i>.
If the output <code>y</code> becomes greater than the threshold time <code>t</code>,
the output <code>passed</code> is <code>true</code>.
Otherwise it is <code>false</code>.
</p>
<p>
In the limiting case where the timer value reaches the threshold <code>t</code>
and the input <code>u</code> becomes <code>false</code> simultaneously,
the output <code>passed</code> remains <code>false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
August 28, 2020, by Michael Wetter:<br/>
Revised implementation to correctly deal with non-zero simulation start time,
and to avoid state events.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2101\">issue 2101</a>.
</li>
<li>
August 26, 2020, by Jianjun Hu:<br/>
Removed <code>reset</code> boolean input and added output <code>passed</code>
to show if the time becomes greater than threshold time.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2101\">issue 2101</a>.
</li>
<li>
July 31, 2020, by Jianjun Hu:<br/>
Fixed the reset input. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2056\">issue 2056</a>.
</li>
<li>
November 8, 2019, by Michael Wetter:<br/>
Revised implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1221\">issue 1221</a>.
</li>
<li>
July 23, 2018, by Jianjun Hu:<br/>
Added conditional boolean input for cumulative time measuring. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1221\">issue 1221</a>.
</li>
<li>
July 18, 2018, by Jianjun Hu:<br/>
Updated implementation to output accumulated true input time.  This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1212\">issue 1212</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Timer;

          block TrueDelay
            "Delay a rising edge of the input, but do not delay a falling edge."
            parameter Real delayTime(
              final quantity="Time",
              final unit="s")
              "Delay time";
            parameter Boolean delayOnInit=false
              "Set to true to delay initial true input";
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Real t_past(
              final quantity="Time",
              final unit="s",
              fixed=false)
              "Time before simulation started";
            Real t_next(
              final quantity="Time",
              final unit="s")
              "Next event time";

          initial equation
            t_past=time-1000;
            pre(u)=false;
            pre(t_next)=time-1000;

          equation
            when initial() then
              t_next=
                if not delayOnInit then
                  t_past
                else
                  time+delayTime;
              y=if not
                      (delayOnInit and delayTime > 0) then
                  u
                else
                  false;
            elsewhen u then
              t_next=time+delayTime;
              y=if delayTime > 0 then
                  false
                else
                  true;
            elsewhen not u then
              t_next=t_past;
              y=false;
            elsewhen time >= pre(t_next) then
              t_next=t_past;
              y=u;
            end when;
            annotation (
              defaultComponentName="truDel",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-250,-120},{250,-150}},
                    lineColor={0,0,0},
                    textString="%delayTime"),
                  Line(
                    points={{-80,-66},{-60,-66},{-60,-22},{38,-22},{38,-66},{66,-66}}),
                  Line(
                    points={{-80,32},{-4,32},{-4,76},{38,76},{38,32},{66,32}},
                    color={255,0,255}),
                  Ellipse(
                    extent={{-71,7},{-85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
Block that delays a signal when it becomes <code>true</code>.
</p>
<p>
A rising edge of the Boolean input <code>u</code> gives a delayed output.
A falling edge of the input is immediately given to the output. If
<code>delayOnInit = true</code>, then a <code>true</code> input signal
at the start time is also delayed, otherwise the input signal is
produced immediately at the output.
</p>
<p>
Simulation results of a typical example with a delay time of <i>0.1</i> second
is shown below.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueDelay1.png\"
     alt=\"OnDelay1.png\" />
<br/>
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueDelay2.png\"
     alt=\"OnDelay2.png\" />
</p>

</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
February 11, 2019, by Milica Grahovac:<br/>
Added boolean input to enable delay of an initial true input.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end TrueDelay;

          block TrueFalseHold
            "Block that holds an output signal for at least a specified duration"
            parameter Real trueHoldDuration(
              final quantity="Time",
              final unit="s")
              "true hold duration";
            parameter Real falseHoldDuration(
              final quantity="Time",
              final unit="s")=trueHoldDuration
              "false hold duration";
            Interfaces.BooleanInput u
              "Boolean input signal"
              annotation (Placement(transformation(extent={{-220,-20},{-180,20}}),iconTransformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Boolean output signal"
              annotation (Placement(transformation(extent={{160,-20},{200,20}}),iconTransformation(extent={{100,-20},{140,20}})));

        protected
            Buildings.Controls.OBC.CDL.Logical.TrueDelay onDel1(
              delayTime=falseHoldDuration)
              "Output true when timer elapsed the required time"
              annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
            Buildings.Controls.OBC.CDL.Logical.TrueDelay onDel2(
              delayTime=trueHoldDuration)
              "Output true when timer elapsed the required time"
              annotation (Placement(transformation(extent={{20,-70},{40,-50}})));
            inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
              "Root of state graph"
              annotation (Placement(transformation(extent={{-160,100},{-140,120}})));
            Modelica.StateGraph.StepWithSignal outputFalse(
              nIn=2)
              "State for which the block outputs false"
              annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
            Modelica.StateGraph.TransitionWithSignal toTrue
              "Transition to true"
              annotation (Placement(transformation(extent={{-30,10},{-10,30}})));
            CDL.Logical.Not notU
              "Negation of input"
              annotation (Placement(transformation(extent={{-140,60},{-120,80}})));
            Modelica.StateGraph.StepWithSignal outputTrue(
              nIn=2)
              "State with true output signal"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            Modelica.StateGraph.TransitionWithSignal toFalse
              "Transition to false"
              annotation (Placement(transformation(extent={{30,10},{50,30}})));
            CDL.Logical.And and2
              "Check for input and elapsed timer"
              annotation (Placement(transformation(extent={{60,-70},{80,-50}})));
            CDL.Logical.And and1
              "Check for input and elapsed timer"
              annotation (Placement(transformation(extent={{-50,-40},{-30,-20}})));
            Modelica.StateGraph.InitialStep initialStep(
              nIn=0,
              nOut=2)
              "Initial state"
              annotation (Placement(transformation(extent={{-120,100},{-100,120}})));
            Modelica.StateGraph.TransitionWithSignal toTrue1
              "Transition to true"
              annotation (Placement(transformation(extent={{-70,102},{-50,122}})));
            Modelica.StateGraph.TransitionWithSignal toFalse1
              "Transition to false"
              annotation (Placement(transformation(extent={{-90,80},{-70,100}})));

          equation
            connect(outputTrue.outPort[1],toFalse.inPort)
              annotation (Line(points={{20.5,20},{28,20},{36,20}},color={0,0,0}));
            connect(outputTrue.active,y)
              annotation (Line(points={{10,9},{10,0},{180,0}},color={255,0,255}));
            connect(outputFalse.outPort[1],toTrue.inPort)
              annotation (Line(points={{-39.5,20},{-32,20},{-24,20}},color={0,0,0}));
            connect(toFalse.outPort,outputFalse.inPort[1])
              annotation (Line(points={{41.5,20},{60,20},{60,40},{-70,40},{-70,20.5},{-61,20.5}},color={0,0,0}));
            connect(outputTrue.active,onDel2.u)
              annotation (Line(points={{10,9},{10,0},{10,-60},{18,-60}},color={255,0,255}));
            connect(notU.y,and2.u2)
              annotation (Line(points={{-118,70},{140,70},{140,-80},{48,-80},{48,-68},{58,-68}},color={255,0,255}));
            connect(and2.y,toFalse.condition)
              annotation (Line(points={{82,-60},{100,-60},{100,-20},{40,-20},{40,8}},color={255,0,255}));
            connect(outputFalse.active,onDel1.u)
              annotation (Line(points={{-50,9},{-50,0},{-140,0},{-140,-30},{-102,-30}},color={255,0,255}));
            connect(u,and1.u2)
              annotation (Line(points={{-200,0},{-160,0},{-160,-50},{-60,-50},{-60,-38},{-52,-38},{-52,-38}},color={255,0,255}));
            connect(and1.y,toTrue.condition)
              annotation (Line(points={{-28,-30},{-20,-30},{-20,8}},color={255,0,255}));
            connect(u,toTrue1.condition)
              annotation (Line(points={{-200,0},{-160,0},{-160,52},{-60,52},{-60,100}},color={255,0,255}));
            connect(toTrue1.outPort,outputTrue.inPort[1])
              annotation (Line(points={{-58.5,112},{-10,112},{-10,20.5},{-1,20.5}},color={0,0,0}));
            connect(toTrue.outPort,outputTrue.inPort[2])
              annotation (Line(points={{-18.5,20},{-1,20},{-1,19.5}},color={0,0,0}));
            connect(toFalse1.outPort,outputFalse.inPort[2])
              annotation (Line(points={{-78.5,90},{-72,90},{-72,44},{-72,20},{-61,20},{-61,19.5}},color={0,0,0}));
            connect(initialStep.outPort[1],toTrue1.inPort)
              annotation (Line(points={{-99.5,110.25},{-90,110.25},{-90,110},{-90,112},{-64,112}},color={0,0,0}));
            connect(initialStep.outPort[2],toFalse1.inPort)
              annotation (Line(points={{-99.5,109.75},{-94,109.75},{-94,110},{-90,110},{-90,90},{-84,90}},color={0,0,0}));
            connect(notU.u,u)
              annotation (Line(points={{-142,70},{-160,70},{-160,0},{-200,0}},color={255,0,255}));
            connect(notU.y,toFalse1.condition)
              annotation (Line(points={{-118,70},{-80,70},{-80,78}},color={255,0,255}));
            connect(onDel1.y,and1.u1)
              annotation (Line(points={{-78,-30},{-52,-30}},color={255,0,255}));
            connect(onDel2.y,and2.u1)
              annotation (Line(points={{42,-60},{42,-60},{58,-60}},color={255,0,255}));
            annotation (
              defaultComponentName="truFalHol",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised,
                    lineColor={0,0,0}),
                  Line(
                    points={{-84,10},{-50,10},{-50,54},{-18,54},{-18,10},{-18,10}},
                    color={255,0,255}),
                  Line(
                    points={{-78,-46},{-48,-46},{-48,-2},{-24,-2},{-24,-46},{-24,-46}}),
                  Line(
                    points={{-24,-46},{6,-46},{6,-2},{44,-2},{44,-46},{74,-46}}),
                  Line(
                    points={{-18,10},{14,10},{14,54},{46,54},{46,10},{66,10}},
                    color={255,0,255}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-88,-62},{92,-90}},
                    lineColor={0,0,255},
                    textString="%falseHoldDuration"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-83,7},{-69,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-90,96},{96,68}},
                    lineColor={0,0,255},
                    textString="%trueHoldDuration")}),
              Diagram(
                coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-180,-120},{160,140}})),
              Documentation(
                info="<html>
<p>
Block that holds a <code>true</code> or <code>false</code> signal for at least a defined time period.
</p>
<p>
Whenever the input <code>u</code> switches, the output <code>y</code>
switches and remains at that value for at least <code>duration</code>
seconds, where <code>duration</code> is a parameter.
After <code>duration</code> elapsed, the output will be
<code>y = u</code>.
If this change required changing the value of <code>y</code>,
then <code>y</code> will remain at that value for at least <code>duration</code>.
Otherwise, <code>y</code> will change immediately whenever <code>u</code>
changes.
</p>
<p>
This block could for example be used to disable an economizer,
and not re-enable it for <i>10</i> minutes, and vice versa.
</p>
<p>
The image below shows the implementation with a state graph in which
each transition is only triggered when the input has the corresponding value,
and the current state has been active for at least <code>duration</code> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueFalseHoldImplementation.png\"
alt=\"Input and output of the block\"/>
</p>

<p>
Simulation results of a typical example with <code>duration = 1000</code> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueFalseHold.png\"
alt=\"Input and output of the block\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
September 18, 2017, by Michael Wetter:<br/>
Improved event handling.
</li>
<li>
July 14, 2017, by Michael Wetter:<br/>
Corrected model to set output equal to input during initialization.
</li>
<li>
June 13, 2017, by Michael Wetter:<br/>
Reimplemented model using a state graph to avoid having to test for equality within tolerance,
and to correct a bug.
This implementation is also easier to understand.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/789\">issue 789</a>.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
          end TrueFalseHold;

          block TrueHoldWithReset
            "Block that holds a true signal for at least a requested duration"
            parameter Real duration(
              final quantity="Time",
              final unit="s")
              "Time duration of the true output signal hold";
            Interfaces.BooleanInput u
              "Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y
              "Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
              "Root of state graph"
              annotation (Placement(transformation(extent={{70,68},{90,88}})));
            Buildings.Controls.OBC.CDL.Logical.TrueDelay onDelay(
              final delayTime=duration)
              "Delay for the on signal"
              annotation (Placement(transformation(extent={{10,10},{30,30}})));
            Modelica.StateGraph.InitialStep initialStep
              "Initial step"
              annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
            Modelica.StateGraph.StepWithSignal outputTrue
              "Holds the output at true"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            Modelica.StateGraph.TransitionWithSignal toOutputTrue
              "Transition that activates sending a true output signal"
              annotation (Placement(transformation(extent={{-50,50},{-30,70}})));
            Modelica.StateGraph.TransitionWithSignal toInitial
              "Transition that activates the initial state"
              annotation (Placement(transformation(extent={{30,50},{50,70}})));

          equation
            connect(initialStep.outPort[1],toOutputTrue.inPort)
              annotation (Line(points={{-59.5,60},{-44,60}},color={0,0,0}));
            connect(outputTrue.active,y)
              annotation (Line(points={{0,49},{0,0},{120,0}},color={255,0,255}));
            connect(toOutputTrue.condition,u)
              annotation (Line(points={{-40,48},{-40,0},{-120,0}},color={255,0,255}));
            connect(toInitial.outPort,initialStep.inPort[1])
              annotation (Line(points={{41.5,60},{52,60},{52,86},{-90,86},{-90,60},{-81,60}},color={0,0,0}));
            connect(outputTrue.active,onDelay.u)
              annotation (Line(points={{0,49},{0,20},{8,20}},color={255,0,255}));
            connect(toOutputTrue.outPort,outputTrue.inPort[1])
              annotation (Line(points={{-38.5,60},{-11,60}},color={0,0,0}));
            connect(outputTrue.outPort[1],toInitial.inPort)
              annotation (Line(points={{10.5,60},{36,60}},color={0,0,0}));
            connect(onDelay.y,toInitial.condition)
              annotation (Line(points={{32,20},{40,20},{40,48}},color={255,0,255}));
            annotation (
              defaultComponentName="truHol",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Line(
                    points={{-72,18},{-48,18},{-48,62},{52,62},{52,18},{80,18}},
                    color={255,0,255}),
                  Line(
                    points={{-68,-46},{-48,-46},{-48,-2},{22,-2},{22,-46},{78,-46}}),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,-62},{96,-90}},
                    lineColor={0,0,255},
                    textString="%duration"),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if y then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-83,7},{-69,-7}},
                    lineColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillColor=DynamicSelect({235,235,235},
                      if u then
                        {0,255,0}
                      else
                        {235,235,235}),
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that holds a <code>true</code> input signal for at least a defined time period.
</p>
<p>
At initialization, the output <code>y</code> is equal to the input <code>u</code>.
If the input <code>u</code> becomes <code>true</code>, or is <code>true</code>
during intialization, a timer starts
and the Boolean output <code>y</code> stays <code>true</code> for the time
period provided by the parameter <code>duration</code>.
When this time is elapsed, the input is checked again. If
it is <code>true</code>, then the timer is restarted and the output remains
<code>true</code> for another <code>duration</code> seconds.
If the input <code>u</code> is <code>false</code> after
<code>holdTime</code> seconds, then the ouput is switched to <code>false</code>,
until the input becomes <code>true</code> again.
</p>
<p>
The figure below shows the state chart of the implementation. Note that the
transition are done in zero time.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithResetImplementation.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The figure below shows an example with a hold time of <i>3600</i> seconds
and a pulse width period <i>9000</i> seconds that starts at <i>t=200</i> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset.png\"
alt=\"Input and output of the block\"/>
</p>

<p>
The figure below shows an example with a hold time of <i>60</i> seconds
and a pulse width period <i>3600</i> seconds that starts at <i>t=0</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset1.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The next two figures show the same experiment, except that the input <code>u</code>
has been negated. The figure below has again a hold time of <i>3600</i> seconds
and a pulse width period <i>9000</i> seconds that starts at <i>t=200</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset2.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The figure below has again a hold time of <i>60</i> seconds
and a pulse width period <i>3600</i> seconds that starts at <i>t=0</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset3.png\"
alt=\"Input and output of the block\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
November 12, 2020, by Michael Wetter:<br/>
Reformulated to remove dependency to <code>Modelica.SIunits</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2243\">issue 2243</a>.
</li>
<li>
September 18, 2017, by Michael Wetter:<br/>
Improved event handling.
</li>
<li>
June 13, 2017, by Michael Wetter:<br/>
Reimplemented model using a state graph to avoid having to test for equality within tolerance.
This implementation is also easier to understand.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/789\">issue 789</a>.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
          end TrueHoldWithReset;

          package Sources "Package with blocks that generate source signals"

            block Constant
              "Output constant signal of type Boolean"
              parameter Boolean k
                "Constant output value";
              Interfaces.BooleanOutput y
                "Connector of Boolean output signal"
                annotation (Placement(transformation(extent={{100,-20},{140,20}})));

            equation
              y=k;
              annotation (
                defaultComponentName="con",
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}),
                  graphics={
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255}),
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      fillColor={210,210,210},
                      lineThickness=5.0,
                      fillPattern=FillPattern.Solid,
                      borderPattern=BorderPattern.Raised),
                    Ellipse(
                      extent={{71,7},{85,-7}},
                      lineColor=DynamicSelect({235,235,235},
                        if y then
                          {0,255,0}
                        else
                          {235,235,235}),
                      fillColor=DynamicSelect({235,235,235},
                        if y then
                          {0,255,0}
                        else
                          {235,235,235}),
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-90,-70},{72,-70}},
                      color={255,0,255}),
                    Polygon(
                      points={{90,-70},{68,-62},{68,-78},{90,-70}},
                      lineColor={255,0,255},
                      fillColor={255,0,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-80,88},{-88,66},{-72,66},{-80,88}},
                      lineColor={255,0,255},
                      fillColor={255,0,255},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-80,66},{-80,-82}},
                      color={255,0,255}),
                    Line(
                      points={{-80,0},{64,0}}),
                    Text(
                      extent={{-150,-140},{150,-110}},
                      lineColor={0,0,0},
                      textString="%k")}),
                Documentation(
                  info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a Boolean-valued parameter.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>"));
            end Constant;
            annotation (
              Documentation(
                info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),    Icon(
                graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={23.3333,0.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                  Rectangle(
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-70,-4.5},{0,4.5}})}));
          end Sources;
          annotation (
            Documentation(
              info="<html>
<p>
Package with blocks for elementary mathematical functions
for boolean variables.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Line(
                  points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
                  color={255,0,255})}));
        end Logical;

        package Routing "Package with blocks that combine and extract signals"

          block BooleanScalarReplicator
            "Boolean signal replicator"
            parameter Integer nout=1
              "Number of outputs";
            Interfaces.BooleanInput u
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y[nout]
              "Connector of Boolean output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=fill(
              u,
              nout);
            annotation (
              defaultComponentName="booScaRep",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,0},{-6,0}},
                    color={255,0,255}),
                  Line(
                    points={{100,0},{10,0}},
                    color={255,0,255}),
                  Line(
                    points={{0,0},{100,10}},
                    color={255,0,255}),
                  Line(
                    points={{0,0},{100,-10}},
                    color={255,0,255}),
                  Ellipse(
                    extent={{-14,16},{16,-14}},
                    lineColor={0,0,0},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
This block replicates the Boolean input signal to an array of <code>nout</code>
identical Boolean output signals.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 27, 2021, by Baptiste Ravache:<br/>
Renamed to <code>BooleanScalarReplicator</code>.
</li>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end BooleanScalarReplicator;

          block BooleanVectorFilter
            "Filter a boolean vector based on a boolean mask"
            parameter Integer nin "Size of input vector";
            parameter Integer nout "Size of output vector";
            parameter Boolean msk[nin]=fill(true,nin) "Array mask";

            Interfaces.BooleanInput u[nin]
              "Connector of Boolean input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.BooleanOutput y[nout]
              "Connector of Boolean output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Integer mskId[nout] = Modelica.Math.BooleanVectors.index(msk)
              "Indices of included element in input vector";

          initial equation
            assert(nout==sum({if msk[i] then 1 else 0 for i in 1:nin}),
              "In " + getInstanceName() + ": The size of the output vector does not
    match the size of included elements in the mask.");
          equation
            y = u[mskId];
            annotation (
              defaultComponentName="booVecFil",
              Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-102,0},{-60,0}}, color={255,0,255}),
                  Line(points={{70,0},{100,0}}, color={255,0,255}),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Polygon(
                    points={{-60,80},{-60,-80},{20,-10},{60,-10},{80,10},{20,10},{-60,80}},
                    lineColor={0,0,0},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid,
                    lineThickness=0.5)}),                                  Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
June 22, 2021, by Baptiste Ravache:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<p>
This block filters a Boolean vector of size <code>nin</code> to
a vector of size <code>nout</code> given a Boolean mask
<code>msk</code>.
</p>
<p>
If an entry in <code>msk</code> is <code>true</code>, then the value
of this input will be sent to the output <code>y</code>, otherwise it
will be discarded.
</p>
<p>
The parameter <code>msk</code> must have exactly <code>nout</code> entries
set to <code>true</code>, otherwise an error message is issued.
</p>
</html>"));
          end BooleanVectorFilter;

          block IntegerScalarReplicator
            "Integer signal replicator"
            parameter Integer nout=1
              "Number of outputs";
            Interfaces.IntegerInput u
              "Connector of Integer input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.IntegerOutput y[nout]
              "Connector of Integer output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=fill(
              u,
              nout);
            annotation (
              defaultComponentName="intScaRep",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,0},{-6,0}},
                    color={255,127,0}),
                  Line(
                    points={{100,0},{10,0}},
                    color={255,127,0}),
                  Line(
                    points={{0,0},{100,10}},
                    color={255,127,0}),
                  Line(
                    points={{0,0},{100,-10}},
                    color={255,127,0}),
                  Ellipse(
                    extent={{-14,16},{16,-14}},
                    lineColor={0,0,0},
                    fillColor={255,127,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
This block replicates the Integer input signal to an array of <code>nout</code>
identical Integer output signals.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 27, 2021, by Baptiste Ravache:<br/>
Renamed to <code>IntegerScalarReplicator</code>.
</li>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end IntegerScalarReplicator;

          block RealScalarReplicator
            "Real signal replicator"
            parameter Integer nout=1
              "Number of outputs";
            Interfaces.RealInput u
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y[nout]
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y=fill(
              u,
              nout);
            annotation (
              defaultComponentName="reaScaRep",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,0},{-6,0}},
                    color={0,0,127}),
                  Line(
                    points={{100,0},{10,0}},
                    color={0,0,127}),
                  Line(
                    points={{0,0},{100,10}},
                    color={0,0,127}),
                  Line(
                    points={{0,0},{100,-10}},
                    color={0,0,127}),
                  Ellipse(
                    extent={{-14,16},{16,-14}},
                    lineColor={0,0,0},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
              Documentation(
                info="<html>
<p>
This block replicates the Real input signal to an array of <code>nout</code>
identical Real output signals.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 27, 2021, by Baptiste Ravache:<br/>
Renamed to <code>RealScalarReplicator</code>.
</li>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end RealScalarReplicator;

          block RealVectorFilter
            "Filter a real vector of based on a boolean mask"
            parameter Integer nin "Size of input vector";
            parameter Integer nout "Size of output vector";
            parameter Boolean msk[nin]=fill(true,nin) "Array mask";

            Interfaces.RealInput u[nin]
              "Connector of Real input signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Interfaces.RealOutput y[nout]
              "Connector of Real output signals"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
            parameter Integer mskId[nout] = Modelica.Math.BooleanVectors.index(msk)
              "Indices of included element in input vector";

          initial equation
            assert(nout==sum({if msk[i] then 1 else 0 for i in 1:nin}),
              "The size of the output vector does not match the
    size of included elements in the mask.");
          equation
            y = u[mskId];
            annotation (
              defaultComponentName="reaVecFil",
              Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Polygon(
                    points={{-60,80},{-60,-80},{20,-10},{60,-10},{80,10},{20,10},{-60,80}},
                    lineColor={0,0,0},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineThickness=0.5),
                  Line(points={{-100,0},{-60,0}}, color={0,0,127}),
                  Line(points={{70,0},{100,0}}, color={0,0,127})}),
              Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
June 22, 2021, by Baptiste Ravache:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<p>
This block filters a Real vector of size <code>nin</code> to
a vector of size <code>nout</code> given a boolean mask
<code>msk</code>.
</p>
<p>
If an entry in <code>msk</code> is <code>true</code>, then the value
of this input will be sent to the output <code>y</code>, otherwise it
will be discarded.
</p>
<p>
The parameter <code>msk</code> must have exactly <code>nout</code> entries
set to <code>true</code>, otherwise an error message is issued.
</p>
</html>"));
          end RealVectorFilter;
          annotation (
            Documentation(
              info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Line(
                  points={{-90,0},{4,0}},
                  color={95,95,95}),
                Line(
                  points={{88,65},{48,65},{-8,0}},
                  color={95,95,95}),
                Line(
                  points={{-8,0},{93,0}},
                  color={95,95,95}),
                Line(
                  points={{87,-65},{48,-65},{-8,0}},
                  color={95,95,95})}));
        end Routing;

        package Utilities "Package with utility functions"

          block Assert
            "Print a warning message when input becomes false"
            parameter String message
              "Message written when u becomes false";
            Buildings.Controls.OBC.CDL.Interfaces.BooleanInput u
              "Boolean input that triggers assert when it becomes false"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          equation
            assert(
              u,
              message,
              AssertionLevel.warning);
            annotation (
              defaultComponentName="assMes",
              Icon(
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{0,80},{-80,-60},{80,-60},{0,80}},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Text(
                    extent={{-100,160},{100,106}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Polygon(
                    points={{0,72},{-72,-56},{72,-56},{0,72}},
                    lineColor={0,0,0},
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-4,38},{2,-24}},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Ellipse(
                    extent={{-6,-32},{4,-42}},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid)}),
              Documentation(
                info="<html>
<p>
Block that writes a warning if the input becomes <code>false</code>.
</p>
<p>
Tools or control systems are expected to write <code>message</code> together
with a time stamp to an output device and/or a log file.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 6, 2017, by Michael Wetter:<br/>
Simplified implementation.
</li>
<li>
November 3, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Assert;
          annotation (
            preferredView="info",
            Documentation(
              info="<html>
<p>
This package contains utility models
that are used throughout the library.
</p>
</html>"),  Icon(
              coordinateSystem(
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={1.3835,-4.1418},
                  rotation=45.0,
                  fillColor={64,64,64},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
                Polygon(
                  origin={10.1018,5.218},
                  rotation=-45.0,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
        end Utilities;

        package Types "Package with type definitions"

          type SimpleController = enumeration(
            P
            "P controller",
            PI
            "PI controller",
            PD
            "PD controller",
            PID
            "PID controller")
            "Enumeration defining P, PI, PD, or PID simple controller type"
            annotation (Evaluate=true,Documentation(info="<html>
<p>
Enumeration to define the type of the controller.
Possible values are:
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>P</code></td>
<td>
Controller with proportional term.
</td></tr>
<tr><td><code>PI</code></td>
<td>
Controller with proportional and integral terms.
</td></tr>
<tr><td><code>PD</code></td>
<td>
Controller with proportional and derivative term.
</td></tr>
<tr><td><code>PID</code></td>
<td>
Controller with proportional, integral and derivative terms.
</td></tr>
</table>
</html>",          revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
          annotation (
            Documentation(
              info="<html>
<p>
This package contains type definitions.
</p>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={-12.167,-23},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},{14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,-30},{4.167,20},{12.167,65}},
                  smooth=Smooth.Bezier,
                  lineColor={0,0,0}),
                Polygon(
                  origin={2.7403,1.6673},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
                  smooth=Smooth.Bezier)}));
        end Types;

        package Interfaces
        "Package with connectors for input and output signals"

          connector BooleanInput=input Boolean
            "'input Boolean' as connector"
          annotation (defaultComponentName="u",
           Icon(graphics={Polygon(lineColor={255,0,255},
                                  fillColor={255,0,255},
                                  fillPattern = FillPattern.Solid,
                                  points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(extent={{-100,-100},{100,100}},
                                 preserveAspectRatio=true,
                                 initialScale=0.2)),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{0,50},{100,0},{0,-50},{0,50}},
                                     lineColor={255,0,255},
                                     fillColor={255,0,255},fillPattern = FillPattern.Solid),
                             Text(extent={{-10,85},{-10,60}},
                                  lineColor={255,0,255},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>",          revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector BooleanOutput=output Boolean
            "'output Boolean' as connector"
          annotation (defaultComponentName="y",
           Icon(coordinateSystem(preserveAspectRatio=true,
                                 initialScale=0.2,
                                 extent={{-100,-100},{100,100}}),
                graphics={Polygon(lineColor={255,0,255},
                                  fillColor={255,255,255},
                                  fillPattern= FillPattern.Solid,
                                  points={{-100,50},{0,0},{-100,-50}})}),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{-100,50},{0,0},{-100,-50},{-100,50}},
                                     lineColor={255,0,255},
                                     fillColor={255,255,255},
                                     fillPattern= FillPattern.Solid),
                             Text(extent={{30,110},{30,60}},
                                  lineColor={255,0,255},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>",          revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector IntegerInput=input Integer
            "'input Integer' as connector"
          annotation (defaultComponentName="u",
           Icon(graphics={Polygon(lineColor={255,127,0},
                                  fillColor={255,127,0},
                                  fillPattern=FillPattern.Solid,
                                  points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(extent={{-100,-100},{100,100}},
                                 preserveAspectRatio=true,
                                 initialScale=0.2)),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{0,50},{100,0},{0,-50},{0,50}},
                                     lineColor={255,127,0},
                                     fillColor={255,127,0},
                                     fillPattern=FillPattern.Solid),
                             Text(extent={{-10,85},{-10,60}},
                                  lineColor={255,127,0},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>",          revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector IntegerOutput=output Integer
            "'output Integer' as connector"
          annotation (defaultComponentName="y",
           Icon(coordinateSystem(preserveAspectRatio=true,
                                 initialScale=0.2,
                                 extent={{-100,-100},{100,100}}),
                graphics={Polygon(lineColor={255,127,0},
                                  fillColor={255,255,255},
                                  fillPattern=FillPattern.Solid,
                                  points={{-100,50},{0,0},{-100,-50}})}),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100,-100},{100,100}}),
                   graphics={Polygon(points={{-100,50},{0,0},{-100,-50},{-100,50}},
                                     lineColor={255,127,0},
                                     fillColor={255,255,255},
                                     fillPattern=FillPattern.Solid),
                             Text(extent={{30,110},{30,60}},
                                  lineColor={255,127,0},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>",          revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector RealInput=input Real
            "'input Real' as connector"
          annotation (defaultComponentName="u",
           Icon(graphics={Polygon(lineColor={0,0,127},
                                  fillColor={0,0,127},
                                  fillPattern=FillPattern.Solid,
                                  points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
                                 preserveAspectRatio=true,
                                 initialScale=0.2)),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100.0,-100.0},{100.0,100.0}}),
                   graphics={Polygon(lineColor={0,0,127},
                                     fillColor={0,0,127},
                                     fillPattern=FillPattern.Solid,
                                     points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
                             Text(lineColor={0,0,127},
                                  extent={{-10.0,60.0},{-10.0,85.0}},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>",          revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));

          connector RealOutput=output Real
            "'output Real' as connector"
          annotation (defaultComponentName="y",
           Icon(coordinateSystem(preserveAspectRatio=true,
                                 initialScale=0.2,
                                 extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={Polygon(lineColor={0,0,127},
                                  fillColor={255,255,255},
                                  fillPattern=FillPattern.Solid,
                                  points={{-100,50},{0,0},{-100,-50}})}),
           Diagram(coordinateSystem(preserveAspectRatio=true,
                                    initialScale=0.2,
                                    extent={{-100.0,-100.0},{100.0,100.0}}),
                   graphics={Polygon(lineColor={0,0,127},
                                     fillColor={255,255,255},
                                     fillPattern=FillPattern.Solid,
                                     points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
                             Text(lineColor={0,0,127},
                                  extent={{30.0,60.0},{30.0,110.0}},
                                  textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>",          revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          annotation (
            preferredView="info",
            Documentation(
              info="<html>
<p>
This package contains implementations of connectors for input
and output signals of blocks.
</p>
<p>
The connectors are compatible with, and equivalent to,
the connectors from the Modelica Standard Library.
They are here implemented to make the <code>CDL</code>
package a self-contained package.
</p>
</html>"),  Icon(
              graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={20.0,0.0},
                  lineColor={64,64,64},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
                Polygon(
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}));
        end Interfaces;
        annotation (
          Documentation(
            info="<html>
<p>
Package that has elementary input-output blocks
that form the Control Description Language (CDL).
The implementation is structured into sub-packages.
The packages <code>Validation</code> and <code>Examples</code>
contain validation and example models.
These are not part of the CDL specification, but rather
implemented to provide reference responses computed by the CDL blocks.
For a specification of CDL, see
<a href=\"http://obc.lbl.gov/specification/cdl.html\">
http://obc.lbl.gov/specification/cdl.html</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),Icon(
            graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Ellipse(
                origin={10.0,10.0},
                fillColor={76,76,76},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-80.0,-80.0},{-20.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,-80.0},{60.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,0.0},{60.0,60.0}}),
              Ellipse(
                origin={10.0,10.0},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-80.0,0.0},{-20.0,60.0}})}));
      end CDL;
    annotation (
    Documentation(info="<html>
<p>
Package that contains a library of elementary control blocks
and a library that implements control sequences from the ASHRAE Guideline 36.
</p>
<p>
These implementations have been developed
through the OpenBuildingControl (<a href=\"https://obc.lbl.gov\">obc.lbl.gov</a>) project
that develops a process and tools for the
performance evaluation, specification and verification
of building control sequences.
</p>
<p>
For a tutorial for how to implement control sequences using the
Control Description Language (CDL), see
<a href=\"modelica://Buildings.Examples.Tutorial.CDL\">
Buildings.Examples.Tutorial.CDL</a>.
</p>
</html>"),
    Icon(graphics={Bitmap(extent={{-92,-98},{104,96}},
    fileName="modelica://Buildings/Resources/Images/Controls/OBC/OBC_logo-only_150dpi.png")}));
    end OBC;

    package SetPoints "Package with models for control set points"
      extends Modelica.Icons.VariantsPackage;

      block OccupancySchedule "Occupancy schedule with look-ahead"
        extends Modelica.Blocks.Icons.Block;

        parameter Real occupancy[:]=3600*{7, 19}
          "Occupancy table, each entry switching occupancy on or off";
        parameter Boolean firstEntryOccupied = true
          "Set to true if first entry in occupancy denotes a changed from unoccupied to occupied";
        parameter Modelica.SIunits.Time period =   86400 "End time of periodicity";

        Modelica.Blocks.Interfaces.RealOutput tNexNonOcc
          "Time until next non-occupancy"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealOutput tNexOcc "Time until next occupancy"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Blocks.Interfaces.BooleanOutput occupied
          "Outputs true if occupied at current time"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
        final parameter Integer nRow = size(occupancy,1)
          "Number of rows in the schedule";

        discrete Modelica.SIunits.Time tOcc "Time when next occupancy starts";
        discrete Modelica.SIunits.Time tNonOcc "Time when next non-occupancy starts";
        discrete Modelica.SIunits.Time tNext "Time of next switch in schedule";

        function getOutput "Get the next occupancy or non-occupancy outputs"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.Time t "Current model time";
          input Modelica.SIunits.Time period "Periodicity";
          input Real occupancy[nRow]
            "Occupancy table, each entry switching occupancy on or off";
          input Boolean firstEntryOccupied
            "Set to true if first entry in occupancy denotes a changed from unoccupied to occupied";
          input Integer nRow
            "Number of rows in the schedule";

          output Modelica.SIunits.Time tOcc "Time when next occupancy starts";
          output Modelica.SIunits.Time tNonOcc "Time when next non-occupancy starts";
          output Boolean occupied
          "Outputs true if occupied at current time";
          output Modelica.SIunits.Time tNext "Time of next switch in schedule";

      protected
          Integer iPerSta
            "Counter for the period in which the next occupancy starts";
          Integer iPerSto
            "Counter for the period in which the next occupancy stops";
          Integer nexStaInd "Next index when occupancy starts";
          Integer nexStoInd "Next index when occupancy stops";
        algorithm
          // Initialize variables
          iPerSta := integer(t/period);
          iPerSto := iPerSta;

          // First, assume that the first entry is occupied
          nexStaInd := 1;
          nexStoInd := 2;
          // nRow is an even number
          for
           i in 1:2:nRow-1 loop
         if t >= occupancy[i] + iPerSta*period then
           nexStaInd := i+2;
         end if;
          end for;
          for
           i in 2:2:nRow loop
         if t >= occupancy[i] + iPerSto*period then
           nexStoInd := i+2;
         end if;
          end for;
          if nexStaInd > nRow then
          nexStaInd := 1;
          iPerSta :=iPerSta + 1;
          end if;
          if nexStoInd > nRow then
          nexStoInd := 2;
          iPerSto :=iPerSto + 1;
          end if;
          tOcc := occupancy[nexStaInd] + iPerSta*period;
          tNonOcc := occupancy[nexStoInd] + iPerSto*period;

          occupied := tNonOcc < tOcc;
          // Now, correct if the first entry is vaccant instead of occupied
          if not firstEntryOccupied then
           (nexStaInd, nexStoInd) := switchInteger(nexStaInd, nexStoInd);
           (iPerSta, iPerSto)     := switchInteger(iPerSta,   iPerSto);
           (tOcc, tNonOcc)        := switchReal(tOcc,      tNonOcc);
         occupied := not occupied;
          end if;

         tNext :=min(tOcc, tNonOcc);
        end getOutput;

      encapsulated function switchInteger "Switch two Integer arguments"
        import Modelica;
        extends Modelica.Icons.Function;
        input Integer x1 "First argument";
        input Integer x2 "Second argument";
        output Integer y1 "Output = x2";
        output Integer y2 "Output = x1";
      algorithm
        y1:=x2;
        y2:=x1;
      end switchInteger;

      encapsulated function switchReal "Switch two Real arguments"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real x1 "First argument";
        input Real x2 "Second argument";
        output Real y1 "Output = x2";
        output Real y2 "Output = x1";
      algorithm
        y1:=x2;
        y2:=x1;
      end switchReal;


      initial equation
        // Check parameters for correctness
       assert(mod(nRow, 2) < 0.1,
         "The parameter \"occupancy\" must have an even number of elements.\n");
       assert(0 <= occupancy[1],
         "The first element of \"occupancy\" must be bigger than or equal to zero."
         + "\n   Received occupancy[1] = " + String(occupancy[1]));
       assert(period >= occupancy[nRow],
         "The parameter \"period\" must be greater than or equal to the last element of \"occupancy\"."
         + "\n   Received period      = " + String(period)
         + "\n            occupancy[" + String(nRow) +
           "] = " + String(occupancy[nRow]));
        for i in 1:nRow-1 loop
          assert(occupancy[i] < occupancy[i+1],
            "The elements of the parameter \"occupancy\" must be strictly increasing.");
        end for;

        (tOcc, tNonOcc, occupied, tNext) = getOutput(t = time, period = period, occupancy= occupancy, firstEntryOccupied = firstEntryOccupied, nRow=nRow);

      equation
        when time >= pre(tNext) then
          (tOcc, tNonOcc, occupied, tNext) = getOutput(t = time, period = period, occupancy= occupancy, firstEntryOccupied = firstEntryOccupied, nRow=nRow);
        end when;

       tNexOcc    =  tOcc-time;
       tNexNonOcc =  tNonOcc-time;

        annotation (
          Icon(graphics={
              Line(
                points={{-62,-68},{-38,-20},{-14,-70}},
                color={0,0,255}),
              Line(
                points={{-38,-20},{-38,44}},
                color={0,0,255}),
              Ellipse(extent={{-54,74},{-22,44}}, lineColor={0,0,255}),
              Line(
                points={{-66,22},{-38,36}},
                color={0,0,255}),
              Line(
                points={{-38,36},{-6,20}},
                color={0,0,255}),
              Text(
                extent={{34,74},{90,50}},
                lineColor={0,0,255},
                textString="occupancy"),
              Text(
                extent={{32,16},{92,-16}},
                lineColor={0,0,255},
                textString="non-occupancy"),
              Text(
                extent={{34,-44},{94,-76}},
                lineColor={0,0,255},
                textString="occupied")}),
      defaultComponentName="occSch",
      Documentation(info="<html>
<p>
This model outputs whether the building is currently occupied,
and how long it will take until the next time when the building
will be occupied or non-occupied.
The latter may be used, for example, to start a ventilation system
half an hour before occupancy starts in order to ventilate the room.
</p>
<p>
The occupancy is defined by a time schedule of the form
</p>
<pre>
  occupancy = 3600*{7, 12, 14, 19}
</pre>
<p>
This indicates that the occupancy is from <i>7:00</i> until <i>12:00</i>
and from <i>14:00</i> to <i>19:00</i>. This will be repeated periodically.
The parameter <code>periodicity</code> defines the periodicity.
The period always starts at <i>t=0</i> seconds.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 25, 2021, by Michael Wetter:<br/>
Integrated changes from Buildings for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1454\">IBPSA, #1454</a>.
</li>
<li>
February 26, 2021, by Michael Wetter:<br/>
Refactored implementation to use a function to compute the next time events.<br/>
This is a work-around for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2369\">Buildings, issue 2369</a>.
</li>
<li>
October 30, 2017, by Michael Wetter:<br/>
Rewrote using <code>equation</code> rather than <code>algorithm</code>
and removed assertion.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/844\">issue 844</a>.
</li>
<li>
September 11, 2012, by Michael Wetter:<br/>
Added <code>pre</code> operator in <code>when</code> clause and relaxed
tolerance in <code>assert</code> statement.
</li>
<li>
July 26, 2012, by Michael Wetter:<br/>
Fixed a bug that caused an error in the schedule if the simulation start time was negative or equal to the first entry in the schedule.
</li>
<li>
February 16, 2012, by Michael Wetter:<br/>
Removed parameter <code>startTime</code>. It was removed because <code>startTime=0</code>
would imply that the schedule should not start for one day if the simulation were
to be started at <i>t=-8760</i> seconds.
Fixed bug that prevented schedule to start when the simulation was started at a time that
is higher than <code>endTime</code>.
Renamed parameter <code>endTime</code> to <code>period</code>.
</li>
<li>
April 2, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OccupancySchedule;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models to compute set points of control systems.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Continuous</a>.
</html>"));
    end SetPoints;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains component models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
  end Controls;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package Dampers "Package with air damper models"
        extends Modelica.Icons.VariantsPackage;

        model Exponential
          "Air damper with exponential opening characteristics"
          extends
          Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential;
        equation
          // Pressure drop calculation
          if linearized then
            m_flow*m_flow_nominal_pos = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                    actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                          dp=dp, k=k,
                          m_flow_turbulent=m_flow_turbulent),
                    simplified= m_flow_nominal_pos*dp/max(Modelica.Constants.eps, dp_nominal_pos));
              else
                dp=homotopy(
                    actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                          m_flow=m_flow, k=k,
                          m_flow_turbulent=m_flow_turbulent),
                    simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
                end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                          dp=dp, k=k, m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                          m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        annotation (
        defaultComponentName="damExp",
        Documentation(info="<html>
<p>
Model of two flow resistances in series:
</p>
<ul>
<li>
one resistance has a fixed flow coefficient;
</li>
<li>
the other resistance represents a damper whose flow coefficient is an
exponential function of the opening angle.
</li>
</ul>
<p>
The lumped flow coefficient <i>k(y)</i> (function of the fractional opening
<i>y</i>) is used to compute the mass flow rate versus pressure drop relation as:
</p>
<p style=\"font-style:italic;\">
  m&#775; = sign(&Delta;p) k(y)  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
<p>
For a description of the damper opening characteristics and typical
parameter values, see the partial model
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential\">
Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
April 12, 2021, by Michael Wetter:<br/>
Guarded against division by zero if the pressure equation is removed.
This then leads to a more meaningful error message.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1243\">IBPSA, #1243</a>.
</li>
<li>
December 23, 2019, by Antoine Gautier:<br/>
Added the pressure drop calculation as it is no longer in the base class.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1188\">IBPSA, #1188</a>.
</li>
<li>
March 22, 2017, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
April 14, 2014 by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Moved assignment of <code>kDam_default</code> and <code>kThetaSqRt_default</code>
from <code>initial algorithm</code> to the variable declaration, to avoid a division
by zero in OpenModelica.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
June 22, 2008 by Michael Wetter:<br/>
Extended range of control signal from 0 to 1 by implementing the function
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.exponentialDamper\">
Buildings.Fluid.Actuators.BaseClasses.exponentialDamper</a>.
</li>
<li>
June 10, 2008 by Michael Wetter:<br/>
Introduced new partial base class,
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential\">
PartialDamperExponential</a>.
</li>
<li>
June 30, 2007 by Michael Wetter:<br/>
Introduced new partial base class,
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialActuator\">PartialActuator</a>.
</li>
<li>
July 27, 2007 by Michael Wetter:<br/>
Introduced partial base class.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,22},{100,-24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),  Polygon(
                  points={{-26,12},{22,54},{22,42},{-26,0},{-26,12}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid), Polygon(
                  points={{-22,-32},{26,10},{26,-2},{-22,-44},{-22,-32}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid)}));
        end Exponential;

        model PressureIndependent
          "Model for an air damper whose mass flow is proportional to the input signal"
          extends
          Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential(
            final linearized=false,
            final casePreInd=true,
            from_dp=true);
          input Real phi = l + y_internal*(1 - l)
            "Ratio actual to nominal mass flow rate of damper, phi=kDam(y)/kDam(y=1)";
          parameter Real l2(unit="1", min=1e-10) = 0.01
            "Gain for mass flow increase if pressure is above nominal pressure"
            annotation(Dialog(tab="Advanced"));
          parameter Real deltax(unit="1", min=1E-5) = 0.02 "Transition interval for flow rate"
            annotation(Dialog(tab="Advanced"));
      protected
          constant Real y_min = 2E-2
            "Minimum value of control signal before zeroing of the opening";
          constant Integer sizeSupSplBnd = 5
            "Number of support points on each quadratic domain for spline interpolation";
          constant Integer sizeSupSpl = 2 * sizeSupSplBnd + 3
            "Total number of support points for spline interpolation";
          constant Real y2dd = 0
            "Second derivative at second support point";

          parameter Real[sizeSupSpl] ySupSpl_raw = cat(
            1,
            linspace(1, yU, sizeSupSplBnd),
            {yU-1/3*(yU-yL), (yU+yL)/2, yU-2/3*(yU-yL)},
            linspace(yL, 0, sizeSupSplBnd))
            "y values of unsorted support points for spline interpolation";
          parameter Real[sizeSupSpl] kSupSpl_raw = Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(
            y=ySupSpl_raw, a=a, b=b, cL=cL, cU=cU, yL=yL, yU=yU) .^ 2
            "k values of unsorted support points for spline interpolation";
          parameter Real[sizeSupSpl] ySupSpl(each fixed=false)
            "y values of sorted support points for spline interpolation";
          parameter Real[sizeSupSpl] kSupSpl(each fixed=false)
            "k values of sorted support points for spline interpolation";
          parameter Integer[sizeSupSpl] idx_sorted(each fixed=false)
            "Indices of sorted support points";
          parameter Real[sizeSupSpl] invSplDer(each fixed=false)
            "Derivatives at support points for spline interpolation";
          parameter Real coeff1 = l2/dpDamper_nominal*m_flow_nominal
            "Parameter for avoiding unnecessary computations";
          parameter Real coeff2 = 1/coeff1
            "Parameter for avoiding unnecessary computations";

          Real kSquInv
            "Square inverse of flow coefficient (damper plus fixed resistance)";
          Real kDamSquInv
            "Square inverse of flow coefficient (damper only)";

          Modelica.SIunits.MassFlowRate m_flow_set
            "Requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_min(displayUnit="Pa")
            "Minimum pressure difference required for delivering requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_x, dp_x1, dp_x2, dp_y2, dp_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_x, m_flow_x1, m_flow_x2, m_flow_y2, m_flow_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_smooth
            "Smooth interpolation result between two flow regimes";
          Modelica.SIunits.PressureDifference dp_smooth
            "Smooth interpolation result between two flow regimes";
          Real y_actual_smooth(final unit="1")
            "Fractional opening computed based on m_flow_smooth and dp";

        function basicFlowFunction_dp_m_flow
          "Inverse of flow function that computes that computes the square inverse of flow coefficient"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Modelica.SIunits.PressureDifference dp
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Modelica.SIunits.MassFlowRate m_flow_small
            "Minimum value of mass flow rate guarding against k=(0)/sqrt(dp)";
          input Modelica.SIunits.PressureDifference dp_small
            "Minimum value of pressure drop guarding against k=m_flow/(0)";
          output Real kSquInv
            "Square inverse of flow coefficient";
        protected
          Modelica.SIunits.PressureDifference dpPos=
            Buildings.Utilities.Math.Functions.smoothMax(dp, -dp, dp_small)
            "Regularized absolute value of pressure drop";
          Real mSqu_flow = Buildings.Utilities.Math.Functions.smoothMax(
            m_flow^2, m_flow_small^2, m_flow_small^2)
            "Regularized square value of mass flow rate";
        algorithm
          kSquInv := dpPos / mSqu_flow;
        annotation (smoothOrder=1);
        end basicFlowFunction_dp_m_flow;

        function exponentialDamper_inv
          "Inverse function of the exponential damper characteristics"
          extends Modelica.Icons.Function;
          input Real kTheta "Loss coefficient";
          input Real[:] kSupSpl "k values of support points";
          input Real[:] ySupSpl "y values of support points";
          input Real[:] invSplDer "Derivatives at support points";
          output Real y "Fractional opening";
        protected
          parameter Integer sizeSupSpl = size(kSupSpl, 1) "Number of spline support points";
          Integer i "Integer to select data interval";
        algorithm
          i := 1;
          for j in 2:sizeSupSpl loop
            if kTheta <= kSupSpl[j] then
              i := j;
              break;
            end if;
          end for;
          y := Buildings.Utilities.Math.Functions.smoothLimit(
            Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
              x=kTheta,
              x1=kSupSpl[i - 1],
              x2=kSupSpl[i],
              y1=ySupSpl[i - 1],
              y2=ySupSpl[i],
              y1d=invSplDer[i - 1],
              y2d=invSplDer[i]),
            0,
            1,
            1E-3);
        annotation (smoothOrder=1);
        end exponentialDamper_inv;

        initial equation
          (kSupSpl, idx_sorted) = Modelica.Math.Vectors.sort(kSupSpl_raw, ascending=true);
          // The sum below is a trick to avoid in OPTIMICA the warning
          // Variable array index in equation can result in slow simulation time.
          // This warning was issued for the formulation ySupSpl = ySupSpl_raw[idx_sorted];
          for i in 1:sizeSupSpl loop
            ySupSpl[i] = sum((if k == idx_sorted[i] then ySupSpl_raw[k] else 0) for k in 1:sizeSupSpl);
          end for;
          invSplDer = Buildings.Utilities.Math.Functions.splineDerivatives(x=kSupSpl_raw, y=ySupSpl_raw);
        equation
          // From TwoWayPressureIndependent valve model
          m_flow_set = m_flow_nominal*phi;
          dp_min = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                      m_flow=m_flow_set,
                      k=kTotMax,
                      m_flow_turbulent=m_flow_turbulent);

          if from_dp then
            m_flow_x=0;
            m_flow_x1=0;
            m_flow_x2=0;
            dp_y1=0;
            dp_y2=0;
            dp_smooth=0;

            dp_x = dp-dp_min;
            dp_x1 = -dp_x2;
            dp_x2 = deltax*dp_min;
            // min function ensures that m_flow_y1 does not increase further for dp_x > dp_x1
            m_flow_y1 = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                                          dp=min(dp, dp_min+dp_x1),
                                          k=kTotMax,
                                          m_flow_turbulent=m_flow_turbulent);
            // max function ensures that m_flow_y2 does not decrease further for dp_x < dp_x2
            m_flow_y2 = m_flow_set + coeff1*max(dp_x,dp_x2);

            m_flow_smooth = noEvent(smooth(2,
                if dp_x <= dp_x1
                then m_flow_y1
                elseif dp_x >=dp_x2
                then m_flow_y2
                else Buildings.Utilities.Math.Functions.quinticHermite(
                         x=dp_x,
                         x1=dp_x1,
                         x2=dp_x2,
                         y1=m_flow_y1,
                         y2=m_flow_y2,
                         y1d= Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(
                                             dp=dp_min + dp_x1,
                                             k=kTotMax,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1),
                         y2d=coeff1,
                         y1dd=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(
                                             dp=dp_min + dp_x1,
                                             k=kTotMax,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1,
                                             dp_der2=0),
                         y2dd=y2dd)));
          else
            dp_x=0;
            dp_x1=0;
            dp_x2=0;
            m_flow_y1=0;
            m_flow_y2=0;
            m_flow_smooth=0;

            m_flow_x = m_flow-m_flow_set;
            m_flow_x1 = -m_flow_x2;
            m_flow_x2 = deltax*m_flow_set;
            // min function ensures that dp_y1 does not increase further for m_flow_x > m_flow_x1
            dp_y1 = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                                             m_flow=min(m_flow, m_flow_set + m_flow_x1),
                                             k=kTotMax,
                                             m_flow_turbulent=m_flow_turbulent);
            // max function ensures that dp_y2 does not decrease further for m_flow_x < m_flow_x2
            dp_y2 = dp_min + coeff2*max(m_flow_x, m_flow_x2);

            dp_smooth = noEvent(smooth(2,
                if m_flow_x <= m_flow_x1
                then dp_y1
                elseif m_flow_x >=m_flow_x2
                then dp_y2
                else Buildings.Utilities.Math.Functions.quinticHermite(
                         x=m_flow_x,
                         x1=m_flow_x1,
                         x2=m_flow_x2,
                         y1=dp_y1,
                         y2=dp_y2,
                         y1d=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=kTotMax,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1),
                         y2d=coeff2,
                         y1dd=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=kTotMax,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1,
                                             m_flow_der2=0),
                         y2dd=y2dd)));
          end if;
          // Computation of damper opening
          kSquInv = basicFlowFunction_dp_m_flow(
            m_flow=m_flow,
            dp=dp,
            m_flow_small=1E-3*abs(m_flow_nominal),
            dp_small=1E-4*dp_nominal_pos);
          kDamSquInv = if dpFixed_nominal > Modelica.Constants.eps then
            kSquInv - 1 / kFixed^2 else kSquInv;
          // Use of regStep might no longer be needed when the leakage flow modeling is updated.
          y_actual_smooth = Buildings.Utilities.Math.Functions.regStep(
            x=y_internal - y_min,
            y1=exponentialDamper_inv(
              kTheta=kDamSquInv*2*rho*A^2, kSupSpl=kSupSpl, ySupSpl=ySupSpl, invSplDer=invSplDer),
            y2=0,
            x_small=1E-3);
          // Homotopy transformation
          if homotopyInitialization then
            if from_dp then
              m_flow=homotopy(actual=m_flow_smooth,
                              simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
            else
              dp=homotopy(actual=dp_smooth,
                          simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
            end if;
            y_actual = homotopy(
              actual=y_actual_smooth,
              simplified=y);
          else
            if from_dp then
              m_flow=m_flow_smooth;
            else
              dp=dp_smooth;
            end if;
            y_actual = y_actual_smooth;
          end if;
        annotation (
          defaultComponentName="damPreInd",
          Documentation(info="<html>
<p>
Model for an air damper whose airflow is proportional to the input signal, assuming
that at <code>y = 1</code>, <code>m_flow = m_flow_nominal</code>. This is unless the pressure difference
<code>dp</code> is too low,
in which case a <code>kDam = m_flow_nominal/sqrt(dp_nominal)</code> characteristic is used.
</p>
<p>
The model is similar to
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayPressureIndependent\">
Buildings.Fluid.Actuators.Valves.TwoWayPressureIndependent</a>,
except for adaptations for damper parameters.
Please see that documentation for more information.
</p>
<h4>Computation of the damper opening</h4>
<p>
The fractional opening of the damper is computed by
</p>
<ul>
<li>
inverting the quadratic flow function to compute the flow coefficient
from the flow rate and the pressure drop values (under the assumption
of a turbulent flow regime);
</li>
<li>
inverting the exponential characteristics to compute the fractional opening
from the loss coefficient value (directly derived from the flow coefficient).
</li>
</ul>
<p>
The quadratic interpolation used outside the exponential domain in the function
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.exponentialDamper\">
Buildings.Fluid.Actuators.BaseClasses.exponentialDamper</a>
yields a local extremum.
Therefore, the formal inversion of the function is not possible.
A cubic spline is used instead to fit the inverse of the damper characteristics.
The central domain of the characteritics having a monotonous exponential profile, its
inverse can be properly approximated with three equidistant support points.
However, the quadratic functions used outside of the exponential domain can have
various profiles depending on the damper coefficients.
Therefore, five linearly distributed support points are used on each side domain to
ensure a good fit of the inverse.
</p>
<p>
Note that below a threshold value of the input control signal (fixed at 0.02),
the fractional opening is forced to zero and no more related to the actual
flow coefficient of the damper.
This avoids steep transients of the computed opening while transitioning from reverse flow.
This is to be considered as a modeling workaround (avoiding the introduction of
an additional state variable) to prevent control chattering during
shut off operation where the pressure difference at the damper boundaries
can vary between slightly positive and negative values due to outdoor pressure
variations.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 11, 2021, by Michael Wetter:<br/>
Reformulated initial equation section to avoid warning in OPTIMICA about
variable array index.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1513\">IBPSA #1513</a>.
</li>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">IBPSA #1498</a>.
</li>
<li>
April 6, 2020, by Antoine Gautier:<br/>
Added the computation of the damper opening.
</li>
<li>
December 23, 2019 by Antoine Gautier:<br/>
Refactored as the model can now extend directly
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential\">
Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</a>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1188\">IBPSA #1188</a>.
</li>
<li>
March 21, 2017 by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"), Icon(graphics={Line(
                 points={{0,100},{0,-24}}),
                Rectangle(
                  extent={{-100,40},{100,-42}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,22},{100,-24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255})}));
        end PressureIndependent;
      annotation (preferredView="info", Documentation(info="<html>
This package contains component models for air dampers.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Dampers;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        model ThreeWayEqualPercentageLinear
          "Three way valve with equal percentage and linear characteristics"
            extends BaseClasses.PartialThreeWayValve(
              redeclare TwoWayEqualPercentage res1(
                R=R,
                delta0=delta0,
                final l=l[1]),
              redeclare TwoWayLinear res3(
                final l=l[2]));
          parameter Real R = 50 "Rangeability, R=50...100 typically";
          parameter Real delta0 = 0.01
            "Range of significant deviation from equal percentage law";

        equation
          connect(inv.y, res3.y) annotation (Line(points={{-62.6,46},{20,46},{20,46},{
                  20,-50},{12,-50}},
                                 color={0,0,127}));
          connect(y_actual, inv.u2) annotation (Line(points={{50,70},{84,70},{84,32},{-68,
                  32},{-68,41.2}},
                                 color={0,0,127}));
          connect(y_actual, res1.y) annotation (Line(points={{50,70},{84,70},{84,32},{
                  -50,32},{-50,12}},
                color={0,0,127}));
          annotation (                       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-72,24},{-34,-20}},
                  lineColor=DynamicSelect({255,255,255}, (1-y)*{255,255,255}),
                  fillPattern=FillPattern.Solid,
                  textString="%%")}),
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Three way valve with equal percentage characteristics
between <code>port_1</code> and <code>port_2</code>
and linear opening characteristic between <code>port_3</code> and <code>port_2</code>.
Such opening characteristics were typical for valves from Landis &amp; Gyr (now
Siemens).
</p><p>
This model is based on the partial valve models
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a> and
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
for the implementation of the three way valve
and see
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for the implementation of the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 5, 2019, by Michael Wetter:<br/>
Moved assignment of leakage from <a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
to the parent classes.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1227\">#1227</a>.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
Added filter to approximate the travel time of the actuator.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 16, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ThreeWayEqualPercentageLinear;

        model TwoWayEqualPercentage
          "Two way valve with equal percentage flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(
            phi=max(0.1*l, if homotopyInitialization then
                homotopy(actual=Buildings.Fluid.Actuators.BaseClasses.equalPercentage(
                y_actual,
                R,
                l,
                delta0), simplified=l + y_actual*(1 - l)) else
                Buildings.Fluid.Actuators.BaseClasses.equalPercentage(
                y_actual,
                R,
                l,
                delta0)));
          parameter Real R=50 "Rangeability, R=50...100 typically";
          parameter Real delta0=0.01
            "Range of significant deviation from equal percentage law";

        initial equation
          // Since the flow model Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
          assert(l < 1/R, "Wrong parameters in valve model.\n"
                        + "  Rangeability R = " + String(R) + "\n"
                        + "  Leakage flow l = " + String(l) + "\n"
                        + "  Must have l < 1/R = " + String(1/R));
          annotation (
            defaultComponentName="val",
            Documentation(info="<html>
<p>
Two way valve with an equal percentage valve opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
August 7, 2020, by Ettore Zanetti:<br/>
changed the computation of <code>phi</code> using
<code>max(0.1*l, . )</code> to avoid
phi=0.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1376\">
issue 1376</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Guarded the computation of <code>phi</code> using
<code>max(0, . )</code> to avoid
negative phi.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1223\">
issue 1223</a>.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
Added filter to approximate the travel time of the actuator.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 5, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Text(
                  extent={{-74,20},{-36,-24}},
                  lineColor=DynamicSelect({255,255,255}, (1-y)*{255,255,255}),
                  fillPattern=FillPattern.Solid,
                  textString="%%")}));
        end TwoWayEqualPercentage;

        model TwoWayLinear "Two way valve with linear flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(phi=max(0.1*l, l + y_actual*(1 - l)));

        initial equation
          // Since the flow model Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
August 7, 2020, by Ettore Zanetti:<br/>
changed the computation of <code>phi</code> using
<code>max(0.1*l, . )</code> to avoid
phi=0.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1376\">
issue 1376</a>.
</li>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Guarded the computation of <code>phi</code> using
<code>max(0, . )</code> to avoid
negative phi.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1223\">
issue 1223</a>.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayLinear;
      annotation (preferredView="info", Documentation(info="<html>
This package contains component models for two- and three-way valves.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        model ActuatorSignal
          "Partial model that implements the filtered opening for valves and dampers"

          constant Integer order(min=1) = 2 "Order of filter";

          parameter Boolean use_inputFilter=true
            "= true, if opening is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening"));
          parameter Modelica.SIunits.Time riseTime=120
            "Rise time of the filter (time to reach 99.6 % of an opening step)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Real y_start=1 "Initial position of actuator"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));

          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
            "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual
            "Actual actuator position"
            annotation (Placement(transformation(extent={{40,60},{60,80}})));

          // Classes used to implement the filtered opening
      protected
          final parameter Modelica.SIunits.Frequency fCut = 5/(2*Modelica.Constants.pi*riseTime)
            "Cut-off frequency of filter";

          parameter Boolean casePreInd = false
            "In case of PressureIndependent the model I/O is modified"
            annotation(Evaluate=true);
          Modelica.Blocks.Interfaces.RealOutput y_internal(unit="1")
            "Output connector for internal use (= y_actual if not casePreInd)";
          Modelica.Blocks.Interfaces.RealOutput y_filtered if use_inputFilter
            "Filtered valve position in the range 0..1"
            annotation (Placement(transformation(extent={{40,78},{60,98}}),
                iconTransformation(extent={{60,50},{80,70}})));

          Buildings.Fluid.BaseClasses.ActuatorFilter filter(
            final n=order,
            final f=fCut,
            final normalized=true,
            final initType=init,
            final y_start=y_start) if use_inputFilter
            "Second order filter to approximate actuator opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{6,81},{20,95}})));

        equation
          connect(filter.y, y_filtered)
            annotation (Line(points={{20.7,88},{50,88}}, color={0,0,127}));
          if use_inputFilter then
            connect(y, filter.u) annotation (Line(points={{1.11022e-15,120},{1.11022e-15,
                    88},{4.6,88}}, color={0,0,127}));
            connect(filter.y, y_internal) annotation (Line(points={{20.7,88},{30,88},{30,
                    70},{50,70}}, color={0,0,127}));
          else
            connect(y, y_internal) annotation (Line(
              points={{1.11022e-15,120},{0,120},{0,70},{50,70}},
              color={0,0,127}));
          end if;
          if not casePreInd then
            connect(y_internal, y_actual);
          end if;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,48},{0,108}}),
                Line(
                  points={{0,70},{40,70}}),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{34,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{34,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,94},{22,48}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold}),
                Text(
                  extent={{-40,126},{-160,76}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, format=".2f")))}),
        Documentation(info="<html>
<p>
This model implements the filter that is used to approximate the travel
time of the actuator.
Models that extend this model use the signal
<code>y_actual</code> to obtain the
current position of the actuator.
</p>
<p>
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>
for a description of the filter.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 10, 2021, by Michael Wetter:<br/>
Changed implementation of the filter and changed the parameter <code>order</code> to a constant
as most users need not change this value.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
April 6, 2020, by Antoine Gautier:<br/>
Add the boolean parameter <code>casePreInd</code>.<br/>
This is needed for the computation of the damper opening in
<a href=\"modelica://Buildings.Fluid.Actuators.Dampers.PressureIndependent\">
Buildings.Fluid.Actuators.Dampers.PressureIndependent</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 14, 2019, by Michael Wetter:<br/>
Set <code>start</code> attribute for <code>filter.x</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1252\">#1252</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
February 16, 2018, by Filip Jorissen:<br/>
Propagated parameter <code>order</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/891\">#891</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ActuatorSignal;

        partial model PartialDamperExponential
          "Partial model for air dampers with exponential opening characteristics"
          extends Buildings.Fluid.BaseClasses.PartialResistance(
            final dp_nominal=dpDamper_nominal+dpFixed_nominal,
            final m_flow_turbulent=if use_deltaM then deltaM * m_flow_nominal else
              eta_default*ReC*sqrt(A)*facRouDuc);
          extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.SIunits.PressureDifference dpDamper_nominal(displayUnit="Pa")
            "Pressure drop of fully open damper at nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.PressureDifference dpFixed_nominal(displayUnit="Pa") = 0
            "Pressure drop of duct and resistances other than the damper in series, at nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Boolean use_deltaM = true
            "Set to true to use deltaM for turbulent transition, else ReC is used";
          parameter Real deltaM = 0.3
            "Fraction of nominal mass flow rate where transition to turbulent occurs"
            annotation(Dialog(enable=use_deltaM));
          final parameter Modelica.SIunits.Velocity v_nominal=
            (2 / rho_default / k1 * dpDamper_nominal)^0.5
            "Nominal face velocity";
          final parameter Modelica.SIunits.Area A=m_flow_nominal/rho_default/v_nominal
            "Face area";
          parameter Boolean roundDuct = false
            "Set to true for round duct, false for square cross section"
            annotation(Dialog(enable=not use_deltaM));
          parameter Real ReC=4000 "Reynolds number where transition to turbulent starts"
            annotation(Dialog(enable=not use_deltaM));
          parameter Real a(unit="1")=-1.51 "Coefficient a for damper characteristics"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Real b(unit="1")=0.105*90 "Coefficient b for damper characteristics"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Real yL(unit="1") = 15/90 "Lower value for damper curve"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Real yU(unit="1") = 55/90 "Upper value for damper curve"
            annotation(Dialog(tab="Damper coefficients"));
          final parameter Real k0(min=0, unit="1") = 2 * rho_default * (A / kDamMin)^2
            "Loss coefficient for y=0 (pressure drop divided by dynamic pressure)"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Real k1(min=0, unit="1") = 0.45
            "Loss coefficient for y=1 (pressure drop divided by dynamic pressure)"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Real l(min=1e-10, max=1) = 0.0001
            "Damper leakage, ratio of flow coefficients k(y=0)/k(y=1)"
            annotation(Dialog(tab="Damper coefficients"));
          parameter Boolean use_constant_density=true
            "Set to true to use constant density for flow friction"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          Medium.Density rho "Medium density";
          final parameter Real kFixed = if dpFixed_nominal > Modelica.Constants.eps then
            m_flow_nominal / sqrt(dpFixed_nominal) else Modelica.Constants.inf
            "Flow coefficient of fixed resistance that may be in series with damper, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real kDam
            "Flow coefficient of damper, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          Real k
            "Flow coefficient of damper plus fixed resistance, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
      protected
          parameter Medium.Density rho_default=Medium.density(sta_default)
            "Density, used to compute fluid volume";
          parameter Real facRouDuc= if roundDuct then sqrt(Modelica.Constants.pi)/2 else 1
            "Shape factor used to compute the hydraulic diameter for round ducts";
          parameter Real kL = Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(
            y=yL, a=a, b=b, cL=cL, cU=cU, yL=yL, yU=yU)^2
            "Loss coefficient at the lower limit of the exponential characteristics";
          parameter Real kU = Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(
            y=yU, a=a, b=b, cL=cL, cU=cU, yL=yL, yU=yU)^2
            "Loss coefficient at the upper limit of the exponential characteristics";
          parameter Real[3] cL={
            (Modelica.Math.log(k0) - b - a)/yL^2,
            (-b*yL - 2*Modelica.Math.log(k0) + 2*b + 2*a)/yL,
            Modelica.Math.log(k0)} "Polynomial coefficients for curve fit for y < yl";
          parameter Real[3] cU={
            (Modelica.Math.log(k1) - a)/(yU^2 - 2*yU + 1),
            (-b*yU^2 - 2*Modelica.Math.log(k1)*yU - (-2*b - 2*a)*yU - b)/(yU^2 - 2*yU + 1),
            (Modelica.Math.log(k1)*yU^2 + b*yU^2 + (-2*b - 2*a)*yU + b + a)/(yU^2 - 2*yU + 1)}
            "Polynomial coefficients for curve fit for y > yu";
          parameter Real kDamMax =  (2 * rho_default / k1)^0.5 * A
            "Flow coefficient of damper fully open, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          parameter Real kTotMax = if dpFixed_nominal > Modelica.Constants.eps then
            sqrt(1 / (1 / kFixed^2 + 1 / kDamMax^2)) else kDamMax
            "Flow coefficient of damper fully open plus fixed resistance, with unit=(kg.m)^(1/2)";
          parameter Real kDamMin = l * kDamMax
            "Flow coefficient of damper fully closed, with unit=(kg.m)^(1/2)";
          parameter Real kTotMin = if dpFixed_nominal > Modelica.Constants.eps then
            sqrt(1 / (1 / kFixed^2 + 1 / kDamMin^2)) else kDamMin
            "Flow coefficient of damper fully closed + fixed resistance, with unit=(kg.m)^(1/2)";
        initial equation
          assert(dpDamper_nominal > Modelica.Constants.eps,
            "In " + getInstanceName() + ": dpDamper_nominal must be strictly greater than zero.");
          assert(dpFixed_nominal >= 0,
            "In " + getInstanceName() + ": dpFixed_nominal must be greater than zero.");
          assert(yL < yU,
            "In " + getInstanceName() + ": yL must be strictly lower than yU.");
          assert(m_flow_turbulent > 0,
            "In " + getInstanceName() + ": m_flow_turbulent must be strictly greater than zero.");
          assert(k1 >= 0.2,
            "In " + getInstanceName() + ": k1 must be greater than 0.2. k1=" + String(k1));
          assert(k1 < kU,
            "In " + getInstanceName() + ": k1 must be strictly lower than exp(a + b * (1 - yU)). k1=" +
            String(k1) + ", exp(...) = " + String(kU));
          assert(k0 <= 1e10,
            "In " + getInstanceName() + ": k0 must be lower than 1e10. k0=" + String(k0));
          assert(k0 > kL,
            "In " + getInstanceName() + ": k0 must be strictly higher than exp(a + b * (1 - yL)). k0=" +
            String(k0) + ", exp(...) = " + String(kL));
        equation
          rho = if use_constant_density then
              rho_default
            else
              Medium.density(Medium.setState_phX(
                port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)));
          // flow coefficient, k = m_flow/sqrt(dp)
          kDam=sqrt(2*rho)*A/Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(
            y=y_actual,
            a=a,
            b=b,
            cL=cL,
            cU=cU,
            yL=yL,
            yU=yU);
          k = if dpFixed_nominal > Modelica.Constants.eps then sqrt(1/(1/kFixed^2 + 1/kDam^2)) else kDam;
        annotation(Documentation(info="<html>
<p>
Partial model for air dampers with exponential opening characteristics.
This is the base model for air dampers.
The model implements the functions that relate the opening signal and the
flow coefficient.
The model also defines parameters that are used by different air damper
models.
</p>
<p>
The model is as in ASHRAE 825-RP except that a control signal of
<code>y=0</code> means the damper is closed, and <code>y=1</code> means
the damper is open.
This is opposite of the implementation of ASHRAE 825-RP, but used here
for consistency within this library.
</p>
<p>
For <code>yL &lt; y &lt; yU</code>, the damper characteristics is:
</p>
<p style=\"font-style:italic;\">
  k<sub>d</sub>(y) = exp(a+b (1-y))
</p>
<p>
where <i>kd</i> is the loss coefficient (total pressure drop divided
by dynamic pressure) and <i>y</i> is the fractional opening.
</p>
<p>
Outside this range, the damper characteristics is defined by a quadratic polynomial that
matches the damper resistance at <code>y=0</code> and <code>y=yL</code> or
<code>y=yU</code> and <code>y=1</code>, respectively.
In addition, the polynomials are such that <i>k<sub>d</sub>(y)</i> is differentiable in
<i>y</i> and the derivative is continuous.
</p>
<p>
The damper characteristics is then used to compute the flow coefficient <i>k(y)</i> as:
</p>
<p style=\"font-style:italic;\">
k(y) = (2 &rho; &frasl; k<sub>d</sub>(y))<sup>1/2</sup> A
</p>
<p>
where <i>A</i> is the face area, which is computed using the nominal
mass flow rate <code>m_flow_nominal</code>, the nominal velocity
<code>v_nominal</code> and the density of the medium.
</p>
<p>
ASHRAE 825-RP lists the following parameter values as typical (note that the
default values in the model correspond to opposed blades).
<br/>
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\"
style=\"border-collapse:collapse;\">
<tr>
<td></td><th>opposed blades</th><th>single blades</th>
</tr>
<tr>
<td>yL</td><td>15/90</td><td>15/90</td>
</tr>
<tr>
<td>yU</td><td>55/90</td><td>65/90</td>
</tr>
<tr>
<td>k1</td><td>0.2 to 0.5</td><td>0.2 to 0.5</td>
</tr>
<tr>
<td>a</td><td>-1.51</td><td>-1.51</td>
</tr>
<tr>
<td>b</td><td>0.105*90</td><td>0.0842*90</td>
</tr>
</table>
<p>
(The loss coefficient in fully closed position <code>k0</code> is computed based on the leakage coefficient
and the coefficient in fully open position.)
</p>
<h4>References</h4>
<p>
P. Haves, L. K. Norford, M. DeSimone and L. Mei,
<i>A Standard Simulation Testbed for the Evaluation of Control Algorithms &amp; Strategies</i>,
ASHRAE Final Report 825-RP, Atlanta, GA.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 23, 2019, by Antoine Gautier:<br/>
Removed the equations involving <code>m_flow</code> and <code>dp</code> that now need
to be added in each derived damper model.<br/>
Added the declaration of <code>dpDamper_nominal</code> and <code>dpFixed_nominal</code>.<br/>
Replaced <code>k0</code> by leakage coefficient.<br/>
Modified the limiting values for <code>k0</code> and <code>k1</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1188\">#1188</a>.
</li>
<li>
March 22, 2017, by Michael Wetter:<br/>
Added back <code>v_nominal</code>, but set the assignment of <code>A</code>
to be final. This allows scaling the model with <code>m_flow_nominal</code>,
which is generally known in the flow leg,
and <code>v_nominal</code>, for which a default value can be specified.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/544\">#544</a>.
</li>
<li>
October 12, 2016 by David Blum:<br/>
Removed parameter <code>v_nominal</code> and variable <code>area</code>,
to simplify parameterization of the model.
Also added assertion statements upon initialization
for parameters <code>k0</code> and <code>k1</code> so that they fall within
suggested ranges found in ASHRAE 825-RP. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/544\">#544</a>.
</li>
<li>
January 27, 2015 by Michael Wetter:<br/>
Set <code>Evaluate=true</code> for <code>use_constant_density</code>.
This is a structural parameter. Adding this annotation leads to fewer
numerical Jacobians for
<code>Buildings.Examples.VAVReheat.ClosedLoop</code>
with
<code>Buildings.Media.PerfectGases.MoistAirUnsaturated</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 22, 2008 by Michael Wetter:<br/>
Extended range of control signal from 0 to 1 by implementing the function
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.exponentialDamper\">
exponentialDamper</a>.
</li>
<li>
June 10, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"), Icon(graphics={Line(
                 points={{0,100},{0,-24}}),
                Rectangle(
                  extent={{-100,40},{100,-42}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,22},{100,-24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255})}));
        end PartialDamperExponential;

        partial model PartialThreeWayValve "Partial three way valve"
          extends Buildings.Fluid.BaseClasses.PartialThreeWayResistance(
            m_flow_small = m_flow_nominal*1e-4,
            final mDyn_flow_nominal = m_flow_nominal,
              redeclare replaceable
              Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve res1
                constrainedby
            Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  dp(start=dpValve_nominal/2),
                  from_dp=from_dp,
                  final linearized=linearized[1],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal,
                  final dpFixed_nominal=dpFixed_nominal[1],
                  final use_inputFilter=false),
              redeclare FixedResistances.LosslessPipe res2(
                m_flow_nominal=m_flow_nominal),
              redeclare replaceable
              Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve res3
                constrainedby
            Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  dp(start=dpValve_nominal/2),
                  from_dp=from_dp,
                  final linearized=linearized[2],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal/fraK^2,
                  final dpFixed_nominal=dpFixed_nominal[2],
                  final use_inputFilter=false));
            extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
            extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.PressureDifference dpFixed_nominal[2](each displayUnit="Pa",
                                                                 each min=0) = {0, 0}
            "Nominal pressure drop of pipes and other equipment in flow legs at port_1 and port_3"
            annotation(Dialog(group="Nominal condition"));

          parameter Real fraK(min=0, max=1) = 0.7
            "Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)";
          parameter Real[2] l(each min=0, each max=1) = {0.0001, 0.0001}
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));

          parameter Boolean[2] linearized = {false, false}
            "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Dialog(tab="Advanced"));

      protected
          Modelica.Blocks.Math.Feedback inv "Inversion of control signal"
            annotation (Placement(transformation(extent={{-74,40},{-62,52}})));
          Modelica.Blocks.Sources.Constant uni(final k=1)
            "Outputs one for bypass valve"
            annotation (Placement(transformation(extent={{-92,40},{-80,52}})));

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(uni.y, inv.u1)
            annotation (Line(points={{-79.4,46},{-72.8,46}},
                             color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,40},{100,-40}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{-100,22},{100,-22}},
              lineColor={0,0,0},
              fillPattern=FillPattern.HorizontalCylinder,
              fillColor={0,127,255}),
            Rectangle(
              extent={{-60,40},{60,-40}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{0,0},{-76,60},{-76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor=DynamicSelect({0,0,0}, y*{255,255,255}),
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,0},{76,60},{76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-40,-56},{40,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={192,192,192}),
            Rectangle(
              extent={{-22,-56},{22,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.VerticalCylinder,
              fillColor={0,127,255}),
            Polygon(
                  points={{0,0},{60,-76},{-60,-76},{0,0}},
                  lineColor={0,0,0},
                  fillColor=DynamicSelect({0,0,0}, (1-y)*{255,255,255}),
                  fillPattern=FillPattern.Solid),
            Line(
              visible=use_inputFilter,
              points={{-30,40},{30,40}}),
                    Line(
              points={{0,40},{0,0}}),
            Line(
              visible=not use_inputFilter,
              points={{0,100},{0,40}})}),
            Documentation(info="<html>
<p>
Partial model of a three way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage
or quick opening. The three way valve model consists of a mixer where
valves are placed in two of the flow legs. The third flow leg
has no friction.
The flow coefficient <code>Kv</code> for flow from <code>port_1 &rarr; port_2</code> is
a parameter.
The flow coefficient for the bypass flow from <code>port_3 &rarr; port_2</code>
is computed as
</p>
<pre>
         Kv(port_3 &rarr; port_2)
  fraK = ----------------------
         Kv(port_1 &rarr; port_2)
</pre>
<p>
where <code>0 &lt; fraK &le; 1</code> is a parameter with a default value
of <code>fraK=0.7</code>.
</p>
<p>
Since this model uses two way valves to construct a three way valve, see
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for details regarding the valve implementation.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
November 5, 2019, by Michael Wetter:<br/>
Moved assignment of leakage from <a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
to the parent classes.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1227\">#1227</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Removed assignment <code>redeclare final package Medium=Medium</code>
as this is now done in the base class.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
November 23, 2015 by Filip Jorissen:<br/>
Corrected valve leakage value to avoid warnings.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Corrected wrong documentation of parameter <code>fraK(min=0, max=1) = 0.7</code>.
The documenation was
<i>Fraction Kv(port_1&rarr;port_2)/Kv(port_3&rarr;port_2)</i> instead of
<i>Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)</i>.
Because the parameter set correctly its attributes <code>min=0</code> and <code>max=1</code>,
instances of this model used the correct value.
</li>
<li>
April 12, 2012 by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialThreeWayValve;

        partial model PartialTwoWayValve "Partial model for a two way valve"

          extends Buildings.Fluid.BaseClasses.PartialResistance(
               final dp_nominal=dpValve_nominal + dpFixed_nominal,
               dp(nominal=6000),
               final m_flow_turbulent = deltaM * abs(m_flow_nominal));

          extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));

          extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.SIunits.PressureDifference dpFixed_nominal(displayUnit="Pa", min=0) = 0
            "Pressure drop of pipe and other resistances that are in series"
             annotation(Dialog(group = "Nominal condition"));

          parameter Real l(min=1e-10, max=1) = 0.0001
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real phi
            "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
          parameter Real kFixed(unit="", min=0) = if dpFixed_nominal > Modelica.Constants.eps
            then m_flow_nominal / sqrt(dpFixed_nominal) else 0
            "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real kVal(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real k(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
        initial equation
          assert(dpFixed_nominal > -Modelica.Constants.eps, "In " + getInstanceName() +
          ": Model requires dpFixed_nominal >= 0 but received dpFixed_nominal = "
                + String(dpFixed_nominal) + " Pa.");
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={Rectangle(
              extent={{-60,40},{60,-40}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{0,0},{-76,60},{-76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor=DynamicSelect({0,0,0}, y*{255,255,255}),
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,-0},{76,60},{76,-60},{0,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              visible=use_inputFilter,
              points={{-30,40},{30,40}}),
            Line(
              points={{0,40},{0,0}}),
            Line(
              visible=not use_inputFilter,
              points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage,
quick opening or pressure-independent.
</p>
<p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop versus flow relation
ship. The region in which it is linearized is parameterized by
</p>
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
<p>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
</p>
<h4>Options</h4>
<p>
This model allows different parameterization of the flow resistance.
The different parameterizations are described in
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.ValveParameters\">
Buildings.Fluid.Actuators.BaseClasses.ValveParameters</a>.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</p>
</html>",
        revisions="<html>
<ul>

<li>
April 2, 2020, by Filip Jorissen:<br/>
Added model name in assert message.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1334\">#1334</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Removed assert for <code>phi>-0.2</code>
since the valve control input is now lower limited
to zero.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1223\">
issue 1223</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 16, 2017, by Michael Wetter:<br/>
Relaxed assertion on <code>phi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/592\">#592</a>.
</li>
<li>
October 27, 2016, by Filip Jorissen:<br/>
Added assert for <code>phi &gt; 0</code>.
This fixes a bug that caused valves to behave
like pumps for negative control signals.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/558\">#558</a>.
</li>
<li>
April 23, 2016, by Michael Wetter:<br/>
Changed test in assertion from <code>dpFixed_nominal > -Modelica.Constants.small</code>
to
<code>dpFixed_nominal > -Modelica.Constants.eps</code>.
Otherwise, JModelica evaluates it as <code>true</code> in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.Examples.TwoWayValves\">
Buildings.Fluid.Actuators.Valves.Examples.TwoWayValves</a>.
See also
<a href=\"https://trac.jmodelica.org/ticket/4932\">https://trac.jmodelica.org/ticket/4932</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/510\">Buildings, issue 510</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
Moved the governing equations to
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValveKv\">
PartialTwoWayValveKv</a>
in order to be able to extend from this partial in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayPressureIndependent\">
TwoWayPressureIndependent</a>
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Reformulated the computation of <code>k</code> to make the model
work in OpenModelica.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Added keyword <code>input</code> to variable <code>phi</code>
to require models that extend this model to provide a binding equation.
This is done to use the same modeling concept as is used for example in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Set <code>dp(nominal=6000)</code> as the previous formulation gives an error during model check
in Dymola 2014. The reason is that the previous formulation used <code>dpValve_nominal</code>, which
is not known at translation time.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Changed assignment of nominal attribute of <code>dp</code> to avoid assigning
a non-literal value.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 12, 2011 by Michael Wetter:<br/>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
Implemented parameterization of flow coefficient as in
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br/>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model PartialTwoWayValveKv
          "Partial model for a two way valve using a Kv characteristic"
          extends Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve;

        equation
         kVal = phi*Kv_SI;
         if (dpFixed_nominal > Modelica.Constants.eps) then
           k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
         else
           k = kVal;
         end if;

         if linearized then
           // This implementation yields m_flow_nominal = phi*kv_SI * sqrt(dp_nominal)
           // if m_flow = m_flow_nominal and dp = dp_nominal
           m_flow*m_flow_nominal_pos = k^2 * dp;
         else
           if homotopyInitialization then
             if from_dp then
                 m_flow=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                 dp=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
             end if;
           else // do not use homotopy
             if from_dp then
               m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              end if;
            end if; // homotopyInitialization
         end if; // linearized
          annotation (
        Documentation(info="<html>
<p>
Partial model for valves with different opening characteristics,
such as linear, equal percentage or quick opening. This partial extends from
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
and also contains the governing equations for these three two way valve models.
</p>
<h4>Implementation</h4>
<p>
Models that extend this model need to provide a binding equation
for the flow function <code>phi</code>.
An example of such a code can be found in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayLinear\">
Buildings.Fluid.Actuators.Valves.TwoWayLinear</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Removed icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 29, 2015 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValveKv;

        partial model ValveParameters "Model with parameters for valves"

          parameter Buildings.Fluid.Types.CvTypes CvData=Buildings.Fluid.Types.CvTypes.OpPoint
            "Selection of flow coefficient"
           annotation(Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Kv then true else false)
            "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Cv then true else false)
            "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.SIunits.Area Av(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Av then true else false)
            "Av (metric) flow coefficient"
           annotation(Dialog(group = "Flow Coefficient",
                             enable = (CvData==Buildings.Fluid.Types.CvTypes.Av)));

          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.PressureDifference dpValve_nominal(
             displayUnit="Pa",
             min=0,
             fixed= if CvData==Buildings.Fluid.Types.CvTypes.OpPoint then true else false)
            "Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint"
            annotation(Dialog(group="Nominal condition",
                       enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));

          parameter Modelica.SIunits.Density rhoStd
            "Inlet density for which valve coefficients are defined"
          annotation(Dialog(group="Nominal condition", tab="Advanced"));

      protected
          parameter Real Kv_SI(
            min=0,
            fixed= false)
            "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));
        initial equation
          if  CvData == Buildings.Fluid.Types.CvTypes.OpPoint then
            Kv_SI =           m_flow_nominal/sqrt(dpValve_nominal);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
          elseif CvData == Buildings.Fluid.Types.CvTypes.Kv then
            Kv_SI =           Kv*rhoStd/3600/sqrt(1E5)
              "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          elseif CvData == Buildings.Fluid.Types.CvTypes.Cv then
            Kv_SI =           Cv*rhoStd*0.0631/1000/sqrt(6895)
              "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          else
            assert(CvData == Buildings.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = "         + String(CvData) + ".");
            Kv_SI =           Av*sqrt(rhoStd);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          end if;

          annotation (Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
</p>
<ul>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).</li>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.</li>
</ul>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the protected parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
The value of <code>Kv_SI</code> is computed based on the parameters
<code>Av</code>,
<code>Kv</code>,
<code>Cv</code>, or, if
<code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>, based on
<code>m_flow_nominal</code> and <code>dpValve_nominal</code>.
Conversely, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>, then
<code>dpValve_nominal</code> is computed based on
<code>Av</code>,
<code>Kv</code>, or
<code>Cv</code>, and the nominal mass flow rate <code>m_flow_nominal</code>.
Therefore, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>,
then specifying a value for <code>dpValve_nominal</code> is a syntax error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Changed attribute <code>min</code> of <code>dpValve_nominal</code>
to <code>0</code>.
This is needed as for example in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable\">
Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable</a>,
<code>dpValve_nominal=0</code>.
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Changed the <code>initial algorithm</code> to an <code>initial equation</code>
section. Otherwise, OpenModelica attempts to solve for the parameter
values using numerical iteration, and fails in doing so.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2013, by Michael Wetter:<br/>
Removed stray backslash in write statement.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters, and removed <code>Kv_SI</code> as
a public parameter because it is always computed based on other parameters.
This change avoids a translation error in Dymola 2014 beta1 in
the pedantic mode, and a translation warning otherwise.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ValveParameters;

        function der_equalPercentage
          "Derivative of valve opening characteristics for equal percentage valve"
          extends Modelica.Icons.Function;

          input Real y "Valve opening signal, y=1 is fully open";
          input Real R "Rangeability, R=50...100 typically";
          input Real l(min=0, max=1) "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real delta "Range of significant deviation from equal percentage law";
          input Real der_y "Derivative of valve opening signal";
          output Real der_phi
            "Derivative of ratio actual to nominal mass flow rate, dphi/dy";
      protected
           Real a "Polynomial coefficient";
           Real b "Polynomial coefficient";
           Real c "Polynomial coefficient";
           Real logR "=log(R)";
           Real z "Auxiliary variable";
           Real q "Auxiliary variable";
           Real p "Auxiliary variable";
        algorithm
          if y < delta/2 then
            der_phi := (R^(delta-1) - l) / delta * der_y;
          else
            if (y > (3/2 * delta)) then
              der_phi := R^(y-1)*Modelica.Math.log(R) * der_y;
            else
              logR := Modelica.Math.log(R);
              z := (3*delta/2);
              q := delta*R^z*logR;
              p := R^z;
              a := (q - 2*p + 2*R^delta)/(delta^3*R);
              b := (-5*q + 12*p - 13*R^delta + l*R)/(2*delta^2*R);
              c := (7*q - 18*p + 24*R^delta - 6*l*R)/(4*delta*R);
              der_phi  := (c + y * ( 2*b + 3*a*y)) * der_y;
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the derivative of the opening characteristics of an equal percentage valve.
</p><p>
The function is the derivative of
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.equalPercentage\">
Buildings.Fluid.Actuators.BaseClasses.equalPercentage</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 30, 2011 by Michael Wetter:<br/>
Removed inputs for which no derivative is implemented from the argument list, and added
<code>zeroDerivative</code> keyword in function that calls this function.
</li>
<li>
February 4, 2010 by Michael Wetter:<br/>
Fixed implementation of derivative function.
</li>
<li>
June 6, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end der_equalPercentage;

        function equalPercentage
          "Valve opening characteristics for equal percentage valve"
          extends Modelica.Icons.Function;

          input Real y "Valve opening signal, y=1 is fully open";
          input Real R "Rangeability, R=50...100 typically";
          input Real l(min=0, max=1) "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real delta "Range of significant deviation from equal percentage law";
          output Real phi "Ratio actual to nominal mass flow rate, phi=Cv(y)/Cv(y=1)";
      protected
           Real a "Polynomial coefficient";
           Real b "Polynomial coefficient";
           Real c "Polynomial coefficient";
           Real d "Polynomial coefficient";
           Real logR "=log(R)";
           Real z "Auxiliary variable";
           Real q "Auxiliary variable";
           Real p "Auxiliary variable";
        algorithm
          if y < delta/2 then
            phi := l + y * (R^(delta-1) - l) / delta;
          else
            if (y > (3/2 * delta)) then
              phi := R^(y-1);
            else
              logR := Modelica.Math.log(R);
              z := (3*delta/2);
              q := delta*R^z*logR;
              p := R^z;
              a := (q - 2*p + 2*R^delta)/(delta^3*R);
              b := (-5*q + 12*p - 13*R^delta + l*R)/(2*delta^2*R);
              c := (7*q - 18*p + 24*R^delta - 6*l*R)/(4*delta*R);
              d := (-3*q + 8*p - 9*R^delta + 9*l*R)/(8*R);
              phi  := d + y * ( c + y * ( b + y * a));
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the opening characteristics of an equal percentage valve.
</p><p>
The function is used by the model
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayEqualPercentage\">
Buildings.Fluid.Actuators.Valves.TwoWayEqualPercentage</a>.
</p><p>
For <code>y &lt; delta/2</code>, the valve characteristics is linear. For <code> y &gt; 3*delta/2</code>
the valve characteristics is equal percentage. In between, a cubic spline is used to ensure
that the valve characteristics is once continuously differentiable with respect to <code>y</code>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
March 30, 2011 by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
June 5, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        smoothOrder=1,
        derivative(zeroDerivative=R, zeroDerivative=l, zeroDerivative=delta)=der_equalPercentage);
        end equalPercentage;

        function exponentialDamper
          "Damper opening characteristics for an exponential damper"
          extends Modelica.Icons.Function;
          input Real y(min=0, max=1, unit="")
            "Control signal, y=0 is closed, y=1 is open";
          input Real a(unit="") "Coefficient a for damper characteristics";
          input Real b(unit="") "Coefficient b for damper characteristics";
          input Real[3] cL "Polynomial coefficients for curve fit for y < yl";
          input Real[3] cU "Polynomial coefficients for curve fit for y > yu";
          input Real yL "Lower value for damper curve";
          input Real yU "Upper value for damper curve";
          output Real kThetaSqRt(min=0)
            "Square root of loss coefficient, sqrt(pressure drop/dynamic pressure)";
      protected
          Real yC(min=0, max=1, unit="")
            "y constrained to 0 <= y <= 1 to avoid numerical problems";
        algorithm
          if y < yL then
            yC :=max(0, y);
            kThetaSqRt := sqrt(Modelica.Math.exp(cL[3] + yC * (cL[2] + yC * cL[1])));
          else
            if (y > yU) then
              yC := min(1, y);
              kThetaSqRt := sqrt(Modelica.Math.exp(cU[3] + yC * (cU[2] + yC * cU[1])));
            else
              kThetaSqRt := sqrt(Modelica.Math.exp(a+b*(1-y))) "y=0 is closed";
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the opening characteristics of an exponential damper.
</p><p>
The function is used by the model
<a href=\"modelica://Buildings.Fluid.Actuators.Dampers.Exponential\">
Buildings.Fluid.Actuators.Dampers.Exponential</a>.
</p><p>
For <code>yL &lt; y &lt; yU</code>, the damper characteristics is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k<sub>d</sub>(y) = exp(a+b (1-y)).
</p>
<p>
Outside this range, the damper characteristic is defined by a quadratic polynomial.
</p>
<p>
Note that this implementation returns <i>sqrt(k<sub>d</sub>(y))</i> instead of <i>k<sub>d</sub>(y)</i>.
This is done for numerical reason since otherwise <i>k<sub>d</sub>(y)</i> may be an iteration
variable, which may cause a lot of warnings and slower convergence if the solver
attempts <i>k<sub>d</sub>(y) &lt; 0</i> during the iterative solution procedure.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2014 by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
July 1, 2011 by Michael Wetter:<br/>
Added constraint to control input to avoid using a number outside
<code>0</code> and <code>1</code> in case that the control input
has a numerical integration error.
</li>
<li>
April 4, 2010 by Michael Wetter:<br/>
Reformulated implementation. The new implementation computes
<code>sqrt(kTheta)</code>. This avoid having <code>kTheta</code> in
the iteration variables, which caused warnings when the solver attempted
<code>kTheta &lt; 0</code>.
</li>
<li>
June 22, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),           smoothOrder=1);
        end exponentialDamper;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Actuators\">Buildings.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for actuators.
</html>"));
    end Actuators;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
        "Delay element, approximated by a first order differential equation"
        extends Buildings.Fluid.MixingVolumes.MixingVolume(final V=V_nominal,
                                                       final mSenFac=1);

        parameter Modelica.SIunits.Time tau = 60 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

    protected
         parameter Modelica.SIunits.Volume V_nominal = m_flow_nominal*tau/rho_default
          "Volume of delay element";
        annotation (    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={      Text(
                extent={{-70,-26},{70,-66}},
                lineColor={255,255,255},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using a first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional, it need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 14, 2013, by Michael Wetter:<br/>
Renamed <code>V0</code> to <code>V_nominal</code> to use consistent notation.
</li>
<li>
September 24, 2008, by Michael Wetter:<br/>
Changed base class from <code>Modelica.Fluid</code> to <code>Buildings</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br/>
Fixed bug in assignment of parameter <code>sta0</code>.
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for transport delays in
piping networks.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>
approximates transport delays using a first order differential equation.
</p>
</html>"));
    end Delays;

    package FixedResistances "Package with models for fixed flow resistances"
      extends Modelica.Icons.VariantsPackage;

      model Junction
        "Flow splitter with fixed resistance at each port"
          extends Buildings.Fluid.BaseClasses.PartialThreeWayResistance(
          m_flow_small=mDyn_flow_nominal*1e-4,
          mDyn_flow_nominal = sum(abs(m_flow_nominal[:])/3),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res1(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[1],
            final dp_nominal=dp_nominal[1],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res2(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[2],
            final dp_nominal=dp_nominal[2],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare Buildings.Fluid.FixedResistances.PressureDrop res3(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[3],
            final dp_nominal=dp_nominal[3],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM));

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Modelica.SIunits.MassFlowRate[3] m_flow_nominal
          "Mass flow rate. Set negative at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));

        parameter Modelica.SIunits.Pressure[3] dp_nominal(each displayUnit = "Pa")
          "Pressure drop at nominal mass flow rate, set to zero or negative number at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));

        parameter Real deltaM(min=0) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(group = "Transition to laminar",
                               enable = not linearized));

        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(tab="Advanced"));

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-100,-46},{-32,-40},{-32,-100},{30,-100},{30,-36},{100,-30},
                    {100,38},{-100,52},{-100,-46}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-34},{-18,-28},{-18,-100},{18,-100},{18,-26},{100,-20},
                    {100,22},{-100,38},{-100,-34}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,128,255}),
              Text(
                extent={{-151,142},{149,102}},
                lineColor={0,0,255},
                textString="%name"),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{-100,10},{-100+100*min(1, max(0, port_1.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))),-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{0,10},{100*max(-1, min(0, port_1.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))),-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{0,10}, {0,10}}, {{100,10}, {(1-min(1, max(0, port_2.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3])))))*100,-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent=DynamicSelect({{0,10}, {0,10}}, {{0,10}, {-max(-1, min(0, port_2.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))*100,-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-10,0},{-10,0}}, {{-10,-100+100*min(1, max(0, port_3.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))},{10,-100}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-10,0},{-10,0}}, {{-10, 100*max(-1, min(0, port_3.m_flow*3/(abs(m_flow_nominal[1])+abs(m_flow_nominal[2])+abs(m_flow_nominal[3]))))},{10,0}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Ellipse(
                visible=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState,
                extent=DynamicSelect({{-35,35},{35,-35}}, {{-0,port_1.m_flow*0},{0,-0}}),
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="jun",
          Documentation(info="<html>
<p>
Model of a flow junction with an optional fixed resistance in each flow leg
and an optional mixing volume at the junction.
</p>
<p>
The pressure drop is implemented using the model
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a>.
If its nominal pressure drop is set to zero, then the pressure drop
model will be removed.
For example, the pressure drop declaration
</p>
<pre>
  m_flow_nominal={ 0.1, 0.1,  -0.2},
  dp_nominal =   {500,    0, -6000}
</pre>
<p>
would model a flow mixer that has the nominal flow rates and associated pressure drops
as shown in the figure below. Note that <code>port_3</code> is set to negative values.
The negative values indicate that at the nominal conditions, fluid is leaving the component.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/FixedResistances/Junction.png\"/>
</p>
<p>
If
<code>energyDynamics &lt;&gt; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the flow junction, a fluid volume is modeled.
The fluid volume is implemented using the model
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>.
The fluid volume has the size
</p>
<pre>
  V = sum(abs(m_flow_nominal[:])/3)*tau/rho_nominal
</pre>
<p>
where <code>tau</code> is a parameter and <code>rho_nominal</code> is the density
of the medium in the volume at nominal condition.
Setting <code>energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial</code>
can help reducing the size of the nonlinear
system of equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
February 26, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
March 26, 2018 by Filip Jorissen:<br/>
Removed <code>final allowFlowReversal=true</code> from all resistances
since this overrides the default simplification when the flow
is not bidirectional.
This change can lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/898\">issue 898</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Renamed model from <code>SplitterFixedResistanceDpM</code> to
<code>FlowJunction</code> and removed the parameters
<code>use_dh</code>, <code>dh</code> and <code>ReC</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
October 14, 2016 by Michael Wetter:<br/>
Added to Annex 60 library.<br/>
Updated comment for parameter <code>use_dh</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
Removed parameter <code>dynamicBalance</code> that overwrote the setting
of <code>energyDynamics</code> and <code>massDynamics</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">
Annex 60, issue 411</a>.
</li>
<li>
February 1, 2012 by Michael Wetter:<br/>
Expanded documentation.
</li>
<li>
August 4, 2011 by Michael Wetter:<br/>
Added <code>final allowFlowReversal=true</code> to all resistances since it is impractical
to avoid flow reversal in large flow networks where such a setting may be useful.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
Based class on
<a href=\"modelica://Buildings.Fluid.BaseClasses.PartialThreeWayFixedResistance\">
Buildings.Fluid.BaseClasses.PartialThreeWayFixedResistance</a>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Junction;

      model LosslessPipe "Pipe with no flow friction and no heat transfer"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;
        final parameter Boolean from_dp=true "Used to satisfy replaceable models";
      equation
        dp=0;
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,60},{100,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,50},{100,-48}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={217,236,255})}),
      defaultComponentName="pip",
          Documentation(info="<html>
<p>
Model of a pipe with no flow resistance, no heat loss and no transport delay.
This model can be used to replace a <code>replaceable</code> pipe model
in flow legs in which no friction should be modeled.
This is for example done in the outlet port of the
base class for three way valves,
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Implementation is now more efficient for <code>allowFlowReversal=false</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/949\">#949</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
June 13, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LosslessPipe;

      model PressureDrop
        "Fixed flow resistance with dp and m_flow as parameter"
        extends Buildings.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if computeFlowResistance then deltaM * m_flow_nominal_pos else 0);

        parameter Real deltaM(min=1E-6) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true,
                        Dialog(group = "Transition to laminar",
                               enable = not linearized));

        final parameter Real k = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
    protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
        final parameter Real coeff=
          if linearized and computeFlowResistance
          then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
          else 0
          "Precomputed coefficient to avoid division by parameter";
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;

       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            if from_dp then
              m_flow = dp*coeff;
            else
              dp = m_flow*coeff;
            end if;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                  actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                    dp=dp,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                  actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                    m_flow=m_flow,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                  dp=dp,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                  m_flow=m_flow,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance

        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>Buildings</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels\">
Buildings.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PressureDrop;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://Buildings.Fluid.Actuators\">
Buildings.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.HydraulicDiameter\">
Buildings.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.LosslessPipe\">
Buildings.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.Junction\">
Buildings.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      model DryCoilEffectivenessNTU
        "Heat exchanger with effectiveness - NTU relation and no moisture condensation"
        extends
        Buildings.Fluid.HeatExchangers.BaseClasses.PartialEffectivenessNTU(
          UA = 1/(1/hA.hA_1 + 1/hA.hA_2));

        parameter Real r_nominal(
          min=0,
          max=1) = 2/3
          "Ratio between air-side and water-side convective heat transfer (hA-value) at nominal condition";

        Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil hA(
          final r_nominal=r_nominal,
          final UA_nominal=UA_nominal,
          final m_flow_nominal_w=m1_flow_nominal,
          final m_flow_nominal_a=m2_flow_nominal,
          waterSideTemperatureDependent=false,
          airSideTemperatureDependent=false)
          "Model for convective heat transfer coefficient";

      equation
        // Convective heat transfer coefficient
        hA.m1_flow = m1_flow;
        hA.m2_flow = m2_flow;
        hA.T_1 = T_in1;
        hA.T_2 = T_in2;

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
          preferredView="info",
      defaultComponentName="hex",
          Documentation(info="<html>
<p>
Model of a coil without humidity condensation.
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q&#775; = Q&#775;<sub>max</sub>  &epsilon;<br/>
  &epsilon; = f(NTU, Z, flowRegime),
</p>
<p>
where
<i>Q&#775;<sub>max</sub></i> is the maximum heat that can be transferred,
<i>&epsilon;</i> is the heat transfer effectiveness,
<i>NTU</i> is the Number of Transfer Units,
<i>Z</i> is the ratio of minimum to maximum capacity flow rate and
<i>flowRegime</i> is the heat exchanger flow regime.
such as
parallel flow, cross flow or counter flow.
</p>
<p>
The flow regimes depend on the heat exchanger configuration. All configurations
defined in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerConfiguration\">
Buildings.Fluid.Types.HeatExchangerConfiguration</a>
are supported.
</p>
<p>
The convective heat transfer coefficients scale proportional to
<i>(m&#775;/m&#775;<sub>0</sub>)<sup>n</sup></i>, where
<i>m&#775;</i> is the mass flow rate,
<i>m&#775;<sub>0</sub></i> is the nominal mass flow rate, and
<i>n=0.8</i> on the air-side and <i>n=0.85</i> on the water side.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://Buildings.Fluid.MassExchangers.ConstantEffectiveness\">
Buildings.Fluid.MassExchangers.ConstantEffectiveness</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 25, 2018, by Michael Wetter:<br/>
Refactored model to use a common base class.
</li>
</ul>
</html>"));
      end DryCoilEffectivenessNTU;

      model HeaterCooler_u "Heater or cooler with prescribed heat flow rate"
        extends Buildings.Fluid.Interfaces.TwoPortHeatMassExchanger(
          redeclare final Buildings.Fluid.MixingVolumes.MixingVolume vol(
          final prescribedHeatFlowRate=true));

        parameter Modelica.SIunits.HeatFlowRate Q_flow_nominal
          "Heat flow rate at u=1, positive for heating";
        Modelica.Blocks.Interfaces.RealInput u(unit="1") "Control input"
          annotation (Placement(transformation(
                extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
          "Heat added to the fluid"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
    protected
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHea(
          final alpha=0)
          "Prescribed heat flow"
          annotation (Placement(transformation(extent={{-40,50},{-20,70}})));
        Modelica.Blocks.Math.Gain gai(k=Q_flow_nominal) "Gain"
          annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
      equation
        connect(u, gai.u) annotation (Line(
            points={{-120,60},{-82,60}},
            color={0,0,127}));
        connect(gai.y, preHea.Q_flow) annotation (Line(
            points={{-59,60},{-40,60}},
            color={0,0,127}));
        connect(preHea.port, vol.heatPort) annotation (Line(
            points={{-20,60},{-9,60},{-9,-10}},
            color={191,0,0}));
        connect(gai.y, Q_flow) annotation (Line(
            points={{-59,60},{-50,60},{-50,80},{80,80},{80,60},{110,60}},
            color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,8},{101,-5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-70,-60},{70,60},{-70,60},{-70,-60}},
                fillColor={127,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Polygon(
                points={{-70,-60},{70,60},{70,-60},{-70,-60}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{70,60},{100,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-56,-12},{54,-72}},
                lineColor={255,255,255},
                textString="Q=%Q_flow_nominal"),
              Rectangle(
                extent={{-100,60},{-70,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-122,106},{-78,78}},
                lineColor={0,0,127},
                textString="u"),
              Text(
                extent={{72,96},{116,68}},
                lineColor={0,0,127},
                textString="Q_flow")}),
      defaultComponentName="hea",
      Documentation(info="<html>
<p>
Model for an ideal heater or cooler with prescribed heat flow rate to the medium.
</p>
<p>
This model adds heat in the amount of <code>Q_flow = u Q_flow_nominal</code> to the medium.
The input signal <code>u</code> and the nominal heat flow rate <code>Q_flow_nominal</code>
can be positive or negative. A positive value of <code>Q_flow</code> means
heating, and negative means cooling.
</p>
<p>
The outlet conditions at <code>port_a</code> are not affected by this model,
other than for a possible pressure difference due to flow friction.
</p>
<p>
Optionally, this model can have a flow resistance.
Set <code>dp_nominal = 0</code> to disable the flow friction calculation.
</p>
<p>
For a model that uses as an input the fluid temperature leaving at
<code>port_b</code>, use
<a href=\"modelica://Buildings.Fluid.HeatExchangers.PrescribedOutlet\">
Buildings.Fluid.HeatExchangers.PrescribedOutlet</a>
</p>
<h4>Limitations</h4>
<p>
This model does not affect the humidity of the air. Therefore,
if used to cool air below the dew point temperature, the water mass fraction
will not change.
</p>
<h4>Validation</h4>
<p>
The model has been validated against the analytical solution in
the example
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Validation.HeaterCooler_u\">
Buildings.Fluid.HeatExchangers.Validation.HeaterCooler_u</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Set <code>preHea(final alpha=0)</code> as this allows to simplify the
system of equations.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/570\">#570</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Set <code>prescribedHeatFlowRate=true</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
May 1, 2015, by Marcus Fuchs:<br/>
Corrected typo in documentation.
</li>
<li>
November 12, 2014, by Michael Wetter:<br/>
Added output signal <code>Q_flow</code> so that it has
the same output ports as
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Validation.PrescribedOutlet\">
Buildings.Fluid.HeatExchangers.Validation.PrescribedOutlet</a>.
</li>
<li>
September 11, 2014, by Christoph Nytsch-Geusen:<br/>
Renaming class to <code>HeaterCooler_u</code>.
</li>
<li>
October 15, 2013, by Michael Wetter:<br/>
Redeclared the control volume to be final so that it does not show
anymore in the parameter window.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Redeclared fluid volume as final. This prevents the fluid volume model
to appear in the dialog window.
</li>
<li>
May 24, 2011, by Michael Wetter:<br/>
Changed base class to allow using the model as a dynamic or a steady-state model.
</li>
<li>
April 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end HeaterCooler_u;

      model WetCoilEffectivenessNTU
        "Heat exchanger with effectiveness - NTU relation and with moisture condensation"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface(
          redeclare replaceable package Medium2 = Buildings.Media.Air);
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
          final computeFlowResistance1=true,
          final computeFlowResistance2=true);

        import con = Buildings.Fluid.Types.HeatExchangerConfiguration;
        import flo = Buildings.Fluid.Types.HeatExchangerFlowRegime;

        parameter Buildings.Fluid.Types.HeatExchangerConfiguration configuration=
          con.CounterFlow
          "Heat exchanger configuration";
        parameter Real r_nominal=2/3
          "Ratio between air-side and water-side convective heat transfer coefficient";

        parameter Boolean use_Q_flow_nominal = false
          "Set to true to specify Q_flow_nominal and inlet conditions, or to false to specify UA_nominal"
          annotation (
            Evaluate=true,
            Dialog(group="Nominal thermal performance"));

        parameter Modelica.SIunits.HeatFlowRate Q_flow_nominal(
          fixed=use_Q_flow_nominal)
          "Nominal heat flow rate (positive for heat transfer from 1 to 2)"
          annotation (Dialog(
            group="Nominal thermal performance",
            enable=use_Q_flow_nominal));
        parameter Modelica.SIunits.Temperature T_a1_nominal(
          fixed=use_Q_flow_nominal)
          "Water inlet temperature at a rated condition"
          annotation (Dialog(
            group="Nominal thermal performance",
            enable=use_Q_flow_nominal));
        parameter Modelica.SIunits.Temperature T_a2_nominal(
          fixed=use_Q_flow_nominal)
          "Air inlet temperature at a rated condition"
          annotation (Dialog(
            group="Nominal thermal performance",
            enable=use_Q_flow_nominal));
        parameter Modelica.SIunits.MassFraction w_a2_nominal(
          start=0.01,
          fixed=use_Q_flow_nominal)
          "Humidity ratio of inlet air at a rated condition (in kg/kg dry air)"
          annotation (Dialog(
            group="Nominal thermal performance",
            enable=use_Q_flow_nominal));

        parameter Modelica.SIunits.ThermalConductance UA_nominal(
          fixed=not use_Q_flow_nominal,
          min=0,
          start=1/(1/10+1/20))
          "Thermal conductance at nominal flow, used to compute heat capacity"
          annotation(Dialog(
            group="Nominal thermal performance",
            enable=not use_Q_flow_nominal));

        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=
          Modelica.Fluid.Types.Dynamics.SteadyState
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        Modelica.SIunits.HeatFlowRate Q1_flow = -dryWetCalcs.QTot_flow
          "Heat input into water stream (positive if air is cooled)";
        Modelica.SIunits.HeatFlowRate Q2_flow = dryWetCalcs.QTot_flow
          "Total heat input into air stream (negative if air is cooled)";
        Modelica.SIunits.HeatFlowRate QSen2_flow = dryWetCalcs.QSen_flow
          "Sensible heat input into air stream (negative if air is cooled)";
        Modelica.SIunits.HeatFlowRate QLat2_flow=
          Buildings.Utilities.Psychrometrics.Constants.h_fg * mWat_flow
          "Latent heat input into air (negative if air is dehumidified)";
        Real SHR(
          min=0,
          max=1,
          unit="1") = QSen2_flow /
            noEvent(if (Q2_flow > 1E-6 or Q2_flow < -1E-6) then Q2_flow else 1)
          "Sensible to total heat ratio";
        Modelica.SIunits.MassFlowRate mWat_flow = dryWetCalcs.mCon_flow
          "Water flow rate of condensate removed from the air stream";

        Real dryFra(final unit="1", min=0, max=1) = dryWetCalcs.dryFra
          "Dry fraction, 0.3 means condensation occurs at 30% heat exchange length from air inlet";
    protected
        final parameter Modelica.SIunits.MassFraction X_w_a2_nominal=
          w_a2_nominal / (1+w_a2_nominal)
          "Water mass fraction of inlet air at a rated condition (in kg/kg total air)";

        parameter Boolean waterSideFlowDependent=true
          "Set to false to make water-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideFlowDependent=true
          "Set to false to make air-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean waterSideTemperatureDependent=false
          "Set to false to make water-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideTemperatureDependent=false
          "Set to false to make air-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));

        Real delta=1E-2
          "Parameter for normalization";
        Real delta1=1E-1
          "Parameter for normalization";
        Real fac1 = Buildings.Utilities.Math.Functions.smoothMin(
          (1/delta * m1_flow/m1_flow_nominal)^2,1,delta1);
        Real fac2 = Buildings.Utilities.Math.Functions.smoothMin(
          (1/delta * m2_flow/m2_flow_nominal)^2,1,delta1);
        Real Qfac = fac1*fac2;

        Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilUARated UAFroRated(
          final use_Q_flow_nominal=use_Q_flow_nominal,
          final QTot_flow=Q_flow_nominal,
          final UA=UA_nominal,
          final r_nominal=r_nominal,
          final TAirIn=T_a2_nominal,
          final X_wAirIn=X_w_a2_nominal,
          final TWatIn=T_a1_nominal,
          final mAir_flow=m2_flow_nominal,
          final mWat_flow=m1_flow_nominal)
          "Model that computes UA_nominal";

        Buildings.Fluid.HeatExchangers.HeaterCooler_u heaCoo(
          redeclare final package Medium = Medium1,
          final dp_nominal = dp1_nominal,
          final m_flow_nominal = m1_flow_nominal,
          final energyDynamics = energyDynamics,
          final massDynamics = massDynamics,
          final Q_flow_nominal=-1)
          "Heat exchange with water stream"
          annotation (Placement(transformation(extent={{60,50},{80,70}})));

        Buildings.Fluid.Humidifiers.Humidifier_u heaCooHum_u(
          redeclare final package Medium = Medium2,
          final mWat_flow_nominal = 1,
          final dp_nominal = dp2_nominal,
          final m_flow_nominal = m2_flow_nominal,
          final energyDynamics = energyDynamics,
          final massDynamics = massDynamics)
          "Heat and moisture exchange with air stream"
          annotation (Placement(transformation(extent={{-60,-70},{-80,-50}})));
        Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil hA(
          final UA_nominal = UA_nominal,
          final m_flow_nominal_a = m2_flow_nominal,
          final m_flow_nominal_w = m1_flow_nominal,
          final waterSideTemperatureDependent = waterSideTemperatureDependent,
          final waterSideFlowDependent = waterSideFlowDependent,
          final airSideTemperatureDependent = airSideTemperatureDependent,
          final airSideFlowDependent = airSideFlowDependent,
          r_nominal = r_nominal)
          "Model for convective heat transfer coefficient"
          annotation (Placement(transformation(extent={{-68,-13},{-50,9}})));
        Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilDryWetRegime dryWetCalcs(
          fullyWet(hAirOut(start=Medium2.h_default)),
          final cfg=flowRegime,
          final mWat_flow_nominal=m1_flow_nominal,
          final mAir_flow_nominal=m2_flow_nominal,
          final Qfac=Qfac)
          "Dry/wet calculations block"
          annotation (Placement(transformation(extent={{-20,-40},{60,40}})));

        Modelica.Blocks.Sources.RealExpression cp_a1Exp(
          final y=Medium1.specificHeatCapacityCp(state_a1_inflow))
          "Expression for cp of air"
          annotation (Placement(transformation(extent={{-44,18},{-30,30}})));
        Modelica.Blocks.Sources.RealExpression XWat_a2Exp(
          final y = if allowFlowReversal2
          then
            fra_a2 * state_a2_inflow.X[nWat] + fra_b2 * state_b2_inflow.X[nWat]
          else
            state_a2_inflow.X[nWat])
          "Expression for XWat"
          annotation (Placement(transformation(extent={{-44,-2},{-30,10}})));
        Modelica.Blocks.Sources.RealExpression p_a2Exp(
          final y = port_a2.p)
          "Pressure at port a2"
          annotation (Placement(transformation(extent={{-44,-10},{-30,2}})));
        Modelica.Blocks.Sources.RealExpression h_a2Exp(
          final y = if allowFlowReversal2
          then
            fra_a2 * Medium2.specificEnthalpy(state_a2_inflow)
            + fra_b2 * Medium2.specificEnthalpy(state_b2_inflow)
          else
            Medium2.specificEnthalpy(state_a2_inflow))
          "Specific enthalpy at port a2"
          annotation (Placement(transformation(extent={{-44,-18},{-30,-6}})));
        Modelica.Blocks.Sources.RealExpression cp_a2Exp(final y=
              Medium2.specificHeatCapacityCp(state_a2_inflow))
          "Specific heat capacity at port a2"
          annotation (Placement(transformation(extent={{-44,-30},{-30,-18}})));
        Modelica.Blocks.Sources.RealExpression TIn_a1Exp(
          final y = if allowFlowReversal1
          then
            fra_a1 * Medium1.temperature(state_a1_inflow)
            + fra_b1 * Medium1.temperature(state_b1_inflow)
          else
            Medium1.temperature(state_a1_inflow))
          "Temperature at port a1"
          annotation (Placement(transformation(extent={{-98,16},{-84,28}})));
        Modelica.Blocks.Sources.RealExpression TIn_a2Exp(
          final y = if allowFlowReversal2
          then
            fra_a2 * Medium2.temperature(state_a2_inflow)
            + fra_b2 * Medium2.temperature(state_b2_inflow)
          else
            Medium2.temperature(state_a2_inflow))
          "Temperature at port a2"
          annotation (Placement(transformation(extent={{-98,-8},{-84,4}})));
        Modelica.Blocks.Sources.RealExpression m_flow_a1Exp(
          final y=Buildings.Utilities.Math.Functions.regNonZeroPower(
            x=port_a1.m_flow,n=1,delta=delta*m1_flow_nominal))
          "Absolute value of mass flow rate on water side"
          annotation (Placement(transformation(extent={{-98,30},{-84,42}})));
        Modelica.Blocks.Sources.RealExpression m_flow_a2Exp(
          final y=Buildings.Utilities.Math.Functions.regNonZeroPower(
            x=port_a2.m_flow,n=1,delta=delta*m2_flow_nominal))
          "Absolute value of mass flow rate on air side"
          annotation (Placement(transformation(extent={{-98,-36},{-84,-24}})));
        final parameter Integer nWat=
          Buildings.Fluid.HeatExchangers.BaseClasses.determineWaterIndex(
            Medium2.substanceNames)
          "Index of water";
        parameter flo flowRegime_nominal(fixed=false)
          "Heat exchanger flow regime at nominal flow rates";
        flo flowRegime(fixed=false, start=flowRegime_nominal)
          "Heat exchanger flow regime";

        Buildings.HeatTransfer.Sources.PrescribedHeatFlow preHea
          "Prescribed heat flow"
          annotation (Placement(transformation(extent={{20,-90},{0,-70}})));
        Real fra_a1(min=0, max=1) = if allowFlowReversal1
          then Modelica.Fluid.Utilities.regStep(
            m1_flow,
            1,
            0,
            m1_flow_small)
          else 1
          "Fraction of incoming state taken from port a2
    (used to avoid excessive calls to regStep)";
        Real fra_b1(min=0, max=1) = if allowFlowReversal1
          then 1-fra_a1
          else 0
          "Fraction of incoming state taken from port b2
    (used to avoid excessive calls to regStep)";
        Real fra_a2(min=0, max=1) = if allowFlowReversal2
          then Modelica.Fluid.Utilities.regStep(
            m2_flow,
            1,
            0,
            m2_flow_small)
          else 1
          "Fraction of incoming state taken from port a2
    (used to avoid excessive calls to regStep)";
        Real fra_b2(min=0, max=1) = if allowFlowReversal2
          then 1-fra_a2
          else 0
          "Fraction of incoming state taken from port b2
    (used to avoid excessive calls to regStep)";

        Modelica.SIunits.ThermalConductance C1_flow = abs(m1_flow)*
          ( if allowFlowReversal1 then
                 fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                 fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
              Medium1.specificHeatCapacityCp(state_a1_inflow))
          "Heat capacity flow rate medium 1";
        Modelica.SIunits.ThermalConductance C2_flow = abs(m2_flow)*
          ( if allowFlowReversal2 then
                 fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                 fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
              Medium2.specificHeatCapacityCp(state_a2_inflow))
          "Heat capacity flow rate medium 2";
        parameter Modelica.SIunits.SpecificHeatCapacity cp1_nominal(fixed=false)
          "Specific heat capacity of medium 1 at nominal condition";
        parameter Modelica.SIunits.SpecificHeatCapacity cp2_nominal(fixed=false)
          "Specific heat capacity of medium 2 at nominal condition";
        parameter Modelica.SIunits.ThermalConductance C1_flow_nominal(fixed=false)
          "Nominal capacity flow rate of Medium 1";
        parameter Modelica.SIunits.ThermalConductance C2_flow_nominal(fixed=false)
          "Nominal capacity flow rate of Medium 2";
        final parameter Medium1.ThermodynamicState sta1_default = Medium1.setState_phX(
           h=Medium1.h_default,
           p=Medium1.p_default,
           X=Medium1.X_default[1:Medium1.nXi]) "Default state for medium 1";
        final parameter Medium2.ThermodynamicState sta2_default = Medium2.setState_phX(
           h=Medium2.h_default,
           p=Medium2.p_default,
           X=Medium2.X_default[1:Medium2.nXi]) "Default state for medium 2";

      initial equation
        cp1_nominal = Medium1.specificHeatCapacityCp(sta1_default);
        cp2_nominal = Medium2.specificHeatCapacityCp(sta2_default);
        C1_flow_nominal = m1_flow_nominal*cp1_nominal;
        C2_flow_nominal = m2_flow_nominal*cp2_nominal;
        if (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
          flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal)
            then
              flo.CrossFlowCMinMixedCMaxUnmixed
            else
              flo.CrossFlowCMinUnmixedCMaxMixed;
        elseif (configuration == con.CrossFlowStream1UnmixedStream2Mixed) then
          flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal)
            then
              flo.CrossFlowCMinUnmixedCMaxMixed
            else
              flo.CrossFlowCMinMixedCMaxUnmixed;
        elseif (configuration == con.ParallelFlow) then
          flowRegime_nominal = flo.ParallelFlow;
        elseif (configuration == con.CounterFlow) then
          flowRegime_nominal = flo.CounterFlow;
        elseif (configuration == con.CrossFlowUnmixed) then
          flowRegime_nominal = flo.CrossFlowUnmixed;
        else
          // Invalid flow regime. Assign a value to flowRegime_nominal, and stop with an assert
          flowRegime_nominal = flo.CrossFlowUnmixed;
          assert(configuration >= con.ParallelFlow and
            configuration <= con.CrossFlowStream1UnmixedStream2Mixed,
            "Invalid heat exchanger configuration.");
        end if;
      equation
        // Assign the flow regime for the given heat exchanger configuration and
        // mass flow rates
        if (configuration == con.ParallelFlow) then
          flowRegime = if (C1_flow*C2_flow >= 0)
            then
              flo.ParallelFlow
            else
              flo.CounterFlow;
        elseif (configuration == con.CounterFlow) then
          flowRegime = if (C1_flow*C2_flow >= 0)
            then
              flo.CounterFlow
            else
              flo.ParallelFlow;
        elseif (configuration == con.CrossFlowUnmixed) then
          flowRegime = flo.CrossFlowUnmixed;
        elseif (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
          flowRegime = if (C1_flow < C2_flow)
            then
              flo.CrossFlowCMinMixedCMaxUnmixed
            else
              flo.CrossFlowCMinUnmixedCMaxMixed;
        else
          // have ( configuration == con.CrossFlowStream1UnmixedStream2Mixed)
          flowRegime = if (C1_flow < C2_flow)
            then
              flo.CrossFlowCMinUnmixedCMaxMixed
            else
              flo.CrossFlowCMinMixedCMaxUnmixed;
        end if;

        connect(heaCoo.port_b, port_b1) annotation (Line(points={{80,60},{80,60},{100,60}},color={0,127,255},
            thickness=1));
        connect(heaCooHum_u.port_b, port_b2) annotation (Line(
            points={{-80,-60},{-90,-60},{-100,-60}},
            color={0,127,255},
            thickness=1));
        connect(hA.hA_1, dryWetCalcs.UAWat) annotation (Line(points={{-49.1,5.7},{-46,
                5.7},{-46,36.6667},{-22.8571,36.6667}},  color={0,0,127}));
        connect(hA.hA_2, dryWetCalcs.UAAir) annotation (Line(points={{-49.1,-9.7},{
                -46,-9.7},{-46,-36},{-46,-36.6667},{-22.8571,-36.6667}},
                                                           color={0,0,127}));
        connect(cp_a1Exp.y, dryWetCalcs.cpWat) annotation (Line(points={{-29.3,24},{
                -22.8571,24},{-22.8571,23.3333}},
                                         color={0,0,127}));
        connect(XWat_a2Exp.y, dryWetCalcs.X_wAirIn) annotation (Line(points={{-29.3,4},
                {-22.8571,4},{-22.8571,3.33333}},  color={0,0,127}));
        connect(p_a2Exp.y, dryWetCalcs.pAir) annotation (Line(points={{-29.3,-4},{
                -22.8571,-4},{-22.8571,-3.33333}},
                                        color={0,0,127}));
        connect(h_a2Exp.y, dryWetCalcs.hAirIn) annotation (Line(points={{-29.3,-12},{
                -22,-12},{-22,-10},{-22.8571,-10}},
                                          color={0,0,127}));
        connect(cp_a2Exp.y, dryWetCalcs.cpAir) annotation (Line(points={{-29.3,-24},{
                -22.8571,-24},{-22.8571,-23.3333}},
                                           color={0,0,127}));
        connect(TIn_a1Exp.y, hA.T_1) annotation (Line(points={{-83.3,22},{-80,22},{-80,
                1.3},{-68.9,1.3}},       color={0,0,127}));
        connect(TIn_a1Exp.y, dryWetCalcs.TWatIn) annotation (Line(points={{-83.3,22},
                {-50,22},{-50,16.6667},{-22.8571,16.6667}}, color={0,0,127}));
        connect(TIn_a2Exp.y, hA.T_2) annotation (Line(points={{-83.3,-2},{-76,-2},{-76,
                -5.3},{-68.9,-5.3}},   color={0,0,127}));
        connect(TIn_a2Exp.y, dryWetCalcs.TAirIn) annotation (Line(points={{-83.3,-2},
                {-76,-2},{-76,-16.6667},{-22.8571,-16.6667}}, color={0,0,127}));
        connect(m_flow_a1Exp.y, hA.m1_flow) annotation (Line(points={{-83.3,36},{-76,36},
                {-76,5.7},{-68.9,5.7}},       color={0,0,127}));
        connect(m_flow_a1Exp.y, dryWetCalcs.mWat_flow) annotation (Line(points={{-83.3,
                36},{-50,36},{-50,30},{-22.8571,30}},       color={0,0,127}));
        connect(port_a1, heaCoo.port_a) annotation (Line(
            points={{-100,60},{-20,60},{60,60}},
            color={0,127,255},
            thickness=1));
        connect(m_flow_a2Exp.y, hA.m2_flow) annotation (Line(points={{-83.3,-30},{-80,
                -30},{-80,-9.7},{-68.9,-9.7}},
                                             color={0,0,127}));
        connect(m_flow_a2Exp.y, dryWetCalcs.mAir_flow) annotation (Line(points={{-83.3,
                -30},{-22.8571,-30}},                      color={0,0,127}));
        connect(port_a2, heaCooHum_u.port_a) annotation (Line(
            points={{100,-60},{20,-60},{-60,-60}},
            color={0,127,255},
            thickness=1));
        connect(preHea.port, heaCooHum_u.heatPort) annotation (Line(points={{0,-80},{-40,
                -80},{-40,-66},{-60,-66}}, color={191,0,0}));
        connect(dryWetCalcs.QTot_flow, heaCoo.u) annotation (Line(points={{62.8571,
                -6.66667},{80,-6.66667},{80,44},{40,44},{40,66},{58,66}},
                                                                color={0,0,127}));
        connect(dryWetCalcs.mCon_flow, heaCooHum_u.u) annotation (Line(points={{62.8571,
                -33.3333},{70,-33.3333},{70,-54},{-59,-54}}, color={0,0,127}));
        connect(preHea.Q_flow, dryWetCalcs.QTot_flow) annotation (Line(points={{20,-80},
                {44,-80},{80,-80},{80,-6.66667},{62.8571,-6.66667}},
                                                                 color={0,0,127}));
        annotation (
          defaultComponentName="hexWetNtu",
          Icon(graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{36,80},{40,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,80},{-36,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-2,80},{2,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,65},{103,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,65},{103,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{46,-62},{44,-72},{50,-76},{58,-72},{56,-62},{50,-50},{46,-62}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier),
              Polygon(
                points={{24,-52},{22,-62},{28,-66},{36,-62},{34,-52},{28,-40},{24,-52}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier),
              Polygon(
                points={{0,-48},{-2,-58},{4,-62},{12,-58},{10,-48},{4,-36},{0,-48}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier),
              Polygon(
                points={{-18,-64},{-20,-74},{-14,-78},{-6,-74},{-8,-64},{-14,-52},{
                    -18,-64}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier),
              Polygon(
                points={{-40,-50},{-42,-60},{-36,-64},{-28,-60},{-30,-50},{-36,-38},{
                    -40,-50}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier),
              Polygon(
                points={{-58,-62},{-60,-72},{-54,-76},{-46,-72},{-48,-62},{-54,-50},{
                    -58,-62}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                smooth=Smooth.Bezier)}),
              Diagram(graphics={Text(
                extent={{44,84},{86,76}},
                lineColor={28,108,200},
                textString="Water Side",
                textStyle={TextStyle.Italic},
                horizontalAlignment=TextAlignment.Left),
              Text(
                extent={{-42,-80},{0,-88}},
                lineColor={28,108,200},
                textStyle={TextStyle.Italic},
                horizontalAlignment=TextAlignment.Left,
                textString="Air Side")}),
          Documentation(info="<html>
<p>
This model describes a cooling coil applicable for fully-dry,
partially-wet, and fully-wet regimes.
The model is developed for counter flow heat exchangers but is also applicable
for the cross-flow configuration, although in the latter case it is recommended
to have more than four tube rows (Elmahdy and Mitalas, 1977 and Braun, 1988).
The model can also be used for a heat exchanger which acts as both heating coil
(for some period of time) and cooling coil (for the others).
However, it is not recommended to use this model for heating coil only or for
cooling coil with no water condensation because for these situations,
<a href=\"modelica://Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU\">
Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU</a>
computes faster.
</p>
<h4>Main equations</h4>
<p>
The coil model consists of two-equation sets, one for the fully-dry mode and
the other for the fully-wet mode. For the fully-dry mode, the <i>&epsilon;-NTU</i>
approach (Elmahdy and Mitalas, 1977) is used.
For the fully-wet mode, equations from Braun (1988) and Mitchell and Braun (2012a and b),
which are essentially the extension of the <i>&epsilon;-NTU</i> approach to simultaneous sensible
and latent heat transfer, are utilized.
The equation sets are switched depending on the switching criteria described below
that determines the right mode based on a coil surface temperature and dew-point
temperature for the air at the inlet of the coil.
The transition regime between the two modes, which represents the partially-wet and
partially-dry coil, is approximated by employing a fuzzy modeling approach,
so-called Takagi-Sugeno fuzzy modeling (Takagi and Sugeno, 1985), which provides a
continuously differentiable model that can cover all fully-dry, partially-wet,
and fully-wet regimes.
</p>
<p>The switching rules are:</p>
<ul>
<li>R1: If the coil surface temperature at the air inlet is lower than the
dew-point temperature of air at inlet, then the cooling coil surface is fully-wet.
</li>
<li>
R2: If the coil surface temperature at the air outlet is higher than the
dew-point temperature of air at inlet, then the cooling coil surface is fully-dry.
</li>
<li>
R3: If any of the conditions in R1 or R2 is not satisfied, then the cooling coil
surface is partially wet.
</li>
</ul>
<p>
For more detailed descriptions of the fully-wet coil model and the fuzzy modeling approach,
see
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilWetRegime\">
Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilWetRegime</a>.
and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilDryWetRegime\">
Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilDryWetRegime</a>.
</p>
<h4>Assumptions and limitations</h4>
<p>This model contains the following assumptions and limitations:</p>
<p>Medium 2 must be air due to the use of various psychrometric functions.</p>
<p>
When parameterizing this model with rated conditions (with the parameter
<code>use_UA_nominal</code> set to <code>false</code>), those should
correspond to a fully-dry or a fully-wet coil regime, because
the model uncertainty yielded by partially-wet rated conditions
has not been assessed yet.
</p>
<p>The model uses steady-state physics. That is, no dynamics associated
with water and coil materials are considered.</p>
<p>The Lewis number, which relates the mass transfer coefficient to the heat transfer
coefficient, is assumed to be <i>1</i>.</p>
<p>The model is not suitable for a cross-flow heat exchanger of which the number
of passes is less than four.</p>
<h4>Validation</h4>
<p>Validation results can be found in
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Validation.WetCoilEffectivenessNTU\">
Buildings.Fluid.HeatExchangers.Validation.WetCoilEffectivenessNTU</a>.
<h4>References</h4>
<p>Braun, James E. 1988.
&quot;Methodologies for the Design and Control of
Central Cooling Plants&quot;.
PhD Thesis. University of Wisconsin - Madison.
Available
<a href=\"https://minds.wisconsin.edu/handle/1793/46694\">
online</a>.
</p>
<p>Mitchell, John W., and James E. Braun. 2012a.
Principles of heating, ventilation, and air conditioning in buildings.
Hoboken, N.J.: Wiley.</p>
<p>Mitchell, John W., and James E. Braun. 2012b.
&quot;Supplementary Material Chapter 2: Heat Exchangers for Cooling Applications&quot;.
Excerpt from Principles of heating, ventilation, and air conditioning in buildings.
Hoboken, N.J.: Wiley.
Available
<a href=\"http://bcs.wiley.com/he-bcs/Books?action=index&amp;itemId=0470624574&amp;bcsId=7185\">
online</a>.
</p>
<p>Elmahdy, A.H. and Mitalas, G.P. 1977.
&quot;A Simple Model for Cooling and Dehumidifying Coils for Use
In Calculating Energy Requirements for Buildings&quot;.
ASHRAE Transactions. Vol.83. Part 2. pp. 103-117.</p>
<p>Takagi, T. and Sugeno, M., 1985.
Fuzzy identification of systems and its applications to modeling and control.
&nbsp;IEEE transactions on systems, man, and cybernetics, (1), pp.116-132.</p>
</html>",                          revisions="<html>
<ul>
<li>Jan 21, 2021, by Donghun Kim:<br/>First implementation of the fuzzy model.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">issue 622</a> for more information. </li>
</ul>
</html>"));
      end WetCoilEffectivenessNTU;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        model HADryCoil
          "Sensible convective heat transfer model for air to water coil"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.ThermalConductance UA_nominal(min=0)
            "Thermal conductance at nominal flow"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_w
            "Water mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_a "Air mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          Modelica.Blocks.Interfaces.RealInput m1_flow(final unit="kg/s") "Mass flow rate medium 1"
            annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput m2_flow(final unit="kg/s") "Mass flow rate medium 2"
            annotation (Placement(transformation(extent={{-120,-80},{-100,-60}})));
          Modelica.Blocks.Interfaces.RealInput T_1(final unit="K") "Temperature medium 1"
            annotation (Placement(transformation(extent={{-120,20},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput T_2(final unit="K") "Temperature medium 2"
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealOutput hA_1(final unit="W/K")
            "Convective heat transfer medium 1" annotation (Placement(transformation(
                  extent={{100,60},{120,80}})));
          Modelica.Blocks.Interfaces.RealOutput hA_2(final unit="W/K")
            "Convective heat transfer medium 2" annotation (Placement(transformation(
                  extent={{100,-80},{120,-60}})));

          parameter Real r_nominal(min=0)=0.5
            "Ratio between air-side and water-side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_w(min=0)=UA_nominal * (r_nominal+1)/r_nominal
            "Water side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_a(min=0)=r_nominal * hA_nominal_w
            "Air side convective heat transfer coefficient, including fin resistance"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Real n_w(min=0, max=1)=0.85
            "Water-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Real n_a(min=0, max=1)=0.8
            "Air-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Modelica.SIunits.Temperature T0_w=
                  Modelica.SIunits.Conversions.from_degC(20) "Water temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.Temperature T0_a=
                  Modelica.SIunits.Conversions.from_degC(20) "Air temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Boolean waterSideFlowDependent=true
            "Set to false to make water-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideFlowDependent = true
            "Set to false to make air-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean waterSideTemperatureDependent = true
            "Set to false to make water-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideTemperatureDependent = true
            "Set to false to make air-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
      protected
          Real x_a(min=0)
            "Factor for air side temperature dependent variation of heat transfer coefficient";
          Real x_w(min=0)
            "Factor for water side temperature dependent variation of heat transfer coefficient";
          parameter Real s_w(min=0, fixed=false)
            "Coefficient for temperature dependence of water side heat transfer coefficient";
          Real fm_w "Fraction of actual to nominal mass flow rate";
          Real fm_a "Fraction of actual to nominal mass flow rate";
        initial equation
          s_w =  if waterSideTemperatureDependent then
                    0.014/(1+0.014*Modelica.SIunits.Conversions.to_degC(T0_w)) else
                      1;
        equation
          fm_w = if waterSideFlowDependent then
                      m1_flow / m_flow_nominal_w else 1;
          fm_a = if airSideFlowDependent then
                      m2_flow / m_flow_nominal_a else 1;
          x_w = if waterSideTemperatureDependent then
                 1 + s_w * (T_1-T0_w) else
                      1;
          x_a = if airSideTemperatureDependent then
                 1 + 7.8532E-4 * (T_2-T0_a) else
                      1;
          if waterSideFlowDependent then
            hA_1 = x_w * hA_nominal_w
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_w, n_w, 0.1);
          else
            hA_1 = x_w * hA_nominal_w;
          end if;

          if airSideFlowDependent then
            hA_2 = x_a * hA_nominal_a
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_a, n_a, 0.1);
          else
            hA_2 = x_a * hA_nominal_a;
          end if;
        annotation (Documentation(info="<html>
<p>
Model for sensible convective heat transfer coefficients for an air to water coil.
</p>
<p>
This model computes the convective heat transfer coefficient
for an air to water coil.
The parameters allow a user to enable or disable, individually
for each medium, the mass flow and/or the temperature dependence
of the convective heat transfer coefficients.
For a detailed explanation of the equation, see
the references below.
</p>
<h4>References</h4>
<ul>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7353\">
Simulation model finned water-air-coil without condensation</a>,
LBNL-42355,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7352\">
Simulation model air-to-air plate heat exchanger</a>,
LBNL-42354,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
April 9, 2017, by Michael Wetter:<br/>
Corrected coefficient in Taylor expansion of <code>x_a</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/698\">#698</a>.
</li>
<li>
June 8, 2010, by Michael Wetter:<br/>
Fixed bug in computation of <code>s_w</code>.
The old implementation used the current inlet water temperature instead
of the design condition that corresponds to <code>UA_nominal</code>.
</li>
<li>
April 16, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={            Text(
                  extent={{-60,90},{66,0}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="hA"),
                Ellipse(
                  extent={{-32,-10},{-12,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{34,-10},{54,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{0,-10},{20,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-64,-10},{-44,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-48,-40},{-28,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-16,-40},{4,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{16,-40},{36,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{50,-40},{70,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-68,-66},{-48,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,-66},{-16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-66},{16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{30,-66},{50,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}));
        end HADryCoil;

        partial model PartialEffectiveness
          "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(
            prescribedHeatFlowRate1=true,
            prescribedHeatFlowRate2=true,
            show_T=false);

          Medium1.Temperature T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow)
            "Inlet temperature medium 1";
          Medium2.Temperature T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow)
            "Inlet temperature medium 2";
          Modelica.SIunits.ThermalConductance C1_flow = abs(m1_flow)*
            ( if allowFlowReversal1 then
                   fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                   fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
                Medium1.specificHeatCapacityCp(state_a1_inflow))
            "Heat capacity flow rate medium 1";
          Modelica.SIunits.ThermalConductance C2_flow = abs(m2_flow)*
            ( if allowFlowReversal2 then
                   fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                   fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
                Medium2.specificHeatCapacityCp(state_a2_inflow))
            "Heat capacity flow rate medium 2";
          Modelica.SIunits.ThermalConductance CMin_flow(min=0) = min(C1_flow, C2_flow)
            "Minimum heat capacity flow rate";
          Modelica.SIunits.HeatFlowRate QMax_flow = CMin_flow*(T_in2 - T_in1)
            "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_default(fixed=false)
            "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_default(fixed=false)
            "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_small(fixed=false)
            "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1) = if allowFlowReversal1
            then Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small)
            else 1
            "Fraction of incoming state taken from port a1 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1) = if allowFlowReversal1
            then 1-fra_a1
            else 0
            "Fraction of incoming state taken from port b1 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1) = if allowFlowReversal2
            then Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1) = if allowFlowReversal2
            then 1-fra_a2
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
        initial equation
          cp1_default = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
            Medium1.p_default,
            Medium1.T_default,
            Medium1.X_default));
          cp2_default = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
            Medium2.p_default,
            Medium2.T_default,
            Medium2.X_default));
          CMin_flow_small = min(m1_flow_small*cp1_default, m2_flow_small*cp2_default);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models.
</p>
<p>
Classes that extend this model need to implement heat and
mass balance equations in a form like
</p>
<pre>
  // transferred heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
<p>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 21, 2019, by Filip Jorissen:<br/>
Revised implementation of all equations
such that a binding equation is used. 
I.e. we set the variable value at the variable definition
instead of using the equation section.
This allows overwriting the equation
when extending the model.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1102\">#1102</a>.
</li>
<li>
April 30, 2018, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate1=true</code> and 
<code>prescribedHeatFlowRate2=true</code>.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/907\">#907</a>.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Changed type of <code>T_in1</code> and <code>T_in2</code>
to <code>Medium1.Temperature</code> and <code>Medium2.Temperature</code>
to avoid an error because of conflicting start values if
<a href=\"modelica://Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl\">
Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl</a>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br/>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectiveness;

        model PartialEffectivenessNTU
          "Partial model for heat exchanger with effectiveness - NTU relation and no moisture condensation"
          extends
          Buildings.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
              sensibleOnly1=true,
              sensibleOnly2=true,
              Q1_flow = eps*QMax_flow,
              Q2_flow = -Q1_flow,
              mWat1_flow = 0,
              mWat2_flow = 0);
          import con = Buildings.Fluid.Types.HeatExchangerConfiguration;
          import flo = Buildings.Fluid.Types.HeatExchangerFlowRegime;

          parameter con configuration "Heat exchanger configuration"
            annotation (Evaluate=true);

          parameter Boolean use_Q_flow_nominal = true
            "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness"
            annotation (Evaluate=true,
                        Dialog(group="Nominal thermal performance"));

          parameter Modelica.SIunits.HeatFlowRate Q_flow_nominal(fixed=use_Q_flow_nominal)
            "Nominal heat flow rate (positive for heat transfer from 1 to 2)"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));
          parameter Modelica.SIunits.Temperature T_a1_nominal(fixed=use_Q_flow_nominal)
            "Nominal temperature at port a1"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));
          parameter Modelica.SIunits.Temperature T_a2_nominal(fixed=use_Q_flow_nominal)
            "Nominal temperature at port a2"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));

          parameter Real eps_nominal(fixed=not use_Q_flow_nominal)
            "Nominal heat transfer effectiveness"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=not use_Q_flow_nominal));

          input Modelica.SIunits.ThermalConductance UA "UA value";

          Real eps(min=0, max=1) "Heat exchanger effectiveness";

          // NTU has been removed as NTU goes to infinity as CMin goes to zero.
          // This quantity is not good for modeling.
          //  Real NTU(min=0) "Number of transfer units";
          final parameter Modelica.SIunits.ThermalConductance UA_nominal(fixed=false)
            "Nominal UA value";
          final parameter Real NTU_nominal(min=0, fixed=false)
            "Nominal number of transfer units";

      protected
          final parameter Medium1.ThermodynamicState sta1_default = Medium1.setState_pTX(
             T=Medium1.T_default,
             p=Medium1.p_default,
             X=Medium1.X_default[1:Medium1.nXi]) "Default state for medium 1";
          final parameter Medium2.ThermodynamicState sta2_default = Medium2.setState_pTX(
             T=Medium1.T_default,
             p=Medium2.p_default,
             X=Medium2.X_default[1:Medium2.nXi]) "Default state for medium 2";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_nominal(fixed=false)
            "Specific heat capacity of medium 1 at nominal condition";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_nominal(fixed=false)
            "Specific heat capacity of medium 2 at nominal condition";
          parameter Modelica.SIunits.ThermalConductance C1_flow_nominal(fixed=false)
            "Nominal capacity flow rate of Medium 1";
          parameter Modelica.SIunits.ThermalConductance C2_flow_nominal(fixed=false)
            "Nominal capacity flow rate of Medium 2";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_nominal(fixed=false)
            "Minimal capacity flow rate at nominal condition";
          parameter Modelica.SIunits.ThermalConductance CMax_flow_nominal(fixed=false)
            "Maximum capacity flow rate at nominal condition";
          parameter Real Z_nominal(
            min=0,
            max=1,
            fixed=false) "Ratio of capacity flow rate at nominal condition";
          parameter Modelica.SIunits.Temperature T_b1_nominal(fixed=false)
            "Nominal temperature at port b1";
          parameter Modelica.SIunits.Temperature T_b2_nominal(fixed=false)
            "Nominal temperature at port b2";
          parameter flo flowRegime_nominal(fixed=false)
            "Heat exchanger flow regime at nominal flow rates";
          flo flowRegime(fixed=false, start=flowRegime_nominal)
            "Heat exchanger flow regime";
        initial equation
          assert(m1_flow_nominal > 0,
            "m1_flow_nominal must be positive, m1_flow_nominal = " + String(
            m1_flow_nominal));
          assert(m2_flow_nominal > 0,
            "m2_flow_nominal must be positive, m2_flow_nominal = " + String(
            m2_flow_nominal));

          cp1_nominal = Medium1.specificHeatCapacityCp(sta1_default);
          cp2_nominal = Medium2.specificHeatCapacityCp(sta2_default);

          // Heat transferred from fluid 1 to 2 at nominal condition
          C1_flow_nominal = m1_flow_nominal*cp1_nominal;
          C2_flow_nominal = m2_flow_nominal*cp2_nominal;
          CMin_flow_nominal = min(C1_flow_nominal, C2_flow_nominal);
          CMax_flow_nominal = max(C1_flow_nominal, C2_flow_nominal);
          Z_nominal = CMin_flow_nominal/CMax_flow_nominal;
          Q_flow_nominal = m1_flow_nominal*cp1_nominal*(T_a1_nominal - T_b1_nominal);
          if use_Q_flow_nominal then
            Q_flow_nominal = -m2_flow_nominal*cp2_nominal*(T_a2_nominal - T_b2_nominal);
            eps_nominal = abs(Q_flow_nominal/((T_a1_nominal - T_a2_nominal)*
              CMin_flow_nominal));
            assert(Q_flow_nominal / (T_a1_nominal - T_a2_nominal) >= 0,
            "In " + getInstanceName() + ": Q_flow_nominal is defined with the wrong sign. " +
            "By convention, a positive value describes a heat flow from Medium1 to Medium2. " +
            "The parameter T_a1_nominal should then be larger than T_a2_nominal." +
            "Future version of this library might enforce this convention and throw an error.",
            level = AssertionLevel.warning);
          else
            T_a1_nominal = Medium1.T_default;
            T_a2_nominal = Medium2.T_default;
            T_b1_nominal = Medium1.T_default;
            T_b2_nominal = Medium2.T_default;
          end if;
          assert(eps_nominal > 0 and eps_nominal < 1,
            "eps_nominal out of bounds, eps_nominal = " + String(eps_nominal) +
            "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = "
             + String(abs(Q_flow_nominal/0.8/CMin_flow_nominal)) +
            "\n  or increase flow rates. The current parameters result in " +
            "\n  CMin_flow_nominal = " + String(CMin_flow_nominal) +
            "\n  CMax_flow_nominal = " + String(CMax_flow_nominal));
          // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
          if (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
            flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinMixedCMaxUnmixed
               else flo.CrossFlowCMinUnmixedCMaxMixed;
          elseif (configuration == con.CrossFlowStream1UnmixedStream2Mixed) then
            flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinUnmixedCMaxMixed
               else flo.CrossFlowCMinMixedCMaxUnmixed;
          elseif (configuration == con.ParallelFlow) then
            flowRegime_nominal = flo.ParallelFlow;
          elseif (configuration == con.CounterFlow) then
            flowRegime_nominal = flo.CounterFlow;
          elseif (configuration == con.CrossFlowUnmixed) then
            flowRegime_nominal = flo.CrossFlowUnmixed;
          else
            // Invalid flow regime. Assign a value to flowRegime_nominal, and stop with an assert
            flowRegime_nominal = flo.CrossFlowUnmixed;
            assert(configuration >= con.ParallelFlow and configuration <= con.CrossFlowStream1UnmixedStream2Mixed,
              "Invalid heat exchanger configuration.");
          end if;
          // The equation sorter of Dymola 7.3 does not guarantee that the above assert is tested prior to the
          // function call on the next line. Thus, we add the test on eps_nominal to avoid an error in ntu_epsilonZ
          // for invalid input arguments
          NTU_nominal = if (eps_nominal > 0 and eps_nominal < 1) then
            Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(
            eps=eps_nominal,
            Z=Z_nominal,
            flowRegime=Integer(flowRegime_nominal)) else 0;
          UA_nominal = NTU_nominal*CMin_flow_nominal;
        equation
          // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
          if (configuration == con.ParallelFlow) then
            flowRegime = if (C1_flow*C2_flow >= 0) then flo.ParallelFlow else flo.CounterFlow;
          elseif (configuration == con.CounterFlow) then
            flowRegime = if (C1_flow*C2_flow >= 0) then flo.CounterFlow else flo.ParallelFlow;
          elseif (configuration == con.CrossFlowUnmixed) then
            flowRegime = flo.CrossFlowUnmixed;
          elseif (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
            flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinMixedCMaxUnmixed
               else flo.CrossFlowCMinUnmixedCMaxMixed;
          else
            // have ( configuration == con.CrossFlowStream1UnmixedStream2Mixed)
            flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinUnmixedCMaxMixed
               else flo.CrossFlowCMinMixedCMaxUnmixed;
          end if;

          // Effectiveness
          eps = Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(
            UA=UA,
            C1_flow=C1_flow,
            C2_flow=C2_flow,
            flowRegime=Integer(flowRegime),
            CMin_flow_nominal=CMin_flow_nominal,
            CMax_flow_nominal=CMax_flow_nominal,
            delta=delta);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-82}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        defaultComponentName="hex",
            Documentation(info="<html>
<p>
Partial model of a heat exchanger without humidity condensation.
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub>  &epsilon;<br/>
  &epsilon; = f(NTU, Z, flowRegime),
</p>
<p>
where
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred,
<i>&epsilon;</i> is the heat transfer effectiveness,
<i>NTU</i> is the Number of Transfer Units,
<i>Z</i> is the ratio of minimum to maximum capacity flow rate and
<i>flowRegime</i> is the heat exchanger flow regime.
such as
parallel flow, cross flow or counter flow.
</p>
<p>
The flow regimes depend on the heat exchanger configuration. All configurations
defined in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerConfiguration\">
Buildings.Fluid.Types.HeatExchangerConfiguration</a>
are supported.
</p>
<p>
Models that extend from this partial model need to provide an assignment
for <code>UA</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 25, 2021 by Baptiste Ravache:<br/>
Added a warning for when Q_flow_nominal is specified with the wrong sign.
</li>
<li>
January 10, 2018 by Michael Wetter:<br/>
Removed variable <code>Z</code> that is not used.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1328\">issue 1328</a>.
</li>
<li>
January 10, 2018 by Filip Jorissen:<br/>
Corrected an error where the value of NTU was assigned to Z.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1328\">issue 1328</a>.
</li>
<li>
February 27, 2016 by Michael Wetter:<br/>
Introduced <code>sta1_default</code> and <code>sta2_default</code>
to enable translation under OpenModelica.
Removed <code>max=1</code> attribute for <code>Z</code>. This is needed as near
zero flow, <code>Z</code> can be larger than one due to the regularization.
As <code>Z</code> is not used in this model other than for reporting, this bound
need not be enforced (and the calculation of <code>eps</code> is fine at these small flow rates).
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/490\">issue 490</a>.
</li>
<li>
April 29, 2014 by Michael Wetter:<br/>
Changed <code>assert</code> statement to avoid comparing
enumeration with an integer, which triggers a warning
in Dymola 2015.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectivenessNTU;

        model WetCoilDryRegime
          "Fully dry coil model"

          // - water
          input Modelica.SIunits.ThermalConductance UAWat
            "UA for water side";
          input Modelica.SIunits.MassFlowRate mWat_flow
            "Mass flow rate for water";
          input Modelica.SIunits.MassFlowRate mWatNonZer_flow(min=Modelica.Constants.eps)
            "Mass flow rate for water, bounded away from zero";

          input Modelica.SIunits.SpecificHeatCapacity cpWat
            "Specific heat capacity of water";
          input Modelica.SIunits.Temperature TWatIn
            "Water temperature at inlet";
          // -- air
          input Modelica.SIunits.ThermalConductance UAAir
            "UA for air side";
          input Modelica.SIunits.MassFlowRate mAir_flow(min=Modelica.Constants.eps)
            "Mass flow rate of air";
          input Modelica.SIunits.MassFlowRate mAirNonZer_flow(min=Modelica.Constants.eps)
            "Mass flow rate for air, bounded away from zero";
          input Modelica.SIunits.SpecificHeatCapacity cpAir
            "Specific heat capacity of moist air at constant pressure";
          input Modelica.SIunits.Temperature TAirIn
            "Temperature of air at inlet";
          // -- misc.
          input Buildings.Fluid.Types.HeatExchangerFlowRegime cfg
            "The flow regime of the heat exchanger";
          input Modelica.SIunits.MassFlowRate mAir_flow_nominal
            "Nominal mass flow rate for air";
          input Modelica.SIunits.MassFlowRate mWat_flow_nominal
            "Nominal mass flow rate for water";

          parameter Real delta = 1E-3 "Small value used for smoothing";

          output Modelica.SIunits.HeatFlowRate QTot_flow
            "Heat transferred from water to air";
          output Modelica.SIunits.Temperature TWatOut
            "Temperature of water at outlet";
          output Modelica.SIunits.Temperature TAirOut
            "Temperature of air at the outlet";
          output Real eps(min=0, max=1, unit="1")
            "Effectiveness for heat exchanger";
          Modelica.SIunits.ThermalConductance CWat_flow=mWat_flow*cpWat
            "Capacitance rate of water";
          Modelica.SIunits.ThermalConductance CAir_flow=mAir_flow*cpAir
            "Capacitance rate of air";
          Modelica.SIunits.ThermalConductance CMin_flow_nominal=
            min(mAir_flow_nominal*cpAir,mWat_flow_nominal*cpWat)
            "Minimum capacity rate";
          Modelica.SIunits.ThermalConductance CMax_flow_nominal=
            max(mAir_flow_nominal*cpAir,mWat_flow_nominal*cpWat)
            "Maximum capacity rate";
          Modelica.SIunits.ThermalConductance CMin_flow=
            Buildings.Utilities.Math.Functions.smoothMin(
              x1=CAir_flow,x2=CWat_flow,deltaX=1E-3*(CMax_flow_nominal-CMin_flow_nominal))
            "Minimum capacity rate";
          Modelica.SIunits.ThermalConductance UA
            "Overall heat transfer coefficient";
          output Modelica.SIunits.Temperature TSurAirOut
            "Surface Temperature at air outlet";
        equation
          UA = 1/ (1 / UAAir + 1 / UAWat);

          eps=epsilon_C(
            UA=UA,
            C1_flow=CWat_flow,
            C2_flow=CAir_flow,
            flowRegime=Integer(cfg),
            CMin_flow_nominal= CMin_flow_nominal,
            CMax_flow_nominal=CMax_flow_nominal,
            delta= delta);

          QTot_flow = eps*CMin_flow*(TAirIn-TWatIn);
          TAirOut=TAirIn-QTot_flow/(mAirNonZer_flow*cpAir);
          TWatOut=TWatIn+QTot_flow/(mWatNonZer_flow*cpWat);

          (TAirOut-TSurAirOut)*UAAir=(TSurAirOut-TWatIn)*UAWat;

          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid)}), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(revisions="<html>
<ul>
<li>Jan 21, 2021, by Donghun Kim:<br/>First implementation of the fuzzy model.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">issue 622</a>
for more information.</li>
</ul>
</html>",         info="<html>
<p>This model implements the calculation for a 100% dry coil.</p>
<p>
See
<a href=\"modelica://Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU\">
Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU</a>
for documentation.
</p>
</html>"));
        end WetCoilDryRegime;

        model WetCoilDryWetRegime
          "Model implementing the switching algorithm of the TK-fuzzy model for cooling coil application"

          parameter Modelica.SIunits.MassFlowRate mWat_flow_nominal(min=0)
            "Nominal mass flow rate for water"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate mAir_flow_nominal(min=0)
            "Nominal mass flow rate for air"
            annotation(Dialog(group = "Nominal condition"));

          input Real Qfac(final unit="1")
            "a smoothing factor to prevent division-by-zero";

          input Buildings.Fluid.Types.HeatExchangerFlowRegime cfg=
            Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow
              "heat exchanger configuration";

          // -- Water
          Modelica.Blocks.Interfaces.RealInput UAWat(
            final quantity="ThermalConductance",
            final unit="W/K")
            "Product of heat transfer coefficient times area for water side"
            annotation (Placement(transformation(extent={{-160,100},{-140,120}}),
                iconTransformation(extent={{-160,100},{-140,120}})));
          Modelica.Blocks.Interfaces.RealInput mWat_flow(
            quantity="MassFlowRate",
            min = 0,
            final unit="kg/s")
            "Mass flow rate for water"
            annotation (Placement(transformation(extent={{-160,80},{-140,100}}),
                iconTransformation(extent={{-160,80},{-140,100}})));
          Modelica.Blocks.Interfaces.RealInput cpWat(
            final quantity="SpecificHeatCapacity",
            final unit="J/(kg.K)")
            "Inlet water temperature"
            annotation (Placement(transformation(extent={{-160,60},{-140,80}}),
                iconTransformation(extent={{-160,60},{-140,80}})));
          Modelica.Blocks.Interfaces.RealInput TWatIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 200,
            start = 288.15,
            nominal = 300,
            displayUnit="degC")
            "Inlet water temperature"
            annotation (Placement(transformation(extent={{-160,40},{-140,60}}),
                iconTransformation(extent={{-160,40},{-140,60}})));
          // -- Air
          Modelica.Blocks.Interfaces.RealInput UAAir(
            final quantity="ThermalConductance",
            final unit="W/K")
            "Product of heat transfer coefficient times area for air side"
            annotation (Placement(transformation(extent={{-160,-120},{-140,-100}}),
                iconTransformation(extent={{-160,-120},{-140,-100}})));
          Modelica.Blocks.Interfaces.RealInput mAir_flow(
            quantity="MassFlowRate",
            min = 0,
            final unit="kg/s")
            "Mass flow rate for air"
            annotation (Placement(transformation(extent={{-160,-100},{-140,-80}}),
                iconTransformation(extent={{-160,-100},{-140,-80}})));
          Modelica.Blocks.Interfaces.RealInput cpAir(
            final quantity="SpecificHeatCapacity",
            final unit="J/(kg.K)")
            "Inlet specific heat capacity (at constant pressure)"
            annotation (Placement(
                transformation(extent={{-160,-80},{-140,-60}}), iconTransformation(
                  extent={{-160,-80},{-140,-60}})));
          Modelica.Blocks.Interfaces.RealInput TAirIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 200,
            start = 288.15,
            nominal = 300,
            displayUnit="degC")
            "Inlet air temperature"
            annotation (Placement(transformation(extent={{-160,-60},{-140,-40}}),
                iconTransformation(extent={{-160,-60},{-140,-40}})));
          Modelica.Blocks.Interfaces.RealInput hAirIn(
            final quantity="SpecificEnergy",
            final unit="J/kg")
            "Inlet air enthalpy"
            annotation (
              Placement(transformation(extent={{-160,-40},{-140,-20}}),
                iconTransformation(extent={{-160,-40},{-140,-20}})));
          Modelica.Blocks.Interfaces.RealInput pAir(
            final quantity="Pressure",
            final unit="Pa",
            displayUnit="bar",
            min=70000,
            nominal = 1e5)
            "Inlet air absolute pressure"
            annotation (Placement(transformation(extent={{-160,-20},{-140,0}}),
                iconTransformation(extent={{-160,-20},{-140,0}})));
          Modelica.Blocks.Interfaces.RealInput X_wAirIn(
            min=0,
            max=1,
            unit="1")
            "Mass fraction of water in inlet air (kg water/kg total air)"
            annotation (
              Placement(transformation(extent={{-160,0},{-140,20}}), iconTransformation(
                  extent={{-160,0},{-140,20}})));

          Modelica.Blocks.Interfaces.RealOutput QTot_flow(
            final quantity="Power",
            final unit="W")
            "Total heat transfer from water into air, negative for cooling"
            annotation (
              Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={150,-20})));
          Modelica.Blocks.Interfaces.RealOutput QSen_flow(
            final quantity="Power",
            final unit="W")
            "Sensible heat transfer from water into air, negative for cooling"
            annotation (
              Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={150,-60})));
          Modelica.SIunits.HeatFlowRate QLat_flow  "Latent heat transfer rate";

          Modelica.Blocks.Interfaces.RealOutput mCon_flow(
            quantity="MassFlowRate",
            final unit="kg/s")
            "Mass flow of the condensate, negative for dehumidification"
            annotation (
              Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=0,
                origin={150,-100})));
          Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilDryRegime fullyDry(
            final UAWat=UAWat,
            final mWat_flow=mWat_flow,
            final cpWat=cpWat,
            final TWatIn=TWatIn,
            final UAAir=UAAir,
            final mAir_flow=mAir_flow,
            final mWatNonZer_flow=mWatNonZer_flow,
            final mAirNonZer_flow=mAirNonZer_flow,
            final cpAir=cpAir,
            final TAirIn=TAirIn,
            final cfg=cfg,
            final mAir_flow_nominal=mAir_flow_nominal,
            final mWat_flow_nominal=mWat_flow_nominal) "Fully-dry coil model";

          Buildings.Fluid.HeatExchangers.BaseClasses.WetCoilWetRegime fullyWet(
            final UAWat=UAWat,
            final mWat_flow=mWat_flow,
            final cpWat=cpWat,
            final TWatIn=TWatIn,
            final UAAir=UAAir,
            final mAir_flow=mAir_flow,
            final mWatNonZer_flow=mWatNonZer_flow,
            final mAirNonZer_flow=mAirNonZer_flow,
            final cpAir=cpAir,
            final TAirIn=TAirIn,
            final cfg=cfg,
            final mAir_flow_nominal=mAir_flow_nominal,
            final mWat_flow_nominal=mWat_flow_nominal,
            final pAir=pAir,
            final X_wAirIn=X_wAirIn) "Fully-wet coil model";

          Real dryFra(final unit="1", min=0, max=1)
            "Dry fraction, 0.3 means condensation occurs at 30% heat exchange length from air inlet";
      protected
          Modelica.SIunits.MassFlowRate mAirNonZer_flow(min=Modelica.Constants.eps)=
            Buildings.Utilities.Math.Functions.smoothMax(
              x1=mAir_flow,
              x2=1E-3       *mAir_flow_nominal,
              deltaX=0.25E-3*mAir_flow_nominal)
            "Mass flow rate of air";
          Modelica.SIunits.MassFlowRate mWatNonZer_flow(min=Modelica.Constants.eps)=
            Buildings.Utilities.Math.Functions.smoothMax(
              x1=mWat_flow,
              x2=1E-3       *mWat_flow_nominal,
              deltaX=0.25E-3*mWat_flow_nominal)
            "Mass flow rate of water";

          Modelica.SIunits.Temperature TAirInDewPoi
            "Dew point temperature of incoming air";

          Buildings.Utilities.Psychrometrics.pW_X pWIn(
            final X_w=X_wAirIn,
            final p_in=pAir);
          Buildings.Utilities.Psychrometrics.TDewPoi_pW TDewIn(
            final p_w=pWIn.p_w);

          //-- Values for fuzzy logics
          Real mu_FW(final unit="1", min=0, max=1), mu_FD(unit="1",min=0, max=1)
            "Membership functions for Fully-Wet and Fully-Dry conditions";
          Real w_FW(final unit="1", min=0, max=1),  w_FD(unit="1",min=0, max=1)
            "Normalized weight functions for Fully-Wet and Fully-Dry conditions";

        equation

          TAirInDewPoi=TDewIn.T;

          mu_FW= Buildings.Utilities.Math.Functions.spliceFunction(
          pos=0,neg=1,x=fullyWet.TSurAirIn-TAirInDewPoi,
          deltax=Buildings.Utilities.Math.Functions.smoothMax(abs(fullyDry.TSurAirOut-fullyWet.TSurAirIn), 1e-2,1e-3));
          //max(abs(fullyDry.TSurAirOut- fullyWet.TSurAirIn),1e-3));

          mu_FD= Buildings.Utilities.Math.Functions.spliceFunction(
          pos=1,neg=0,x=fullyDry.TSurAirOut-TAirInDewPoi,
          deltax=Buildings.Utilities.Math.Functions.smoothMax(abs(fullyDry.TSurAirOut-fullyWet.TSurAirIn), 1e-2,1e-3));
          //max(abs(fullyDry.TSurAirOut- fullyWet.TSurAirIn),1e-3));

          w_FW=mu_FW/(mu_FW+mu_FD);
          w_FD=mu_FD/(mu_FW+mu_FD);

          QTot_flow= -(w_FW*fullyWet.QTot_flow+w_FD*fullyDry.QTot_flow)*Qfac;
          QSen_flow= -(w_FW*fullyWet.QSen_flow+w_FD*fullyDry.QTot_flow)*Qfac;
          dryFra= w_FD;

          QLat_flow=QTot_flow-QSen_flow;
          mCon_flow=QLat_flow/Buildings.Utilities.Psychrometrics.Constants.h_fg*Qfac;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,-120},
                    {140,120}}), graphics={
                Rectangle(
                  extent={{-140,120},{140,-120}},
                  lineColor={0,0,0},
                  lineThickness=0.5,
                  pattern=LinePattern.Dot,
                  fillColor={236,236,236},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{20,40},{100,-40}},
                  lineColor={28,108,200},
                  fillColor={170,227,255},
                  fillPattern=FillPattern.Forward),
                Text(
                  extent={{24,36},{96,2}},
                  textStyle={TextStyle.Bold},
                  pattern=LinePattern.None,
                  textString="WET",
                  lineColor={0,0,0}),
                Line(
                  points={{20,0},{120,0}},
                  color={28,108,200},
                  thickness=1,
                  pattern=LinePattern.Dash),
                Ellipse(
                  extent={{72,0},{66,-6}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{82,-4},{76,-10}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{96,0},{88,-8}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{64,-4},{58,-10}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{54,0},{48,-6}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{42,-4},{36,-10}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{32,0},{24,-8}},
                  lineColor={28,108,200},
                  fillColor={170,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,40},{20,-40}},
                  lineColor={28,108,200},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Forward),
                Text(
                  extent={{-16,-4},{56,-38}},
                  textStyle={TextStyle.Bold},
                  textString="CALCS",
                  pattern=LinePattern.None),
                Line(
                  points={{-80,0},{20,0}},
                  color={28,108,200},
                  thickness=1,
                  pattern=LinePattern.Dash),
                Text(
                  extent={{-56,36},{16,2}},
                  textStyle={TextStyle.Bold},
                  textString="DRY",
                  pattern=LinePattern.None),
                Text(
                  extent={{-22,60},{58,40}},
                  lineColor={28,108,200},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Forward,
                  textString="Water",
                  textStyle={TextStyle.Italic}),
                Text(
                  extent={{-20,-40},{60,-60}},
                  lineColor={28,108,200},
                  fillColor={170,170,255},
                  fillPattern=FillPattern.Forward,
                  textString="Air",
                  textStyle={TextStyle.Italic}),
                Text(
                  extent={{-116,-104},{-116,-116}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="hA"),
                Text(
                  extent={{-116,116},{-116,104}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="hA"),
                Text(
                  extent={{-116,96},{-116,84}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="masFlo"),
                Text(
                  extent={{-116,76},{-116,64}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="cp"),
                Text(
                  extent={{-116,56},{-116,44}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="T_in"),
                Text(
                  extent={{-116,-84},{-116,-96}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="masFlo"),
                Text(
                  extent={{-116,-64},{-116,-76}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="cp"),
                Text(
                  extent={{-116,-44},{-116,-56}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="T_in"),
                Text(
                  extent={{-116,-24},{-116,-36}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="h_in"),
                Text(
                  extent={{-116,-4},{-116,-16}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="p_in"),
                Text(
                  extent={{-116,16},{-116,4}},
                  lineColor={28,108,200},
                  horizontalAlignment=TextAlignment.Left,
                  textString="w_in"),
                Text(
                  extent={{120,-12},{120,-24}},
                  lineColor={28,108,200},
                  textString="QTot_flow"),
                Text(
                  extent={{104,-94},{104,-106}},
                  lineColor={28,108,200},
                  textString="mCon_flow"),
                Text(
                  extent={{118,-52},{118,-64}},
                  lineColor={28,108,200},
                  textString="QSen")}),                                  Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-140,-120},{140,120}})),
            Documentation(revisions="<html>
<ul>
<li>Jan 21, 2021, by Donghun Kim:<br/>First implementation of the fuzzy model.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">issue 622</a> for more information.
</li>
</ul>
</html>",         info="<html>
<p>
This model implements the switching algorithm for the dry and wet regime.
</p>
<p>
The switching criteria for (counter-flow) cooling coil modes are as follows.</p>
<p>
R1: If the coil surface temperature at the air inlet is lower than the dew-point
temperature at the inlet to the coil, then the cooling coil surface is fully-wet.</p>
<p>
R2: If the surface temperature at the air outlet section is higher than
the dew-point temperature of the air at the inlet, then the cooling coil surface is fully-dry.</p>
<p>
At each point of a simulation time step, the fuzzy-modeling approach determines
the weights for R1 and R2 respectively (namely <i>&mu;<sub>FW</sub></i> and <i>&mu;<sub>FD</sub></i>)
from the dew-point and coil surface temperatures.</p>
<p>
It calculates total and sensible heat transfer rates according to the weights as follows.
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>tot</sub>=&mu;<sub>FD</sub> Q&#775;<sub>tot,FD</sub>+&mu;<sub>FW</sub> Q<sub>tot,FW</sub>
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>sen</sub>=&mu;<sub>FD</sub> Q&#775;<sub>sen,FD</sub>+&mu;<sub>FW</sub> Q<sub>sen,FW</sub>
</p>
<p>
The fuzzy-modeling ensures <i>&mu;<sub>FW</sub> + &mu;<sub>FD</sub> = 1</i>,
<i>&mu;<sub>FW</sub> &gt;=0</i> and <i>&mu;<sub>FD</sub> &gt;=0</i>, which means the fuzzy
model outcomes of <i>Q&#775;<sub>sen</sub></i> and <i>Q&#775;<sub>tot</sub></i> are always convex combinations of heat transfer
rates for fully-dry and fully-wet modes and therefore are always bounded by them.
</p>
<p>
The modeling approach also results in <i>n</i>-th order differentiable model
depending on the selection of the underlying membership functions. This cooling
coil model is once continuously differentiable at the mode switches.
</p>
</html>"));
        end WetCoilDryWetRegime;

        model WetCoilUARated
          "Model that calculates the UA-value from cooling coil data at rated conditions."

          replaceable package MediumA=Buildings.Media.Air
            constrainedby Modelica.Media.Interfaces.PartialMedium
            "Air-side medium";
          replaceable package MediumW=Buildings.Media.Water
            constrainedby Modelica.Media.Interfaces.PartialMedium
            "Water-side medium";

          parameter Boolean use_Q_flow_nominal = false
            "Set to true to specify Q_flow_nominal and inlet conditions, or to false to specify UA_nominal"
            annotation (
              Evaluate=true,
              Dialog(group="Nominal thermal performance"));
          parameter Modelica.SIunits.HeatFlowRate QTot_flow
            "Nominal heat flow rate (positive for heat transfer from 1 to 2)";
          parameter Modelica.SIunits.Temperature TAirIn
            "Air inlet temperature at a rated condition";

          parameter Modelica.SIunits.MassFraction X_wAirIn
            "Mass fraction of water in inlet air at a rated condition";
          parameter Modelica.SIunits.Temperature TWatIn
            "Water inlet temperature at a rated condition";

          parameter Modelica.SIunits.MassFlowRate mAir_flow
            "Air mass flow rate at a rated condition";
          parameter Modelica.SIunits.MassFlowRate mWat_flow
            "Water mass flow rate at a rated condition";
          parameter Modelica.SIunits.ThermalConductance UA
            "the overall heat transfer coefficient for a fully dry condition";
          parameter Real r_nominal(min=0, max=1)
            "Ratio between air-side and water-side convective heat transfer at nominal condition";

      protected
          constant Modelica.SIunits.SpecificEnthalpy hfg=
            Buildings.Utilities.Psychrometrics.Constants.h_fg
            "Enthapy of vaporization of water";
          constant Modelica.SIunits.SpecificEnthalpy hUnit=1
            "Physical dimension of specific enthalpy used for a unit conversion";
          constant Modelica.SIunits.Temperature TUnit=1
            "Physical dimension of temperature used for a unit conversion";
          constant Modelica.SIunits.SpecificHeatCapacity cpUnit=1
            "Physical dimension of specific heat capacity used for a unit conversion";
          parameter Modelica.SIunits.Temperature TAirOut(fixed=false)
            "Air outlet temperature  at a rated condition";
          parameter Modelica.SIunits.Temperature TWatOut=
            TWatIn - QTot_flow / cpWat / mWat_flow
            "Water outlet temperature at a rated condition";
          parameter Modelica.SIunits.SpecificEnthalpy hAirIn = MediumA.specificEnthalpy_pTX(
            p=MediumA.p_default, T=TAirIn, X={X_wAirIn, 1-X_wAirIn})
            "Enthalpy of incoming moist air at a rated condition";
          parameter MediumA.ThermodynamicState staAir=MediumA.setState_phX(
            p=MediumA.p_default, h=hAirIn, X={X_wAirIn, 1-X_wAirIn})
            "Inlet air thermodynamic state";
          parameter Modelica.SIunits.SpecificHeatCapacity cpAir=
            MediumA.specificHeatCapacityCp(staAir)
            "Isobaric specific heat capacity of air";
          parameter Modelica.SIunits.SpecificEnthalpy hAirOut=
            hAirIn + QTot_flow / mAir_flow
            "Enthalpy of outgoing moist air at a rated condition";
          parameter Modelica.SIunits.SpecificEnthalpy hWatIn = MediumW.specificEnthalpy_pTX(
            p=MediumW.p_default, T=TWatIn, X=MediumW.X_default)
            "Enthalpy of incoming moist air at a rated condition";
          parameter MediumW.ThermodynamicState staWat=MediumW.setState_phX(
            p=MediumW.p_default, h=hWatIn, X=MediumW.X_default)
            "Inlet water thermodynamic state";
          parameter Modelica.SIunits.SpecificHeatCapacity cpWat=
              MediumW.specificHeatCapacityCp(staWat)
            "Isobaric specific heat capacity of water";
          parameter Modelica.SIunits.SpecificHeatCapacity cpEff(fixed=false, min= 0)
            "Effective specific heat: change in saturated moist air enthalpy with respect to
    temperature along the saturation line between inlet and outlet water temperatures";
          parameter Modelica.SIunits.SpecificEnthalpy LMED(fixed=false)
            "Log mean enthalpy difference";
          parameter Modelica.SIunits.MassFlowRate UASta(fixed=false, min=0, start=1/(1/10+1/20))
            "Overall heat transfer coefficient for enthalpy difference";
          parameter Modelica.SIunits.ThermalConductance UAAir(min=0,start=10,fixed=false)
            "Air side convective heat transfer coefficient, including fin resistance";
          parameter Modelica.SIunits.ThermalConductance UAWat(min=0,start=20,fixed=false)
            "Water side convective heat transfer coefficient";
          parameter Boolean isFulDry(fixed=false)
            "Indicator of the fully-dry coil regime";
          parameter Boolean isFulWet(fixed=false)
            "Indicator of the fully-wet coil regime";
          parameter Modelica.SIunits.AbsolutePressure pSatTWatIn=
            Buildings.Utilities.Psychrometrics.Functions.saturationPressure(TWatIn)
            "Saturation pressure of water at the water inlet temperature";
          parameter Modelica.SIunits.MassFraction X_wSatTWatIn=
            Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
              pSat=pSatTWatIn, p=MediumA.p_default, phi=1)
            "Mass fraction of water in saturated moist air at the water inlet temperature";
          parameter Modelica.SIunits.SpecificEnthalpy hSatTWatIn=
            Buildings.Media.Air.specificEnthalpy_pTX(
              p=MediumA.p_default, T=TWatIn, X={X_wSatTWatIn,1-X_wSatTWatIn})
            "Enthalpy of saturated moist air at the water inlet temperature";
          parameter Modelica.SIunits.AbsolutePressure pSatTWatOut=
            Buildings.Utilities.Psychrometrics.Functions.saturationPressure(TWatOut)
            "Saturation pressure of water at the water oulet temperature";
          parameter Modelica.SIunits.MassFraction X_wSatTWatOut=
            Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
              pSat=pSatTWatOut, p=MediumA.p_default, phi=1)
            "Mass fraction of water in saturated moist air at the water outlet temperature";
          parameter Modelica.SIunits.SpecificEnthalpy hSatTWatOut=
            Buildings.Media.Air.specificEnthalpy_pTX(
              p=MediumA.p_default, T=TWatOut, X={X_wSatTWatOut,1-X_wSatTWatOut})
            "Enthalpy of saturated moist air at the water oulet temperature";
        initial equation
          isFulDry = if use_Q_flow_nominal then (X_wSatTWatIn >= X_wAirIn) else true;
          isFulWet = if use_Q_flow_nominal then (X_wSatTWatOut <= X_wAirIn) else true;
          assert(
            not use_Q_flow_nominal or
              hAirOut >= hSatTWatIn and hAirIn >= hSatTWatOut or
              hAirOut <= hSatTWatIn and hAirIn <= hSatTWatOut,
            "In " + getInstanceName() +
            ": The moist air enthalpy at the coil inlet or outlet is unrealistically low. " +
            "Check the rated conditions.");
          assert(
            isFulDry or isFulWet,
            "In " + getInstanceName() +
            ": The nominal conditions correspond to a partially-wet coil regime. " +
            "The modeling uncertainty under such conditions has not been assessed. " +
            "Rather specify nominal conditions in fully-dry or fully-wet regime.",
            level=AssertionLevel.warning);
          if use_Q_flow_nominal then
            if isFulDry then
              TAirOut = TAirIn + QTot_flow / mAir_flow / cpAir;
              LMED=Buildings.Fluid.HeatExchangers.BaseClasses.lmtd(
                TWatIn,
                TWatOut,
                TAirIn,
                TAirOut) / TUnit * hUnit;
              QTot_flow=LMED*UASta;
              cpEff = 0;
              UA = UASta*cpUnit;
            else //fully wet
              // calculation of overall UAsta based on log mean enthalpy difference
              LMED=Buildings.Fluid.HeatExchangers.BaseClasses.lmtd(
                hSatTWatIn/hUnit*TUnit,
                hSatTWatOut/hUnit*TUnit,
                hAirIn/hUnit*TUnit,
                hAirOut/hUnit*TUnit) / TUnit * hUnit;
              QTot_flow=LMED*UASta;
              cpEff= (hSatTWatOut-hSatTWatIn)/(TWatOut-TWatIn);
              UASta = (UAAir/cpAir)/(1 + (cpEff*UAAir)/(cpAir*UAWat));
              // Dummy value.
              TAirOut=MediumA.T_default;
            end if;
          else
            // Dummy values.
            TAirIn=MediumA.T_default;
            TAirOut=MediumA.T_default;
            X_wAirIn=MediumA.X_default[1];
            TWatIn=MediumA.T_default;
            TWatOut=MediumA.T_default;
            hAirIn=MediumA.h_default;
            hAirOut=MediumA.h_default;
            LMED=hUnit;
            -QTot_flow=LMED*UASta;
            cpEff= 0;
          end if;

          UAWat = UAAir / r_nominal;
          UA = 1/ (1/UAAir  + 1/UAWat);

          annotation (Icon(coordinateSystem(preserveAspectRatio=false),
            graphics={
                Rectangle(
                extent={{100,-98},{-100,100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}), Diagram(
              coordinateSystem(preserveAspectRatio=false)),
            Documentation(revisions="<html>
<ul>
<li>
February 18, 2021 by Donghun Kim:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
This model calculates the overall heat transfer coefficient, i.e., 
<i>UA</i>-value, from cooling coil data at rated conditions.
</p>
<p>
The main limitation of the current implementation is that the rated 
conditions should correspond to a fully-dry or a fully-wet coil regime.
The modeling uncertainty yielded by partially-wet rated conditions
has not been assessed yet.
</p>
</html>"));
        end WetCoilUARated;

        model WetCoilWetRegime
          "Fully wet coil model using esilon_C.mo function"
          constant Real cpEff0=2050 "Used for scaling";
          constant Real cpWat0=4200 "Used for scaling";
          parameter Real delta = 1E-3 "Small value used for smoothing";
          constant Modelica.SIunits.SpecificHeatCapacity cpDum=1
            "Dummy cp to eliminate the warning message of the unit mismatch when using the eps-NTU model for the wet coil";
          constant Modelica.SIunits.TemperatureDifference dTWat=0.1;
          parameter Real tau=6*60
            "Time constant for the state estimation: introduced to avoid the algebraic loop of the wet coil equations";

          // - water
          input Modelica.SIunits.ThermalConductance UAWat
            "UA for water side";
          input Modelica.SIunits.MassFlowRate mWat_flow
            "Mass flow rate for water";
          input Modelica.SIunits.MassFlowRate mWatNonZer_flow
            "None-zero Mass flow rate for water";
          input Modelica.SIunits.SpecificHeatCapacity cpWat
            "Specific heat capacity of water";
          input Modelica.SIunits.Temperature TWatIn
            "Water temperature at inlet";
          input Modelica.SIunits.MassFlowRate mWat_flow_nominal;
          // -- air
          input Modelica.SIunits.Pressure pAir
            "Pressure on air-side of coil";
          input Modelica.SIunits.ThermalConductance UAAir
            "UA for air side";
          input Modelica.SIunits.MassFlowRate mAir_flow
            "Mass flow rate of air";
          input Modelica.SIunits.MassFlowRate mAirNonZer_flow
            "None-zero Mass flow rate for water";
          input Modelica.SIunits.SpecificHeatCapacity cpAir
            "Specific heat capacity of moist air at constant pressure";
          input Modelica.SIunits.Temperature TAirIn
            "Temperature of air at inlet";
          input Modelica.SIunits.MassFraction X_wAirIn
            "Mass fraction of water in moist air at inlet";
          input Buildings.Fluid.Types.HeatExchangerFlowRegime cfg
            "The configuration of the heat exchanger";
          input Modelica.SIunits.MassFlowRate mAir_flow_nominal;

          Modelica.SIunits.SpecificEnthalpy hAirIn
            "Specific enthalpy of air at inlet conditions";
          Buildings.Utilities.Psychrometrics.hSat_pTSat hSatWatInM(p=pAir,TSat=TWatIn)
            "Model to calculate saturated specific enthalpy of air at water inlet temperature";
          Modelica.SIunits.SpecificEnthalpy hSatWatIn
            "Saturated specific enthalpy of air at water inlet temperature";

          Buildings.Utilities.Psychrometrics.hSat_pTSat hSatWatIn_dT_M(p=pAir,TSat=TWatIn+dTWat)
            "Model to calculate derivative of saturated specific enthalpy of air at water inlet temperature";
          Modelica.SIunits.SpecificHeatCapacity dhSatdTWatIn
           "Deriviative of saturated moist air enthalpy at water inlet temperature";
          Real NonZerDelWatTem
          "Regularization water temperature difference betwee inlet and outlet";


           Modelica.SIunits.SpecificEnthalpy hAirOut
            "Specific enthalpy of moist air at the air outlet";
          Buildings.Utilities.Psychrometrics.hSat_pTSat hSatWatOutM(p=pAir,TSat=TWatOutEst)
            "Model to calculate saturated specific enthalpy of air at water outlet temperature";
          Modelica.SIunits.SpecificEnthalpy hSatWatOut
            "Saturated specific enthalpy of air at water outlet temperature";

          Modelica.SIunits.Temperature TSurEff
           "Effective surface temperature of the coil to split sensible and latent heat from total heat transfer rate";

          Modelica.SIunits.SpecificEnthalpy hSatSurEff
          "Enthalpy of saturated moist air at the effective surface temperature";

          Buildings.Utilities.Psychrometrics.hSat_pTSat hSatSurEffM(p=pAir,TSat=TSurEff)
           "An object to calculate the saturated enthalpy of moist air at the coil surface temperature";
          Buildings.Utilities.Psychrometrics.hSat_pTSat hSatSurEffMinM(p=pAir,TSat=273.15+1)
          "An object to calculate a lower bound of the saturated enthalpy of moist 
  air at the coil surface temperature";

          Modelica.SIunits.SpecificHeatCapacity cpEff
            "Effective specific heat: change in enthalpy with respect to temperature
     along the saturation line at the local water temperature";


          Modelica.SIunits.MassFlowRate UASta
            "Overall mass transfer coefficient for dry coil";

          Real NTUAirSta(unit="1")
            "Number of transfer units for air-side only (NTU_a*)";

          Real epsSta(start=0.66, unit="1")
            "Effectiveness for heat exchanger (e*)";

          Modelica.SIunits.MassFlowRate CStaMin
           "Min of product of mass flow rates and specific heats; analogous to Cmin";

          Modelica.SIunits.MassFlowRate CStaMin_flow_nominal= min(
            mAir_flow_nominal,mWat_flow_nominal*cpEff0/cpWat0)
            "Analogus to CMin_flow_nominal, only for a regularization";
          Modelica.SIunits.MassFlowRate CStaMax_flow_nominal= max(
            mAir_flow_nominal,mWat_flow_nominal*cpEff0/cpWat0)
            "Analogus to CMax_flow_nominal, only for a regularization";
          Modelica.SIunits.MassFlowRate deltaCStaMin=delta*min(
            mAir_flow_nominal,mWat_flow_nominal*cpEff0/cpWat0)
            "Min of product of mass flow rates and specific heats, analogous to Cmin";
          Modelica.SIunits.Temperature TWatOutEst
            "State_estimation of Temperature of water at outlet";

          output Modelica.SIunits.HeatFlowRate QTot_flow
            "Total heat flow from water to air stream";
           output Modelica.SIunits.HeatFlowRate QSen_flow
            "Sensible heat flow from water to air stream";
          output Modelica.SIunits.Temperature TWatOut
            "Temperature at the water outlet";
          output Modelica.SIunits.Temperature TSurAirIn
            "Coil surface temperature at the air inlet";
          output Modelica.SIunits.Temperature TAirOut
            "Temperature at the air outlet";
        initial equation
          TWatOutEst=0.5*(TWatIn+ TAirIn);

        equation

          hAirIn=Buildings.Media.Air.specificEnthalpy_pTX(p=pAir,T=TAirIn,X={X_wAirIn,1-X_wAirIn});
          hSatWatIn=hSatWatInM.hSat;
          dhSatdTWatIn=(hSatWatIn_dT_M.hSat-hSatWatInM.hSat)/dTWat; // dTWat is a parameter
          hSatWatOut= hSatWatOutM.hSat;
          NonZerDelWatTem=Buildings.Utilities.Math.Functions.regNonZeroPower(x=TWatOutEst-TWatIn,n=1,delta=0.1);
          cpEff = Buildings.Utilities.Math.Functions.smoothMax(
          (hSatWatOut - hSatWatIn)/NonZerDelWatTem,
          dhSatdTWatIn,
          cpEff0*delta);

          CStaMin=Buildings.Utilities.Math.Functions.smoothMin(
          mAir_flow,
          mWat_flow*cpWat/cpEff,
          deltaCStaMin/4);

          UASta = (UAAir/cpAir)/(1 + (cpEff*UAAir)/(cpAir*UAWat));

          epsSta=epsilon_C(
          UA=UASta*cpDum,
          C1_flow=mWat_flow*cpWat/cpEff*cpDum,
          C2_flow=mAir_flow*cpDum,
          flowRegime=Integer(cfg),
          CMin_flow_nominal=CStaMin_flow_nominal*cpDum,
          CMax_flow_nominal=CStaMax_flow_nominal*cpDum,
          delta=delta);

          QTot_flow = epsSta*CStaMin*(hAirIn  - hSatWatIn);

          QTot_flow = mAir_flow*(hAirIn- hAirOut);
          QTot_flow = mWat_flow*cpWat*(TWatOut-TWatIn);

          NTUAirSta = UAAir/(mAir_flow*cpAir);

          hSatSurEff = Buildings.Utilities.Math.Functions.smoothMax(
            x1 = hSatSurEffMinM.hSat,
            x2 = hAirIn  +(hAirOut - hAirIn) / (1 - exp(-NTUAirSta)),
            deltaX = delta*1E4); // NTUAirSta is bounded as long as UAAir>0 due to the regularization of mAir_flow

          hSatSurEffM.hSat=hSatSurEff;
          TAirOut = TSurEff +(TAirIn  - TSurEff)*exp(-NTUAirSta);
          QSen_flow= Buildings.Utilities.Math.Functions.smoothMin(
            x1 = mAir_flow*cpAir*(TAirIn-TAirOut),
            x2 = QTot_flow,
            deltaX = delta*mWatNonZer_flow*cpWat0*5); // the last term is only for regularization with DTWater=5oC

          (TAirIn-TSurAirIn)*UAAir=(TSurAirIn-TWatOut)*UAWat;
          der(TWatOutEst)=-1/tau*TWatOutEst+1/tau*TWatOut;

        annotation (Icon(graphics={
                Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={28,108,200},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid)}), Documentation(revisions="<html>
<ul>
<li>Jan 21, 2021, by Donghun Kim:<br/>First implementation of the fuzzy model. 
See 
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">
issue 622</a> 
for more information. 
</li>
</ul>
</html>",         info="<html>
<p>
This model implements the calculation for a 100% wet coil. 
</p>
<p>
The equations from Braun (1988) and Mitchell and Braun (2012a and b),
which are essentially the extension of the <i>&epsilon;-NTU</i> approach to
simultaneous sensible and latent heat transfer, are utilized. 
</p>
<p>
The mathematical equations are analogous to that of the sensible heat exchanger.
However, the key distinction is from that the heat transfer is driven by an enthalpy difference
not by an temperature difference. This change in the driving potential results in re-defining 
capacitances and heat transfer coefficients accordinlgy.
</p>

<p>
The total heat transfer rate is expressed as
</p>
<p align=\"center\"> 
<i> Q<sub>tot</sub>=&epsilon;* C*<sub>min </sub>
(h<sub>air,in</sub>-h<sub>sat</sub>(T<sub>wat,in</sub>))</i>,
</p>
<p>
where <i>&epsilon;*=f(Cr*,NTU*)</i> and <i>f</i> is the same <i>&epsilon;-NTU</i> relationships
(depending on the heat exchanger configuration) for the sensible heat exchanger.
</p>
<p>
<i>h<sub>air,in</sub> </i> and <i>h<sub>sat</sub></i>(<i>T<sub>wat,in</sub></i>) are
the specific enthalpies of the incoming moist air and saturated moist air 
at the water inlet temperature.
</p>
<p>
The capacitances of water and air streams are defined as
</p>
<p align=\"center\"><i>C*<sub>air</sub>=m<sub>air</sub></i> and
<i>C*<sub>wat</sub>=m<sub>wat</sub>c<sub>p,wat</sub>/csat</i>,
</p>
<p>
where <i>csat</i> is an specific heat capacity, which indicates the sensitivity
of the enthalpy of the staturated moist air w.r.t. the temperature, and is defined
here as <i>csat=(h<sub>sat</sub>(T<sub>wat,out</sub>)-h<sub>sat</sub>(T<sub>wat,in</sub>))
/(T<sub>wat,out</sub>-T<sub>wat,in</sub>)</i>. 
</p>
<p>
The capacitance ratio and minimum capacitance are naturally defined as
</p>
<p align=\"center\"> <i>Cr*=min(C*<sub>air</sub>,C*<sub>wat</sub>)/max(C*<sub>air</sub>,C*<sub>wat</sub>)</i>
and <i>C*<sub>min</sub>=min(C*<sub>air</sub>,C*<sub>wat</sub>)</i>.
</p>
<p><br/>
The number of transfer unit for the wet-coil is defined as <i>NTU*=UA*/C*<sub>min</sub></i>, where 
</p>
<p align=\"center\">
<i>UA*=1/(1/(UA<sub>air</sub>/c<sub>p,air</sub>)+1/(UA<sub>wat</sub>/csat)</i>. 
</p>

<h4>References </h4>
<p>
Braun, James E. 1988.
&quot;Methodologies for the Design and Control of Central Cooling Plants&quot;.
PhD Thesis. University of Wisconsin - Madison.
Available
<a href=\"https://minds.wisconsin.edu/handle/1793/46694\">
online</a>.
</p>
<p>
Mitchell, John W., and James E. Braun. 2012a.
Principles of heating, ventilation, and air conditioning in buildings.
Hoboken, N.J.: Wiley. 
</p>
<p>
Mitchell, John W., and James E. Braun. 2012b.
&quot;Supplementary Material Chapter 2: Heat Exchangers for Cooling Applications&quot;.
Excerpt from Principles of heating, ventilation, and air conditioning in buildings.
Hoboken, N.J.: Wiley.
Available
<a href=\"http://bcs.wiley.com/he-bcs/Books?action=index&amp;itemId=0470624574&amp;bcsId=7185\">
online</a>.
</p>
</html>"));
        end WetCoilWetRegime;

        function determineWaterIndex
          "Determine the index of water in a 2-component medium model"
          input String[:] substanceNames "Names of substances of media";
          output Integer idxWat "Index of water";
      protected
          Boolean found(fixed=false) "Flag, used for error checking";
          Integer N = size(substanceNames, 1) "Number of substances";
        algorithm
          found:=false;
          idxWat := 1;
          for i in 1:N loop
            if Modelica.Utilities.Strings.isEqual(
                string1=substanceNames[i],
                string2="water",
                caseSensitive=false) then
                idxWat := i;
                found := true;
            end if;
          end for;
          assert(found,
            "Did not find medium species 'water' in the medium model. " +
            "Change medium model.");
          annotation (Documentation(revisions="<html>
<ul>
<li>
April 19, 2017, by Michael Wetter:<br/>
Removed assertion as function is valid also for other values than <code>N==2</code>.
</li>
<li>
March 17, 2017, by Michael O'Keefe:<br/>
First implementation. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">
issue 622</a> for more information.
</li>
</ul>
</html>",         info="<html>
<p>
Given an array of strings representing substance names, this function returns
the integer index of the substance named \"water\" (case-insensitive).
</p>

<p>
This function is useful to automate lookup up the index of water within a media
so as to avoid hard-coding or guessing what the index will be. Typically, this
function would be run once at initialization time.
</p>
</html>"));
        end determineWaterIndex;

        function epsilon_C
          "Computes heat exchanger effectiveness for given capacity flow rates and heat exchanger flow regime"
          input Modelica.SIunits.ThermalConductance UA "UA value";
          input Modelica.SIunits.ThermalConductance C1_flow
            "Enthalpy flow rate medium 1";
          input Modelica.SIunits.ThermalConductance C2_flow
            "Enthalpy flow rate medium 2";
          input Integer flowRegime
            "Heat exchanger flow regime, see  Buildings.Fluid.Types.HeatExchangerFlowRegime";
          input Modelica.SIunits.ThermalConductance CMin_flow_nominal
            "Minimum enthalpy flow rate at nominal condition";
          input Modelica.SIunits.ThermalConductance CMax_flow_nominal
            "Maximum enthalpy flow rate at nominal condition";
          input Real delta = 1E-3 "Small value used for smoothing";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";

      protected
          Modelica.SIunits.ThermalConductance deltaCMin
            "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance deltaCMax
            "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance CMin_flow "Minimum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMax_flow "Maximum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMinNZ_flow
            "Minimum capacity flow rate, bounded away from zero";
          Modelica.SIunits.ThermalConductance CMaxNZ_flow
            "Maximum capacity flow rate, bounded away from zero";
          Real gaiEps(min=0, max=1)
            "Gain used to force UA to zero for very small flow rates";
          Real gaiNTU(min=1E-10, max=1)
            "Gain used to force NTU to a number slightly above zero for very small flow rates. Because NTU is used in NTU^-(0.22), it must not be zero.";
          Real NTU "Number of transfer units";
          Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";

        algorithm
          deltaCMin := delta*CMin_flow_nominal;
          deltaCMax := delta*CMax_flow_nominal;
          // effectiveness
          CMin_flow :=Buildings.Utilities.Math.Functions.smoothMin(
            C1_flow,
            C2_flow,
            deltaCMin/4);
          CMax_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            C1_flow,
            C2_flow,
            deltaCMax/4);
          // CMin and CMax, constrained to be non-zero to compute eps-NTU-Z relationship
          CMinNZ_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            CMin_flow,
            deltaCMin,
            deltaCMin/4);
          CMaxNZ_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            CMax_flow,
            deltaCMax,
            deltaCMax/4);
          Z := CMin_flow/CMaxNZ_flow+1E-10*deltaCMin;
          // Gain that goes to zero as CMin_flow gets below deltaCMin
          // This is needed to allow zero flow
          gaiEps := Buildings.Utilities.Math.Functions.spliceFunction(
                   pos=1,
                   neg=0,
                   x=CMin_flow-deltaCMin,
                   deltax=deltaCMin/2);
          gaiNTU := Buildings.Utilities.Math.Functions.spliceFunction(
                   pos=1,
                   neg=delta,
                   x=CMin_flow-deltaCMin,
                   deltax=deltaCMin/2);

          NTU := gaiNTU*UA/CMinNZ_flow;
          eps := gaiEps*Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
                          NTU=NTU,
                          Z=Z,
                          flowRegime=flowRegime);

          annotation (
          Inline=false,
          smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the heat exchanger effectiveness,
the Number of Transfer Units, and the capacity flow ratio
for given capacity flow rates.
</p>
<p>
The implementation allows for zero flow rate.
As <code>CMin_flow</code> crosses <code>delta*CMin_flow_nominal</code> from above,
the Number of Transfer Units and the heat exchanger effectiveness go to zero.
</p>
<p>
The different options for the flow regime are declared in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime\">
Buildings.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 10, 2018, by Michael Wetter:<br/>
Removed outputs <code>Z</code> and <code>NTU</code> as they are not used by other models.
Removed <code>if</code> statement that can cause a discontinuous derivative.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>Buildings.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was done to have the same argument list as
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ\">
Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ</a>,
in which the type had to be changed.
</li>
<li>
July 6, 2014, by Michael Wetter:<br/>
Removed unused <code>import</code> statement.
</li>
<li>
February 20, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_C;

        function epsilon_ntuZ
          "Computes heat exchanger effectiveness for given number of transfer units and heat exchanger flow regime"
          import f = Buildings.Fluid.Types.HeatExchangerFlowRegime;
          input Real NTU "Number of transfer units";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime, see  Buildings.Fluid.Types.HeatExchangerFlowRegime";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";
      protected
          Real a "Auxiliary variable";
        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := 0;
            eps := (1 - Modelica.Math.exp(-NTU*(1 + Z)))/(1 + Z);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            eps := (1 - Modelica.Math.exp(-NTU*(1 - a)))/(1 - a*Modelica.Math.exp(-NTU*(
              1 - a)));
          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
           a := NTU^(-0.22);
            eps := 1 - Modelica.Math.exp( ( Modelica.Math.exp( - NTU * Z * a)  - 1)  / (Z * a));
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
            a := 0;
            eps := (1 - Modelica.Math.exp(-Z*(1 - Modelica.Math.exp(-NTU))))/Z;
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
            a := 0;
            eps := 1 - Modelica.Math.exp(-(1 - Modelica.Math.exp(-Z*NTU))/Z);
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            eps := 1 - Modelica.Math.exp(-NTU);
          else
            a := 0;
            eps := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;
          annotation(preferredView="info",
                     inverse(NTU=Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(eps=eps, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
                   Documentation(info="<html>
<p>
This function computes the heat exchanger effectiveness for a given number of transfer units, capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime\">
Buildings.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>Buildings.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was required because this argument is passed in Dymola 2015 in the function
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C\">
Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C</a>
as an integer. Without this change, a translation warning occurs.
</li>
<li>
September 25, 2013, by Michael Wetter:<br/>
Changed test in the <code>assert</code> statement as OpenModelica
had an error when comparing enumerations with integers.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_ntuZ;

        function lmtd "Log-mean temperature difference"
          input Modelica.SIunits.Temperature T_a1 "Temperature at port a1";
          input Modelica.SIunits.Temperature T_b1 "Temperature at port b1";
          input Modelica.SIunits.Temperature T_a2 "Temperature at port a2";
          input Modelica.SIunits.Temperature T_b2 "Temperature at port b2";
          output Modelica.SIunits.TemperatureDifference lmtd
            "Log-mean temperature difference";
      protected
          Modelica.SIunits.TemperatureDifference dT1 "Temperature difference side 1";
          Modelica.SIunits.TemperatureDifference dT2 "Temperature difference side 2";
        algorithm
          dT1 :=T_a1 - T_b2;
          dT2 :=T_b1 - T_a2;
          lmtd :=(dT2 - dT1)/Modelica.Math.log(dT2/dT1);
        annotation (preferredView="info",
        Documentation(info="<html>
<p>
This function computes the log mean temperature difference of a heat exchanger.
</p>
<p>
Note that the implementation requires the temperature differences <i>T<sub>a1</sub> - T<sub>b2</sub></i> and
<i>T<sub>b1</sub> - T<sub>a2</sub></i> to be not equal to each other.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 30, 2020, by Michael Wetter:<br/>
Updated documentation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2268\">#2268</a>.
</li>
<li>
May 28, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end lmtd;

        function ntu_epsilonZ
          "Computes number of transfer units for given heat exchanger effectiveness and heat exchanger flow regime"
          import f = Buildings.Fluid.Types.HeatExchangerFlowRegime;
          input Real eps(min=0, max=0.999) "Heat exchanger effectiveness";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime";
          output Real NTU "Number of transfer units";

      protected
          Real a "Auxiliary variable";

          function epsilon_ntuZ_crossFlowUnmixed
            "Internal function to solve eps=f(NTU, Z) for NTU for cross flow unmixed"
            extends Modelica.Math.Nonlinear.Interfaces.partialScalarFunction;

            input Real eps(min=0, max=0.999) "Heat exchanger effectiveness";
            input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";

        protected
            Real NTUExp "Auxiliary variable";

          algorithm
            NTUExp := u^(-0.22);
            y := 1 - Modelica.Math.exp( ( Modelica.Math.exp( - u * Z * NTUExp)  - 1)  / (Z * NTUExp))-eps;
          end epsilon_ntuZ_crossFlowUnmixed;

        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := Z+1;
            assert(eps < 1/a,
              "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.
  Received eps = "         + String(eps) + "
             Z = "         + String(Z) + "
       1/(Z+1) = "         + String(1/a));
            NTU := -(Modelica.Math.log(1-eps*a))/(a);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            NTU := Modelica.Math.log((1-eps)/(1-eps*a)) / (a-1);

          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
            a := 0;
            // The function Internal.solve evaluates epsilon_ntuZ at NTU=x_min-1e-10 and NTU=x_max+1e-10
            // when it solves iteratively epsilon_ntuZ for ntu
            // Therefore, we set x_min=1.5*1e-10 to prevent computing NTU^(-0.22)=(-1e-10)^(-0.22).
            NTU :=Modelica.Math.Nonlinear.solveOneNonlinearEquation(
              f=function epsilon_ntuZ_crossFlowUnmixed(eps=eps, Z=Z),
              u_min=1.5*1e-10,
              u_max=1e6);
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
           a := smooth(1, if Z > 0.03 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+(Modelica.Math.log(1-eps*a)/a));
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
           a := smooth(1, if Z > 0.03 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+Z*Modelica.Math.log(1-eps))/Z;
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            NTU := -Modelica.Math.log((1-eps));
          else
            a := 0;
            NTU := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;

          annotation (preferredView="info",
                     inverse(eps=Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU=NTU, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
        Documentation(info="<html>
<p>
This function computes the number of transfer units for a given heat exchanger effectiveness,
capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime\">
Buildings.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
<p>
Note that for the flow regime <code>CrossFlowUnmixed</code>, computing the
function requires the numerical solution of an equation in one variable.
This is handled internally and not exposed to the global solver.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 28, 2020, by Michael Wetter:<br/>
Replaced call to <code>Media.Common.OneNonLinearEquation</code> to use
<a href=\"modelica://Modelica.Math.Nonlinear.solveOneNonlinearEquation\">
Modelica.Math.Nonlinear.solveOneNonlinearEquation</a>
because <code>Media.Common.OneNonLinearEquation</code> will be obsolete in MSL 4.0.0.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1299\">issue 1299</a>.
</li>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>Buildings.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was done to have the same argument list as
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ\">
Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ</a>,
in which the type had to be changed.
</li>
<li>
April 29, 2013, by Michael Wetter:<br/>
Added dummy argument to function call of <code>Internal.solve</code>
to avoid a warning during model check in Dymola 2015.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ntu_epsilonZ;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.HeatExchangers\">Buildings.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package Humidifiers "Package with humidifier models"
      extends Modelica.Icons.Package;

      model Humidifier_u
        "Ideal humidifier or dehumidifier with prescribed water mass flow rate addition or subtraction"
        extends Buildings.Fluid.Interfaces.TwoPortHeatMassExchanger(
          redeclare replaceable package Medium =
              Modelica.Media.Interfaces.PartialCondensingGases,
          redeclare final Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir vol(
          final prescribedHeatFlowRate=true));

        parameter Modelica.SIunits.MassFlowRate mWat_flow_nominal
          "Water mass flow rate at u=1, positive for humidification";

        Modelica.Blocks.Interfaces.RealInput u(unit="1") "Control input"
          annotation (Placement(transformation(
                extent={{-140,40},{-100,80}}), iconTransformation(extent={{-120,50},{
                  -100,70}})));

        Modelica.Blocks.Interfaces.RealOutput mWat_flow(unit="kg/s")
          "Water added to the fluid"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
          "Heat port for total heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-70},{-90,-50}})));

    protected
        Modelica.Blocks.Math.Gain gai(final k=mWat_flow_nominal) "Gain"
          annotation (Placement(transformation(extent={{-80,50},{-60,70}})));

      equation
        connect(u, gai.u) annotation (Line(
            points={{-120,60},{-82,60}},
            color={0,0,127}));
        connect(gai.y, vol.mWat_flow) annotation (Line(
            points={{-59,60},{-30,60},{-30,-18},{-11,-18}},
            color={0,0,127}));
        connect(vol.heatPort, heatPort) annotation (Line(points={{-9,-10},{-20,-10},{-20,
                -60},{-100,-60}}, color={191,0,0}));

        connect(gai.y, mWat_flow)
          annotation (Line(points={{-59,60},{110,60},{110,60}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Text(
                extent={{-52,-60},{58,-120}},
                textString="m=%m_flow_nominal",
                pattern=LinePattern.None,
                lineColor={0,0,127}),
              Rectangle(
                extent={{-100,61},{-70,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-114,104},{-70,76}},
                lineColor={0,0,127},
                textString="u"),
              Rectangle(
                visible=use_T_in,
                extent={{-100,-59},{-70,-62}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,5},{101,-5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,62,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{42,42},{54,34},{54,34},{42,28},{42,30},{50,34},{50,34},{42,
                    40},{42,42}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{58,-54},{54,52}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{70,61},{100,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{30,112},{96,58}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Polygon(
                points={{42,10},{54,2},{54,2},{42,-4},{42,-2},{50,2},{50,2},{42,8},{
                    42,10}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{42,-26},{54,-34},{54,-34},{42,-40},{42,-38},{50,-34},{50,-34},
                    {42,-28},{42,-26}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="hum",
      Documentation(info="<html>
<p>
Model for an air humidifier or dehumidifier.
</p>
<p>
This model adds (or removes) moisture from the air stream.
The amount of exchanged moisture is equal to
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775;<sub>wat</sub> = u  m&#775;<sub>wat,nom</sub>,
</p>
<p>
where <i>u</i> is the control input signal and
<i>m&#775;<sub>wat,nom</sub></i> is equal to the parameter <code>mWat_flow_nominal</code>.
The parameter <code>mWat_flow_nominal</code> can be positive or negative.
If <i>m&#775;<sub>wat</sub></i> is positive, then moisture is added
to the air stream, otherwise it is removed.
</p>
<p>
If the heat port <code>heatPort</code> is unconnected, then the enthalpy of the
air that flows through the device remains unchanged, e.g., the humidification
is adiabatic. To change the enthalpy of the air, add heat flow to the connector
<code>heatPort</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 12, 2017, by Michael Wetter:<br/>
Removed parameters <code>use_T_in</code> and <code>T</code>.
This removes the optional specification of temperature through the parameter <code>T</code>
or the input connector <code>T_in</code>.
Exposed the heat port of the control volume to allow adding heat,
for example, to use the model as a steam humidifier.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">
Buildings #704</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Set <code>prescribedHeatFlowRate=true</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Corrected issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>
which led to twice the amount of latent heat being added to the fluid stream.
</li>
<li>
October 14, 2013 by Michael Wetter:<br/>
Constrained medium to be a subclass of
<code>Modelica.Media.Interfaces.PartialCondensingGases</code>,
as this base class declares the function
<code>enthalpyOfCondensingGas</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
May 24, 2011, by Michael Wetter:<br/>
Changed base class to allow using the model as a dynamic or a steady-state model.
</li>
<li>
April 14, 2010, by Michael Wetter:<br/>
Converted temperature input to a conditional connector.
</li>
<li>
April 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Humidifier_u;
    annotation (preferredView="info", Documentation(info="<html>
<p>
Package with humidifiers.
</p>
</html>"),
        Icon(graphics={
            Rectangle(
              extent={{-72,70},{70,-72}},
              lineColor={0,0,255},
              pattern=LinePattern.None,
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{46,-52},{34,54}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{8,48},{34,32},{34,32},{8,18},{8,24},{24,32},{24,32},{8,42},{
                8,48}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{8,0},{34,-16},{34,-16},{8,-30},{8,-24},{24,-16},{24,-16},{8,
                -6},{8,0}},
              lineColor={255,255,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}));
    end Humidifiers;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          final initialize_p = not Medium.singleState,
          steBal(final use_C_flow = use_C_flow),
          dynBal(final use_C_flow = use_C_flow));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start)) "Heat port for heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

      equation
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-96,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},
                {12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},
                {52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://Buildings.Fluid.Sensors.Examples.PPM\">Buildings.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
<p>
For the rationale of selecting different energy and mass balances, and for the
use of <code>prescribedHeatFlowRate</code>, see the documentation of
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCooler_u\">
Buildings.Fluid.HeatExchangers.HeaterCooler_u</a> and
<a href=\"modelica://Buildings.Fluid.Humidifiers.Humidifier_u\">
Buildings.Fluid.Humidifiers.Humidifier_u</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Changed code for handling trace substance insertions using input <code>C_flow</code>.
</li>
<li>
May 1, 2015 by Michael Wetter<br/>
Set <code>final</code> keyword for <code>masExc(final k=0)</code>.
This addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/230\">
issue 230</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}),
            graphics={
            Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      model MixingVolumeMoistAir
        "Mixing volume with heat port for latent heat exchange, to be used if moisture is added or removed"
        extends Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          dynBal(
            final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          steBal(final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          final initialize_p = not Medium.singleState);

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       final unit = "kg/s")
          "Water flow rate added into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealOutput X_w(final unit="kg/kg")
          "Species composition of medium"
          annotation (Placement(transformation(extent={{100,-60},{140,-20}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start))
          "Heat port for sensible plus latent heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

    protected
        parameter Real s[Medium.nXi] = {
        if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false) then 1 else 0
                                                  for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Modelica.Blocks.Sources.RealExpression XLiq(y=s*Xi)
          "Species composition of the medium"
          annotation (Placement(transformation(extent={{72,-52},{94,-28}})));
      equation
        connect(mWat_flow, steBal.mWat_flow) annotation (Line(
            points={{-120,80},{-120,80},{4,80},{4,14},{18,14}},
            color={0,0,127}));
        connect(mWat_flow, dynBal.mWat_flow) annotation (Line(
            points={{-120,80},{-50,80},{52,80},{52,12},{58,12}},
            color={0,0,127}));
        connect(XLiq.y, X_w) annotation (Line(
            points={{95.1,-40},{120,-40}},
            color={0,0,127}));
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},{
                12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},{
                52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (defaultComponentName="vol",
      Documentation(info="<html>
<p>
Model for an ideally mixed fluid volume and the ability
to store mass and energy. The volume is fixed,
and latent and sensible heat can be exchanged.
</p>
<p>
This model represents the same physics as
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>, but in addition, it allows
adding or subtracting water to the control volume.
The mass flow rate of the added or subtracted water is
specified at the port <code>mWat_flow</code>.
Adding <code>mWat_flow</code> itself does not affect the energy balance
in this model. Hence, the enthalpy that is added or removed with the
flow of <code>mWat_flow</code> needs to be added to the heat port
<code>heatPort</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://Buildings.Fluid.Sensors.Examples.PPM\">Buildings.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>steBal</code>
as this constant is no longer used.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
December 18, 2013 by Michael Wetter:<br/>
Changed computation of <code>s</code> to allow this model to also be used
with <code>Buildings.Media.Water</code>.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Removed dublicate declaration of medium model.
</li>
<li>
September 27, 2013 by Michael Wetter:<br/>
Reformulated assignment of <code>i_w</code> to avoid a warning in OpenModelica.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Changed model to no longer use the obsolete model <code>Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>
in the conservation equation model.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the use of the deprecated
<code>cardinality</code> function.
Therefore, all input signals must be connected.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
May 29, 2010 by Michael Wetter:<br/>
Rewrote computation of index of water substance.
For the old formulation, Dymola 7.4 failed to differentiate the
model when trying to reduce the index of the DAE.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MixingVolumeMoistAir;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

          // We set prescribedHeatFlowRate=false so that the
          // volume works without the user having to set this advanced parameter,
          // but to get high robustness, a user can set it to the appropriate value
          // as described in the info section.
          constant Boolean prescribedHeatFlowRate = false
            "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";

          constant Boolean simplify_mWat_flow = true
            "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
            "Small mass flow rate for regularization of zero flow"
            annotation(Dialog(tab = "Advanced"));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.SIunits.Volume V "Volume";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));

          Medium.Temperature T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}))
            "Temperature of the fluid";
          Modelica.Blocks.Interfaces.RealOutput U(unit="J")
            "Internal energy of the component";
          Modelica.SIunits.Pressure p = if nPorts > 0 then ports[1].p else p_start
            "Pressure of the fluid";
          Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
          Modelica.SIunits.MassFraction Xi[Medium.nXi] = XiOut_internal
            "Species concentration of the fluid";
          Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
            "Species mass of the component";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
            "Trace substance mixture content";
          Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
            "Trace substance mass of the component";

      protected
          Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small,
            final prescribedHeatFlowRate=prescribedHeatFlowRate,
            hOut(start=Medium.specificEnthalpy_pTX(
                         p=p_start,
                         T=T_start,
                         X=X_start))) if
                 useSteadyStateTwoPort "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Buildings.Fluid.Interfaces.ConservationEquation dynBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            nPorts=nPorts,
            final mSenFac=mSenFac) if
                 not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));

          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.SIunits.Density rho_start=Medium.density(
           state=state_start) "Density, used to compute start and guess values";
          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
          // Density at medium default values, used to compute the size of control volumes
          final parameter Modelica.SIunits.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          // See info section for why prescribedHeatFlowRate is used here.
          // The condition below may only be changed if StaticTwoPortConservationEquation
          // contains a correct solution for all foreseeable parameters/inputs.
          // See Buildings, issue 282 for a discussion.
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              (prescribedHeatFlowRate or (not allowFlowReversal)) and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";

          Buildings.HeatTransfer.Sources.PrescribedTemperature preTem
            "Port temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
            annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
            "Heat flow sensor"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
          "In " + getInstanceName() + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");       end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
              color={0,127,255}));

          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
              color={0,127,255}));
            U=0;
            mXi=zeros(Medium.nXi);
            m=0;
            mC=zeros(Medium.nC);
            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                    -100}},
              color={0,127,255}));
            connect(U,dynBal.UOut);
            connect(mXi,dynBal.mXiOut);
            connect(m,dynBal.mOut);
            connect(mC,dynBal.mCOut);
            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;

          connect(portT.y, preTem.T)
            annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
          connect(heaFloSen.port_b, preTem.port)
            annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
          connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-16},{6,-16},{6,18},{18,18}},
                                             color={0,0,127}));
          connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                       color={0,0,127}));
          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&deg;C,
the downstream temperature is <i>10</i>&deg;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&deg;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&deg;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 18, 2020, by Michael Wetter:<br/>
Set start value for <code>steBal.hOut</code> so that <code>T_start</code>
can be used which is not known in that instance.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 30, 2019 by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> to flow
reversal check.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1228\">
issue 1228</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.SIunits.Temperature</code>
to avoid an
error because of conflicting start values if
<code>Buildings.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={
               Text(
                  extent={{-60,-26},{56,-58}},
                  lineColor={255,255,255},
                  textString="V=%V"),
                Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  lineColor={0,0,255}),
               Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor=DynamicSelect({170,213,255}, min(1, max(0, (1-(T-273.15)/50)))*{28,108,200}+min(1, max(0, (T-273.15)/50))*{255,0,0})),
                Text(
                  extent={{62,28},{-58,-22}},
                  lineColor={255,255,255},
                  textString=DynamicSelect("", String(T-273.15, format=".1f")))}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">Buildings.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.Package;

      model SpeedControlled_y
        "Fan or pump with ideally controlled normalized speed y as input signal"
        extends Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          final nominalValuesDefineDefaultPressureCurve=false,
          final computePowerUsingSimilarityLaws=true,
          final m_flow_nominal = max(per.pressure.V_flow)*rho_default,
          final stageInputs(each final unit="1") = per.speeds,
          final constInput(final unit="1") =       per.constantSpeed,
          filter(
            final y_start=y_start,
            u(final unit="1"),
            y(final unit="1")),
          eff(
            per(final pressure = per.pressure,
                final use_powerCharacteristic = per.use_powerCharacteristic),
                r_N(start=y_start)),
          gaiSpe(u(final unit="1"),
                 final k=1/per.speed_nominal));

        parameter Real y_start(min=0, max=1, unit="1")=0 "Initial value of speed"
          annotation(Dialog(tab="Dynamics", group="Filtered speed", enable=use_inputFilter));

        Modelica.Blocks.Interfaces.RealInput y(
          unit="1") if
          inputType == Buildings.Fluid.Types.InputType.Continuous
          "Constant normalized rotational speed"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));

    protected
        Modelica.Blocks.Math.Gain gain(final k=-1) "Pressure gain"
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=270,
              origin={10,-20})));
      initial equation
        assert(per.havePressureCurve,
         "SpeedControlled_y requires to set the pressure vs. flow rate curve in record 'per'.");

      equation
        connect(gaiSpe.u, y)
          annotation (Line(points={{-2.8,80},{0,80},{0,120}}, color={0,0,127}));
        connect(gaiSpe.y, inputSwitch.u) annotation (Line(points={{-16.6,80},{-26,80},
                {-26,50},{-22,50}}, color={0,0,127}));
        connect(eff.dp, gain.u)
          annotation (Line(points={{-11,-50},{10,-50},{10,-32}}, color={0,0,127}));
        connect(gain.y, preSou.dp_in)
          annotation (Line(points={{10,-9},{10,14},{56,14},{56,8},{56,8}},
                                                           color={0,0,127}));

        if use_inputFilter then
          connect(filter.y, eff.y_in) annotation (Line(points={{41,70.5},{44,70.5},{44,
                  26},{-26,26},{-26,-46}},  color={0,0,127}));
        else
          connect(inputSwitch.y, eff.y_in) annotation (Line(points={{1,50},{44,50},{44,
                  26},{-26,26},{-26,-46}},
                                         color={0,0,127}));
        end if;

          annotation (defaultComponentName="fan",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}),
               graphics={
              Text(
                extent={{-40,126},{-160,76}},
                lineColor={0,0,127},
                visible=inputType == Buildings.Fluid.Types.InputType.Continuous or inputType == Buildings.Fluid.Types.InputType.Stages,
                textString=DynamicSelect("y", if inputType == Buildings.Fluid.Types.InputType.Continuous then String(y, format=".2f") else String(stage)))}),
          Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed normalized speed.
The input connector provides the normalized rotational speed (between 0 and 1).
The head is computed based on the performance curve that take as an argument
the actual volume flow rate divided by the maximum flow rate and the relative
speed of the fan.
The efficiency of the device is computed based
on the efficiency curves that take as an argument
the actual volume flow rate divided by the maximum possible volume flow rate, or
based on the motor performance curves.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
June 17, 2021, by Michael Wetter:<br/>
Changed implementation of the filter.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating stage.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Updated parameter names for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Revised implementation that uses the new performance data as a record.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>
October 1, 2009, by Michael Wetter:<br/>
Model added to the Buildings library. Changed control signal from rpm to normalized value between 0 and 1</li>
<li>
October 31, 2005 by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br/>
Model added to the Fluid library
</li>
</ul>
</html>"));
      end SpeedControlled_y;

      package Data "Package containing data for real pumps/fans"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Generic data record for movers"
          extends Modelica.Icons.Record;

          // Pressure requires default values to avoid in Dymola the message
          // Failed to expand the variable pressure.V_flow.
          parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure(
            V_flow = {0, 0},
            dp =     {0, 0}) "Volume flow rate vs. total pressure rise"
            annotation(Evaluate=true,
                       Dialog(group="Pressure curve"));

          parameter Boolean use_powerCharacteristic=false
            "Use power data instead of motor efficiency"
            annotation (Dialog(group="Power computation"));

          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            hydraulicEfficiency(
              V_flow={0},
              eta={0.7}) "Hydraulic efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            motorEfficiency(
              V_flow={0},
              eta={0.7})
            "Electric motor efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));

          // Power requires default values to avoid in Dymola the message
          // Failed to expand the variable Power.V_flow
          parameter BaseClasses.Characteristics.powerParameters power(
            V_flow={0},
            P={0})
            "Volume flow rate vs. electrical power consumption (used if use_powerCharacteristic=true)"
           annotation (Dialog(group="Power computation",
                              enable=use_powerCharacteristic));

          parameter Boolean motorCooledByFluid=true
            "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Motor heat rejection"));

          parameter Real speed_nominal(
            final min=0,
            final unit="1") = 1 "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));

          parameter Real constantSpeed(final min=0, final unit="1") = constantSpeed_rpm/speed_rpm_nominal
            "Normalized speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));

          parameter Real[:] speeds(each final min = 0, each final unit="1") = speeds_rpm/speed_rpm_nominal
            "Vector of normalized speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));

          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm speed_rpm_nominal=1500
            "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Speeds in RPM"));

          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm constantSpeed_rpm=speed_rpm_nominal
            "Speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Speeds in RPM"));

          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm[:] speeds_rpm = {speed_rpm_nominal}
            "Vector of speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Speeds in RPM"));

          // Set a parameter in order for
          // (a) FlowControlled_m_flow and FlowControlled_dp being able to set a reasonable
          //     default pressure curve if it is not specified here, and
          // (b) SpeedControlled_y and SpeedControlled_Nrpm being able to issue an assert
          //     if no pressure curve is specified.
          final parameter Boolean havePressureCurve=
            sum(pressure.V_flow) > Modelica.Constants.eps and
            sum(pressure.dp) > Modelica.Constants.eps
            "= true, if default record values are being used";

          annotation (
          defaultComponentPrefixes = "parameter",
          defaultComponentName = "per",
          Documentation(revisions="<html>
<ul>
<li>
February 19, 2016, by Filip Jorissen:<br/>
Refactored model such that <code>SpeedControlled_Nrpm</code>,
<code>SpeedControlled_y</code> and <code>FlowControlled</code>
are integrated into one record.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Changed parameter <code>N_nominal</code> to
<code>speed_rpm_nominal</code> as it is the same quantity as <code>speeds_rmp</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
January 19, 2016, by Filip Jorissen:<br/>
Added parameter <code>speeds_rpm</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
February 13, 2015, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised record for OpenModelica.
</li>
<li>
November 22, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Record containing parameters for pumps or fans.
</p>
<h4>Typical use</h4>
<p>
This record may be used to assign for example fan performance data using
declaration such as
</p>
<pre>
  Buildings.Fluid.Movers.SpeedControlled_y fan(
    redeclare package Medium = Medium,
      per(pressure(V_flow={0,m_flow_nominal,2*m_flow_nominal}/1.2,
                   dp={2*dp_nominal,dp_nominal,0}))) \"Fan\";
</pre>
<p>
This data record can be used with
<a href=\"modelica://Buildings.Fluid.Movers.SpeedControlled_Nrpm\">
Buildings.Fluid.Movers.SpeedControlled_Nrpm</a>,
<a href=\"modelica://Buildings.Fluid.Movers.SpeedControlled_y\">
Buildings.Fluid.Movers.SpeedControlled_y</a>,
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_dp\">
Buildings.Fluid.Movers.FlowControlled_dp</a>,
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>.
</p>
<p>
An example that uses manufacturer data can be found in
<a href=\"modelica://Buildings.Fluid.Movers.Validation.Pump_Nrpm_stratos\">
Buildings.Fluid.Movers.Validation.Pump_Nrpm_stratos</a>.
</p>
<h4>Parameters in RPM</h4>
<p>
The parameters <code>speed_rpm_nominal</code>,
<code>constantSpeed_rpm</code> and
<code>speeds_rpm</code> are used to assign the non-dimensional speeds
</p>
<pre>
  parameter Real constantSpeed(final min=0, final unit=\"1\") = constantSpeed_rpm/speed_rpm_nominal;
  parameter Real[:] speeds(each final min = 0, each final unit=\"1\") = speeds_rpm/speed_rpm_nominal;
</pre>
<p>
In addition, <code>speed_rpm_nominal</code> is used in
<a href=\"modelica://Buildings.Fluid.Movers.SpeedControlled_Nrpm\">
Buildings.Fluid.Movers.SpeedControlled_Nrpm</a>
to normalize the control input signal.
Otherwise, these speed parameters in RPM are not used in the models.
</p>
</html>"));
        end Generic;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains data for fans and pumps.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>"));
      end Data;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        model FlowMachineInterface
          "Partial model with performance curves for fans or pumps"
          extends Modelica.Blocks.Icons.Block;

          import cha = Buildings.Fluid.Movers.BaseClasses.Characteristics;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Buildings.Fluid.Movers.Data.Generic per
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{60,-80},{80,-60}})));

          parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable preVar=
            Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed "Type of prescribed variable";
          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          final parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal=
            per.pressure.V_flow[nOri] "Nominal volume flow rate, used for homotopy";

          parameter Modelica.SIunits.Density rho_default
            "Fluid density at medium default state";

          parameter Boolean haveVMax
            "Flag, true if user specified data that contain V_flow_max";

          parameter Modelica.SIunits.VolumeFlowRate V_flow_max
            "Maximum volume flow rate, used for smoothing";

          parameter Integer nOri(min=1) "Number of data points for pressure curve"
            annotation(Evaluate=true);

         // Normalized speed
          Modelica.Blocks.Interfaces.RealInput y_in(final unit="1") if preSpe
            "Prescribed mover speed"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,120})));

          Modelica.Blocks.Interfaces.RealOutput y_out(
            final unit="1") "Mover speed (prescribed or computed)"
            annotation (Placement(transformation(extent={{100,90},{120,110}})));

          Modelica.Blocks.Interfaces.RealInput m_flow(
            final quantity="MassFlowRate",
            final unit="kg/s") "Mass flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          Modelica.Blocks.Interfaces.RealInput rho(
            final quantity="Density",
            final unit="kg/m3",
            min=0.0) "Medium density"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Modelica.Blocks.Interfaces.RealOutput V_flow(
            quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{100,38},{120,58}}),
                iconTransformation(extent={{100,38},{120,58}})));

          Modelica.Blocks.Interfaces.RealInput dp_in(
            quantity="PressureDifference",
            final unit="Pa") if prePre "Prescribed pressure increase"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={40,120})));

          Modelica.Blocks.Interfaces.RealOutput dp(
            quantity="Pressure",
            final unit="Pa") if not prePre "Pressure increase (computed or prescribed)"
            annotation (Placement(transformation(extent={{100,70},{120,90}})));

          Modelica.Blocks.Interfaces.RealOutput WFlo(
            quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));

          Modelica.Blocks.Interfaces.RealOutput PEle(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,-20},{120,0}}),
                iconTransformation(extent={{100,-20},{120,0}})));

          Modelica.Blocks.Interfaces.RealOutput eta(
            final quantity="Efficiency",
            final unit="1") "Overall efficiency"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));

          Modelica.Blocks.Interfaces.RealOutput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{100,-80},{120,-60}}),
                iconTransformation(extent={{100,-80},{120,-60}})));

          Modelica.Blocks.Interfaces.RealOutput etaMot(
            final quantity="Efficiency",
            final unit="1") "Motor efficiency"
            annotation (Placement(transformation(extent={{100,-110},{120,-90}}),
                iconTransformation(extent={{100,-110},{120,-90}})));

          // "Shaft rotational speed";
          Modelica.Blocks.Interfaces.RealOutput r_N(unit="1")
            "Ratio N_actual/N_nominal";
          Real r_V(start=1, unit="1") "Ratio V_flow/V_flow_max";

      protected
          final parameter Boolean preSpe=
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed
            "True if speed is a prescribed variable of this block";
          final parameter Boolean prePre=
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference or
            preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate
            "True if pressure head is a prescribed variable of this block";

          // Derivatives for cubic spline
          final parameter Real motDer[size(per.motorEfficiency.V_flow, 1)](each fixed=false)
            "Coefficients for polynomial of motor efficiency vs. volume flow rate";
          final parameter Real hydDer[size(per.hydraulicEfficiency.V_flow,1)](each fixed=false)
            "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";

          parameter Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")=
            if haveDPMax then
              per.pressure.dp[1]
            else
              per.pressure.dp[1] - ((per.pressure.dp[2] - per.pressure.dp[1])/(
                per.pressure.V_flow[2] - per.pressure.V_flow[1]))*per.pressure.V_flow[1]
            "Maximum head";

          parameter Real delta = 0.05
            "Small value used to for regularization and to approximate an internal flow resistance of the fan";

          parameter Real kRes(min=0, unit="kg/(s.m4)") =  dpMax/V_flow_max*delta^2/10
            "Coefficient for internal pressure drop of fan or pump";

          parameter Integer curve=
             if (haveVMax and haveDPMax) or (nOri == 2) then 1
             elseif haveVMax or haveDPMax then 2
             else 3
            "Flag, used to pick the right representatio of the fan or pump pressure curve";

          final parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur1(
            final n = nOri,
            final V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {per.pressure.V_flow[i] for i in 1:nOri}
                     else
                     zeros(nOri),
            final dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {(per.pressure.dp[i] + per.pressure.V_flow[i] * kRes) for i in 1:nOri}
                     else
                     zeros(nOri))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";

          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur2(
            final n = nOri + 1,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, { per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max})
                     else
                      zeros(nOri + 1),
            dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0})
                     else
                       zeros(nOri+1))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur3(
            final n = nOri + 2,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max}),
            dp =     if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0}))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";

          parameter Real preDer1[nOri](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer2[nOri+1](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer3[nOri+2](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real powDer[size(per.power.V_flow,1)]=
           if per.use_powerCharacteristic then
             Buildings.Utilities.Math.Functions.splineDerivatives(
                           x=per.power.V_flow,
                           y=per.power.P,
                           ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(x=per.power.P,
                                                                                             strict=false))
           else
             zeros(size(per.power.V_flow,1))
            "Coefficients for polynomial of power vs. flow rate";

          parameter Boolean haveMinimumDecrease=
            Modelica.Math.BooleanVectors.allTrue({(per.pressure.dp[i + 1] -
            per.pressure.dp[i])/(per.pressure.V_flow[i + 1] - per.pressure.V_flow[
            i]) < -kRes for i in 1:nOri - 1}) "Flag used for reporting";

          parameter Boolean haveDPMax = (abs(per.pressure.V_flow[1])  < Modelica.Constants.eps)
            "Flag, true if user specified data that contain dpMax";

          Modelica.Blocks.Interfaces.RealOutput dp_internal
            "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
        function getPerformanceDataAsString
          input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure
              "Performance data";
          input Real derivative[:](unit="kg/(s.m4)") "Derivative";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(derivative, 1) loop
            str :=str + "  V_flow[" + String(i) + "]=" + String(
                pressure.V_flow[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\t" + "dp[" + String(i) + "]=" +
                String(
                pressure.dp[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\tResulting derivative dp/dV_flow = "
                 + String(
                derivative[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getPerformanceDataAsString;

        function getArrayAsString
          input Real array[:] "Array to be printed";
          input String varName "Variable name";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(array, 1) loop
            str :=str + "  " + varName + "[" + String(i) + "]=" + String(
                array[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getArrayAsString;

        initial equation
          // Check validity of data
          assert(nOri > 1, "Must have at least two data points for pressure.V_flow.");
          assert(Buildings.Utilities.Math.Functions.isMonotonic(x=per.pressure.V_flow, strict=true) and
          per.pressure.V_flow[1] > -Modelica.Constants.eps,
          "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
"         + getArrayAsString(per.pressure.V_flow, "pressure.V_flow"));

          if not haveVMax then
            assert((per.pressure.V_flow[nOri]-per.pressure.V_flow[nOri-1])
                 /((per.pressure.dp[nOri]-per.pressure.dp[nOri-1]))<0,
            "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
"         + getArrayAsString(per.pressure.dp, "dp"));

          end if;

          // Write warning if the volumetric flow rate versus pressure curve does not satisfy
          // the minimum decrease condition
          if (not haveMinimumDecrease) then
            Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < "         + String(-kRes) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
"         + getArrayAsString({(per.pressure.dp[i+1]-per.pressure.dp[i])
                /(per.pressure.V_flow[i+1]-per.pressure.V_flow[i]) for i in 1:nOri-1}, "d") + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.");
          end if;

          // Correction for flow resistance of pump or fan
          if (haveVMax and haveDPMax) or (nOri == 2) then  // ----- Curve 1
            // V_flow_max and dpMax are provided by the user, or we only have two data points
            preDer1= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur1.V_flow,
              y=pCur1.dp);
            preDer2= zeros(nOri + 1);
            preDer3= zeros(nOri + 2);
          elseif haveVMax or haveDPMax then  // ----- Curve 2
            // V_flow_max or dpMax is provided by the user, but not both
            preDer1= zeros(nOri);
            preDer2= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur2.V_flow,
              y=pCur2.dp);
            preDer3= zeros(nOri + 2);
          else  // ----- Curve 3
            // Neither V_flow_max nor dpMax are provided by the user
            preDer1= zeros(nOri);
            preDer2= zeros(nOri + 1);
            preDer3= Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur3.V_flow,
              y=pCur3.dp);
          end if;

         // Compute derivatives for cubic spline
         motDer = if per.use_powerCharacteristic then zeros(size(per.motorEfficiency.V_flow,
            1)) elseif (size(per.motorEfficiency.V_flow, 1) == 1) then {0} else
            Buildings.Utilities.Math.Functions.splineDerivatives(
            x=per.motorEfficiency.V_flow,
            y=per.motorEfficiency.eta,
            ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(x=per.motorEfficiency.eta,
              strict=false));
          hydDer = if per.use_powerCharacteristic then zeros(size(per.hydraulicEfficiency.V_flow,
            1)) elseif (size(per.hydraulicEfficiency.V_flow, 1) == 1) then {0}
             else Buildings.Utilities.Math.Functions.splineDerivatives(x=per.hydraulicEfficiency.V_flow,
            y=per.hydraulicEfficiency.eta);

          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          //assign values of dp and r_N, depending on which variable exists and is prescribed
          connect(dp_internal,dp);
          connect(dp_internal,dp_in);
          connect(r_N, y_in);
          y_out=r_N;

          V_flow = m_flow/rho;

          // Hydraulic equations
          r_V = V_flow/V_flow_max;

          // If the speed is not prescribed and we do not require exact power computations, we set r_N = 1.
          // Similarity laws are then not used, meaning the power computation is less accurate.
          // This however has the advantage that no non-linear algebraic loop is formed and
          // it allows an implementation when the pressure curve is unknown.
          if (computePowerUsingSimilarityLaws == false) and preVar <> Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
            r_N=1;
          else
          // For the homotopy method, we approximate dp by an equation
          // that is linear in V_flow, and that goes linearly to 0 as r_N goes to 0.
          // The three branches below are identical, except that we pass either
          // pCur1, pCur2 or pCur3, and preDer1, preDer2 or preDer3
          if (curve == 1) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1),
                                                   simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                       r_N=r_N,
                                                       dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                       d=preDer1,
                                                       per=pCur1);
            end if;     // end of computation for this branch
           elseif (curve == 2) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2),
                                                    simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer2,
                                                              per=pCur2);
            end if;     // end of computation for this branch
          else
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3),
                                  simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                       +(V_flow-V_flow_nominal)*
                                               (cha.pressure(V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3))
                                                            /(2*delta*V_flow_nominal)));

            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer3,
                                                              per=pCur3);
            end if;
            // end of computation for this branch
          end if;
            // end of if/else choosing between exact/simplified power computation
          end if;

          // Flow work
          WFlo = dp_internal*V_flow;

          // Power consumption
          if per.use_powerCharacteristic then
            // For the homotopy, we want P/V_flow to be bounded as V_flow -> 0 to avoid a very high medium
            // temperature near zero flow.
            if homotopyInitialization then
              PEle = homotopy(actual=cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta),
                              simplified=V_flow/V_flow_nominal*
                                    cha.power(per=per.power, V_flow=V_flow_nominal, r_N=1, d=powDer, delta=delta));
            else
              PEle = (rho/rho_default)*cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta);
            end if;
            // To compute the efficiency, we set a lower bound on the electricity consumption.
            // This is needed because WFlo can be close to zero when P is zero, thereby
            // causing a division by zero.
            // Earlier versions of the model computed WFlo = eta * P, but this caused
            // a division by zero.
            eta = WFlo / Buildings.Utilities.Math.Functions.smoothMax(x1=PEle, x2=1E-5, deltaX=1E-6);
            // In this configuration, we only know the total power consumption.
            // Because nothing is known about etaMot versus etaHyd, we set etaHyd=1. This will
            // cause etaMot=eta, because eta=etaHyd*etaMot.
            // Earlier versions used etaMot=sqrt(eta), but as eta->0, this function has
            // and infinite derivative.
            etaHyd = 1;
            etaMot = eta;
          else
            if homotopyInitialization then
              etaHyd = homotopy(actual=cha.efficiency(per=per.hydraulicEfficiency,     V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow_max,   d=hydDer, r_N=r_N, delta=delta));
              etaMot = homotopy(actual=cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.motorEfficiency, V_flow=V_flow_max,   d=motDer, r_N=r_N, delta=delta));
            else
              etaHyd = cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta);
              etaMot = cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta);
            end if;
            // To compute the electrical power, we set a lower bound for eta to avoid
            // a division by zero.
            PEle = WFlo / Buildings.Utilities.Math.Functions.smoothMax(x1=eta, x2=1E-5, deltaX=1E-6);
            eta = etaHyd * etaMot;

          end if;

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                            graphics={
                Text(extent={{56,66},{106,52}},
                  lineColor={0,0,127},
                  textString="dp"),
                Text(extent={{56,8},{106,-6}},
                  lineColor={0,0,127},
                  textString="PEle"),
                Text(extent={{52,-22},{102,-36}},
                  lineColor={0,0,127},
                  textString="eta"),
                Text(extent={{50,-52},{100,-66}},
                  lineColor={0,0,127},
                  textString="etaHyd"),
                Text(extent={{50,-72},{100,-86}},
                  lineColor={0,0,127},
                  textString="etaMot"),
                Ellipse(
                  extent={{-78,34},{44,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-62,18},{28,-72}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-26,-18},{-8,-36}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,-22},{-32,-8},{-30,10},{-8,20},{-6,14},{-24,6},{-24,-8},{
                      -18,-20},{-26,-22}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-8,-32},{-2,-46},{-4,-64},{-26,-74},{-28,-68},{-10,-60},{-10,
                      -46},{-16,-34},{-8,-32}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{7,21},{13,7},{11,-11},{-11,-21},{-13,-15},{5,-7},{5,7},{-1,19},
                      {7,21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={9,-23},
                  rotation=90),
                Polygon(
                  points={{-7,-21},{-13,-7},{-11,11},{11,21},{13,15},{-5,7},{-5,-7},{1,-19},
                      {-7,-21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={-43,-31},
                  rotation=90),
                Text(extent={{56,36},{106,22}},
                  lineColor={0,0,127},
                  textString="WFlo"),
                Text(extent={{56,94},{106,80}},
                  lineColor={0,0,127},
                  textString="V_flow"),
                Line(
                  points={{-74,92},{-74,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-74,40},{46,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,86},{-40,84},{8,68},{36,42}},
                  color={0,0,0},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
This is an interface that implements the functions to compute the head, power draw
and efficiency of fans and pumps.
</p>
<p>
The nominal hydraulic characteristic (volume flow rate versus total pressure)
is given by a set of data points
using the data record <code>per</code>, which is an instance of
<a href=\"modelica://Buildings.Fluid.Movers.Data.Generic\">
Buildings.Fluid.Movers.Data.Generic</a>.
A cubic hermite spline with linear extrapolation is used to compute
the performance at other operating points.
</p>
<p>
The fan or pump energy balance can be specified in two alternative ways:
</p>
<ul>
<li>
If <code>per.use_powerCharacteristic = false</code>, then the data points for
normalized volume flow rate versus efficiency is used to determine the efficiency,
and then the power consumption. The default is a constant efficiency of <i>0.7</i>.
</li>
<li>
If <code>per.use_powerCharacteristic = true</code>, then the data points for
normalized volume flow rate versus power consumption
is used to determine the power consumption, and then the efficiency
is computed based on the actual power consumption and the flow work.
</li>
</ul>
<p>
For exceptions to this general rule, check the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>

<h4>Implementation</h4>
<p>
For numerical reasons, the user-provided data points for volume flow rate
versus pressure rise are modified to add a fan internal flow resistance.
Because this flow resistance is subtracted during the simulation when
computing the fan pressure rise, the model reproduces the exact points
that were provided by the user.
</p>
<p>
Also for numerical reasons, the pressure rise at zero flow rate and
the flow rate at zero pressure rise is added to the user-provided data,
unless the user already provides these data points.
Since Modelica 3.2 does not allow dynamic memory allocation, this
implementation required the use of three different arrays for the
situation where no additional point is added, where one additional
point is added and where two additional points are added.
The parameter <code>curve</code> causes the correct data record
to be used during the simulation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference and reformatted code.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 2, 2015, by Michael Wetter:<br/>
Corrected computation of
<code>etaMot = cha.efficiency(per=per.motorEfficiency, V_flow=V_flow, d=motDer, r_N=r_N, delta=1E-4)</code>
which previously used <code>V_flow_max</code> instead of <code>V_flow</code>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Removed in <code>N_actual</code> and <code>N_filtered</code>
the <code>max</code> attribute to
avoid a translation warning.
</li>
<li>
April 21, 2014, by Filip Jorissen and Michael Wetter:<br/>
Changed model to use
<a href=\"modelica://Buildings.Fluid.Movers.Data.Generic\">
Buildings.Fluid.Movers.Data.Generic</a>.
April 19, 2014, by Filip Jorissen:<br/>
Passed extra parameters to power() and efficiency()
to be able to properly evaluate the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 27, 2013, by Michael Wetter:<br/>
Reformulated <code>per=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3</code>
by moving the computation into the idividual logical branches because OpenModelica generates an
error when assign the statement to <code>data</code>
as <code>pCur1</code>, <code>pCur2</code> and <code>pCur3</code> have different dimensions.
</li>
<li>
September 17, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of parameters
that are an array.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Removed assignment in declaration of <code>pCur?.V_flow</code> as
these parameters have the attribute <code>fixed=false</code> set.
</li>
<li>
October 11, 2012, by Michael Wetter:<br/>
Added implementation of <code>WFlo = eta * P</code> with
guard against division by zero.
Changed implementation of <code>etaMot=sqrt(eta)</code> to
<code>etaHyd = 1</code> to avoid infinite derivative as <code>eta</code>
converges to zero.
</li>
<li>
February 20, 2012, by Michael Wetter:<br/>
Assigned value to nominal attribute of <code>V_flow</code>.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
October 4 2011, by Michael Wetter:<br/>
Revised the implementation of the pressure drop computation as a function
of speed and volume flow rate.
The new implementation avoids a singularity near zero volume flow rate and zero speed.
</li>
<li>
March 28 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FlowMachineInterface;

        model IdealSource
          "Base class for pressure and mass flow source with optional power input"
          extends Buildings.Fluid.Interfaces.PartialTwoPortTransport(show_T=false);

          // Quantity to control
          parameter Boolean control_m_flow
            "if true, then the mass flow rate is equal to the value of m_flow_in"
            annotation(Evaluate = true);
          parameter Boolean control_dp = not control_m_flow
            "if true, then the head is equal to the value of dp_in"
            annotation(Evaluate = true);

          Modelica.Blocks.Interfaces.RealInput m_flow_in(unit="kg/s") if control_m_flow
            "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in(unit="Pa") if control_dp
            "Prescribed pressure difference port_a.p-port_b.p"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));

      protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal(unit="kg/s")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal(unit="Pa")
            "Needed to connect to conditional connector";

        equation
          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
          else
            m_flow_internal = 0;
          end if;
          if control_dp then
            dp = dp_internal;
          else
            dp_internal = 0;
          end if;

          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);

          // Energy balance (no storage)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);

          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  lineColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  lineColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to
adding heat to the volume, and flow work to this model.
</p>
<p>
Typically either <code>control_m_flow</code> or
<code>control_dp</code> should be <code>true</code> to avoid a
singular system.
If <code>control_m_flow = true</code>, then the mass flow rate
is set to the value of the input connector <code>m_flow_in</code>.
Otherwise, this model does not specify the mass flow rate.
Similarly, if <code>control_dp = true</code>, the head is equal to the
value of the input connector <code>dp_in</code>.
Otherwise, this model does not specify the head.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 4, 2017, by Filip Jorissen:<br/>
Implemented option to set <code>control_dp</code>
independently from <code>control_m_flow</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 2, 2017, by Filip Jorissen:<br/>
Implemented simplification when <code>allowFlowReversal=false</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/673\">#673</a>.
</li>
<li>
March 20, 2016, by Michael Wetter:<br/>
Corrected documentation for <code>dp_in</code>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Added units to the signal connectors.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end IdealSource;

        partial model PartialFlowMachine
          "Partial model to interface fan or pump models with the medium"
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
            final mSenFac=1);
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            m_flow_nominal(final min=Modelica.Constants.small),
            show_T=false,
            port_a(
              h_outflow(start=h_outflow_start)),
            port_b(
              h_outflow(start=h_outflow_start),
              p(start=p_start),
              final m_flow(max = if allowFlowReversal then +Modelica.Constants.inf else 0)));

          replaceable parameter Buildings.Fluid.Movers.Data.Generic per
            constrainedby Buildings.Fluid.Movers.Data.Generic
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{52,60},{72,80}})));

          parameter Buildings.Fluid.Types.InputType inputType = Buildings.Fluid.Types.InputType.Continuous
            "Control input type"
            annotation(Dialog(
              group="Control"));
          parameter Real constInput = 0 "Constant input set point"
            annotation(Dialog(
              group="Control",
              enable=inputType == Buildings.Fluid.Types.InputType.Constant));
          parameter Real stageInputs[:]
            "Vector of input set points corresponding to stages"
            annotation(Dialog(
              group="Control",
              enable=inputType == Buildings.Fluid.Types.InputType.Stages));

          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          parameter Boolean addPowerToMedium=true
            "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Boolean nominalValuesDefineDefaultPressureCurve = false
            "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve";

          parameter Modelica.SIunits.Time tau=1
            "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic"
            annotation (Dialog(tab="Dynamics",
                                group="Nominal condition",
                                enable=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
                                       massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState));

          // Classes used to implement the filtered speed
          parameter Boolean use_inputFilter=true
            "= true, if speed is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered speed"));
          parameter Modelica.SIunits.Time riseTime=30
            "Rise time of the filter (time to reach 99.6 % of the speed)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));

          // Connectors and ports
            Modelica.Blocks.Interfaces.IntegerInput stage if
               inputType == Buildings.Fluid.Types.InputType.Stages
            "Stage input signal for the pressure head"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual(
            final unit="1")
            "Actual normalised pump speed that is used for computations"
            annotation (Placement(transformation(extent={{100,60},{120,80}}),
                iconTransformation(extent={{100,60},{120,80}})));

          Modelica.Blocks.Interfaces.RealOutput P(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat dissipation to environment"
            annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                iconTransformation(extent={{-10,-78},{10,-58}})));

          // Variables
          Modelica.SIunits.VolumeFlowRate VMachine_flow(start=_VMachine_flow) = eff.V_flow "Volume flow rate";
          Modelica.SIunits.PressureDifference dpMachine(displayUnit="Pa")=
              -preSou.dp "Pressure difference";

          Real eta(unit="1", final quantity="Efficiency") =    eff.eta "Global efficiency";
          Real etaHyd(unit="1", final quantity="Efficiency") = eff.etaHyd "Hydraulic efficiency";
          Real etaMot(unit="1", final quantity="Efficiency") = eff.etaMot "Motor efficiency";

          // Quantity to control
      protected
          final parameter Modelica.SIunits.VolumeFlowRate _VMachine_flow = 0
            "Start value for VMachine_flow, used to avoid a warning if not specified";

          parameter Types.PrescribedVariable preVar "Type of prescribed variable";

          // The parameter speedIsInput is required to conditionally remove the instance gain.
          // If the conditional removal of this instance where to use the test
          // preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          // then OpenModelica fails to translate the model with the message
          // .../PartialFlowMachine.mo:185:3-189:70:writable]
          // Error: Variable Types.PrescribedVariable.Speed not found in scope
          // Buildings.Fluid.Movers.SpeedControlled_y$floMac1.
          final parameter Boolean speedIsInput=
            (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)
            "Parameter that is true if speed is the controlled variables";

          final parameter Integer nOri = size(per.pressure.V_flow, 1)
            "Number of data points for pressure curve"
            annotation(Evaluate=true);

          final parameter Boolean haveVMax = (abs(per.pressure.dp[nOri]) < Modelica.Constants.eps)
            "Flag, true if user specified data that contain V_flow_max";

          final parameter Modelica.SIunits.VolumeFlowRate V_flow_max=
            if per.havePressureCurve then
            (if haveVMax then
              per.pressure.V_flow[nOri]
             else
              per.pressure.V_flow[nOri] - (per.pressure.V_flow[nOri] - per.pressure.V_flow[
              nOri - 1])/((per.pressure.dp[nOri] - per.pressure.dp[nOri - 1]))*per.pressure.dp[nOri])
            else
              m_flow_nominal/rho_default "Maximum volume flow rate, used for smoothing";
          final parameter Modelica.SIunits.Density rho_default=
            Medium.density_pTX(
              p=Medium.p_default,
              T=Medium.T_default,
              X=Medium.X_default) "Default medium density";

          final parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start) "Medium state at start values";

          final parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
            "Start value for outflowing enthalpy";

          final parameter Modelica.SIunits.Frequency fCut = 5/(2*Modelica.Constants.pi*riseTime)
            "Cut-off frequency of filter";

          Modelica.Blocks.Sources.Constant[size(stageInputs, 1)] stageValues(
            final k=stageInputs) if
              inputType == Buildings.Fluid.Types.InputType.Stages "Stage input values"
            annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Blocks.Sources.Constant setConst(
            final k=constInput) if
              inputType == Buildings.Fluid.Types.InputType.Constant
            "Constant input set point"
            annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

          Extractor extractor(final nin=size(stageInputs,1)) if
              inputType == Buildings.Fluid.Types.InputType.Stages "Stage input extractor"
            annotation (Placement(transformation(extent={{-50,60},{-30,40}})));

          Modelica.Blocks.Routing.RealPassThrough inputSwitch
            "Dummy connection for easy connection of input options"
            annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                origin={-10,50})));

          Buildings.Fluid.Delays.DelayFirstOrder vol(
            redeclare final package Medium = Medium,
            final tau=tau,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final m_flow_nominal=m_flow_nominal,
            final m_flow_small=m_flow_small,
            final p_start=p_start,
            final prescribedHeatFlowRate=true,
            final allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-70,0},{-90,20}})));

          Buildings.Fluid.BaseClasses.ActuatorFilter filter(
            final n=2,
            final f=fCut,
            final normalized=true,
            final initType=init) if use_inputFilter
            "Second order filter to approximate dynamics of pump speed, and to improve numerics"
            annotation (Placement(transformation(extent={{20,61},{40,80}})));

          Modelica.Blocks.Math.Gain gaiSpe(y(final unit="1")) if
            inputType == Buildings.Fluid.Types.InputType.Continuous and
            speedIsInput
            "Gain to normalized speed using speed_nominal or speed_rpm_nominal"
            annotation (Placement(transformation(extent={{-4,74},{-16,86}})));

          Buildings.Fluid.Movers.BaseClasses.IdealSource preSou(
            redeclare final package Medium = Medium,
            final m_flow_small=m_flow_small,
            final allowFlowReversal=allowFlowReversal,
            final control_m_flow= (preVar ==  Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate))
            "Pressure source"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));

          Buildings.Fluid.Movers.BaseClasses.PowerInterface heaDis(
            final motorCooledByFluid=per.motorCooledByFluid,
            final delta_V_flow=1E-3*V_flow_max) if
              addPowerToMedium "Heat dissipation into medium"
            annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

          Modelica.Blocks.Math.Add PToMed(final k1=1, final k2=1) if
            addPowerToMedium "Heat and work input into medium"
            annotation (Placement(transformation(extent={{50,-90},{70,-70}})));

          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prePow(
            final alpha=0) if
            addPowerToMedium
            "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-14,-104},{-34,-84}})));

          Modelica.Blocks.Sources.RealExpression rho_inlet(y=
            Medium.density(
              Medium.setState_phX(port_a.p,
                                  inStream(port_a.h_outflow),
                                  inStream(port_a.Xi_outflow))))
            "Density of the inflowing fluid"
            annotation (Placement(transformation(extent={{-90,-74},{-70,-54}})));

          Buildings.Fluid.Sensors.MassFlowRate senMasFlo(
            redeclare final package Medium = Medium) "Mass flow rate sensor"
            annotation (Placement(transformation(extent={{-50,10},{-30,-10}})));

          Sensors.RelativePressure senRelPre(
            redeclare final package Medium = Medium) "Head of mover"
            annotation (Placement(transformation(extent={{58,-27},{43,-14}})));

          // Because the speed data are not used by FlowMachineInterface, we set them
          // to zero.
          FlowMachineInterface eff(
            per(
              final hydraulicEfficiency = per.hydraulicEfficiency,
              final motorEfficiency =     per.motorEfficiency,
              final motorCooledByFluid =  per.motorCooledByFluid,
              final speed_nominal =       0,
              final constantSpeed =       0,
              final speeds =              {0},
              final power =               per.power),
            final nOri = nOri,
            final rho_default=rho_default,
            final computePowerUsingSimilarityLaws=computePowerUsingSimilarityLaws,
            final haveVMax=haveVMax,
            final V_flow_max=V_flow_max,
            r_V(start=m_flow_nominal/rho_default),
            final preVar=preVar) "Flow machine"
            annotation (Placement(transformation(extent={{-32,-68},{-12,-48}})));

      protected
          block Extractor
            "Extract scalar signal out of signal vector dependent on IntegerRealInput index"
            extends Modelica.Blocks.Interfaces.MISO;

            Modelica.Blocks.Interfaces.IntegerInput index "Integer input for control input"
            annotation (Placement(
                  transformation(
                  origin={0,-120},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          equation
          y = sum({if index == i then u[i] else 0 for i in 1:nin});

          annotation (Icon(graphics={
                  Rectangle(
                    extent={{-80,50},{-40,-50}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                        -84.4104,1.9079}},
                    lineColor={0,0,127},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                        127}),
                  Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
                  Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
                  Ellipse(
                    extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
                  Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                        0,0,127}),
                  Polygon(
                    points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-39,42},{-39,38},{-35,40},{-39,42}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                        {-38.8728,-38.0295}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                        14.8801}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-30,50},{30,-50}},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{100,0},{0,0}}, color={0,0,127}),
                  Line(points={{0,2},{0,-104}}, color={255,128,0}),
                  Line(points={{-35,40},{-20,40}}, color={0,0,127}),
                  Line(points={{-35,13},{-20,13}}, color={0,0,127}),
                  Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
                  Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
                  Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                        127}),
                  Ellipse(
                    extent={{-6,6},{6,-6}},
                    lineColor={255,128,0},
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid)}));
          end Extractor;

        initial equation
          // Check incorrect value of m_flow_nominal
          assert(m_flow_nominal >= Modelica.Constants.small, "In "+ getInstanceName()+
          ": The value of parameter m_flow_nominal should be greater or equal than " +
          String(Modelica.Constants.small) + " but it equals " + String(m_flow_nominal));
          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // Therefore, scaling the power using the speed is inaccurate.
          assert(nominalValuesDefineDefaultPressureCurve or
                 per.havePressureCurve or
                 (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed),
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // In addition, the user wants to use (V_flow, P) to compute the power.
          // This can lead to using a power that is less than the flow work. We avoid
          // this by ignoring the setting of per.use_powerCharacteristics.
          // The comment is split into two parts since otherwise the JModelica C-compiler
          // throws warnings.
          assert(nominalValuesDefineDefaultPressureCurve or
                 (per.havePressureCurve or
                   (preVar == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)) or
                 per.use_powerCharacteristic == false,
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false."         +
                     "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

        equation
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-34,-94},{-60,-94},{-60,10},{-70,10}},
              color={191,0,0}));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-70,10},{-70,10},{-60,10},{-60,-100}},
              color={191,0,0}));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{60,0},{100,0}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(stageValues.y, extractor.u) annotation (Line(
              points={{-59,50},{-52,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.y, inputSwitch.u) annotation (Line(
              points={{-29,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(setConst.y, inputSwitch.u) annotation (Line(
              points={{-59,80},{-26,80},{-26,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.index, stage) annotation (Line(
              points={{-40,62},{-40,90},{0,90},{0,120}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(PToMed.y, prePow.Q_flow) annotation (Line(points={{71,-80},{80,-80},{80,
                  -94},{-14,-94}},                 color={0,0,127}));
          connect(PToMed.u1, heaDis.Q_flow) annotation (Line(points={{48,-74},{44,-74},{
                  44,-72},{44,-70},{41,-70}},
                                     color={0,0,127}));

          connect(senRelPre.port_b, preSou.port_a) annotation (Line(points={{43,-20.5},{
                  20,-20.5},{20,0},{40,0}},
                                       color={0,127,255}));
          connect(senRelPre.port_a, preSou.port_b) annotation (Line(points={{58,-20.5},{
                  80,-20.5},{80,0},{60,0}},
                                       color={0,127,255}));
          connect(heaDis.etaHyd,eff. etaHyd) annotation (Line(points={{18,-60},{10,-60},
                  {10,-65},{-11,-65}},                     color={0,0,127}));
          connect(heaDis.V_flow,eff. V_flow) annotation (Line(points={{18,-66},{14,-66},
                  {14,-53.2},{-6,-53.2},{-11,-53.2}},
                                             color={0,0,127}));
          connect(eff.PEle, heaDis.PEle) annotation (Line(points={{-11,-59},{0,-59},{0,-80},
                  {18,-80}},      color={0,0,127}));
          connect(eff.WFlo, heaDis.WFlo) annotation (Line(points={{-11,-56},{-8,-56},{-8,
                  -74},{18,-74}}, color={0,0,127}));
          connect(rho_inlet.y,eff. rho) annotation (Line(points={{-69,-64},{-69,-64},{-34,
                  -64}},                          color={0,0,127}));
          connect(eff.m_flow, senMasFlo.m_flow) annotation (Line(points={{-34,-54},{-34,
                  -54},{-40,-54},{-40,-11}},               color={0,0,127}));
          connect(eff.PEle, P) annotation (Line(points={{-11,-59},{0,-59},{0,-50},{90,
                  -50},{90,90},{110,90}},
                                     color={0,0,127}));
          connect(eff.WFlo, PToMed.u2) annotation (Line(points={{-11,-56},{-8,-56},{-8,-86},
                  {48,-86}},      color={0,0,127}));
          connect(inputSwitch.y, filter.u) annotation (Line(points={{1,50},{12,50},{12,70.5},
                  {18,70.5}},     color={0,0,127}));

          connect(senRelPre.p_rel, eff.dp_in) annotation (Line(points={{50.5,-26.35},{50.5,
                  -38},{-18,-38},{-18,-46}},               color={0,0,127}));
          connect(eff.y_out, y_actual) annotation (Line(points={{-11,-48},{92,-48},{92,
                  70},{110,70}},
                             color={0,0,127}));
          connect(port_a, vol.ports[1])
            annotation (Line(points={{-100,0},{-78,0},{-78,0}}, color={0,127,255}));
          connect(vol.ports[2], senMasFlo.port_a)
            annotation (Line(points={{-82,0},{-82,0},{-50,0}}, color={0,127,255}));
          connect(senMasFlo.port_b, preSou.port_a)
            annotation (Line(points={{-30,0},{40,0},{40,0}}, color={0,127,255}));
           annotation(Icon(coordinateSystem(preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}),
            graphics={
                Line(
                  points={{0,70},{100,70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,90},{100,90}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}}),
                Rectangle(
                  extent={{-100,16},{100,-16}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-58,58},{58,-58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,50},{0,-50},{54,0},{0,50}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{4,16},{36,-16}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState,
                  fillColor={0,100,199}),
                Text(extent={{64,106},{114,92}},
                  lineColor={0,0,127},
                  textString="P"),
                Text(extent={{42,86},{92,72}},
                  lineColor={0,0,127},
                  textString="y_actual"),
                Line(
                  points={{0,100},{0,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{34,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{34,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,92},{22,46}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
            Documentation(info="<html>
<p>
This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Optionally, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 17, 2021, by Michael Wetter:<br/>
Changed implementation of the filter.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1498\">#1498</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
January 22, 2019, by Filip Jorissen:<br/>
Split long assert output string into two strings to avoid compiler warnings
in JModelica.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1081\">#1081</a>.
</li>
<li>
January 8, 2019, by Filip Jorissen:<br/>
Added assert for value of <code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/908\">#908</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Set start value for <code>VMachine_flow</code> to avoid a warning in
<a href=\"modelica://Buildings.Fluid.Movers.Examples.MoverContinuous\">
Buildings.Fluid.Movers.Examples.MoverContinuous</a>.
</li>
<li>
July 29, 2016, by Michael Wetter:<br/>
Made <code>Extractor</code> protected so that it can be removed later
with a backwards compatible change.
</li>
<li>
July 19, 2016, by Filip Jorissen:<br/>
Created custom implementation for extractor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/498\">#498</a>.
</li>
<li>
June 16, 2016, by Filip Jorissen:<br/>
Switched position of mixing volume and mass flow rate sensor.
This is to have a consistent operating point tuple
of <code>dp</code> and <code>m_flow</code> when having
compressible flow.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This model now includes code for both speed and flow prescribed models,
eliminating the need for an additional level of partial models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
Removed the parameter <code>dynamicBalance</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">#411</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
Removed assignment of <code>min</code> and <code>max</code> attributes
of the port mass flow rate as this is already done in the base class.
Removed <code>import</code> statement.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
Added code for displaying constant set point in symbol.
</li>
<li>
January 24, 2015, by Michael Wetter:<br/>
Propagated <code>m_flow_small</code> of instance <code>vol</code> and made
all its parameters final.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br/>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        model PowerInterface
          "Partial model to compute power draw and heat dissipation of fans and pumps"
          extends Modelica.Blocks.Icons.Block;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Boolean motorCooledByFluid
            "Flag, true if the motor is cooled by the fluid stream";

          parameter Modelica.SIunits.VolumeFlowRate delta_V_flow
            "Factor used for setting heat input into medium to zero at very small flows";

          Modelica.Blocks.Interfaces.RealInput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{-140,80},{-100,120}}),
                iconTransformation(extent={{-140,80},{-100,120}})));

          Modelica.Blocks.Interfaces.RealInput V_flow(
            final quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,20},{-100,60}})));

          Modelica.Blocks.Interfaces.RealInput WFlo(
            final quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
                iconTransformation(extent={{-140,-60},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealInput PEle(
            final quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{-140,-120},{-100,-80}})));

          Modelica.Blocks.Interfaces.RealOutput Q_flow(
            quantity="Power",
            final unit="W") "Heat input from fan or pump to medium"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          Modelica.SIunits.Power WHyd
            "Hydraulic power input (converted to flow work and heat)";

      protected
          Modelica.SIunits.HeatFlowRate QThe_flow
            "Heat input from fan or pump to medium";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd * WHyd   = WFlo;
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then PEle else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          Q_flow = if homotopyInitialization then
            homotopy(actual=Buildings.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow),
                    simplified=0)
            else
              Buildings.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
            Line( origin={-49.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={0.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={50.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Polygon(
            origin={48,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-2,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-52,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0})}),
            Documentation(info="<html>
<p>Block that implements the functions to compute the
heat dissipation of fans and pumps. It is used by the model
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine\">
Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
First implementation during refactoring of mover models to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
</ul>
</html>"));
        end PowerInterface;

        package Characteristics "Functions for fan or pump characteristics"

          function efficiency "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per
              "Efficiency performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real delta "Small value for switching implementation around zero rpm";
            output Real eta(unit="1", final quantity="Efficiency") "Efficiency";

        protected
            Integer n = size(per.V_flow, 1) "Number of data points";
            Real rat "Ratio of V_flow/r_N";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := per.eta[1];
            else
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      Buildings.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              i :=1;
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.eta[i],
                          y2=per.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;

            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>", revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Corrected documentation as curve uses <i>V&#775;</i>
as an independent variable.
</li>
<li>
September 30, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow</code>
instead of <code>r_V</code>.
</li>
<li>
April 19, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>r_V/r_N</code>
instead of <code>r_V</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiency;

          function power "Flow vs. electrical power characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters per
              "Pressure performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real delta "Small value for switching implementation around zero rpm";
            output Modelica.SIunits.Power P "Power consumption";

        protected
             Integer n=size(per.V_flow, 1) "Dimension of data vector";

             Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_N";
             Integer i "Integer to select data interval";

          algorithm
            if n == 1 then
              P := r_N^3*per.P[1];
            else
              i :=1;
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      Buildings.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              P:=r_N^3*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.P[i],
                          y2=per.P[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan power consumption for given volume flow rate,
speed and performance data. The power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  P = r<sub>N</sub><sup>3</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>P</i> is the power consumption,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow/r_N</code>
instead of <code>V_flow</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end power;

          function pressure
            "Pump or fan head away from the origin without correction for mover flow resistance"
            extends Modelica.Icons.Function;

            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives of flow rate vs. pressure at the support points";
            input Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")
              "Maximum pressure drop at nominal speed, for regularisation";
            input Modelica.SIunits.VolumeFlowRate V_flow_max
              "Maximum flow rate at nominal speed, for regularisation";
            input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal per
              "Pressure performance data";

            output Modelica.SIunits.PressureDifference dp(displayUnit="Pa") "Pressure raise";

        protected
            constant Real delta = 0.05
              "Small number for r_N below which we don't care about the affinity laws";
            constant Real delta2 = delta/2 "= delta/2";
            Real r_R(unit="1") "Relative revolution, bounded below by delta";
            Integer i "Integer to select data interval";
            Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_R";

          algorithm
            // For r_N < delta, we restrict r_N in the term V_flow/r_N.
            // This is done using a cubic spline in a region 0.75*delta < r_N < 1.25*r_N
            // We call this restricted value r_R
            if r_N > delta then
              r_R :=r_N;
            elseif r_N < 0 then
              r_R := delta2;
            else
              // Restrict r_N using a spline
              r_R :=Modelica.Fluid.Utilities.cubicHermite(
                x=r_N,
                x1=0,
                x2=delta,
                y1=delta2,
                y2=delta,
                y1d=0,
                y2d=1);
            end if;

            i :=1;

            rat := V_flow/r_R;
            for j in 1:size(d, 1)-1 loop
              if rat > per.V_flow[j] then
                i := j;
              end if;
            end for;
            // In the assignment below,
            // dp -> 0 as r_N -> 0 quadratically, because rat is bounded
            // by the above regularization
            if r_N>=0 then
              dp:=r_N^2*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                        x=rat,
                        x1=per.V_flow[i],
                        x2=per.V_flow[i + 1],
                        y1=per.dp[i],
                        y2=per.dp[i + 1],
                        y1d=d[i],
                        y2d=d[i+1]);
            else
              dp:=-r_N^2*(dpMax-dpMax/V_flow_max*V_flow);
            end if;
          annotation(smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = r<sub>N</sub><sup>2</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&Delta;p</i> is the pressure rise,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
<p>
The function allows <i>r<sub>N</sub></i> to be zero.
</p>
</html>",   revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter and Filip Jorissen:<br/>
Changed implementation to allow <code>r_N = 0</code>.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 7, 2016, by Michael Wetter:<br/>
Moved function which was a protected function to make it public, as it
is now called by
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</li>
</ul>
</html>"));
          end pressure;

          record efficiencyParameters "Record for efficiency parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](
              each min=0) "Volumetric flow rate at user-selected operating points";
            parameter Modelica.SIunits.Efficiency eta[size(V_flow,1)](
              each max=1) "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
efficiency.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          record flowParameters "Record for flow parameters"
            extends Modelica.Icons.Record;

            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[size(V_flow,1)](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";

            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParameters;

          record flowParametersInternal "Record for flow parameters with prescribed size"
            extends Modelica.Icons.Record;
            parameter Integer n "Number of elements in each array"
             annotation(Evaluate=true);
            parameter Modelica.SIunits.VolumeFlowRate V_flow[n](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[n](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
<p>
This record is identical to
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters</a>,
except that it takes the size of the array as a parameter. This is required
in Dymola 2014. Otherwise, the array size would need to be computed in
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
in the <code>initial algorithm</code> section, which is not supported.
</p>
</html>", revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
March 22, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParametersInternal;

          record powerParameters "Record for electrical power parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.Power P[size(V_flow,1)](each min=0)
              "Fan or pump electrical power at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
electrical power.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>P</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
October 10, 2012, by Michael Wetter:<br/>
Fixed wrong <code>displayUnit</code> and
<code>max</code> attribute for power.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end powerParameters;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for information about these performance curves.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter:<br/>
Deleted function <code>performanceCurve</code> as it is no longer needed. Instead, the function
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure\">
Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure</a>
is used for all speeds.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type PrescribedVariable = enumeration(
            Speed   "Speed is prescribed",
            FlowRate   "Flow rate is prescribed",
            PressureDifference   "Pressure difference is prescribed")
            "Enumeration to choose what variable is prescribed";
         annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions for movers.
</p>
</html>"));
        end Types;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Movers\">Buildings.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for fans and pumps.
</html>"),
      Icon(graphics={Ellipse(
            extent={{-66,66},{68,-68}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid), Polygon(
            points={{0,66},{0,-68},{68,0},{0,66}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      model MassFlowRate "Ideal sensor for mass flow rate"
      extends Buildings.Fluid.Sensors.BaseClasses.PartialFlowSensor(
        final m_flow_nominal = 0,
        final m_flow_small = 0);
      extends Modelica.Icons.RotationalSensor;
      Modelica.Blocks.Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                   final unit="kg/s")
        "Mass flow rate from port_a to port_b" annotation (Placement(
            transformation(
            origin={0,110},
            extent={{10,-10},{-10,10}},
            rotation=270)));

      equation
      m_flow = port_a.m_flow;
        annotation (
          defaultComponentName="senMasFlo",
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Line(points={{70,0},{100,0}}, color={0,128,255}),
            Text(
              extent={{162,120},{2,90}},
              lineColor={0,0,0},
              textString="m_flow"),
            Line(points={{0,100},{0,70}}, color={0,0,127}),
            Line(points={{-100,0},{-70,0}}, color={0,128,255}),
            Text(
              extent={{-20,116},{-140,66}},
              lineColor={0,0,0},
              textString=DynamicSelect("", String(m_flow, leftjustified=false, significantDigits=3)))}),
      Documentation(info="<html>
<p>
This model outputs the mass flow rate flowing from
<code>port_a</code> to <code>port_b</code>.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end MassFlowRate;

      model RelativePressure "Ideal relative pressure sensor"
        extends Modelica.Icons.TranslationalSensor;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the sensor"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        Modelica.Fluid.Interfaces.FluidPort_a port_a(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream a"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream b"
          annotation (Placement(transformation(extent={{110,-12},{90,8}}), iconTransformation(extent={{110,-10},{90,10}})));

        Modelica.Blocks.Interfaces.RealOutput p_rel(final quantity="PressureDifference",
                                                    final unit="Pa",
                                                    displayUnit="Pa")
          "Relative pressure of port_a minus port_b" annotation (Placement(transformation(
              origin={0,-90},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = 0;
        port_b.h_outflow = 0;
        port_a.Xi_outflow = zeros(Medium.nXi);
        port_b.Xi_outflow = zeros(Medium.nXi);
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        // Relative pressure
        p_rel = port_a.p - port_b.p;
        annotation (defaultComponentName="senRelPre",
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Line(points={{0,-30},{0,-80}}, color={0,0,127}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{130,-70},{4,-100}},
                lineColor={0,0,0},
                textString="p_rel"),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255}),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-20,-56},{-140,-106}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(p_rel, leftjustified=false, significantDigits=3)))}),
          Documentation(info="<html>
<p>
The relative pressure <code>port_a.p - port_b.p</code> is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
Corrected the quantity of the output signal from <code>Pressure</code>
to <code>PressureDifference</code>.
This was needed for the model
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>
when revising it for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">
issue 417</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation, based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end RelativePressure;

      model TemperatureTwoPort "Ideal two port temperature sensor"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit="K",
                                                displayUnit = "degC",
                                                min = 0,
                                                start=T_start)
          "Temperature of the passing fluid"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
          "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));

        parameter Boolean transferHeat = false
          "if true, temperature T converges towards TAmb when no flow"
          annotation(Evaluate=true, Dialog(group="Heat transfer"));
        parameter Modelica.SIunits.Temperature TAmb=Medium.T_default
          "Fixed ambient temperature for heat transfer"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));
        parameter Modelica.SIunits.Time tauHeaTra(min=1)=1200
          "Time constant for heat transfer, default 20 minutes"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));

    protected
        parameter Real tauHeaTraInv(final unit = "1/s")=
          if tauHeaTra<1E-10 then 0 else 1/tauHeaTra
          "Dummy parameter to avoid division by tauHeaTra";
        parameter Real ratTau = if dynamic then tauHeaTra/tau else 1
          "Ratio of tau";
        Medium.Temperature TMed(start=T_start)
          "Medium temperature to which the sensor is exposed";
        Medium.Temperature T_a_inflow "Temperature of inflowing fluid at port_a";
        Medium.Temperature T_b_inflow
          "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(T) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            T = T_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           T_a_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_b_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_a.p, h=port_a.h_outflow, X=port_a.Xi_outflow));
           TMed = Modelica.Fluid.Utilities.regStep(
                    x=port_a.m_flow,
                    y1=T_a_inflow,
                    y2=T_b_inflow,
                    x_small=m_flow_small);
        else
           TMed = Medium.temperature(state=
                    Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_a_inflow = TMed;
           T_b_inflow = TMed;
        end if;
        // Output signal of sensor
        if dynamic then
          if transferHeat then
            der(T) = (TMed-T)*k*tauInv + (TAmb-T)*tauHeaTraInv/(ratTau*k+1);
          else
            der(T) = (TMed-T)*k*tauInv;
          end if;
        else
          T = TMed;
        end if;
      annotation (defaultComponentName="senTem",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Line(points={{-100,0},{92,0}}, color={0,128,255}),
              Ellipse(
                extent={{-20,-58},{20,-20}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,60},{-12,60}}),
              Line(points={{-40,30},{-12,30}}),
              Line(points={{-40,0},{-12,0}}),
              Rectangle(
                extent={{-12,60},{12,-24}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,60},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{12,
                    80},{12,60},{-12,60}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Text(
                extent={{102,140},{-18,90}},
                lineColor={0,0,0},
                textString="T"),
              Line(
                points={{-12,60},{-12,-25}},
                thickness=0.5),
              Line(
                points={{12,60},{12,-24}},
                thickness=0.5),
              Line(points={{0,100},{0,50}}, color={0,0,127}),
          Line(
          origin={-77.5,-22.3333},
          points={{43.5,8.3333},{37.5,0.3333},{21.5,-3.6667},{37.5,-17.6667},{7.5,-17.6667},
                    {19.5,-37.6667},{3.5,-38.3333},{-2.5,-48.3333}},
            smooth=Smooth.Bezier,
            visible=transferHeat),
              Polygon(
                points={{-90,-80},{-84,-66},{-76,-74},{-90,-80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={0,0,0},
                visible=transferHeat),
              Text(
               extent={{-20,120},{-140,70}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(T-273.15, format=".1f")))}),
          Documentation(info="<html>
<p>
This model outputs the temperature of the medium in the flow
between its fluid ports. The sensor does not influence the fluid.
</p>
<h4>Typical use and important parameters</h4>
<p>
If the parameter <code>tau</code> is non-zero, then its output <i>T</i>
converges to the temperature of the incoming fluid using
a first order differential equation.
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
<p>
If <code>transferHeat = true</code>, then heat transfer with the ambient is
approximated and <i>T</i> converges towards the fixed ambient
temperature <i>T<sub>Amb</sub></i> using a first order approximation
with a time constant of <code>tauHeaTra</code>
when the flow rate is small.
Note that no energy is exchanged with the fluid as the
sensor does not influence the fluid temperature.
</p>
<p>
Setting <code>transferHeat = true</code> is useful, for example,
if the sensor is used to measure the fluid temperature in
a system with on/off control on the mass flow rate.
If <code>transferHeat</code> were <code>false</code>, then the sensor output <i>T</i>
would remain constant if the mass flow rate is set to zero, and hence
the controller may never switch the mass flow rate on again.
</p>
<p>
In general, applications in which the sensor output is not used to switch
the mass flow rate on should set <code>transferHeat=false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 23, 2017 by Filip Jorissen:<br/>
Revised implementation of equations
when <code>transferHeat=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/840\">#840</a>.
</li>
<li>
January 12, 2016 by Filip Jorissen:<br/>
Removed parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
</li>
<li>
June 19, 2015 by Michael Wetter:<br/>
Revised model and documentation.
</li>
<li>
June 18, 2015 by Filip Jorissen:<br/>
Added option for simulating thermal losses.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Set start attribute for temperature output. Prior to this change,
the output was 0 at initial time, which caused the plot of the output to
use 0 Kelvin as the lower value of the ordinate.
</li>
<li>
September 10, 2008, by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://Buildings.Fluid.Sensors.Temperature\">Buildings.Fluid.Sensors.Temperature</a>.
</li>
</ul>
</html>"));
      end TemperatureTwoPort;

      model VolumeFlowRate "Ideal sensor for volume flow rate"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor(
          tau=0);
        extends Modelica.Icons.RotationalSensor;
        parameter Medium.Density
          d_start=Medium.density(Medium.setState_pTX(p_start, T_start, X_start))
          "Initial or guess value of density"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
          "Temperature used to compute d_start"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.Pressure p_start=Medium.p_default
          "Pressure used to compute d_start"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.MassFraction X_start[Medium.nX]=Medium.X_default
          "Mass fraction used to compute d_start"
          annotation (Dialog(group="Initialization"));
        Modelica.Blocks.Interfaces.RealOutput V_flow(final quantity="VolumeFlowRate",
                                                     final unit="m3/s")
          "Volume flow rate from port_a to port_b"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
    protected
        Medium.Density dMed(start=d_start)
          "Medium temperature to which the sensor is exposed";

        Medium.Density d_a_inflow(start=d_start)
          "Density of inflowing fluid at port_a";
        Medium.Density d_b_inflow(start=d_start)
          "Density of inflowing fluid at port_b, or rho_a_inflow if uni-directional flow";
        Medium.Density d(start=d_start) "Density of the passing fluid";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(d) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            d = d_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           d_a_inflow = Medium.density(state=
                          Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           d_b_inflow = Medium.density(state=
                          Medium.setState_phX(p=port_a.p, h=port_a.h_outflow, X=port_a.Xi_outflow));
           dMed = Modelica.Fluid.Utilities.regStep(
                    x=port_a.m_flow,
                    y1=d_a_inflow,
                    y2=d_b_inflow,
                    x_small=m_flow_small);
        else
           dMed = Medium.density(state=Medium.setState_phX(
                    p=port_b.p,
                    h=port_b.h_outflow,
                    X=port_b.Xi_outflow));
           d_a_inflow = dMed;
           d_b_inflow = dMed;
        end if;
        // Output signal of density sensor that is used to compute
        // the volume flow rate
        if dynamic then
          der(d) = (dMed-d)*k*tauInv;
        else
          d = dMed;
        end if;
        // Volume flow rate
        V_flow = port_a.m_flow/d;
      annotation (defaultComponentName="senVolFlo",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Text(
                extent={{160,120},{0,90}},
                lineColor={0,0,0},
                textString="V_flow"),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Line(points={{-100,0},{-70,0}}, color={0,128,255}),
              Line(points={{70,0},{100,0}}, color={0,128,255}),
              Text(
               extent={{-20,120},{-140,70}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(V_flow, leftjustified=false, significantDigits=3)))}),
        Documentation(info="<html>
<p>
This model outputs the volume flow rate flowing from
<code>port_a</code> to <code>port_b</code>.
The sensor is ideal, i.e., it does not influence the fluid.
If the parameter <code>tau</code> is non-zero, then the measured
density that is used to convert the mass flow rate into
volumetric flow rate is computed using a first order differential equation.
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 19, 2020, by Antoine Gautier:<br/>
Changed default value for <code>tau</code> from <code>1</code> to <code>0</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1406\">#1406</a>.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
January 18, 2016 by Filip Jorissen:<br/>
Using parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
August 31, 2013, by Michael Wetter:<br/>
Removed default value <code>tau=0</code> as the base class
already sets <code>tau=1</code>.
This change was made so that all sensors use the same default value.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end VolumeFlowRate;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialDynamicFlowSensor
          "Partial component to model sensors that measure flow properties using a dynamic model"
          extends PartialFlowSensor;

          parameter Modelica.SIunits.Time tau(min=0) = 1
            "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
          parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState
            "Type of initialization (InitialState and InitialOutput are identical)"
          annotation(Evaluate=true, Dialog(group="Initialization"));
      protected
          Real k(start=1)
            "Gain to take flow rate into account for sensor time constant";
          final parameter Boolean dynamic = tau > 1E-10 or tau < -1E-10
            "Flag, true if the sensor is a dynamic sensor"
            annotation(Evaluate=true);
          Real mNor_flow "Normalized mass flow rate";
          final parameter Real tauInv(final unit="s-1")= if dynamic then 1/tau else 0
            "Inverse of tau";
        equation
          if dynamic then
            mNor_flow = port_a.m_flow/m_flow_nominal;
            k = Modelica.Fluid.Utilities.regStep(x=port_a.m_flow,
                                                 y1= mNor_flow,
                                                 y2=-mNor_flow,
                                                 x_small=m_flow_small);
          else
            mNor_flow = 1;
            k = 1;
          end if;
          annotation (Icon(graphics={
                Line(visible=(tau <> 0),
                points={{52,60},{58,74},{66,86},{76,92},{88,96},{98,96}}, color={0,
                      0,127})}), Documentation(info="<html>
<p>
Partial component to model a sensor that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.</p>
<p>
The sensor computes a gain that is zero at zero mass flow rate.
This avoids fast transients if the flow is close to zero, thereby
improving the numerical efficiency.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 9, 2016, by Michael Wetter:<br/>
Improved documentation for <code>tau</code>.
</li>
<li>
January 12, 2016, by Filip Jorissen:<br/>
Added optional parameter <code>tauInv</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Changed the parameter <code>initType</code> to
<code>Modelica.Blocks.Types.Init.InitialState</code>.
This allows a pedantic model check in Dymola 2014 of models that instanciate sensors
but do not set this parameter. It also ensures that different Modelica simulators solve
the same initialization problem.
</li>
<li>
July 7, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialDynamicFlowSensor;

        partial model PartialFlowSensor
          "Partial component to model sensors that measure flow properties"
          extends Buildings.Fluid.Interfaces.PartialTwoPort;
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate, used for regularization near zero flow"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*m_flow_nominal
            "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
            annotation(Dialog(tab="Advanced"));
        equation
          // mass balance
          port_b.m_flow = -port_a.m_flow;
          // momentum equation (no pressure loss)
          port_a.p = port_b.p;
          // isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (Documentation(info="<html>
<p>
Partial component to model a sensor.
The sensor is ideal. It does not influence mass, energy,
species or substance balance, and it has no flow friction.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
June 19, 2015, by Michael Wetter:<br/>
Moved <code>m_flow_small</code> to the <code>Advanced</code> tab
as it usually need not be changed by the user.
Other models such as heat exchangers also have this parameter
on the <code>Advanced</code> tab.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialFlowSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sensors\">Buildings.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
</li>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Sources "Package with boundary condition models"
      extends Modelica.Icons.SourcesPackage;

      model Outside
        "Boundary that takes weather data, and optionally trace substances, as an input"
        extends Buildings.Fluid.Sources.BaseClasses.Outside;

      equation
        connect(weaBus.pAtm, p_in_internal);
        connect(weaBus.TDryBul, T_in_internal);
        annotation (defaultComponentName="out",
          Documentation(info="<html>
<p>
This model describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained
from weather data.
</p>
<p>
To use this model, connect weather data from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a> to the port
<code>weaBus</code> of this model.
This will cause the medium of this model to be
at the pressure that is obtained from the weather file, and any flow that
leaves this model to be at the temperature and humidity that are obtained
from the weather data.
</p>
<p>If the parameter <code>use_C_in</code> is <code>false</code> (default option),
the <code>C</code> parameter
is used as the trace substance for flow that leaves the component, and the
<code>C_in</code> input connector is disabled; if <code>use_C_in</code> is <code>true</code>,
then the <code>C</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>
Note that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 26, 2011 by Michael Wetter:<br/>
Introduced new base class to allow implementation of wind pressure for natural ventilation.
</li>
<li>
April 27, 2011 by Michael Wetter:<br/>
Revised implementation to allow medium model that do not have water vapor.
</li>
<li>
Feb. 9, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Outside;

      model Outside_CpLowRise
        "Boundary that takes weather data as an input and computes wind pressure for low-rise buildings"
        extends Buildings.Fluid.Sources.BaseClasses.Outside;

        parameter Real Cp0(min=0, max=1, final unit="1") = 0.6
          "Wind pressure coefficient for wind normal to wall";
        parameter Real s(final min=0, final unit="1")
          "Side ratio, s=length of this wall/length of adjacent wall";
        parameter Modelica.SIunits.Angle azi "Surface azimuth (South:0, West:pi/2)"
          annotation (choicesAllMatching=true);

        Modelica.SIunits.Angle alpha "Wind incidence angle (0: normal to wall)";
        Real CpAct(min=0, final unit="1") "Actual wind pressure coefficient";
        Modelica.SIunits.Pressure pWin(displayUnit="Pa")
          "Change in pressure due to wind force";
    protected
        Modelica.Blocks.Interfaces.RealInput pWea(min=0, nominal=1E5, final unit="Pa")
          "Pressure from weather bus";
        Modelica.Blocks.Interfaces.RealInput vWin(final unit="m/s")
          "Wind speed from weather bus";
        Modelica.Blocks.Interfaces.RealOutput pTot(min=0, nominal=1E5, final unit="Pa")
          "Sum of atmospheric pressure and wind pressure";
        final parameter Real G = Modelica.Math.log(s)
          "Natural logarithm of side ratio";

        Modelica.Blocks.Interfaces.RealInput winDir(final unit="rad",
                                                    displayUnit="deg")
          "Wind direction from weather bus";
        Modelica.SIunits.Angle surOut = azi-Modelica.Constants.pi
          "Angle of surface that is used to compute angle of attack of wind";
        Modelica.Blocks.Interfaces.RealInput d = Medium.density(
          Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal));

      equation
        alpha = winDir-surOut;
        CpAct = Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise(
                  Cp0=Cp0, incAng=alpha, G=G);
        pWin = 0.5*CpAct*d*vWin*vWin;
        pTot = pWea + pWin;

        connect(weaBus.winDir, winDir);
        connect(weaBus.winSpe, vWin);
        connect(weaBus.pAtm, pWea);
        connect(p_in_internal, pTot);
        connect(weaBus.TDryBul, T_in_internal);
        annotation (defaultComponentName="out",
          Documentation(info="<html>
<p>
This model describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained
from weather data. The model is identical to
<a href=\"modelica://Buildings.Fluid.Sources.Outside\">
Buildings.Fluid.Sources.Outside</a>,
except that it adds the wind pressure to the
pressure at the fluid port <code>ports</code>.
The correlation that is used to compute the wind pressure is based
on Swami and Chandra (1987) and valid for low-rise buildings
with rectangular shape.
The same correlation is also implemented in CONTAM (Persily and Ivy, 2001).
For other buildings, the model
<a href=\"modelica://Buildings.Fluid.Sources.Outside_Cp\">
Buildings.Fluid.Sources.Outside_Cp</a> should be used that takes
the wind pressure coefficient as an input or parameter.
</p>
<p>
The wind pressure coefficient is computed based on the
side ratio of the walls, which is defined as
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = x &frasl; y
</p>
<p>
where <i>x</i> is the length of the wall that will be connected to
this model, and <i>y</i> is the length of the adjacent wall.
The wind direction is computed relative to the azimuth of this surface,
which is equal to the parameter <code>azi</code>.
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>.
For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use
<code>Buildings.Types.Azimuth.S</code>.
</p>
<p>
Based on the surface azimuth, the wind direction and the side ratio
of the walls, the model computes how much the wind pressure
is attenuated compared to the reference wind pressure <code>Cp0</code>.
The reference wind pressure <code>Cp0</code> is a user-defined parameter,
and must be equal to the wind pressure at zero wind incidence angle.
Swami and Chandra (1987) recommend <i>C<sub>p0</sub> = 0.6</i> for
all low-rise buildings as this represents the average of
various values reported in the literature.
The computation of the actual wind pressure coefficient <i>C<sub>p</sub></i>
is explained in the function
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise\">
Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise</a>
that is called by this model.
</p>
<p>
The pressure <i>p</i> at the port <code>ports</code> is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  p = p<sub>w</sub> + C<sub>p</sub> 1 &frasl; 2 v<sup>2</sup> &rho;,
</p>
<p>
where
<i>p<sub>w</sub></i> is the atmospheric pressure from the weather bus,
<i>v</i> is the wind speed from the weather bus, and
<i>&rho;</i> is the fluid density.
</p>

<h4>References</h4>
<ul>
<li>
Muthusamy V. Swami and
Subrato Chandra.
<i>
<a href=\"http://www.fsec.ucf.edu/en/publications/pdf/FSEC-CR-163-86.pdf\">
Procedures for
Calculating Natural
Ventilation Airflow
Rates in Buildings.</a></i>
Florida Solar Energy Center, FSEC-CR-163-86. March, 1987.
Cape Canaveral, Florida.
</li>
<li>
Andrew K. Persily and Elizabeth M. Ivy.
<i>
<a href=\"http://ws680.nist.gov/publication/get_pdf.cfm?pub_id=860831\">
Input Data for Multizone Airflow and IAQ Analysis.</a></i>
NIST, NISTIR 6585.
January, 2001.
Gaithersburg, MD.
</li>
</ul>
</html>",
      revisions="<html>
<ul>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>unit</code> and <code>quantity</code> attributes.
</li>
<li>
October 26, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Text(
                visible=use_Cp_in,
                extent={{-140,92},{-92,62}},
                lineColor={0,0,255},
                textString="C_p"),
                Text(
                visible=use_C_in,
                extent={{-154,-28},{-102,-62}},
                lineColor={0,0,255},
                textString="C"),
              Text(
                extent={{-28,22},{28,-22}},
                lineColor={255,255,255},
                textString="Cp")}));
      end Outside_CpLowRise;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sources"
        extends Modelica.Icons.BasesPackage;

        partial model Outside
          "Boundary that takes weather data, and optionally trace substances, as an input"
          extends Buildings.Fluid.Sources.BaseClasses.PartialSource(final verifyInputs=true);

          parameter Boolean use_C_in = false
            "Get the trace substances from the input connector"
            annotation(Evaluate=true, HideResult=true);
          parameter Medium.ExtraProperty C[Medium.nC](
            final quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
            "Fixed values of trace substances"
            annotation (Dialog(enable = (not use_C_in) and Medium.nC > 0));

          Modelica.Blocks.Interfaces.RealInput C_in[Medium.nC](
            final quantity=Medium.extraPropertiesNames) if use_C_in
            "Prescribed boundary trace substances"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Buildings.BoundaryConditions.WeatherData.Bus weaBus "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-120,-18},{-80,22}})));
      protected
          final parameter Boolean singleSubstance = (Medium.nX == 1)
            "True if single substance medium";
          Buildings.Utilities.Psychrometrics.X_pTphi x_pTphi if
               not singleSubstance "Block to compute water vapor concentration";

          Modelica.Blocks.Interfaces.RealInput T_in_internal(final unit="K",
                                                             displayUnit="degC")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput h_internal = Medium.specificEnthalpy(
            Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal));

        equation
          // Check medium properties
          Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
            Medium.singleState, true, X_in_internal, "Boundary_pT");

          // Conditional connectors for trace substances
          connect(C_in, C_in_internal);
          if not use_C_in then
            C_in_internal = C;
          end if;
          // Connections to input. This is required to obtain the data from
          // the weather bus in case that the component x_pTphi is conditionally removed
          connect(weaBus.TDryBul, T_in_internal);

          // Connections to compute species concentration
          connect(p_in_internal, x_pTphi.p_in);
          connect(T_in_internal, x_pTphi.T);
          connect(weaBus.relHum, x_pTphi.phi);

          connect(X_in_internal, x_pTphi.X);
          if singleSubstance then
            X_in_internal = ones(Medium.nX);
          end if;

          connect(X_in_internal[1:Medium.nXi], Xi_in_internal);

          ports.C_outflow = fill(C_in_internal, nPorts);

          if not verifyInputs then
            h_internal    = Medium.h_default;
            p_in_internal = Medium.p_default;
            X_in_internal = Medium.X_default;
            T_in_internal = Medium.T_default;
          end if;

          // Assign medium properties
          connect(medium.h, h_internal);
          connect(medium.Xi, Xi_in_internal);

          for i in 1:nPorts loop
            ports[i].p          = p_in_internal;
            ports[i].h_outflow  = h_internal;
            ports[i].Xi_outflow = Xi_in_internal;
          end for;

          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  visible=use_C_in,
                  points={{-100,-80},{-60,-80}},
                  color={0,0,255}),
                Text(
                  visible=use_C_in,
                  extent={{-164,-90},{-62,-130}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="C"),
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor=DynamicSelect({0,127,255},
                    min(1, max(0, (1-(weaBus.TDryBul-273.15)/50)))*{28,108,200}+
                    min(1, max(0, (weaBus.TDryBul-273.15)/50))*{255,0,0})),
                Text(
                  extent={{62,28},{-58,-22}},
                  lineColor={255,255,255},
                  textString=DynamicSelect("", String(weaBus.TDryBul-273.15, format=".1f")))}),
            Documentation(info="<html>
<p>
This is the base class for models that describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained
from weather data, and that may be modified based on the wind pressure.
</p>
<p>If the parameter <code>use_C_in</code> is <code>false</code> (default option),
the <code>C</code> parameter
is used as the trace substance for flow that leaves the component, and the
<code>C_in</code> input connector is disabled; if <code>use_C_in</code> is <code>true</code>,
then the <code>C</code> parameter is ignored, and the value provided by the input connector is used instead.</p>
<p>
Note that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
November 14, 2019, by Michael Wetter:<br/>
Removed duplicate connector.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1248\"> #1248</a>.
</li>
<li>
January 14, 2019 by Jianjun Hu:<br/>
Changed to extend <a href=\"modelica://Buildings.Fluid.Sources.BaseClasses.PartialSource\">
Buildings.Fluid.Sources.BaseClasses.PartialSource</a>. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\"> #1050</a>.
</li>
<li>
May 30, 2017 by Jianjun Hu:<br/>
Corrected <code>X_in_internal = zeros()</code> to be <code>X_in_internal = ones()</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/787\"> #787</a>.
</li>
<li>
April, 25, 2016 by Marcus Fuchs:<br/>
Introduced missing <code>each</code> keyword. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/454\"> #454</a>,
to prevent a warning in OpenModelica.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>unit</code> and <code>quantity</code> attributes.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 26, 2011 by Michael Wetter:<br/>
Introduced new base class to allow implementation of wind pressure for natural ventilation.
</li>
<li>
April 27, 2011 by Michael Wetter:<br/>
Revised implementation to allow medium model that do not have water vapor.
</li>
<li>
Feb. 9, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Outside;

        partial model PartialSource
          "Partial component source with one fluid connector"

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choices(
                choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
                choice(redeclare package Medium = Buildings.Media.Water "Water"),
                choice(redeclare package Medium =
                    Buildings.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));
          parameter Boolean verifyInputs = false
            "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          Modelica.Fluid.Interfaces.FluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium,
            each m_flow(max=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Leaving
                            then 0 else +Modelica.Constants.inf,
                        min=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Entering
                            then 0 else -Modelica.Constants.inf))
            "Fluid ports"
            annotation (Placement(transformation(extent={{90,40},{110,-40}})));

      protected
          parameter Modelica.Fluid.Types.PortFlowDirection flowDirection=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
            "Allowed flow direction" annotation (Evaluate=true, Dialog(tab="Advanced"));
          Modelica.Blocks.Interfaces.RealInput p_in_internal(final unit="Pa")
            "Needed to connect to conditional connector";
          Medium.BaseProperties medium if verifyInputs "Medium in the source";
          Modelica.Blocks.Interfaces.RealInput Xi_in_internal[Medium.nXi](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput X_in_internal[Medium.nX](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput C_in_internal[Medium.nC](
            final quantity=Medium.extraPropertiesNames)
            "Needed to connect to conditional connector";


        initial equation
          // Only one connection allowed to a port to avoid unwanted ideal mixing
          for i in 1:nPorts loop
            assert(cardinality(ports[i]) <= 1,"
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");       end for;

        equation
          connect(medium.p, p_in_internal);

          annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Partial model for a fluid source that either prescribes
pressure or mass flow rate.
Models that extend this partial model need to prescribe the outflowing
specific enthalpy, composition and trace substances.
This partial model only declares the <code>ports</code>
and ensures that the pressures at all ports are equal.
</p>
<h4>Implementation</h4>
<p>
If the parameter <code>verifyInputs</code> is set to <code>true</code>,
then a protected instance of medium base properties is enabled.
This instance verifies that the
medium temperature is within the bounds <code>T_min</code> and <code>T_max</code>,
where <code>T_min</code> and <code>T_max</code> are constants of the <code>Medium</code>.
If the temperature is outside these bounds, the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 1, 2021, by Michael Wetter:<br/>
Corrected misplaced <code>each</code> and added missing instance comment.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1462\">IBPSA, #1462</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">IBPSA, #1050</a>.
</li>
<li>
May 30, 2018, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">IBPSA, #882</a>.
</li>
</ul>
</html>"));
        end PartialSource;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sources\">Buildings.Fluid.Sources</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type CvTypes = enumeration(
        OpPoint   "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",
        Kv   "Kv (metric) flow coefficient",
        Cv   "Cv (US) flow coefficient",
        Av   "Av (metric) flow coefficient")
        "Enumeration to define the choice of valve flow coefficient" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table summary=\"summary\"  border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>

<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
Users Guide</a>.
</p>

</html>"));

      type HeatExchangerConfiguration = enumeration(
        ParallelFlow   "Parallel flow",
        CounterFlow   "Counter flow",
        CrossFlowUnmixed   "Cross flow, both streams unmixed",
        CrossFlowStream1MixedStream2Unmixed
            "Cross flow, stream 1 mixed, stream 2 unmixed",
        CrossFlowStream1UnmixedStream2Mixed
            "Cross flow, stream 1 unmixed, stream 2 mixed",
        ConstantTemperaturePhaseChange   "Constant temperature phase change in one stream")
        "Enumeration for heat exchanger construction"
      annotation(Documentation(info="<html>
<p>
 Enumeration that defines the heat exchanger construction.
</p>
<p>
The following heat exchanger configurations are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowStream1MixedStream2Unmixed</td><td>Cross flow, stream 1 mixed, stream 2 unmixed</td></tr>
<tr><td>CrossFlowStream1UnmixedStream2Mixed</td><td>Cross flow, stream 1 unmixed, stream 2 mixed</td></tr>
<tr><td>ConstantTemperaturePhaseChange</td><td>Constant temperature phase change in one stream</td></tr>
</table>
<p>
Note that for a given heat exchanger, the
 <code>HeatExchangerConfiguration</code> is fixed. However, if the capacity
 flow rates change, then the
 <a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime\">
 Buildings.Fluid.Types.HeatExchangerFlowRegime</a> may change. For example,
 a counter flow heat exchanger has <code>HeatExchangerConfiguration=CounterFlow</code>,
 but the <a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime\">
 Buildings.Fluid.Types.HeatExchangerFlowRegime</a> can change to parallel flow if one of the two capacity flow rates reverts
 its direction.
 </p>
</html>",     revisions=
              "<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
Added <code>ConstantTemperaturePhaseChange</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/694\">
Buildings #694</a>.
</li>
<li>
February 18, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type HeatExchangerFlowRegime = enumeration(
        ParallelFlow   "Parallel flow",
        CounterFlow   "Counter flow",
        CrossFlowUnmixed   "Cross flow, both streams unmixed",
        CrossFlowCMinMixedCMaxUnmixed   "Cross flow, CMin mixed,   CMax unmixed",
        CrossFlowCMinUnmixedCMaxMixed   "Cross flow, CMin unmixed, CMax mixed",
        ConstantTemperaturePhaseChange   "Constant temperature phase change in one stream")
        "Enumeration for heat exchanger flow configuration"
      annotation(Documentation(info="<html>
<p>
 Enumeration to define the heat exchanger flow regime.
</p>
<p>
This enumeration defines for the current capacity flow rate the kind of
heat transfer relation that will be used to compute the relation between
effectiveness and Number of Transfer Units.
</p>
<p>
The following heat exchanger flow regimes are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowCMinMixedCMaxUnmixed</td><td>Cross flow, CMin mixed,   CMax unmixed</td></tr>
<tr><td>CrossFlowCMinUnmixedCMaxMixed</td><td>Cross flow, CMin unmixed, CMax mixed</td></tr>
<tr><td>ConstantTemperaturePhaseChange</td><td>Constant temperature phase change in one stream</td></tr>
</table>
</html>",     revisions="<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
Added <code>ConstantTemperaturePhaseChange</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/694\">
Buildings #694</a>.
</li>
<li>
February 18, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type InputType = enumeration(
        Constant   "Use parameter to set stage",
        Stages   "Use integer input to select stage",
        Continuous   "Use continuous, real input") "Input options for movers"
        annotation (Documentation(info="<html>
<p>
This type allows defining which type of input should be used for movers.
This can either be
</p>
<ol>
<li>
a constant set point declared by a parameter,
</li>
<li>
a series of possible set points that can be switched using an integer input, or
</li>
<li>
a continuously variable set point.
</li>
</ol>
</html>",     revisions="<html>
<ul>
<li>
April 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
     annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"

        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;

        // Constants
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure"
          annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";

        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that use this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving specific enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
        Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
          "Internal energy of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,20})));
        Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit=
             "kg") "Species mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-20})));
        Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
          "Mass of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,60})));
        Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
          "Trace substance mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-60})));

        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          p(start=p_start),
          h(start=hStart),
          T(start=T_start),
          Xi(start=X_start[1:Medium.nXi]),
          X(start=X_start),
          d(start=rho_start)) "Medium properties";

        Modelica.SIunits.Energy U(start=fluidVolume*rho_start*
          Medium.specificInternalEnergy(Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) +
          (T_start - Medium.reference_T)*CSen,
          nominal = 1E5) "Internal energy of fluid";

        Modelica.SIunits.Mass m(
          start=fluidVolume*rho_start,
          stateSelect=if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          then StateSelect.default else StateSelect.prefer)
          "Mass of fluid";

        Modelica.SIunits.Mass[Medium.nXi] mXi(
          start=fluidVolume*rho_start*X_start[1:Medium.nXi])
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC(
          start=fluidVolume*rho_start*C_start)
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";

        // Parameters that need to be defined by an extending class
        parameter Modelica.SIunits.Volume fluidVolume "Volume";
        final parameter Modelica.SIunits.HeatCapacity CSen=
          (mSenFac - 1)*rho_default*cp_default*fluidVolume
          "Aditional heat capacity for implementing mFactor";
    protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.SIunits.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
        Medium.specificHeatCapacityCp(state=state_default)
          "Heat capacity, to compute additional dry mass";
        parameter Modelica.SIunits.Density rho_start=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

        // Parameter for avoiding extra overhead calculations when CSen==0
        final parameter Boolean computeCSen = abs(mSenFac-1) > Modelica.Constants.eps
          annotation(Evaluate=true);
        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.Density rho_default=Medium.density(
          state=state_default) "Density, used to compute fluid mass";
        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                  string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.SIunits.SpecificEnthalpy hStart=
          Medium.specificEnthalpy_pTX(p_start, T_start, X_start)
          "Start value for specific enthalpy";

        // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
        // cannot differentiate the equations.
        constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
         "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";

        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";

      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "In " + getInstanceName() + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '"
               + Medium.mediumName + "'.
         Check medium model.");

        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "In " + getInstanceName() + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Total quantities
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          m = fluidVolume*rho_start;
        else
          if _simplify_mWat_flow then
            // If moisture is neglected in mass balance, assume for computation
            // of the mass of air that the air is at Medium.X_default.
            m = fluidVolume*Medium.density(Medium.setState_phX(
              p = medium.p,
              h = hOut,
              X = Medium.X_default));
          else
            // Use actual density
            m = fluidVolume*medium.d;
          end if;
        end if;
        mXi = m*medium.Xi;
        if computeCSen then
          U = m*medium.u + CSen*(medium.T-Medium.reference_T);
        else
          U = m*medium.u;
        end if;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          //The semiLinear function should be used for the equations below
          //for allowing min/max simplifications.
          //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
          ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
            "Enthalpy flow";
          for j in 1:Medium.nXi loop
            ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
              "Component mass flow";
          end for;
          for j in 1:Medium.nC loop
            ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
              "Trace substance mass flow";
          end for;
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        else
          der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
        else
          der(mXi) = mbXi_flow + mWat_flow_internal * s;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow + C_flow_internal;
        else
          der(mC)  = mbC_flow + C_flow_internal;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
        UOut=U;
        mXiOut=mXi;
        mOut=m;
        mCOut=mC;
        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
Buildings.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 26, 2019, by Filip Jorissen:<br/>
Returning <code>getInstanceName()</code> in asserts.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1133\">1133</a>.
</li>
<li>
April 16, 2019, by Michael Wetter:<br/>
Changed computation of <code>computeCSen</code> to avoid the volume to become
a structural parameter.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1122\">IBPSA, issue 1122</a>.
</li>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IBPSA, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                lineColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      partial model PartialFourPort "Partial model with four ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports.
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except for the
fowllowing:
</p>
<ol>
<li>it has four ports, and
</li>
<li>
the parameters <code>port_a_exposesState</code>,
<code>port_b_exposesState</code> and
<code>showDesignFlowDirection</code>
are not implemented.
</li>
</ol>
</html>",       revisions="<html>
<ul>
<li>
April 6, 2020, by Filip Jorissen:<br/>
Added arrows to the icon indicating the intended flow direction
when <code>allowFlowReversal=false</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1336\">#1336</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Renamed model from <code>FourPort</code> to
<code>PartialFourPort</code>.
Removed parameters
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
October 30, 2015, by Matthis Thorade:<br/>
Added <code>partial</code> keyword to model declaration.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of nominal value for
<code>Xi_outflow</code>.
</li>
<li>
September 17, 2010 by Michael Wetter:<br/>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Added start values for outflowing enthalpy because they
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
            Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name"),
            Polygon(
                points={{-5,10},{25,10},{-5,-10},{-5,10}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal1,
                origin={75,50},
                rotation=360),
            Polygon(
                points={{10,10},{-20,-10},{10,-10},{10,10}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal2,
                origin={-79,-50},
                rotation=360)}));
      end PartialFourPort;

      partial model PartialFourPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPort;
        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);


        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp1(displayUnit="Pa") = port_a1.p - port_b1.p
          "Pressure difference between port_a1 and port_b1";

        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp2(displayUnit="Pa") = port_a2.p - port_b2.p
          "Pressure difference between port_a2 and port_b2";

        Medium1.ThermodynamicState sta_a1=
            Medium1.setState_phX(port_a1.p,
                                 noEvent(actualStream(port_a1.h_outflow)),
                                 noEvent(actualStream(port_a1.Xi_outflow))) if
               show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
            Medium1.setState_phX(port_b1.p,
                                 noEvent(actualStream(port_b1.h_outflow)),
                                 noEvent(actualStream(port_b1.Xi_outflow))) if
               show_T "Medium properties in port_b1";
        Medium2.ThermodynamicState sta_a2=
            Medium2.setState_phX(port_a2.p,
                                 noEvent(actualStream(port_a2.h_outflow)),
                                 noEvent(actualStream(port_a2.Xi_outflow))) if
               show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
            Medium2.setState_phX(port_b2.p,
                                 noEvent(actualStream(port_b2.h_outflow)),
                                 noEvent(actualStream(port_b2.Xi_outflow))) if
               show_T "Medium properties in port_b2";
    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";

        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transport two fluid streams between four ports.
It is similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Removed assignment of <code>min</code> and <code>max</code>
attributes of port mass flow rates, as this is already
done in the base class.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a1</code>,
<code>sta_a2</code>, <code>sta_b1</code> and <code>sta_b2</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definitions of <code>dp1</code> and <code>dp2</code> because they cause some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Replaced the erroneous function call <code>Medium.density</code> with
<code>Medium1.density</code> and <code>Medium2.density</code>.
Changed condition to remove <code>sta_a1</code> and <code>sta_a2</code> to also
compute the states at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      partial model PartialTwoPort "Partial component with two ports"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialFourPort\">
Buildings.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                visible=not allowFlowReversal),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name")}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));

        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);

        Modelica.SIunits.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";

        Modelica.SIunits.PressureDifference dp(start=_dp_start, displayUnit="Pa") = port_a.p - port_b.p
          "Pressure difference between port_a and port_b";

        Medium.ThermodynamicState sta_a=
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow))) if
               show_T "Medium properties in port_a";

        Medium.ThermodynamicState sta_b=
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow))) if
                show_T "Medium properties in port_b";

    protected
        final parameter Modelica.SIunits.MassFlowRate _m_flow_start = 0
        "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
        final parameter Modelica.SIunits.PressureDifference _dp_start(displayUnit="Pa") = 0
        "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transports a fluid between two ports. It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://Buildings.Fluid.Movers.FlowControlled_m_flow\">
Buildings.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialTwoPortTransport
        "Partial element transporting fluid between two ports without storage of mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPort;

        // Advanced
        // Note: value of dp_start shall be refined by derived model,
        // based on local dp_nominal
        parameter Modelica.SIunits.PressureDifference dp_start(displayUnit="Pa") = 0
          "Guess value of dp = port_a.p - port_b.p"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium.MassFlowRate m_flow_start = 0
          "Guess value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced"));
        // Note: value of m_flow_small shall be refined by derived model,
        // based on local m_flow_nominal
        parameter Medium.MassFlowRate m_flow_small
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));

        // Diagnostics
        parameter Boolean show_T = true
          "= true, if temperatures at port_a and port_b are computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);
        parameter Boolean show_V_flow = true
          "= true, if volume flow rate at inflowing port is computed"
          annotation (
            Dialog(tab="Advanced", group="Diagnostics"),
            HideResult=true);

        // Variables
        Medium.MassFlowRate m_flow(
           min=if allowFlowReversal then -Modelica.Constants.inf else 0,
           start = m_flow_start) "Mass flow rate in design flow direction";
        Modelica.SIunits.PressureDifference dp(start=dp_start,
                                               displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";

        Modelica.SIunits.VolumeFlowRate V_flow=
            m_flow/Modelica.Fluid.Utilities.regStep(m_flow,
                        Medium.density(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.density(
                             Medium.setState_phX(
                               p = port_b.p,
                               h = inStream(port_b.h_outflow),
                               X = inStream(port_b.Xi_outflow))),
                        m_flow_small) if show_V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";

        Medium.Temperature port_a_T=
            Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_a, if show_T = true";
        Medium.Temperature port_b_T=
            Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_b.p,
                            h = inStream(port_b.h_outflow),
                            X = inStream(port_b.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_b, if show_T = true";
      equation
        // Pressure drop in design flow direction
        dp = port_a.p - port_b.p;

        // Design direction of mass flow rate
        m_flow = port_a.m_flow;
        assert(m_flow > -m_flow_small or allowFlowReversal,
            "Reverting flow occurs even though allowFlowReversal is false");

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.</p>
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>The momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code>,</li>
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
<p>
Moreover appropriate values shall be assigned to the following parameters:
</p>
<ul>
<li><code>dp_start</code> for a guess of the pressure drop</li>
<li><code>m_flow_small</code> for regularization of zero flow.</li>
</ul>
<h4>Implementation</h4>
<p>
This is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>
except that it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
September 15, 2016, by Michael Wetter:<br/>
Removed wrong annotation, which caused an error in the pedantic model check
of Dymola 2017 FD01.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/516\">#516</a>.
</li>
<li>
January 22, 2016, by Henning Francke:<br/>
Corrected type declaration of pressure.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignments of parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code> in base class.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/305\">#305</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed protected conditional variables <code>state_a</code> and <code>state_b</code>,
as they were used outside of a connect statement, which causes an
error during pedantic model check in Dymola 2016.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/128\">#128</a>.
</li>
<li>
April 1, 2015, by Michael Wetter:<br/>
Made computation of <code>state_a</code> and <code>state_p</code>
conditional on <code>show_T</code> or <code>show_V_flow</code>.
This avoids computing temperature from enthalpy if temperature is
a state of the medium, and the result is not used.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortTransport;

      model StaticFourPortHeatMassExchanger
        "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface;
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));

        constant Boolean prescribedHeatFlowRate1 = false
          "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
        constant Boolean prescribedHeatFlowRate2 = false
          "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        // Q1_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q1_flow
          "Heat transferred into the medium 1";
        input Medium1.MassFlowRate mWat1_flow
          "Moisture mass flow rate added to the medium 1";
        // Q2_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q2_flow
          "Heat transferred into the medium 2";
        input Medium2.MassFlowRate mWat2_flow
          "Moisture mass flow rate added to the medium 2";
        constant Boolean sensibleOnly1
          "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
          "Set to true if sensible exchange only for medium 2";

    protected
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          redeclare final package Medium=Medium1,
          final sensibleOnly = sensibleOnly1,
          final prescribedHeatFlowRate=prescribedHeatFlowRate1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mWat_flow = mWat1_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          redeclare final package Medium=Medium2,
          final sensibleOnly = sensibleOnly2,
          final prescribedHeatFlowRate=prescribedHeatFlowRate2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mWat_flow = mWat2_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 2";

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>,
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>.
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>

<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:</p>
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the sensible and latent heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mWat<i>N</i>_flow</code>, which is the moisture mass flow rate added to the medium <i>N</i>.
</li>
</ul>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mWat<i>N</i>_flow = 0</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these
     equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q1_flow</code> and <code>Q2_flow</code>
include latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

        constant Boolean prescribedHeatFlowRate = false
          "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(final unit="J/kg")
          "Leaving specific enthalpy of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

    protected
        final parameter Boolean use_m_flowInv=
          (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
          "Flag, true if m_flowInv is used in the model"
          annotation (Evaluate=true);
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

        Modelica.SIunits.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters for inverseXRegularized.
        // These are assigned here for efficiency reason.
        // Otherwise, they would need to be computed each time
        // the function is invocated.
        final parameter Real deltaReg = m_flow_small/1E3
          "Smoothing region for inverseXRegularized";

        final parameter Real deltaInvReg = 1/deltaReg
          "Inverse value of delta for inverseXRegularized";

        final parameter Real aReg = -15*deltaInvReg
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real bReg = 119*deltaInvReg^2
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real cReg = -361*deltaInvReg^3
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real dReg = 534*deltaInvReg^4
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real eReg = -380*deltaInvReg^5
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real fReg = 104*deltaInvReg^6
          "Polynomial coefficient for inverseXRegularized";

        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(state=state_default)
          "Specific heat capacity, used to verify energy conservation";
        constant Modelica.SIunits.TemperatureDifference dTMax(min=1) = 200
          "Maximum temperature difference across the StaticTwoPortConservationEquation";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Species flow rate from connector mWat_flow
        mXi_flow = mWat_flow_internal * s;

        // Regularization of m_flow around the origin to avoid a division by zero
        // m_flowInv is only used if prescribedHeatFlowRate == true, or
        // if the input connectors mWat_flow or C_flow are enabled.
        if use_m_flowInv then
          m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(
                             x=port_a.m_flow,
                             delta=deltaReg, deltaInv=deltaInvReg,
                             a=aReg, b=bReg, c=cReg, d=dReg, e=eReg, f=fReg);
        else
          // m_flowInv is not used.
          m_flowInv = 0;
        end if;

        if prescribedHeatFlowRate then
          assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
         "In " + getInstanceName() + ":
   The heat flow rate equals "       + String(Q_flow) +
         " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "       +
         String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
         " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
        end if;

        if allowFlowReversal then
          // Formulate hOut using spliceFunction. This avoids an event iteration.
          // The introduced error is small because deltax=m_flow_small/1e3
          hOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                          y2=port_a.h_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
          XiOut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.Xi_outflow,
                                                           y2=port_a.Xi_outflow,
                                                           x=port_a.m_flow,
                                                           x_small=m_flow_small/1E3);
          COut = Buildings.Utilities.Math.Functions.regStep(y1=port_b.C_outflow,
                                                          y2=port_a.C_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
        else
          hOut =  port_b.h_outflow;
          XiOut = port_b.Xi_outflow;
          COut =  port_b.C_outflow;
        end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

          // Substance balance
          // a) forward flow
          if use_m_flowInv then
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
          else // no water is added
            assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          end if;

          // b) backward flow
          if allowFlowReversal then
            if use_m_flowInv then
              port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
            else // no water added
              assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
              port_a.Xi_outflow = inStream(port_b.Xi_outflow);
            end if;
          else // no  flow reversal
            port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
          end if;

          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow_internal << m_flow, the error is small.
          if prescribedHeatFlowRate then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            if allowFlowReversal then
              port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            else
              port_a.h_outflow = Medium.h_default;
            end if;
          else
            // Case with prescribedHeatFlowRate == false.
            // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
            // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
            // Q_flow * m_flowInv = 0.
            // The same applies for port_b.Xi_outflow and mXi_flow.
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
            if allowFlowReversal then
              port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
            else
              // When allowFlowReversal = false, the downstream enthalpy does not matter.
              // Therefore a dummy value is used to avoid algebraic loops
              port_a.h_outflow = Medium.h_default;
            end if;
          end if;

        // Transport of trace substances
        if use_m_flowInv and use_C_flow then
          port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
        else // no trace substance added.
          assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
          port_b.C_outflow =  inStream(port_a.C_outflow);
        end if;

        if allowFlowReversal then
          if use_C_flow then
            port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
          else
            port_a.C_outflow = inStream(port_b.C_outflow);
          end if;
        else
          port_a.C_outflow = zeros(Medium.nC);
        end if;

        ////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 18, 2020, by Michael Wetter:<br/>
Removed start value for <code>hOut</code> as it will be set by
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://Buildings.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
Buildings.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                lineColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                lineColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                lineColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      model StaticTwoPortHeatMassExchanger
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface;
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));

        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        constant Boolean prescribedHeatFlowRate
          "Set to true if the heat flow rate is not a function of the component temperature";

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        // Model inputs
        // Q_flow is the sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q_flow "Heat transferred into the medium";
        input Modelica.SIunits.MassFlowRate mWat_flow
          "Moisture mass flow rate added to the medium";

        // Models for conservation equations and pressure drop
        Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation vol(
          redeclare final package Medium = Medium,
          final use_mWat_flow = not sensibleOnly,
          final prescribedHeatFlowRate = prescribedHeatFlowRate,
          final m_flow_nominal = m_flow_nominal,
          final allowFlowReversal=allowFlowReversal,
          final m_flow_small=m_flow_small)
          "Control volume for steady-state energy and mass balance"
          annotation (Placement(transformation(extent={{15,-10}, {35,10}})));

        Buildings.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
          "Leaving temperature of the component";

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component";

    protected
        Modelica.Blocks.Sources.RealExpression heaInp(y=Q_flow)
          "Block to set heat input into volume"
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.RealExpression
          masExc(final y=mWat_flow) "Block to set moisture exchange in volume"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(vol.hOut, hOut);
        connect(vol.XiOut, XiOut);
        connect(vol.COut, COut);
        connect(port_a,preDro. port_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.port_a) annotation (Line(
            points={{-30,0},{15,0}},
            color={0,127,255}));

        connect(vol.port_b, port_b) annotation (Line(
            points={{35,0},{67,0},{100,5.55112e-16}},
            color={0,127,255}));

        connect(heaInp.y, vol.Q_flow) annotation (Line(
            points={{1,50},{6,50},{6,8},{13,8}},
            color={0,0,127}));
        connect(masExc.y, vol.mWat_flow) annotation (Line(
            points={{1,30},{4,30},{4,4},{13,4}},
            color={0,0,127}));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the sensible and latent heat flow rate added to the medium.
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q_flow</code>
includes latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015 by Filip Jorissen:<br/>
Renamed <code>use_safeDivision</code> into
<code>prescribedHeatFlowRate</code>.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to pressure drop calculation, as this model no longer has
that parameter.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed model to use graphical modeling.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end StaticTwoPortHeatMassExchanger;

      model TwoPortHeatMassExchanger
        "Partial model transporting one fluid stream with storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
          port_a(h_outflow(start=h_outflow_start)),
          port_b(h_outflow(start=h_outflow_start)));
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=true);

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Modelica.SIunits.Time tau = 30
          "Time constant at nominal flow (if energyDynamics <> SteadyState)"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));

        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start = Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
          final quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
          final quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

        replaceable Buildings.Fluid.MixingVolumes.MixingVolume vol
        constrainedby
        Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          redeclare final package Medium = Medium,
          nPorts = 2,
          V=m_flow_nominal*tau/rho_default,
          final allowFlowReversal=allowFlowReversal,
          final mSenFac=1,
          final m_flow_nominal = m_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start) "Volume for fluid stream"
           annotation (Placement(transformation(extent={{-9,0},{11,-20}})));

        Buildings.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

    protected
        parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
            T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
          "Density, used to compute fluid volume";
        parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start, p=p_start, X=X_start);
        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
          "Start value for outflowing enthalpy";

      initial algorithm
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");

        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(vol.ports[2], port_b) annotation (Line(
            points={{1,0},{100,0}},
            color={0,127,255}));
        connect(port_a, preDro.port_a) annotation (Line(
            points={{-100,0},{-90,0},{-90,0},{-80,0},{-80,0},{-60,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{1,0}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports one fluid stream.
It provides the basic model for implementing dynamic and steady-state
models that exchange heat and water vapor with the fluid stream.
The model also computes the pressure drop due to the flow resistance.
By setting the parameter <code>dp_nominal=0</code>, the computation
of the pressure drop can be avoided.
The variable <code>vol.heatPort.T</code> always has the value of
the temperature of the medium that leaves the component.
For the actual temperatures at the port, the variables <code>sta_a.T</code>
and <code>sta_b.T</code> can be used. These two variables are provided by
the base class
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>.
</p>

For models that extend this model, see for example
<ul>
<li>
the ideal heater or cooler
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCooler_u\">
Buildings.Fluid.HeatExchangers.HeaterCooler_u</a>, and
</li>
<li>
the ideal humidifier
<a href=\"modelica://Buildings.Fluid.Humidifiers.Humidifier_u\">
Buildings.Fluid.Humidifiers.Humidifier_u</a>.
</li>
</ul>

<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX
</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>final quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instance <code>vol</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
May 1, 2015, by Marcus Fuchs:<br/>
Fixed links in documentation.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop element to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameter <code>tau</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 17, 2012, by Michael Wetter:<br/>
Fixed broken link in documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in the pressure drop model.
</li>
<li>
January 15, 2011, by Michael Wetter:<br/>
Fixed wrong class reference in information section.
</li>
<li>
September 13, 2011, by Michael Wetter:<br/>
Changed assignment of <code>vol(mass/energyDynamics=...)</code> as the
previous assignment caused a non-literal start value that was ignored.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Added start value for outflowing enthalpy.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Removed temperature sensor and changed implementation of fluid volume
to allow use of this model for the steady-state and dynamic humidifier
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,5},{100,-4}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-4},{100,5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end TwoPortHeatMassExchanger;

      record FourPortFlowResistanceParameters
        "Parameters for flow resistance for models with four ports"

        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));

        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.PressureDifference dp1_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));

        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.PressureDifference dp2_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = Buildings.Media.Air "Moist air"),
              choice(redeclare package Medium = Buildings.Media.Water "Water"),
              choice(redeclare package Medium =
                  Buildings.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the volume"
          annotation(Dialog(tab="Dynamics"));

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
Buildings.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"

        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(min=0,
                                                                 displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));

      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;

    package BaseClasses "Package with base classes for Buildings.Fluid"
      extends Modelica.Icons.BasesPackage;

      block ActuatorFilter
        "Filter used for actuators of valves, dampers and movers"
        import Modelica.Blocks.Types.Init;
        extends Modelica.Blocks.Interfaces.SISO;

        constant Integer n=2 "Order of filter";
        parameter Modelica.SIunits.Frequency f(start=1) "Cut-off frequency";
        parameter Boolean normalized = true
          "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
          annotation (
            Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start[n]=zeros(n) "Initial or guess values of states"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0.0
          "Initial value of output (remaining states are in steady state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));

        parameter Real u_nominal = 1 "Magnitude of input";

        Real x[n](each final stateSelect=StateSelect.never) = u_nom*s
          "Transformed filter states";


    protected
        final parameter Real u_nom = if abs(u_nominal-1) < 1E-12 then 1-1E-12 else u_nominal
          "Magnitude of input (set to a value different from 1 to avoid elimination by symbolic processing)";

        parameter Real alpha=if normalized then sqrt(2^(1/n) - 1) else 1.0
          "Frequency correction factor for normalized filter";
        parameter Real w_u=2*Modelica.Constants.pi*f/alpha/u_nom;

        Real s[n](start=x_start/u_nom) "Filter states";

      initial equation
        if initType == Init.SteadyState then
          der(s) = zeros(n);
        elseif initType == Init.InitialState then
          s = x_start/u_nom;
        elseif initType == Init.InitialOutput then
          y = y_start;
          der(s[1:n - 1]) = zeros(n - 1);
        end if;

      equation
        der(s[1]) = (u - u_nom*s[1])*w_u;
        for i in 2:n loop
          der(s[i]) = (u_nom*s[i - 1] - u_nom*s[i])*w_u;
        end for;
        y =u_nom*s[n];

        annotation (
          defaultComponentName="act",
          Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
              Line(points={{-80.6897,77.6256},{-80.6897,-90.3744}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{-79.7044,90.6305},{-87.7044,68.6305},{-71.7044,68.6305},{-79.7044,90.6305}}),
              Line(points={{-90.0,-80.0},{82.0,-80.0}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
              Line(origin = {-17.976,-6.521},
                points = {{96.962,55.158},{16.42,50.489},{-18.988,18.583},{-32.024,-53.479},{-62.024,-73.479}},
                color = {0,0,127},
                smooth = Smooth.Bezier),
              Text(lineColor={192,192,192},
                extent={{-70.0,48.0},{26.0,94.0}},
                textString="%n"),
              Text(extent={{8.0,-146.0},{8.0,-106.0}},
                textString="f=%f")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}})),
          Documentation(info="<html>
<p>
This block implements a filter that is used to approximate the actuators
of valves, dampers and fans.
</p>
<h4>Implementation</h4>
<p>
The implementation is based on
<a href=\"modelica://Modelica.Blocks.Continuous.CriticalDamping\">
Modelica.Blocks.Continuous.CriticalDamping</a>.
It differs from that model in that the internal state of the filter <code>s</code>
is transformed using <code>x = u_nominal*s</code>.
It turns out that this transformation leads to smaller system of nonlinear equations if <code>u_nominal &ne; 0</code>, see
<a href=\"https://https://github.com/ibpsa/modelica-ibpsa/issues/1498#issuecomment-885020611\">IBPSA, #1498</a>
for a discussion.
</html>",       revisions="<html>
<ul>
<li>
July 22, 2021, by Michael Wetter:<br/>
First implementation for
<a href=\"https://https://github.com/ibpsa/modelica-ibpsa/issues/1498\">IBPSA, #1498</a>
</li>
</ul>
</html>"));
      end ActuatorFilter;

      partial model PartialResistance "Partial model for a hydraulic resistance"
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           dp(nominal=if dp_nominal_pos > Modelica.Constants.eps
                then dp_nominal_pos else 1),
           m_flow(
              nominal=if m_flow_nominal_pos > Modelica.Constants.eps
                then m_flow_nominal_pos else 1),
           final m_flow_small = 1E-4*abs(m_flow_nominal));

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.PressureDifference dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));

        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";

    protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_default=Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";

        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.PressureDifference dp_nominal_pos(displayUnit="Pa") = abs(dp_nominal)
          "Absolute value of nominal pressure difference";
      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-22}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255}),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{100,10},{100+200*max(-1, min(0, m_flow/(abs(m_flow_nominal)))),-10}}),
                lineColor={28,108,200},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent=DynamicSelect({{-100,10},{-100,10}}, {{-100,10},{-100+200*min(1, max(0, m_flow/abs(m_flow_nominal))),-10}}),
                lineColor={28,108,200},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None)}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://Buildings.Fluid.FixedResistances.PressureDrop\">
Buildings.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
February 26, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialResistance;

      partial model PartialThreeWayResistance
        "Flow splitter with partial resistance model at each port"
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
          final mSenFac=1);

        Modelica.Fluid.Interfaces.FluidPort_a port_1(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_1== Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "First port, typically inlet"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_2(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Second port, typically outlet"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_3(
          redeclare package Medium=Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Third port, can be either inlet or outlet"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        parameter Modelica.SIunits.Time tau=10
          "Time constant at nominal flow for dynamic energy and momentum balance"
          annotation(Dialog(tab="Dynamics", group="Nominal condition",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Modelica.SIunits.MassFlowRate mDyn_flow_nominal
          "Nominal mass flow rate for dynamic momentum and energy balance"
          annotation(Dialog(tab="Dynamics", group="Equations",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));

        parameter Boolean from_dp = true
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_1"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_2"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_3"
         annotation(Dialog(tab="Advanced"));
        parameter Boolean verifyFlowReversal = false
          "=true, to assert that the flow does not reverse when portFlowDirection_* does not equal Bidirectional"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small
          "Small mass flow rate for checking flow reversal"
          annotation(Dialog(tab="Advanced",enable=verifyFlowReversal));


        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res1
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res2
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{60,-10},{40,10}})));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res3
          constrainedby Buildings.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_3 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(
              origin={0,-50},
              extent={{-10,10},{10,-10}},
              rotation=90)));

        Buildings.Fluid.Delays.DelayFirstOrder vol(
          redeclare final package Medium = Medium,
          final nPorts=3,
          final tau=tau,
          final m_flow_nominal=mDyn_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final allowFlowReversal=true,
          final prescribedHeatFlowRate=false) if
             have_controlVolume "Fluid volume to break algebraic loop"
          annotation (Placement(transformation(extent={{-10,0},{10,20}})));

    protected
        parameter Boolean have_controlVolume=
            energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
             massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState
          "Boolean flag used to remove conditional components";

        Modelica.Fluid.Interfaces.FluidPort_a port_internal(
          redeclare package Medium = Medium) if not have_controlVolume
          "Internal dummy port for easier connection of conditional connections"
          annotation (Placement(transformation(extent={{-10,50},{10,70}})));
      initial equation
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Leaving,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Leaving, which is non-physical.");
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Entering,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Entering, which is non-physical.");

      equation
        if verifyFlowReversal then
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_1.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_1 despite portFlowDirection_1=PortFlowDirection.Entering, since m_flow="       +
            String(port_1.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_1.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_1 despite portFlowDirection_1=PortFlowDirection.Leaving, since m_flow="       +
            String(port_1.m_flow) + ">"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_2.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_2 despite portFlowDirection_2=PortFlowDirection.Entering, since m_flow="       +
            String(port_2.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_2.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_2 despite portFlowDirection_2=PortFlowDirection.Leaving, since m_flow="       +
            String(port_2.m_flow) + ">"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_3.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_3 despite portFlowDirection_3=PortFlowDirection.Entering, since m_flow="       +
            String(port_3.m_flow) + "<-"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_3.m_flow< m_flow_small,
            "In " + getInstanceName() + ": 
      Flow is entering port_3 despite portFlowDirection_3=PortFlowDirection.Leaving, since m_flow="       +
            String(port_3.m_flow) + ">"+String(m_flow_small));
          end if;
        end if;

        if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res1.port_a, port_internal) annotation (Line(
            points={{-60,0},{-60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_a, vol.ports[1]) annotation (Line(
            points={{-60,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_b) annotation (Line(points={{-100,0},{-100,0},{-40,
                  0}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res1.port_b, port_internal) annotation (Line(
            points={{-40,0},{-40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_a) annotation (Line(points={{-100,0},{-100,0},{-60,0}}, color={0,127,255}));
        end if;

        if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res2.port_a, port_internal) annotation (Line(
            points={{60,0},{60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_a, vol.ports[2]) annotation (Line(
            points={{60,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_b) annotation (Line(points={{100,0},{100,0},{40,0}},    color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res2.port_b, port_internal) annotation (Line(
            points={{40,0},{40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_b, vol.ports[2]) annotation (Line(
            points={{40,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_a) annotation (Line(points={{100,0},{100,0},{60,0}},    color={0,127,255}));
        end if;

        if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res3.port_a, port_internal) annotation (Line(
            points={{-4.44089e-16,-60},{20,-60},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_a, vol.ports[3]) annotation (Line(
            points={{-6.66134e-16,-60},{0,-60},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_b) annotation (Line(points={{0,-100},{0,-100},{0,-40}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res3.port_b, port_internal) annotation (Line(
            points={{4.44089e-16,-40},{20,-40},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_b, vol.ports[3]) annotation (Line(
            points={{4.44089e-16,-40},{0,-40},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_a) annotation (Line(points={{0,-100},{0,-100},{0,-60}}, color={0,127,255}));
        end if;
         annotation (
          Documentation(info="<html>
<p>
Partial model for flow resistances with three ports such as a
flow mixer/splitter or a three way valve.
</p>
<p>
If <code>energyDynamics &ne; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the junction of the three flows,
a mixing volume will be present. This will introduce a dynamic energy and momentum
balance, which often breaks algebraic loops.
The time constant of the mixing volume is determined by the parameter <code>tau</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 22, 2020, by Filip Jorissen:<br/>
Corrected error message of asserts that verify whether flow reversal occurs when 
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1327\">#1327</a>.
</li>
<li>
July 7, 2018, by Filip Jorissen:<br/>
Added asserts that verify whether flow reversal occurs when 
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/963\">#963</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added graphical illustrations for the values of <code>portFlowDirection</code>.
Added asserts that verify the consistency of
the values of <code>portFlowDirection</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/902\">#902</a>.
</li>
<li>
February 22, 2016, by Michael Wetter:<br/>
Conditionally removed control volume <code>vol</code>, and added the conditional connnector
<code>port_internal</code>.
This was already done when the parameter <code>dynamicBalance</code> was present, but
was updated wrong when this parameter was removed.
Without these conditional components, the regression test for
<code>Buildings.Fluid.Examples.ResistanceVolumeFlowReversal</code> fails to simulate.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Added assignment <code>redeclare final package Medium=Medium</code>
as this is required for OpenModelica.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
February 20, 2016, by Ruben Baetens:<br/>
Removal of <code>dynamicBalance</code> as parameter for <code>massDynamics</code> and <code>energyDynamics</code>.
</li>
<li>
April 13 2015, by Filip Jorissen:<br/>
Exposed options for flow reversal to users and added corresponding implementation.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
Changed start values from <code>system.p_start</code> or (code <code>T_start</code>)
to <code>Medium.p_default</code>.
</li>
<li>
September 18, 2008 by Michael Wetter:<br/>
Replaced splitter model with a fluid port since the
splitter model in Modelica.Fluid 1.0 beta does not transport
<code>mC_flow</code>.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Polygon(
                points={{104,28},{124,20},{104,12},{104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{124,28},{104,20},{124,12},{124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-124,28},{-104,20},{-124,12},{-124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-104,28},{-124,20},{-104,12},{-104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{1,8},{21,6.12323e-17},{1,-8},{1,8}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering,
                origin={20,-125},
                rotation=90),
              Polygon(
                points={{21,14},{1,6},{21,-2},{21,14}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving,
                origin={26,-125},
                rotation=90)}));
      end PartialThreeWayResistance;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp
          "Function that computes mass flow rate for given pressure drop"

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
           m_flow := smooth(2, if noEvent(abs(dp)>dp_turbulent)
                       then sign(dp)*k*sqrt(abs(dp))
                       else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm);
          annotation(Inline=false,
                   smoothOrder=2,
                   derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                   inverse(dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                     m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Added <code>smooth(2, . )</code> for avoiding
a warning in the check valve model.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>Buildings.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_dp;

        function basicFlowFunction_dp_der
          "1st derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNormSq=(dp/dp_turbulent)^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                        then 0.5*k/sqrt(abs(dp))
                        else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der;

        function basicFlowFunction_dp_der2
          "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der2
            "2nd derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                         then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                         else m_flow_turbulent/dp_turbulent*(
                               (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                             + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der2;

        function basicFlowFunction_m_flow
          "Function that computes pressure drop for given mass flow rate"

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";

        algorithm
         dp := smooth(2, if noEvent(abs(m_flow)>m_flow_turbulent)
              then sign(m_flow)*(m_flow/k)^2
              else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);

         annotation (Inline=false,
                     smoothOrder=2,
                     derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                     inverse(m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                       dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 9, 2019, by Michael Wetter:<br/>
Added <code>smooth(2, . )</code>, similar to
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow;

        function basicFlowFunction_m_flow_der
          "1st derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
          output Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2*m_flow/k^2
                   else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der;

        function basicFlowFunction_m_flow_der2
          "2nd derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "1st derivative of mass flow rate in design flow direction";
          input Real m_flow_der2(unit="kg/s3")
            "2nd derivative of mass flow rate in design flow direction";
          output Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                   else dp_turbulent/m_flow_turbulent*(
                         (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                       + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der2;
      annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid\">Buildings.Fluid</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}, color={0,0,0}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package HeatTransfer "Package with heat transfer models"
    extends Modelica.Icons.Package;

    package Conduction "Package with models for heat conduction"
      extends Modelica.Icons.VariantsPackage;

      model MultiLayer
        "Model for heat conductance through a solid with multiple material layers"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=sum(lay[i].R for i in 1:nLay));
        Modelica.SIunits.Temperature T[sum(layers.nSta)](
          each nominal = 300) "Temperature at the states";
        Modelica.SIunits.HeatFlowRate Q_flow[sum(layers.nSta)+nLay]
          "Heat flow rate from state i to i+1";
        extends
        Buildings.HeatTransfer.Conduction.BaseClasses.PartialConstruction;

        parameter Boolean stateAtSurface_a=true
          "=true, a state will be at the surface a"
          annotation (Dialog(tab="Dynamics"),
                      Evaluate=true);
        parameter Boolean stateAtSurface_b=true
          "=true, a state will be at the surface b"
          annotation (Dialog(tab="Dynamics"),
                      Evaluate=true);

    protected
        Buildings.HeatTransfer.Conduction.SingleLayer[nLay] lay(
         final nSta2={layers.nSta[i] for i in 1:nLay},
         each final A=A,
         final stateAtSurface_a = {if i == 1 then stateAtSurface_a else false for i in 1:nLay},
         final stateAtSurface_b = {if i == nLay then stateAtSurface_b else false for i in 1:nLay},
         material = {layers.material[i] for i in 1:size(layers.material, 1)},
         T_a_start = { T_b_start+(T_a_start-T_b_start) * 1/R *
          sum(layers.material[k].R for k in i:size(layers.material, 1)) for i in 1:size(layers.material, 1)},
         T_b_start = { T_a_start+(T_b_start-T_a_start) * 1/R *
          sum(layers.material[k].R for k in 1:i) for i in 1:size(layers.material, 1)},
         each steadyStateInitial = steadyStateInitial) "Material layer"
          annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

      equation
        // This section assigns the temperatures and heat flow rates of the layer models to
        // an array that makes plotting the results easier.
        for i in 1:nLay loop
          for j in 1:layers.nSta[i] loop
            T[sum(layers.nSta[k] for k in 1:(i-1)) +j] = lay[i].T[j];
          end for;
          for j in 1:layers.nSta[i]+1 loop
            Q_flow[sum(layers.nSta[k] for k in 1:i-1)+(i-1)+j] = lay[i].Q_flow[j];
          end for;
        end for;
        connect(port_a, lay[1].port_a) annotation (Line(
            points={{-100,5.55112e-16},{-60,5.55112e-16},{-60,6.10623e-16},{-20,
                6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        for i in 1:nLay-1 loop
        connect(lay[i].port_b, lay[i+1].port_a) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{20,6.10623e-16},{20,-20},{-40,-20},{
                  -40,6.10623e-16},{-20,6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        end for;
        connect(lay[nLay].port_b, port_b) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{49,6.10623e-16},{49,5.55112e-16},{100,
                5.55112e-16}},
            color={191,0,0},
            smooth=Smooth.None));

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
         Rectangle(
          extent={{0,80},{80,-80}},       fillColor={175,175,175},
         fillPattern=FillPattern.Solid,    lineColor={175,175,175}),
         Rectangle(
          extent={{-80,80},{0,-80}},      fillColor={215,215,215},
         fillPattern=FillPattern.Solid,    lineColor={175,175,175}),
         Line(points={{-92,0},{90,0}},      color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),
         Line(points={{-18,-40},{-32,-40}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),
         Line(points={{-12,-32},{-38,-32}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),            Line(points={{-25,0},{-25,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None),
         Line(points={{32,-40},{18,-40}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),
         Line(points={{38,-32},{12,-32}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),            Line(points={{25,0},{25,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None),
                                           Rectangle(extent={{-60,6},{-40,-6}},
         lineColor = {0, 0, 0}, lineThickness =  0.5, fillColor = {255, 255, 255},
         fillPattern = FillPattern.Solid), Rectangle(extent={{-10,6},{10,-6}},
         lineColor = {0, 0, 0}, lineThickness =  0.5, fillColor = {255, 255, 255},
         fillPattern = FillPattern.Solid), Rectangle(extent={{40,6},{60,-6}},
         lineColor = {0, 0, 0}, lineThickness =  0.5, fillColor = {255, 255, 255},
         fillPattern = FillPattern.Solid),
         Line(points={{86,-40},{72,-40}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_b),
         Line(points={{92,-32},{66,-32}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_b),            Line(points={{79,0},{79,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None,
         visible=stateAtSurface_b),
         Line(points={{-79,0},{-79,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None,
         visible=stateAtSurface_a),
         Line(points={{-66,-32},{-92,-32}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_a),
         Line(points={{-72,-40},{-86,-40}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_a)}),
          defaultComponentName="heaCon",
          Documentation(info="<html>
<p>
This is a model of a heat conductor with multiple material layers and energy storage.
The construction has at least one material layer, and each layer has
at least one temperature node. The layers are modeled using an instance of
<a href=\"Buildings.HeatTransfer.Conduction.SingleLayer\">
Buildings.HeatTransfer.Conduction.SingleLayer</a>.
See this model for an explanation of the equations that are applied to
each material layer.
</p>
<h4>Important parameters</h4>
<p>
The construction material is defined by a record of the package
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a>.
This record allows specifying materials that store energy, and material
that are a thermal conductor only with no heat storage.
To assign the material properties to this model, do the following:
</p>
<ol>
<li>
Create an instance of a record of
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a>, for example
by dragging the record into the schematic model editor.
</li>
<li>
Make sure the instance has the attribute <code>parameter</code>, which may not be
assigned automatically when you drop the model in a graphical editor. For
example, an instanciation may look like
<pre>
 parameter Data.OpaqueConstructions.Insulation100Concrete200 layers
   \"Material layers of construction\"
   annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
</pre>
</li>
<li>
Assign the instance of the material to the instance of the heat transfer
model as shown in
<a href=\"modelica://Buildings.HeatTransfer.Examples.ConductorMultiLayer\">
Buildings.HeatTransfer.Examples.ConductorMultiLayer</a>.
</li>
</ol>
<p>
The parameters <code>stateAtSurface_a</code> and
<code>stateAtSurface_b</code>
determine whether there is a state variable at these surfaces,
as described above.
Note that if <code>stateAtSurface_a = true</code>,
then there is temperature state on the surface a with prescribed
value, as determined by the differential equation of the heat conduction.
Hence, in this situation, it is not possible to
connect a temperature boundary condition such as
<a href=\"modelica://Buildings.HeatTransfer.Sources.FixedTemperature\">
Buildings.HeatTransfer.Sources.FixedTemperature</a> as this would
yield to specifying the same temperature twice.
To avoid this, either set <code>stateAtSurface_a = false</code>,
or place a thermal resistance
between the boundary condition and the surface of this model.
The same applies for surface b.
See the examples in
<a href=\"modelica://Buildings.HeatTransfer.Examples\">
Buildings.HeatTransfer.Examples</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 16, 2017, by Michael Wetter:<br/>
Corrected wrong result variable <code>R</code> and <code>UA</code>.
These variables are only used for reporting.
All other calculations were not affected by this error.
</li>
<li>
January 05, 2017, by Thierry S. Nouidui:<br/>
Removed parameter <code>nSta2</code>.
</li>
<li>
November 17, 2016, by Thierry S. Nouidui:<br/>
Added parameter <code>nSta2</code> to avoid translation error
in Dymola 2107. This is a work-around for a bug in Dymola
which will be addressed in future releases.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Added option to place a state at the surface.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Set the start value of <code>T</code>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
March 18, 2015, by Michael Wetter:<br/>
Replaced <code>nLay</code> in the <code>sum()</code> of the parameter assignment
with <code>size(layers.material, 1)</code> to avoid incorrect results in OpenModelica.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/commit/4578a3d3b80e760cc83d705963f3b17e41c1e7da#diff-9628c0eecd08caed8b30f1f993de7501L12\">github note</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed assignment of <code>nLay</code> to avoid a translation error
in OpenModelica.
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Changed assignment of <code>R</code> to be in the <code>extends</code> statement
to avoid a division by zero in OpenModelica.
</li>
<li>
September 9, 2014, by Michael Wetter:<br/>
Reverted change from March 1 2013 as this causes an error during model check
in Dymola 2015 FD01 beta1.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Reformulated the protected elements and the model instantiation to avoid
a warning in the OpenModelica parser.
</li>
<li>
March 1, 2013, by Michael Wetter:<br/>
Removed <code>initial equation</code> section and assigned the protected parameters
<code>_T_a_start</code> and <code>_T_b_start</code> directly to avoid a warning during
translation.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MultiLayer;

      model SingleLayer "Model for single layer heat conductance"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=if (material.R < Modelica.Constants.eps) then material.x/material.k/A else material.R/A);
         // if material.R == 0, then the material specifies material.k, and this model specifies x
         // For resistances, material.k need not be specified, and hence we use material.R

        // The value T[:].start is used by the solver when finding initial states
        // that satisfy dT/dt=0, which requires solving a system of nonlinear equations
        // if the convection coefficient is a function of temperature.
        Modelica.SIunits.Temperature T[nSta](start=
         if stateAtSurface_a then
           cat(1,
             {T_a_start},
             {(T_a_start + (T_b_start - T_a_start)*UA*sum(RNod[k] for k in 1:i-1)) for i in 2:nSta})
         else
          {(T_a_start + (T_b_start - T_a_start)*UA*sum(RNod[k] for k in 1:i)) for i in 1:nSta},
         each nominal=300)
          "Temperature at the states";

        Modelica.SIunits.HeatFlowRate Q_flow[nSta+1](each start=0)
          "Heat flow rates to each state";
        Modelica.SIunits.SpecificInternalEnergy u[nSta](
          each start=2.7E5,
          each nominal=2.7E5)
          "Definition of specific internal energy";

        parameter Boolean stateAtSurface_a=true
          "=true, a state will be at the surface a"
          annotation (Dialog(tab="Dynamics"),
                      Evaluate=true);
        parameter Boolean stateAtSurface_b=true
          "=true, a state will be at the surface b"
          annotation (Dialog(tab="Dynamics"),
                      Evaluate=true);

        replaceable parameter Data.BaseClasses.Material material
          "Material from Data.Solids, Data.SolidsPCM or Data.Resistances"
          annotation (choicesAllMatching=true, Placement(transformation(extent={{60,60},
                  {80,80}})));

        parameter Boolean steadyStateInitial=false
          "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
              annotation (Dialog(group="Initialization"), Evaluate=true);
        parameter Modelica.SIunits.Temperature T_a_start=293.15
          "Initial temperature at port_a, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Modelica.SIunits.Temperature T_b_start=293.15
          "Initial temperature at port_b, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Integer nSta2=material.nSta
        "Number of states in a material (do not overwrite, used to work around Dymola 2017 bug)"
           annotation (Evaluate=true, HideResult=true, Dialog(enable=false, tab="Advanced"));
    protected
        final parameter Integer nSta=
          max(nSta2,
              if stateAtSurface_a or stateAtSurface_b then 2 else 1)
          "Number of state variables";
        final parameter Integer nR=nSta+1 "Number of thermal resistances";
        parameter Modelica.SIunits.ThermalResistance RNod[nR]=
          if (stateAtSurface_a and stateAtSurface_b) then
            if (nSta==2) then
              {(if i==1 or i==nR then 0 else R/(nSta-1)) for i in 1:nR}
            else
              {(if i==1 or i==nR then 0 elseif i==2 or i==nR-1 then R/(2*(nSta-2)) else R/(nSta-2)) for i in 1:nR}
            elseif (stateAtSurface_a and (not stateAtSurface_b)) then
              {(if i==1 then 0 elseif i==2 or i==nR then R/(2*(nSta-1)) else R/(nSta-1)) for i in 1:nR}
          elseif (stateAtSurface_b and (not stateAtSurface_a)) then
             {(if i==nR then 0 elseif i==1 or i==nR-1 then R/(2*(nSta-1)) else R/(nSta-1)) for i in 1:nR}
          else
            {R/(if i==1 or i==nR then (2*nSta) else nSta) for i in 1:nR}
          "Thermal resistance";

        parameter Modelica.SIunits.Mass m[nSta]=
         (A*material.x*material.d) *
         (if (stateAtSurface_a and stateAtSurface_b) then
           if (nSta==2) then
             {1/(2*(nSta-1)) for i in 1:nSta}
           elseif (nSta==3) then
             {1/(if i==1 or i==nSta then (2*(nSta-1)) else (nSta-1)) for i in 1:nSta}
           else
             {1/(if i==1 or i==nSta or i==2 or i==nSta-1 then (2*(nSta-2)) else (nSta-2)) for i in 1:nSta}
           elseif (stateAtSurface_a and (not stateAtSurface_b)) then
             {1/(if i==1 or i==2 then (2*(nSta-1)) else (nSta-1)) for i in 1:nSta}
           elseif (stateAtSurface_b and (not stateAtSurface_a)) then
             {1/(if i==nSta or i==nSta-1 then (2*(nSta-1)) else (nSta-1)) for i in 1:nSta}
           else
             {1/(nSta) for i in 1:nSta})
          "Mass associated with the temperature state";

        final parameter Real mInv[nSta]=
          if material.steadyState then zeros(nSta) else {1/m[i] for i in 1:nSta}
          "Inverse of the mass associated with the temperature state";

        final parameter Modelica.SIunits.HeatCapacity C[nSta] = m*material.c
          "Heat capacity associated with the temperature state";
        final parameter Real CInv[nSta]=
          if material.steadyState then zeros(nSta) else {1/C[i] for i in 1:nSta}
          "Inverse of heat capacity associated with the temperature state";

        parameter Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM](
          each fixed=false)
          "Support points for derivatives (used for PCM)";
        parameter Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM](
          each fixed=false)
          "Support points for derivatives (used for PCM)";
        parameter Real dT_du[Buildings.HeatTransfer.Conduction.nSupPCM](
          each fixed=false,
          each unit="kg.K2/J")
          "Derivatives dT/du at the support points (used for PCM)";

      initial equation
        // The initialization is only done for materials that store energy.
          if not material.steadyState then
            if steadyStateInitial then
              if material.phasechange then
                der(u) = zeros(nSta);
              else
                der(T) = zeros(nSta);
              end if;
            else
              if stateAtSurface_a then
                T[1] = T_a_start;
                for i in 2:nSta loop
                  T[i] =T_a_start + (T_b_start - T_a_start)*UA*sum(RNod[k] for k in 1:i-1);
                end for;
              else // stateAtSurface_a == false
                for i in 1:nSta loop
                  T[i] = T_a_start + (T_b_start - T_a_start)*UA*sum(RNod[k] for k in 1:i);
                end for;
              end if;
            end if;
          end if;

         if material.phasechange then
           (ud, Td, dT_du) = Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u(
             c =  material.c,
             TSol=material.TSol,
             TLiq=material.TLiq,
             LHea=material.LHea,
             ensureMonotonicity=material.ensureMonotonicity);
         else
           ud    = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
           Td    = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
           dT_du = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
         end if;
      equation
          port_a.Q_flow = +Q_flow[1];
          port_b.Q_flow = -Q_flow[end];

          port_a.T-T[1]    = if stateAtSurface_a then 0 else Q_flow[1]*RNod[1];
          T[nSta]-port_b.T = if stateAtSurface_b then 0 else Q_flow[end]*RNod[end];

          for i in 1:nSta-1 loop
             // Q_flow[i+1] is heat flowing from (i) to (i+1)
             // because T[1] has Q_flow[1] and Q_flow[2] acting on it.
             T[i]-T[i+1] = Q_flow[i+1]*RNod[i+1];
          end for;

          // Steady-state heat balance
          if material.steadyState then
            for i in 2:nSta+1 loop
              Q_flow[i] = port_a.Q_flow;
            end for;

            for i in 1:nSta loop
              if material.phasechange then
                // Phase change material
                T[i]=Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u(
                          ud=ud,
                          Td=Td,
                          dT_du=dT_du,
                          u=u[i]);
              else
                // Regular material
                u[i]=0; // u is not required in this case
              end if;
            end for;
          else
            // Transient heat conduction
            if material.phasechange then
              // Phase change material
              for i in 1:nSta loop
                der(u[i]) = (Q_flow[i]-Q_flow[i+1])*mInv[i];
                // Recalculation of temperature based on specific internal energy
                T[i]=Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u(
                          ud=ud,
                          Td=Td,
                          dT_du=dT_du,
                          u=u[i]);
              end for;
            else
              // Regular material
              for i in 1:nSta loop
                der(T[i]) = (Q_flow[i]-Q_flow[i+1])*CInv[i];
              end for;
              for i in 1:nSta loop
                u[i]=0; // u is not required in this case
              end for;
            end if;
          end if;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=false,extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-100,-80},{6,-98}},
                lineColor={0,0,255},
                textString="%material.x"),
              Text(
                extent={{8,-74},{86,-104}},
                lineColor={0,0,255},
                textString="%nSta"),
         Rectangle(
          extent={{-60,80},{60,-80}},     fillColor={215,215,215},
         fillPattern=FillPattern.Solid,    lineColor={175,175,175}),
         Line(points={{-92,0},{90,0}},      color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),
         Line(points={{8,-40},{-6,-40}},        color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),
         Line(points={{14,-32},{-12,-32}},      color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None),            Line(
                points={{0,0},{0,-32}},
                color={0,0,0},
                thickness=0.5,
                smooth=Smooth.None),       Rectangle(extent={{-40,6},{-20,-6}},
         lineColor = {0, 0, 0}, lineThickness =  0.5, fillColor = {255, 255, 255},
         fillPattern = FillPattern.Solid), Rectangle(extent={{20,6},{40,-6}},
         lineColor = {0, 0, 0}, lineThickness =  0.5, fillColor = {255, 255, 255},
         fillPattern = FillPattern.Solid),
         Line(points={{66,-40},{52,-40}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_b),
         Line(points={{72,-32},{46,-32}},       color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_b),            Line(points={{59,0},{59,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None,
         visible=stateAtSurface_b),
         Line(points={{-59,0},{-59,-32}},
         color = {0, 0, 0}, thickness = 0.5, smooth = Smooth.None,
         visible=stateAtSurface_a),
         Line(points={{-46,-32},{-72,-32}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_a),
         Line(points={{-52,-40},{-66,-40}},     color = {0, 0, 0}, thickness = 0.5,
         smooth = Smooth.None,
         visible=stateAtSurface_a)}),
      defaultComponentName="lay",
          Documentation(info="<html>
<p>
This is a model of a heat conductor for a single layer of homogeneous material
that computes transient or steady-state heat conduction.
</p>
<h4>Main equations</h4>
<h5>Transient heat conduction in materials without phase change</h5>
<p>
If the material is a record that extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Solids\">
Buildings.HeatTransfer.Data.Solids</a> and its
specific heat capacity (as defined by the record <code>material.c</code>)
is non-zero, then this model computes <i>transient</i> heat conduction, i.e., it
computes a numerical approximation to the solution of the heat equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
   &rho; c (&part; T(s,t) &frasl; &part;t) =
    k (&part;&sup2; T(s,t) &frasl; &part;s&sup2;),
</p>
<p>
where
<i>&rho;</i>
is the mass density,
<i>c</i>
is the specific heat capacity per unit mass,
<i>T</i>
is the temperature at location <i>s</i> and time <i>t</i> and
<i>k</i> is the heat conductivity.
At the locations <i>s=0</i> and <i>s=x</i>, where <i>x</i> is the
material thickness, the temperature and heat flow rate is equal to the
temperature and heat flow rate of the heat ports.
</p>
<h5>Transient heat conduction in phase change materials</h5>
<p>
If the material is declared using a record of type
<a href=\"modelica://Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>, the heat transfer
in a phase change material is computed.
The record <a href=\"modelica://Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>
declares the solidus temperature <code>TSol</code>,
the liquidus temperature <code>TLiq</code> and the latent heat of
phase transformation <code>LHea</code>.
For heat transfer with phase change, the specific internal energy <i>u</i>
is the dependent variable, rather than the temperature.
Therefore, the governing equation is
</p>
<p align=\"center\" style=\"font-style:italic;\">
   &rho; (&part; u(s,t) &frasl; &part;t) =
    k (&part;&sup2; T(s,t) &frasl; &part;s&sup2;).
</p>
<p>
The constitutive
relation between specific internal energy <i>u</i> and temperature <i>T</i> is defined in
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u\">
Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u</a> by using
cubic hermite spline interpolation with linear extrapolation.
</p>
<h5>Steady-state heat conduction</h5>
<p>
If <code>material.c=0</code>, or if the material extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Resistances\">
Buildings.HeatTransfer.Data.Resistances</a>,
then steady-state heat conduction is computed. In this situation, the heat
flow between its heat ports is
</p>
<p align=\"center\" style=\"font-style:italic;\">
   Q = A &nbsp; k &frasl; x &nbsp; (T<sub>a</sub>-T<sub>b</sub>),
</p>
<p>
where
<i>A</i> is the cross sectional area,
<i>x</i> is the layer thickness,
<i>T<sub>a</sub></i> is the temperature at port a and
<i>T<sub>b</sub></i> is the temperature at port b.
</p>
<h5>Spatial discretization</h5>
<p>
To spatially discretize the heat equation, the construction is
divided into compartments (control volumes) with <code>material.nSta &ge; 1</code> state variables.
Each control volume has the same material properties.
The state variables are connected to each other through thermal resistances.
If <code>stateAtSurface_a = true</code>, a state is placed
at the surface a, and similarly, if
<code>stateAtSurface_b = true</code>, a state is placed
at the surface b.
Otherwise, these states are placed inside the material, away
from the surface.
Thus, to obtain
the surface temperature, use <code>port_a.T</code> (or <code>port_b.T</code>)
and not the variable <code>T[1]</code>.
</p>

As an example, we assume a material with a length of <code>x</code>
and a discretization with four state variables.
<ul>
<li>
If <code>stateAtSurface_a = false</code> and <code>stateAtSurface_b = false</code>,
then each of the four state variables is placed in the middle of a control volume with length <code>l=x/material.nSta</code>.
<p align=\"left\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Conduction/noStateAtSurface.svg\"/>
</li>
<li>
If <code>stateAtSurface_a = true</code> or <code>stateAtSurface_b = true</code>,
then one state is placed on the surface of the material. Each of the remaining three states
is placed in the middle of a control volume with length <code>l=x/(material.nSta-1)</code>.
<p align=\"left\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Conduction/oneStateAtSurface.svg\"/>
</li>
<li>
If <code>stateAtSurface_a = true</code> and <code>stateAtSurface_b = true</code>,
then two states are placed on the surfaces of the material. Each of the remaining two states is placed
in the middle of a control volume with length <code>l=x/(material.nSta-2)</code>.
<p align=\"left\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Conduction/twoStatesAtSurface.svg\"/>
</li>
</ul>

<p>
To build multi-layer constructions,
use
<a href=\"Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> instead of this model.
</p>
<h4>Important parameters</h4>
<p>
The parameters <code>stateAtSurface_a</code> and
<code>stateAtSurface_b</code>
determine whether there is a state variable at these surfaces,
as described above.
Note that if <code>stateAtSurface_a = true</code>,
then there is temperature state on the surface a with prescribed
value, as determined by the differential equation of the heat conduction.
Hence, in this situation, it is not possible to
connect a temperature boundary condition such as
<a href=\"modelica://Buildings.HeatTransfer.Sources.FixedTemperature\">
Buildings.HeatTransfer.Sources.FixedTemperature</a> as this would
yield to specifying the same temperature twice.
To avoid this, either set <code>stateAtSurface_a = false</code>,
or place a thermal resistance
between the boundary condition and the surface of this model.
The same applies for surface b.
See the examples in
<a href=\"modelica://Buildings.HeatTransfer.Examples\">
Buildings.HeatTransfer.Examples</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 27, 2019, by Michael Wetter:<br/>
Removed assertion on geometry.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1529\">issue 1529</a>.
</li>
<li>
November 22, 2016, by Thierry S. Nouidui:<br/>
Fix bug in mass balance.
</li>
<li>
November 17, 2016, by Thierry S. Nouidui:<br/>
Added parameter <code>nSta2</code> to avoid translation error
in Dymola 2107. This is a work-around for a bug in Dymola
which will be addressed in future releases.
</li>
<li>
November 11, 2016, by Thierry S. Nouidui:<br/>
Revised the implementation for adding a state at the surface.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Added option to place a state at the surface.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
March 1, 2016, by Michael Wetter:<br/>
Removed test for equality of <code>Real</code> variables.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/493\">issue 493</a>.
</li>
<li>
May 21, 2015, by Michael Wetter:<br/>
Reformulated function to reduce use of the division macro
in Dymola.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/417\">issue 417</a>.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed the input argument for the function
<code>Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u</code>
from type
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code>
to the elements of this type as OpenModelica fails to translate the
model if the input to this function is a record.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
January 22, 2013, by Armin Teskeredzic:<br/>
Implementation of phase-change materials based on enthalpy-linearisation method.
Phase-change properties defined in <code>material</code> record and relationship
between enthalpy and temperature defined in the <code>EnthalpyTemperature</code> function.
</li>
<li>
March 9, 2012, by Michael Wetter:<br/>
Removed protected variable <code>der_T</code> as it is not required.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
Changed implementation to allow steady-state and transient heat conduction
depending on the specific heat capacity of the material. This allows using the
same model in composite constructions in which some layers are
computed steady-state and other transient.
</li><li>
February 5 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SingleLayer;

      constant Integer nSupPCM = 6
        "Number of support points to approximate u(T) releation, used only for phase change material";

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Conduction"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConductor "Partial model for heat conductor"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          final parameter Modelica.SIunits.CoefficientOfHeatTransfer U = UA/A
            "U-value (without surface heat transfer coefficients)";
          final parameter Modelica.SIunits.ThermalConductance UA = 1/R
            "Thermal conductance of construction (without surface heat transfer coefficients)";
          parameter Modelica.SIunits.ThermalResistance R
            "Thermal resistance of construction";

          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
            "Heat port at surface a" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
            "Heat port at surface b" annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          annotation (    Documentation(info="<html>
Partial model for single layer and multi layer heat conductors.
The heat conductor can be steady-state or transient.
</html>",         revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConductor;

        model PartialConstruction "Partial model for multi-layer constructions"
          extends Buildings.BaseClasses.BaseIcon;

          replaceable parameter Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Construction definition from Data.OpaqueConstructions"
            annotation (choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          final parameter Integer nLay(min=1, fixed=true) = size(layers.material, 1)
            "Number of layers";
          final parameter Integer nSta[nLay](each min=1)={layers.material[i].nSta for i in 1:nLay}
            "Number of states"  annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
            "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
            "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
            "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          annotation (    Documentation(info="<html>
Partial model for constructions and multi-layer heat conductors.
</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Removed parameter <code>A</code> as it is already declared in
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor\">
Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor</a>
which is often used with this class.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed assignment of <code>nLay</code> to avoid a translation error
in OpenModelica.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in <code>min</code>
attribute of <code>nSta</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConstruction;

        function der_temperature_u
          "Computes the derivative of the temperature of a phase change material with respect to specific internal energy"
          input Modelica.SIunits.SpecificHeatCapacity c "Specific heat capacity";
          input Modelica.SIunits.Temperature TSol
            "Solidus temperature, used only for PCM.";
          input Modelica.SIunits.Temperature TLiq
            "Liquidus temperature, used only for PCM";
          input Modelica.SIunits.SpecificInternalEnergy LHea
            "Latent heat of phase change";
          input Boolean ensureMonotonicity = false
            "Set to true to force derivatives dT/du to be monotone";

          output Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          output Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          output Real dT_du[Buildings.HeatTransfer.Conduction.nSupPCM](
            each fixed=false,
            each unit="kg.K2/J")
            "Derivatives dT/du at the support points";
      protected
          parameter Real scale=0.999 "Used to place points on the phase transition";
          parameter Modelica.SIunits.Temperature Tm1=TSol+(1-scale)*(TLiq-TSol)
            "Support point";
          parameter Modelica.SIunits.Temperature Tm2=TSol+scale*(TLiq-TSol)
            "Support point";
        algorithm
          assert(Buildings.HeatTransfer.Conduction.nSupPCM == 6,
            "The material must have exactly 6 support points for the u(T) relation.");
          assert(TLiq > TSol, "TLiq has to be larger than TSol.");
          // Get the derivative values at the support points
          ud:={c*scale*TSol,
               c*TSol,
               c*Tm1 + LHea*(Tm1 - TSol)/(TLiq - TSol),
               c*Tm2 + LHea*(Tm2 - TSol)/(TLiq - TSol),
               c*TLiq + LHea,
               c*(TLiq + TSol*(1 - scale)) + LHea};
          Td:={scale*TSol,
               TSol,
               Tm1,
               Tm2,
               TLiq,
               TLiq + TSol*(1 - scale)};
          dT_du := Buildings.Utilities.Math.Functions.splineDerivatives(
              x=ud,
              y=Td,
              ensureMonotonicity=ensureMonotonicity);
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
This function computes at the support points <i>T<sub>d</sub></i> the derivatives
<i>dT/du</i> of the cubic hermite spline approximation to the
temperature vs. specific internal energy relation.
These derivatives are then used by the function
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u\">
Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u</a>
to compute for a given specific internal energy the temperature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed the input argument from type
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code>
to the elements of this type as OpenModelica fails to translate the
model if the input to this function is a record.
</li>
<li>
October 13, 2014, by Michael Wetter:<br/>
Corrected the input argument to be an instance of
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code> rather than
<code>Buildings.HeatTransfer.Data.Solids.Generic</code>.
</li>
<li>
March 9, 2013, by Michael Wetter:<br/>
Revised implementation to use new data record.
</li>
<li>
January 19, 2013, by Armin Teskeredzic:<br/>
First implementations.
</li>
</ul>
</html>"));
        end der_temperature_u;

        function temperature_u
          "Computes the temperature of a phase change material for a given specific internal energy"

          input Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          input Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          input Real dT_du[:](each fixed=false, each unit="kg.K2/J")
            "Derivatives dT/du at the support points";

          input Modelica.SIunits.SpecificInternalEnergy u "Specific internal energy";

          output Modelica.SIunits.Temperature T "Resulting temperature";
      protected
          Integer i "Integer to select data interval";
        algorithm
          // i is a counter that is used to pick the derivative
          // that corresponds to the interval that contains x
          i := 1;
          for j in 1:size(ud,1) - 1 loop
            if u > ud[j] then
              i := j;
            end if;
          end for;
          // Extrapolate or interpolate the data
          T :=  Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
             x=u,
             x1=ud[i],
             x2=ud[i + 1],
             y1=Td[i],
             y2=Td[i + 1],
             y1d=dT_du[i],
             y2d=dT_du[i + 1]);
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
This function computes for a given specific internal energy <i>u</i>
the temperature <i>T(u)</i>, using a cubic hermite spline approximation to the
temperature vs. specific internal energy relation.
Input to the function are the derivatives <i>dT/du</i> at the support points.
These derivatives can be computed using
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u\">
Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u</a>.
</p>
<h4>Implementation</h4>
<p>
The derivatives <i>dT/du</i> are an input to this function because they typically only need
to be computed once, whereas <i>T(u)</i> must be evaluated at each time step.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 9, 2013, by Michael Wetter:<br/>
Revised implementation to use new data record.
</li>
<li>
January 19, 2013, by Armin Teskeredzic:<br/>
First implementations.
</li>
</ul>
</html>"));
        end temperature_u;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Conduction\">Buildings.HeatTransfer.Conduction</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat conduction.
</p>
<h4>Implementation</h4>
<p>
The package declares the constant <code>nSupPCM</code>,
which is equal to the number of support points that are used
to approximate the specific internal energy versus temperature relation.
This approximation is used by
<code>Buildings.HeatTransfer.Conduction.SingleLayer</code>
to replace the piece-wise linear function by a cubic hermite spline, with
linear extrapolation, in order to avoid state events during the simulation.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 10, 2013, by Michael Wetter:<br/>
Added constant <code>nSupPCM</code>.
</li>
<li>
February 5, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Conduction;

    package Convection "Package with models for convective heat transfer"
      extends Modelica.Icons.VariantsPackage;

      model Exterior "Model for a exterior (outside) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
          Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
          "Convective heat transfer model"
        annotation(Evaluate=true);

        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3
          "Constant convection coefficient"
         annotation (Dialog(enable=(conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));

        parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness=
          Buildings.HeatTransfer.Types.SurfaceRoughness.Medium "Surface roughness"
          annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

         parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt"
          annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));

        Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
          annotation (Placement(transformation(extent={{-140,80},{-100,120}})));
        Modelica.Blocks.Interfaces.RealInput dir(unit="rad", displayUnit="deg",
           min=0, max=2*Modelica.Constants.pi) "Wind direction (0=wind from North)"
          annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
        Modelica.SIunits.CoefficientOfHeatTransfer hF
          "Convective heat transfer coefficient due to forced convection";
        Modelica.SIunits.HeatFlux qN_flow
          "Convective heat flux from solid -> fluid due to natural convection";
        Modelica.SIunits.HeatFlux qF_flow
          "Convective heat flux from solid -> fluid due to forced convection";
    protected
        constant Modelica.SIunits.Velocity v_small = 0.5
          "Small value for wind velocity below which equations are regularized";
        final parameter Real cosTil=Modelica.Math.cos(til) "Cosine of window tilt";
        final parameter Real sinTil=Modelica.Math.sin(til) "Sine of window tilt";
        final parameter Boolean isCeiling = abs(sinTil) < 10E-10 and cosTil > 0
          "Flag, true if the surface is a ceiling";
        final parameter Boolean isFloor = abs(sinTil) < 10E-10 and cosTil < 0
          "Flag, true if the surface is a floor";

        parameter Real R(fixed=false) "Surface roughness";

        Real W(min=0.5, max=1) "Wind direction modifier";

      initial equation
        if (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VeryRough) then
          R=2.17;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Rough) then
          R=1.67;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Medium) then
          R=1.52;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.MediumSmooth) then
          R=1.13;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Smooth) then
          R=1.11;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VerySmooth) then
          R=1.00;
        else
          R=0;
        end if;
      equation
        if (conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed) then
          qN_flow = hFixed * dT;
          W = 1;
          hF = 0;
          qF_flow = 0;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if isCeiling then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT);
          elseif isFloor then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT);
          else
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT);
          end if;
          // Forced convection
          W = Buildings.Utilities.Math.Functions.regStep(
                x = v-v_small/2,
                y1 = Buildings.HeatTransfer.Convection.Functions.windDirectionModifier(
                  azi=azi,
                  dir=dir),
                y2 = 0.75,
                x_small=v_small/4);
          hF = 2.537 * W * R * 2 / A^(0.25) *
             Buildings.Utilities.Math.Functions.regNonZeroPower(
                 x=v,
                 n=0.5,
                 delta=v_small);
          qF_flow = hF*dT;
        end if;
        q_flow = qN_flow + qF_flow;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0}),
                                               Text(
                extent={{-102,128},{-64,98}},
                lineColor={0,0,127},
                textString="v"),               Text(
                extent={{-100,64},{-62,34}},
                lineColor={0,0,127},
                textString="dir")}),
          defaultComponentName="con",
          Documentation(info="<html>
<p>
This is a model for a convective heat transfer for exterior, outside-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>

<ol>
<li><p>If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.Fixed</a>
</code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</p>
</li>
<li>
<p>
If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind</a>
</code>,
then the convective heat transfer coefficient is
computed based on wind speed, wind direction and temperature difference.
</p>
<p>
The total convection coefficient <i>h<sub>t</sub></i> is the sum of the
temperature-driven free convection coefficient <i>h<sub>n</sub></i>
and the wind-driven forced convection coefficient <i>h<sub>f</sub></i>,
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>t</sub> = h<sub>n</sub> + h<sub>f</sub>
</p>
The free convection coefficient <i>h<sub>n</sub></i> is computed in the same way as in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Interior\">
Buildings.HeatTransfer.Convection.Interior</a>.
The forced convection coefficient <i>h<sub>f</sub></i>
is computed based on a correlation by Sparrow, Ramsey, and Mass
(1979), which is
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( P v &frasl; A )
</p>
<p>
where <i>W=1</i> for windward surfaces and
<i>W=0.5</i> for leeward surfaces, with leeward defined as greater than 100 degrees
from normal incidence,
<i>R</i> is a surface roughness multiplier,
<i>P</i> is the perimeter of the surface and
<i>A</i> is the area of the surface.
This is the same equation as implemented in EnergyPlus 6.0.
</p>
<p>
We make the simplified assumption that the surface is square, and hence we set
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( 4 v &frasl; &radic;(A) )
</p>
<p>
The surface roughness is specified by the parameter <code>surfaceRoughness</code>
which has to be set to a type of
<a href=\"modelica://Buildings.HeatTransfer.Types.SurfaceRoughness\">
Buildings.HeatTransfer.Types.SurfaceRoughness</a>.The coefficients for the surface roughness are
</p>

<table summary=\"summary\" border=\"1\">
<tr>
<th>Roughness index</th>
<th><i>R</i></th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>   <td>2.17</td>  <td>Stucco</td></tr>
<tr><td>Rough</td>        <td>1.67</td>  <td>Brick</td></tr>
<tr><td>MediumRough</td> <td>1.52</td>  <td>Concrete</td></tr>
<tr><td>MediumSmooth</td><td>1.13</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>       <td>1.11</td>  <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>  <td>1.00</td>  <td>Glass</td></tr>
</table>

</li>
</ol>
<h4>References</h4>
<p>
Sparrow, E. M., J. W. Ramsey, and E. A. Mass. 1979. Effect of Finite Width on Heat Transfer
and Fluid Flow about an Inclined Rectangular Plate. Journal of Heat Transfer, Vol. 101, p.
204.
</p>
<p>
Walton, G. N. 1981. Passive Solar Extension of the Building Loads Analysis and System
Thermodynamics (BLAST) Program, Technical Report, United States Army Construction
Engineering Research Laboratory, Champaign, IL.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 7, 2020, by Michael Wetter:<br/>
Set wind direction modifier to a constant as wind velocity approaches zero.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1923\">#1923</a>.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Refactored model as part of enabling the pedantic model check in Dymola 2017 FD01 beta 2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed error in assignment of wind-based convection coefficient.
The old implementation did not take into account the surface roughness.
Bug fix is due to feedback from Tobias Klingbeil (Fraunhofer ISE).
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Exterior;

      model Interior "Model for a interior (room-side) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Buildings.HeatTransfer.Types.InteriorConvection conMod=
          Buildings.HeatTransfer.Types.InteriorConvection.Fixed
          "Convective heat transfer model"
        annotation(Evaluate=true);

        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3
          "Constant convection coefficient"
         annotation (Dialog(enable=(conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

        parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt"
          annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

    protected
        constant Modelica.SIunits.Temperature dT0 = 2
          "Initial temperature used in homotopy method";

        final parameter Real cosTil=Modelica.Math.cos(til) "Cosine of window tilt";
        final parameter Real sinTil=Modelica.Math.sin(til) "Sine of window tilt";
        final parameter Boolean isCeiling = abs(sinTil) < 10E-10 and cosTil > 0
          "Flag, true if the surface is a ceiling";
        final parameter Boolean isFloor = abs(sinTil) < 10E-10 and cosTil < 0
          "Flag, true if the surface is a floor";

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        if (conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed) then
          q_flow = hFixed * dT;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if homotopyInitialization then
            if isCeiling then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT0));
            elseif isFloor then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT0));
            else
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT0));
            end if;
          else
            if isCeiling then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT);
            elseif isFloor then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT);
            else
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT);
            end if;
          end if;

        end if;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0})}),
          defaultComponentName="con",
          Documentation(info="<html>
<p>
This is a model for a convective heat transfer for interior, room-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>
<ul>
<li>If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Fixed</a></code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</li>
<li>
If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Temperature</a></code>, then
the convective heat tranfer coefficient is a function of the temperature difference.
The convective heat flux is computed using
<ul>
<li>
for floors the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor</a>
</li>
<li>
for ceilings the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling</a>
</li>
<li>
for walls the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall</a>
</li>
</ul>
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Refactored model as part of enabling the pedantic model check in Dymola 2017 FD01 beta 2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Interior;

      package Functions "Functions for convective heat transfer"

        function windDirectionModifier
          "Wind direction modifier that is used to compute the wind-driven convective heat transfer coefficient"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.Angle azi "Surface azimuth";
          input Modelica.SIunits.Angle dir(min=0, max=2*Modelica.Constants.pi)
            "Wind direction (0=wind from North)";
          output Real W "Wind direction modifier";
      protected
          constant Modelica.SIunits.Angle lee = Modelica.SIunits.Conversions.from_deg(100)
            "Angle at which the transition occurs";
          constant Real cosLee = Modelica.Math.cos(lee)
            "Cosine of the angle at which the transition occurs";
        algorithm
        // The wind direction is defined in TMY3 as dir=0 if from North, and 0 <= dir < 2*pi
        // Hence, we subtract pi to redefine dir=0 as wind coming from the south.
        // This simplifies the implementation since a surface azimuth is defined as azi=0
        // if the surface is south-facing
          W:=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.5,
            neg=1,
            x=cosLee-Modelica.Math.cos(azi+Modelica.Constants.pi-dir),
            deltax=0.05);
            annotation (
        smoothOrder=1,
        Documentation(info="<html>
<p>
Function that outputs <i>1</i> if the incidence angle is below 100 degrees, and
<i>0.5</i> otherwise.
The implementation is once continuously differentiable in its input arguments.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>
for an example that uses this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end windDirectionModifier;

        package HeatFlux "Correlations for convective heat flux"

          function ceiling "Free convection, ceiling"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
             q_flow  := noEvent(smooth(1, if (dT>0) then 0.76*dT^1.3333 else -1.51*(-dT)^1.3333));

          annotation(smoothOrder=1,
                      Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a ceiling, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=k |&Delta;T|<sup>0.3333</sup>,
</p>
<p>
where
<i>k=1.51</i> if the fluid is warmer than the ceiling,
or <i>k=0.76</i> otherwise.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end ceiling;

          function floor "Free convection, floor"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
            q_flow  := noEvent(smooth(1, if (dT>0) then 1.51*dT^1.3333 else -0.76*(-dT)^1.3333));

          annotation(smoothOrder=1,
          Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a floor, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=k |&Delta;T|<sup>0.3333</sup>,
</p>
<p>
where
<i>k=0.76</i> if the fluid is warmer than the floor,
or <i>k=1.51</i> otherwise.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end floor;

          function rayleigh "Rayleigh number with smooth transition to lower limit"
            extends Modelica.Icons.Function;
           input Modelica.SIunits.Length x "Layer thickness";
           input Modelica.SIunits.Density rho "Mass density";
           input Modelica.SIunits.SpecificHeatCapacity c_p "Specific heat capacity";
           input Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
           input Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
           input Modelica.SIunits.Temperature T_a "Temperature of surface a";
           input Modelica.SIunits.Temperature T_b "Temperature of surface b";
           input Real Ra_min "Minimum value for Rayleigh number";
           output Real Ra "Rayleigh number";
        protected
           Modelica.SIunits.TemperatureDifference dT "Temperature difference";
          algorithm
            Ra := Buildings.Utilities.Math.Functions.smoothMax(
              x1=rho^2*x^3*Modelica.Constants.g_n*c_p*abs(T_a - T_b)/((T_a+T_b)/2*mu*k),
              x2=Ra_min,
              deltaX=Ra_min/10);
          annotation (smoothOrder=1,
          Documentation(info="<html>
This function returns the Rayleigh number.
The parameter <code>RaMin</code> is used to transition
to a lower limit for the Rayleigh number.
This is helpful to avoid a Rayleigh number of zero or
to avoid an expression for a convection coefficient that
has an infinite derivative near zero, i.e., if <i>h=f(Ra<sup>(1/2)</sup>)</i>.
</html>", revisions="<html>
<ul>
<li>
May 21, 2015, by Michael Wetter:<br/>
Reformulated to reduce use of the division macro
in Dymola.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/417\">issue 417</a>.
</li>
<li>
July 2, 2013, by Michael Wetter:<br/>
Renamed function from <code>raleigh</code> to <code>rayleigh</code>.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end rayleigh;

          function wall "Free convection, wall"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;
          algorithm
            q_flow := noEvent(smooth(1, if (dT > 0) then 1.3*dT^1.3333 else -1.3*(-dT)^1.3333));

          annotation (smoothOrder=1,
          Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a wall, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=1.3 |&Delta;T|<sup>0.3333</sup>.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end wall;

          package BaseClasses
          "Base classes for convective heat transfer coefficients"
            extends Modelica.Icons.BasesPackage;

            partial function PartialHeatFlux "Partial function for convective heat flux"
              extends Modelica.Icons.Function;

             input Modelica.SIunits.TemperatureDifference dT
                "Temperature difference solid minus fluid";
             output Modelica.SIunits.HeatFlux q_flow
                "Convective heat flux from solid to fluid";
            annotation (Documentation(info=
            "<html>
<p>
Partial function that is used to implement the convective heat flux
as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end PartialHeatFlux;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux\">Buildings.HeatTransfer.Convection.Functions.HeatFlux</a>.
</p>
</html>"));
          end BaseClasses;
          annotation (Documentation(info="<html>
<p>
This package contains functions for the convective heat transfer.
Input into the functions is the temperature difference between
the solid and the fluid.
The functions compute the convective heat flux, rather than the
convective heat transfer coefficient,
because the convective heat transfer coefficient
is not differentiable around zero for some flow configurations,
such as buoyancy driven flow at a horizontal surface. However, the
product of convective heat transfer coefficient times temperature
difference is differentiable around zero.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HeatFlux;
        annotation (Documentation(revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
This package contains functions that are used in the
package
<a href=\"modelica://Buildings.HeatTransfer\">
Buildings.HeatTransfer</a>.
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Convection"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConvection "Partial model for heat convection"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.HeatFlux q_flow "Convective heat flux from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT(start=0) "= solid.T - fluid.T";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a solid
                                      annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fluid
                                      annotation (Placement(transformation(extent={{90,-10},
                    {110,10}})));

        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = A*q_flow;
          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-35,42},{-5,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}),
            Documentation(info="<html>
Partial model for a convective heat transfer model.
</html>",         revisions="<html>
<ul>
<li>
September 17, 2016, by Michael Wetter:<br/>
Refactored model as part of enabling the pedantic model check in Dymola 2017 FD01 beta 2.
Moved <code>hFixed</code> and assignment of parameters that depend
on the tilt to the models that extend from this model.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConvection;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection\">Buildings.HeatTransfer.Convection</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat convection.
</p>
</html>"));
    end Convection;

    package Radiosity "Package with models for radiosity transfer"
      extends Modelica.Icons.VariantsPackage;

      model OutdoorRadiosity
        "Model for the outdoor radiosity that strikes the window"
        parameter Modelica.SIunits.Area A "Area of receiving surface";
        parameter Real vieFacSky(final min=0, final max=1)
          "View factor from receiving surface to sky (=1 for roofs)";
        parameter Boolean linearize=false "Set to true to linearize emissive power"
          annotation (Evaluate=true);
        parameter Modelica.SIunits.Temperature T0=293.15
          "Temperature used to linearize radiative heat transfer"
          annotation (Dialog(enable=linearize));
        Real TRad4(unit="K4") "4th power of the mean outdoor temperature";
        Modelica.SIunits.Temperature TRad "Mean radiant temperature";

        Modelica.Blocks.Interfaces.RealInput TOut(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Outside temperature" annotation (Placement(transformation(extent={{
                  -140,-60},{-100,-20}}), iconTransformation(extent={{-140,-60},{-100,
                  -20}})));
        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature" annotation (Placement(transformation(
                extent={{-140,20},{-100,60}}), iconTransformation(extent={{-140,20},{
                  -100,60}})));
        Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut
          "Radiosity that flows out of component" annotation (Placement(
              transformation(extent={{100,-10},{120,10}}), iconTransformation(extent=
                  {{100,-10},{120,10}})));
    protected
        final parameter Real T03(
          min=0,
          final unit="K3") = T0^3 "3rd power of temperature T0";
        final parameter Real T04(
          min=0,
          final unit="K4") = T0^4 "4th power of temperature T0";
      equation
        TRad4 = (vieFacSky*TBlaSky^4 + (1 - vieFacSky)*TOut^4);
        JOut = A*Modelica.Constants.sigma*TRad4;
        TRad = if linearize then (TRad4 + 3*T04)/(4*T03) else TRad4^(1/4);

        annotation (
          Icon(graphics={
              Text(
                extent={{-96,-10},{-54,-52}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{64,16},{94,-12}},
                lineColor={0,0,127},
                textString="J"),
              Line(
                points={{6,-36},{28,-8},{20,-8},{28,-8},{28,-16},{28,-16}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,-36},{42,-36},{34,-30},{42,-36},{36,-42}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,0},{20,0},{28,0},{28,8},{28,8}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{42,28},{34,34},{42,28},{36,22}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,56},{20,56},{28,56},{28,48},{28,48}},
                color={127,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{4,74},{-34,-42}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-34,-42},{66,-60}},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Text(
                extent={{-150,142},{150,102}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-96,72},{-54,30}},
                lineColor={0,0,127},
                textString="TBlaSky")}),
          defaultComponentName="radOut",
          Documentation(info="<html>
<p>
Model for the infrared radiosity balance of the outdoor environment.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
February 10, 2012, by Wangda Zuo:<br/>
Fixed a bug in the temperature linearization.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed implementation to use the same equations as is used for opaque walls.
</li>
<li>
August 18, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OutdoorRadiosity;

      block RadiositySplitter
        "Splits the incoming radiosity into two flows based on an input signal"
        extends Modelica.Blocks.Icons.Block;

        Interfaces.RadiosityInflow JIn "Inflowing radiosity"
          annotation (Placement(transformation(extent={{-120,50},{-100,70}})));
        Modelica.Blocks.Interfaces.RealInput u(min=0, max=1)
          "u times incoming radiosity"
          annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}}), iconTransformation(
                extent={{-140,-80},{-100,-40}})));
        Interfaces.RadiosityOutflow JOut_1 "u times incoming radiosity"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));

        Interfaces.RadiosityOutflow JOut_2 "(1-u) times incoming radiosity"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
      equation
        JOut_1 = u    * JIn;
        JOut_2 = (1-u)* JIn;
        annotation (
      defaultComponentName="radSpl",
          Documentation(info="<html>
<p>
This blocks splits the incoming radiosity into two fluxes according to
</p>
<p align=\"center\" style=\"font-style:italic;\">
  J<sub>Out,1</sub> = u J<sub>In</sub>,<br/>
  J<sub>Out,2</sub> = (1-u)  J<sub>In</sub>.
</p>
<p>
This block may be used to split the radiosity flux into a fraction that
strikes the shaded part of a window, and a fraction that strikes the
non-shaded part.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
October 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
          Line(points={{50,0},{100,0}}, color={0,0,127}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),
          Line(points={{102,60},{42,60},{32,40}},    color={0,0,255}),
          Line(points={{102,-60},{42,-60},{32,-40}},    color={0,0,255})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Rectangle(
            extent={{-100,-100},{100,100}},
            lineColor={0,0,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
          Line(points={{50,0},{100,0}}, color={0,0,255}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255}),
          Line(points={{100,60},{40,60},{30,40}},    color={0,0,255}),
          Line(points={{100,-60},{40,-60},{30,-40}},    color={0,0,255})}));
      end RadiositySplitter;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Radiosity"
        extends Modelica.Icons.BasesPackage;

        model ParametersTwoSurfaces
          "Parameters that are used to model two surfaces with the same area"
          parameter Modelica.SIunits.Emissivity absIR_a
            "Infrared absorptivity of surface a";
          parameter Modelica.SIunits.Emissivity absIR_b
            "Infrared absorptivity of surface b";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_a
            "Infrared reflectivity of surface a";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_b
            "Infrared reflectivity of surface b";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR
            "Infrared transmissivity of glass pane";
          parameter Boolean linearize = false "Set to true to linearize emissive power"
          annotation (Evaluate=true);
          parameter Modelica.SIunits.Temperature T0=293.15
            "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize));
      protected
         final parameter Real T03(min=0, final unit="K3")=T0^3
            "3rd power of temperature T0";
         final parameter Real T04(min=0, final unit="K4")=T0^4
            "4th power of temperature T0";
        initial equation
          assert(abs(1-absIR_a-rhoIR_a-tauIR) < 1E-8,
            "Absorptivity, reflectivity and transmissivity of surface a do not add up to one. Check parameters.");
            assert(abs(1-absIR_b-rhoIR_b-tauIR) < 1E-8,
            "Absorptivity, reflectivity and transmissivity of surface b do not add up to one. Check parameters.");

        annotation (
        Documentation(
        info="<html>
<p>
Parameters that are used for classes with two surfaces.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed tolerance of the <code>assert</code> statement.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 20, 2012, by Wangda Zuo:<br/>
Added <code>T04</code> for temperature linearization.
</li>
<li>
August 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ParametersTwoSurfaces;

        partial block RadiosityTwoSurfaces
          "Model for the radiosity balance of a device with two surfaces"
          extends Buildings.BaseClasses.BaseIcon;

          parameter Modelica.SIunits.Area A "Heat transfer area";

          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_a(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at surface a"
            annotation (Placement(transformation(extent={{-120,30},{-100,50}})));
          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_b(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at surface b"
            annotation (Placement(transformation(extent={{120,-50},{100,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_a
            "Outgoing radiosity at surface a"
            annotation (Placement(transformation(extent={{-100,-50},{-120,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_b
            "Outgoing radiosity at surface b"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));

          annotation (           Documentation(info="<html>
Partial model for a device with two surfaces.
</html>",         revisions="<html>
<ul>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port.
</li>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiosityTwoSurfaces;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Radiosity\">Buildings.HeatTransfer.Radiosity</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models for the
infrared radiative heat exchange of window assemblies.
The models are according to TARCOG 2006,
except for the outdoor radiosity, which is computed by
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
The outdoor radiosity is different from the TARCOG implementation so
that the same equations are used for windows as are used for
opaque walls in the room heat transfer model of the package
<a href=\"modelica://Buildings.ThermalZones.Detailed\">
Buildings.ThermalZones.Detailed</a>.
</p>
<p>
By definition, incoming and outcoming radiosity are both positive.
This is required to connect incoming and outcoming radiosity connectors.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>"));
    end Radiosity;

    package Sources "Thermal sources"
    extends Modelica.Icons.SourcesPackage;

      model PrescribedHeatFlow "Prescribed heat flow boundary condition"
        Modelica.Blocks.Interfaces.RealInput Q_flow
              annotation (Placement(transformation(
              origin={-100,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
      equation
        port.Q_flow = -Q_flow;
        annotation (
          defaultComponentName="preHeaFlo",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Line(
                points={{-60,-20},{40,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{40,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{40,0},{40,40},{70,20},{40,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,-40},{40,0},{70,-20},{40,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{70,40},{90,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,100},{150,60}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted as these can cause division by zero in some fluid flow models.
</p>
</html>",    revisions="<html>
<ul>
<li>
March 29 2011, by Michael Wetter:<br/>
First implementation based on <a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>.
</li>
</ul>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-60,-20},{68,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{68,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{60,0},{60,40},{90,20},{60,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{60,-40},{60,0},{90,-20},{60,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedHeatFlow;

      model PrescribedTemperature "Variable temperature boundary condition in Kelvin"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
        Modelica.Blocks.Interfaces.RealInput T annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
      equation
        port.T = T;
        annotation (
          defaultComponentName="preTem",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{50,-20},{50,20},{90,0},{50,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <b>T</b>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{52,-20},{52,20},{90,0},{52,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedTemperature;
      annotation (   Documentation(info="<html>
This package is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources\">
Modelica.Thermal.HeatTransfer.Sources</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted in the models
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow</a> and
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>
 as these can cause division by zero in some fluid flow models.
</html>"));
    end Sources;

    package Windows "Package with models for windows"
      extends Modelica.Icons.VariantsPackage;

      model ExteriorHeatTransfer
        "Model for heat convection and radiation at the exterior surface of a window that may have a shading device"
        extends BaseClasses.PartialWindowBoundaryCondition(final thisSideHasShade=haveExteriorShade);
        parameter Modelica.SIunits.Emissivity absIRSha_air
          "Infrared absorptivity of shade surface that faces air"
              annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.Emissivity absIRSha_glass
          "Infrared absorptivity of shade surface that faces glass"
          annotation (Dialog(group="Shading"));

        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air
          "Infrared transmissivity of shade for radiation coming from the exterior or the room"
          annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass
          "Infrared transmissivity of shade for radiation coming from the glass"
          annotation (Dialog(group="Shading"));

        parameter Boolean linearizeRadiation
          "Set to true to linearize emissive power";
        parameter Real vieFacSky(final min=0, final max=1, final unit="1")
          "View factor from receiving surface to sky";

        Modelica.Blocks.Interfaces.RealInput vWin(final unit="m/s") "Wind speed"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-116,32},{-100,48}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeGla(                                          final A=AGla)
          "Model for the outside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-84,40},{-64,60}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeFra(                                          final A=AFra)
          "Model for the outside convective heat transfer coefficient of the frame"
          annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));
       Radiosity.OutdoorRadiosity radOut(
         final A=AGla, vieFacSky=vieFacSky,
          linearize=linearizeRadiation) "Outdoor radiosity"
          annotation (Placement(transformation(extent={{-72,-72},{-52,-52}})));

        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
              iconTransformation(extent={{-120,-50},{-100,-30}})));
        Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                  final unit = "K", min=0)
          "Outside temperature"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}}),
              iconTransformation(extent={{-120,-92},{-100,-72}})));
        Interfaces.RadiosityOutflow JOutUns
          "Outgoing radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{100,70},{120,90}})));
        Interfaces.RadiosityInflow JInUns
          "Incoming radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{120,50},{100,70}})));
        Interfaces.RadiosityOutflow JOutSha if haveShade
          "Outgoing radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
        Interfaces.RadiosityInflow JInSha if haveShade
          "Incoming radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
        Modelica.Blocks.Interfaces.RealInput QSolAbs_flow(unit="W", quantity="Power") if
             haveShade "Solar radiation absorbed by shade"
          annotation (Placement(transformation(
              origin={0,-120},
              extent={{-20,-20},{20,20}},
              rotation=90), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,-110})));

        BaseClasses.ShadeRadiation shaRad(
          final thisSideHasShade=thisSideHasShade,
          final A=AGla,
          final linearize=linearizeRadiation,
          final absIR_air=if thisSideHasShade then absIRSha_air else 0,
          final absIR_glass=if thisSideHasShade then absIRSha_glass else 0,
          final tauIR_air=if thisSideHasShade then tauIRSha_air else 1,
          final tauIR_glass=if thisSideHasShade then tauIRSha_glass else 1) if
             haveShade "Radiative heat balance of shade"
          annotation (Placement(transformation(extent={{0,-20},{20,0}})));
    protected
        Radiosity.RadiositySplitter radShaOut "Radiosity that strikes shading device"
          annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
        BaseClasses.ShadeConvection shaCon(final thisSideHasShade=thisSideHasShade,
            final A=AGla) if
             haveShade "Convective heat balance of shade"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
    public
        Modelica.Thermal.HeatTransfer.Components.Convection conFra
          "Convective heat transfer between air and frame"
          annotation (Placement(transformation(extent={{50,-98},{30,-78}})));
        Modelica.Thermal.HeatTransfer.Components.Convection conWinUns(
          dT(start=0))
          "Convection from unshaded part of window to outside or room air"
          annotation (Placement(transformation(extent={{60,0},{40,20}})));
    protected
        Modelica.Blocks.Math.Product proUns "Product for unshaded part of window"
          annotation (Placement(transformation(extent={{20,70},{40,90}})));
      equation
        assert(-1E-10<vieFacSky and 1.00001 > vieFacSky,
               "View factor to sky is out of range. vieFacSky = " + String(vieFacSky)
               + "\n   Check parameters.");

        connect(vWin, conCoeGla.v)
                                 annotation (Line(
            points={{-120,40},{-90,40},{-90,50},{-86,50}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vWin, conCoeFra.v) annotation (Line(
            points={{-120,40},{-90,40},{-90,-70},{-22,-70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeFra.GCon, conFra.Gc) annotation (Line(
            points={{1,-70},{40,-70},{40,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-63,50},{-56,50},{-56,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proUns.u2) annotation (Line(
            points={{-63,50},{-40,50},{-40,74},{18,74}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.JOut, radShaOut.JIn) annotation (Line(
            points={{-51,-62},{-46,-62},{-46,-24},{-41,-24}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(radOut.TBlaSky, TBlaSky) annotation (Line(
            points={{-74,-58},{-86,-58},{-86,-40},{-120,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.TOut, TOut) annotation (Line(
            points={{-74,-66},{-86,-66},{-86,-80},{-120,-80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radShaOut.JOut_2,JOutUns)  annotation (Line(
            points={{-19,-36},{90,-36},{90,80},{110,80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.JOut_glass, JOutSha)
         annotation (Line(
            points={{21,-14},{80,-14},{80,-60},{110,-60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.JIn_glass, JInSha)
          annotation (Line(
            points={{21,-18},{70,-18},{70,-80},{110,-80}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(radShaOut.JOut_1, shaRad.JIn_air)
                                                 annotation (Line(
            points={{-19,-24},{-12,-24},{-12,-14},{-1,-14}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.u, shaSig.y)
                                   annotation (Line(
            points={{-1,-2},{-60,-2},{-60,80},{-69,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(glaSha, shaCon.glass) annotation (Line(
            points={{100,-20},{30,-20},{30,30},{19.4,30}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaCon.air, air) annotation (Line(
            points={{0,30},{-20,30},{-20,10},{-80,10},{-80,5.55112e-16},{-100,
                5.55112e-16},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaCon.Gc, proSha.y) annotation (Line(
            points={{-1,34},{-24,34},{-24,30},{-29,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaCon.TSha, shaRad.TSha) annotation (Line(
            points={{16,19},{16,6},{26,6},{26,-26},{15,-26},{15,-21}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaRad.QRadAbs_flow, shaCon.QRadAbs_flow) annotation (Line(
            points={{5,-21},{5,-26},{-6,-26},{-6,12},{4,12},{4,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radShaOut.u, shaSig.y) annotation (Line(
            points={{-42,-36},{-60,-36},{-60,80},{-69,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaRad.QSolAbs_flow, QSolAbs_flow) annotation (Line(
            points={{10,-21},{10,-84},{8.88178e-16,-84},{8.88178e-16,-120}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conFra.fluid, air) annotation (Line(
            points={{30,-88},{-80,-88},{-80,0},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conWinUns.fluid, air)
                                   annotation (Line(
            points={{40,10},{-80,10},{-80,0},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns,conWinUns. solid) annotation (Line(
            points={{100,20},{76,20},{76,10},{60,10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(proUns.y,conWinUns. Gc) annotation (Line(
            points={{41,80},{50,80},{50,20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conFra.solid, frame) annotation (Line(
            points={{50,-88},{70,-88},{70,-100},{70,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaSig.yCom,proUns. u1) annotation (Line(
            points={{-69,74},{-50,74},{-50,86},{18,86}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(graphics={
              Text(
                extent={{-94,48},{-52,32}},
                lineColor={0,0,127},
                textString="vWind"), Ellipse(
                extent={{-110,110},{-90,90}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Text(
                extent={{-96,-76},{-66,-88}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-94,-34},{-54,-46}},
                lineColor={0,0,127},
                textString="TBlaSky"),
              Text(
                extent={{-38,-84},{28,-102}},
                lineColor={0,0,127},
                textString="QSolAbs")}),
      defaultComponentName="extHeaTra",
                 Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the outside-facing surface of a window system and
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2015, by Michael Wetter:<br/>
Refactored model to allow a temperature dependent convective heat transfer
on the room side.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/52\">52</a>.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
October 25 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorHeatTransfer;

      model FixedShade "Model for exterior shade due to overhang and/or side fin"
        extends HeatTransfer.Windows.BaseClasses.ShadeInterface_weatherBus;
        parameter Buildings.ThermalZones.Detailed.BaseClasses.ParameterConstructionWithWindow conPar
          "Construction parameters";

        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi(displayUnit="deg")
          "Surface azimuth; azi= -90 degree East; azi= 0 South";

        Modelica.Blocks.Routing.Multiplex4 mulFraSun(
          n1=1,
          n2=1,
          n3=1,
          n4=1) "Multiplex for fraction of shaded area"
          annotation (Placement(transformation(extent={{32,0},{52,20}})));

        Modelica.Blocks.Math.Add sumFraSun
          "Addition of sun exposed window area fractions"
          annotation (Placement(transformation(extent={{-40,-40},{-28,-28}})));

        Modelica.Blocks.Math.Add resFraSun(k2=1.0, k1=-1.0)
          "Calculates resultant sun exposed window area fraction"
          annotation (Placement(transformation(extent={{-40,-6},{-28,6}})));
        Modelica.Blocks.Sources.Constant overlap(k=1.0)
          "Overlap of sun exposed window area fraction"
          annotation (Placement(transformation(extent={{-40,20},{-28,32}})));
        Modelica.Blocks.Sources.Constant noSunCond(k=small)
          "Condition when the sun is not in front of window"
          annotation (Placement(transformation(extent={{-20,-40},{-8,-28}})));

    protected
        constant Real small = 0.001
          "Small number, used to avoid that sun-exposed fraction of window is negative";

        final parameter Boolean haveOverhang = conPar.ove.haveOverhang
          "Flag for overhang" annotation (Evaluate=true);

        final parameter Boolean haveSideFins = conPar.sidFin.haveSideFins
          "Flag for sidefins" annotation (Evaluate=true);
        final parameter Boolean haveOverhangAndSideFins= (haveOverhang
             and haveSideFins) "Flag for overhang and sidefins";

        final parameter Integer idx = if haveOverhangAndSideFins then 2 elseif haveOverhang then 1 elseif haveSideFins then 3 else 4
          "Integer used to pick the appropriate output signal";

        HeatTransfer.Windows.BaseClasses.Overhang ove(
          final lat=lat,
          final azi=conPar.azi,
          final hWin=conPar.hWin,
          final wWin=conPar.wWin,
          final dep=conPar.ove.dep,
          final gap=conPar.ove.gap,
          final wR=conPar.ove.wR,
          final wL=conPar.ove.wL) "Model for overhang"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));

        HeatTransfer.Windows.BaseClasses.SideFins sidFin(
          final hWin=conPar.hWin,
          final wWin=conPar.wWin,
          final h=conPar.sidFin.h,
          final dep=conPar.sidFin.dep,
          final gap=conPar.sidFin.gap) "Model for side fins"
          annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));

        BoundaryConditions.SolarGeometry.BaseClasses.WallSolarAzimuth walSolAzi
          "Angle measured in horizontal plane between projection of sun's rays and normal to vertical surface"
           annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
        Modelica.Blocks.Math.Product mulHDir
          "Multiplication to obtain direct solar irradiation on shaded window"
          annotation (Placement(transformation(extent={{60,50},{80,70}})));

        Modelica.Blocks.Routing.Extractor extFraSun(final allowOutOfRange=false, final
            nin=4,
          index(start=idx, fixed=true))
          "Extractor to pick the appropriate output signal"
          annotation (Placement(transformation(extent={{60,0},{80,20}})));
        Modelica.Blocks.Sources.IntegerConstant idxSou(final k=idx)
          "Source term to pick output signal"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        Modelica.Blocks.Sources.Constant const(k=1)
          annotation (Placement(transformation(extent={{0,-90},{20,-70}})));

        Utilities.Math.SmoothMax smoMax(deltaX=small/2)
          "Limiter to avoid that the fraction of sun-exposed window is below zero"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      equation
        connect(weaBus.solAlt, walSolAzi.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-76},{-82,-76},{-82,
                -75.2}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));

        connect(incAng, walSolAzi.incAng) annotation (Line(
            points={{-120,-60},{-96,-60},{-96,-84.8},{-82,-84.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(walSolAzi.verAzi, ove.verAzi) annotation (Line(
            points={{-59,-80},{-54,-80},{-54,54},{-42,54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(walSolAzi.verAzi, sidFin.verAzi) annotation (Line(
            points={{-59,-80},{-54,-80},{-54,-56},{-42,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solAlt, sidFin.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-64},{-42,-64}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(mulHDir.y, HDirTil) annotation (Line(
            points={{81,60},{110,60}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(mulHDir.u1, HDirTilUns) annotation (Line(
            points={{58,66},{40,66},{40,80},{-60,80},{-60,60},{-120,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus, ove.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,50},{-40.2,50}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(extFraSun.y, fraSun) annotation (Line(
            points={{81,10},{90,10},{90,5.55112e-16},{110,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extFraSun.y, mulHDir.u2) annotation (Line(
            points={{81,10},{90,10},{90,40},{40,40},{40,54},{58,54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(mulFraSun.y, extFraSun.u)    annotation (Line(
            points={{53,10},{58,10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(ove.fraSun, mulFraSun.u1[1])    annotation (Line(
            points={{-19,50},{24,50},{24,19},{30,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sidFin.fraSun, mulFraSun.u3[1])    annotation (Line(
            points={{-19,-60},{22,-60},{22,7},{30,7}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(const.y, mulFraSun.u4[1])    annotation (Line(
            points={{21,-80},{26,-80},{26,1},{30,1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solAlt, ove.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,46},{-42,46}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(ove.fraSun, sumFraSun.u1)
                                    annotation (Line(
            points={{-19,50},{-14,50},{-14,36},{-48,36},{-48,-30.4},{-41.2,-30.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sumFraSun.y, resFraSun.u2)
                                annotation (Line(
            points={{-27.4,-34},{-22,-34},{-22,-22},{-44,-22},{-44,-3.6},{-41.2,-3.6}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(overlap.y, resFraSun.u1)
                                    annotation (Line(
            points={{-27.4,26},{-22,26},{-22,10},{-44,10},{-44,3.6},{-41.2,3.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sidFin.fraSun, sumFraSun.u2)
                                       annotation (Line(
            points={{-19,-60},{-12,-60},{-12,-44},{-48,-44},{-48,-37.6},{-41.2,-37.6}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(idxSou.y, extFraSun.index) annotation (Line(
            points={{61,-70},{70,-70},{70,-2}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(resFraSun.y, smoMax.u1) annotation (Line(
            points={{-27.4,-1.88738e-16},{-19.7,-1.88738e-16},{-19.7,6},{-12,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(noSunCond.y, smoMax.u2) annotation (Line(
            points={{-7.4,-34},{0,-34},{0,-14},{-20,-14},{-20,-6},{-12,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(smoMax.y, mulFraSun.u2[1]) annotation (Line(
            points={{11,6.10623e-16},{18,6.10623e-16},{18,13},{30,13}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(graphics={Bitmap(extent={{-92,92},{92,-92}},
                  fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/Overhang.png")}),
      defaultComponentName="sha",
      Documentation(info="<html>
<p>
This model outputs the fraction of the window area that is sun exposed
for a window that may have an overhang and sidefins.
Depending on the record with construction data <code>conPar</code>,
an overhang, side fins or no external shade is modeled.
The model allows having an overhang and side fins at the same time.
In such a case, the overhang width should be
measured from the window edge to the sidefin,
because the overhang width beyond the sidefin will
cast a shadow on the side fin and not on the window.
Similarly, the side fin height should be measured
from the upper window edge to the overhang,
because the side fin height above the
overhang will not cast a shadow on the window.
The parameters for the dimensions of the overhang and side fins are as
described in the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.Overhang\">
Buildings.HeatTransfer.Windows.Overhang</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.SideFins\">
Buildings.HeatTransfer.Windows.SideFins</a>.
</p>

<h4>Limitations</h4>
<p>
For overhangs, the model assumes that
</p>
<ul>
<li>
the overhang is at least as wide as the window, i.e.,
<i>w<sub>L</sub> &ge; 0</i> and
<i>w<sub>R</sub> &ge; 0</i>, and
</li>
<li>
the overhang is horizontal.
</li>
</ul>

<p>
For side fins, the model assumes that
</p>
<ul>
<li>
the side fins are placed symmetrically to the left and right of the window,
</li>
<li>
the top of the side fins must be at an equal or greater height than the window, and
</li>
<li>
the side fins extends at least to the lower edge of the window.
</li>
</ul>

<h4>Implementation</h4>
<p>
The detailed calculation method is explained in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.SideFins\">
Buildings.HeatTransfer.Windows.BaseClasses.SideFins</a>
and in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Overhang\">
Buildings.HeatTransfer.Windows.BaseClasses.Overhang</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 7, 2012, by Michael Wetter:<br/>
Renamed model from <code>Shade</code> to <code>FixedShade</code> because
shade is already used for window interior and exterior shades.
</li><li>
July 5, 2012, by Michael Wetter:<br/>
Moved model from package <code>Buildings.ThermalZones.Detailed.BaseClasses</code> to
<code>Buildings.HeatTransfer.Windows</code>, because the overhang and side fin
models are also in this package.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Enabled the model to use overhang and side at the same time.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>

</ul>
</html>"));
      end FixedShade;

      model InteriorHeatTransferConvective
        "Model for heat convection at the interior surface of a window that may have a shading device"
        extends BaseClasses.PartialWindowBoundaryCondition(final thisSideHasShade=haveInteriorShade);

        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=4
          "Constant convection coefficient";
        parameter Types.InteriorConvection conMod=Buildings.HeatTransfer.Types.InteriorConvection.Fixed
          "Convective heat transfer model";
        parameter Modelica.SIunits.Angle til "Surface tilt";

       Modelica.Blocks.Interfaces.RealInput QRadAbs_flow(final unit="W") if
             haveShade
          "Total net radiation that is absorbed by the shade (positive if absorbed)"
           annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                             rotation=270,
              origin={-60,-110}),         iconTransformation(extent={{10,-10},{-10,10}},
              rotation=270,
              origin={-60,-110})));
        Modelica.Blocks.Interfaces.RealOutput TSha(
         final unit="K",
         final quantity="ThermodynamicTemperature") if
            haveShade "Shade temperature"
                             annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-110})));

        Buildings.HeatTransfer.Windows.BaseClasses.InteriorConvectionCoefficient
          conCoeGla(final A=AGla)
          "Model for the inside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-92,26},{-72,46}})));

        BaseClasses.ShadeConvection conSha(
          final A=AGla,
          final thisSideHasShade=thisSideHasShade) if
             haveShade "Convection model for shade"
          annotation (Placement(transformation(extent={{-8,-20},{12,0}})));
        BaseClasses.InteriorConvection conFra(
          final A=AFra,
          final til=til,
          final conMod=conMod,
          hFixed=hFixed) "Convective heat transfer between air and frame"
          annotation (Placement(transformation(extent={{50,-98},{30,-78}})));
        BaseClasses.InteriorConvection conWinUns(
          final A=AGla,
          final til=til,
          final conMod=conMod,
          hFixed=hFixed)
          "Convection from unshaded part of window to outside or room air"
          annotation (Placement(transformation(extent={{60,0},{40,20}})));
      equation
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-71,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(conSha.glass, glaSha) annotation (Line(
            points={{11.4,-10},{54,-10},{54,-20},{100,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(proSha.y, conSha.Gc) annotation (Line(
            points={{-29,30},{-20,30},{-20,-6},{-9,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conSha.TSha, TSha) annotation (Line(
            points={{8,-21},{8,-96},{0,-96},{0,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(QRadAbs_flow, conSha.QRadAbs_flow) annotation (Line(
            points={{-60,-110},{-60,-40},{-4,-40},{-4,-21}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(conFra.fluid, air) annotation (Line(
            points={{30,-88},{-80,-88},{-80,5.55112e-16},{-100,5.55112e-16},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(air, conSha.air) annotation (Line(
            points={{-100,0},{-80,0},{-80,-10},{-8,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conFra.fluid, air) annotation (Line(
            points={{30,-88},{-80,-88},{-80,0},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conWinUns.fluid, air)
                                   annotation (Line(
            points={{40,10},{-80,10},{-80,0},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns,conWinUns. solid) annotation (Line(
            points={{100,20},{76,20},{76,10},{60,10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conFra.solid, frame) annotation (Line(
            points={{50,-88},{70,-88},{70,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaSig.yCom, conWinUns.u) annotation (Line(
            points={{-69,74},{70,74},{70,18},{61,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.yCom, conFra.u) annotation (Line(
            points={{-69,74},{70,74},{70,-80},{51,-80}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (defaultComponentName="intConSha",
      Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the room-facing surface of a window system and
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 2, 2015, by Michael Wetter:<br/>
Refactored model to allow a temperature dependent convective heat transfer
on the room side.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/52\">52</a>.
</li>
<li>
July 11, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Text(
                extent={{-94,-82},{-28,-100}},
                lineColor={0,0,127},
                textString="QRadAbs"),
              Text(
                extent={{-28,-84},{34,-100}},
                lineColor={0,0,127},
                textString="TSha")}));
      end InteriorHeatTransferConvective;

      model Window "Model for a window"

        constant Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(HideResult=true);

        parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
          "Glazing system"
          annotation (choicesAllMatching=true, Placement(transformation(extent={{150,174},
                  {170,194}})));
        parameter Modelica.SIunits.Area A "Heat transfer area";
        parameter Real fFra(min=0, max=1)=0.1 "Fraction of frame";
        final parameter Modelica.SIunits.Area AFra = fFra*A "Frame area";
        final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";
        parameter Boolean linearize=false "Set to true to linearize emissive power";
        parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt";

        parameter Boolean steadyState = true
          "Flag, if true, then window is steady-state, else capacity is added at room-side"
          annotation(Evaluate=true, Dialog(tab="Dynamics"));

        Interfaces.RadiosityOutflow JOutUns_a
          "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,70},{-220,90}})));
        Interfaces.RadiosityInflow JInUns_a
          "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,110},{-200,130}})));
        Interfaces.RadiosityOutflow JOutSha_a if haveShade
          "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,-110},{-220,-90}})));
        Interfaces.RadiosityInflow JInSha_a if haveShade
          "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,-70},{-200,-50}})));

        Interfaces.RadiosityOutflow JOutUns_b
          "Outgoing radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,110},{220,130}})));
        Interfaces.RadiosityInflow JInUns_b
          "Incoming radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,70},{200,90}})));
        Interfaces.RadiosityOutflow JOutSha_b if haveShade
          "Outgoing radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,-70},{220,-50}})));
        Interfaces.RadiosityInflow JInSha_b if haveShade
          "Incoming radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,-110},{200,-90}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaUns(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize,
          final homotopyInitialization=homotopyInitialization)
          "Model for unshaded center of glass"
          annotation (Placement(transformation(extent={{-10,10},{10,30}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaSha(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize,
          final homotopyInitialization=homotopyInitialization) if
             haveShade "Model for shaded center of glass"
          annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor frame(
          G=AFra*glaSys.UFra,
          dT(start=0)) "Thermal conductance of frame"
          annotation (Placement(transformation(extent={{-10,-170},{10,-150}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
          "Heat port at unshaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-210,10},{-190,30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
          "Heat port at unshaded glass of room-facing surface"
          annotation (Placement(transformation(extent={{190,10},{210,30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
          "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-210, -30}, {-190,-10}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
          "Heat port at shaded glass of room-facing surface"
        annotation (Placement(transformation(extent={{190,-30}, {210,-10}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
          "Heat port at frame of exterior-facing surface"
          annotation (Placement(transformation(extent={{-210,-170},{-190,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
          "Heat port at frame of room-facing surface"
           annotation (Placement(transformation(extent={{192,-170},{212,-150}})));
        Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
             haveShade
          "Control signal for the shading device. 0: unshaded; 1: fully shaded (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-240,140},{-200,180}})));

        Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[size(glaSys.glass, 1)](
          each unit="W",
          each quantity="Power")
          "Solar radiation absorbed by unshaded part of glass"
           annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220})));
        Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[size(glaSys.glass, 1)](
           each unit="W",
           each quantity="Power") if haveShade
          "Solar radiation absorbed by shaded part of glass"
         annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={60,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-220})));

        Buildings.HeatTransfer.Windows.BaseClasses.HeatCapacity capGla(
          final haveShade=glaSys.haveExteriorShade or glaSys.haveInteriorShade,
          C=AGla*glaSys.glass[1].x*matGla.d*matGla.c,
          der_TUns(fixed=true),
          der_TSha(fixed=glaSys.haveExteriorShade or glaSys.haveInteriorShade)) if
               not steadyState
          "Heat capacity of glass on room-side, used to reduce nonlinear system of equations"
          annotation (Placement(transformation(extent={{130,38},{150,58}})));
        // We assume the frame is made of wood. Data are used for Plywood, as
        // this is an order of magnitude estimate for the heat capacity of the frame,
        // which is only used to avoid algebraic loops in the room model.
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFra(
          der_T(fixed=true),
          C=AFra*matFra.x*matFra.d*matFra.c) if
               not steadyState
          "Heat capacity of frame on room-side, used to reduce nonlinear system of equations"
          annotation (Placement(transformation(extent={{130,-142},{150,-122}})));

    protected
        final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
          "Parameter, equal to true if the window has a shade"
          annotation(Evaluate=true);

        BaseClasses.ShadingSignal shaSig(final haveShade=glaSys.haveExteriorShade or glaSys.haveInteriorShade)
          "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present"
          annotation (Placement(transformation(extent={{-60,150},{-40,170}})));

        parameter Data.Solids.Plywood matFra(x=0.03)
          "Thermal properties of frame (used to avoid algebraic loops in room model)"
          annotation (Placement(transformation(extent={{108,174},{128,194}})));
        parameter Data.Solids.Glass matGla(
          x=glaSys.glass[end].x,
          nSta=1,
          nStaReal=1)
          "Material properties for thermal capacity of room-facing glass (used to avoid algebraic loops in room model)"
          annotation (Placement(transformation(extent={{108,150},{128,170}})));

      initial equation
        assert(homotopyInitialization, "In " + getInstanceName() +
          ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
          level = AssertionLevel.warning);

      equation
        connect(frame.port_a, fra_a) annotation (Line(
            points={{-10,-160},{-200,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(frame.port_b, fra_b)  annotation (Line(
            points={{10,-160},{202,-160}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(glaUns.glass_a, glaUns_a)
                                        annotation (Line(
            points={{-10,20},{-200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns.glass_b, glaUns_b)
                                        annotation (Line(
            points={{10,20},{200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaSig.yCom, glaUns.u) annotation (Line(
            points={{-39,154},{-20,154},{-20,28},{-11,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.y, glaSha.u) annotation (Line(
            points={{-39,160},{-24,160},{-24,-12},{-11,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.u, uSha) annotation (Line(
            points={{-62,160},{-220,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(glaSha.glass_a, glaSha_a) annotation (Line(
            points={{-10,-20},{-200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaSha.glass_b, glaSha_b) annotation (Line(
            points={{10,-20},{200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(JInUns_a, glaUns.JIn_a) annotation (Line(
            points={{-210,120},{-40,120},{-40,24},{-11,24}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(glaUns.JOut_a, JOutUns_a) annotation (Line(
            points={{-11,16},{-46,16},{-46,80},{-210,80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaUns.JOut_b, JOutUns_b) annotation (Line(
            points={{11,24},{170,24},{170,120},{210,120}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInUns_b, glaUns.JIn_b) annotation (Line(
            points={{210,80},{176,80},{176,16},{11,16}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(JInSha_a, glaSha.JIn_a) annotation (Line(
            points={{-210,-60},{-46,-60},{-46,-16},{-11,-16}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(glaSha.JOut_a, JOutSha_a) annotation (Line(
            points={{-11,-24},{-42,-24},{-42,-100},{-210,-100}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaSha.JOut_b, JOutSha_b) annotation (Line(
            points={{11,-16},{176,-16},{176,-60},{210,-60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInSha_b, glaSha.JIn_b) annotation (Line(
            points={{210,-100},{172,-100},{172,-24},{11,-24}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(glaUns.QAbs_flow, QAbsUns_flow) annotation (Line(
            points={{6.10623e-16,9},{6.10623e-16,4},{-80,4},{-80,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(glaSha.QAbs_flow,QAbsSha_flow)  annotation (Line(
            points={{6.10623e-16,-31},{6.10623e-16,-60},{60,-60},{60,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(capFra.port, fra_b) annotation (Line(points={{140,-142},{140,-160},{
                202,-160}}, color={191,0,0}));
        connect(capGla.ySha, shaSig.y) annotation (Line(points={{128,52},{80,52},{-24,
                52},{-24,160},{-39,160}}, color={0,0,127}));
        connect(capGla.yCom, shaSig.yCom) annotation (Line(points={{128,44},{60,44},{-20,
                44},{-20,154},{-39,154}}, color={0,0,127}));
        connect(capGla.portSha, glaSha_b) annotation (Line(points={{150,52},{160,52},{
                160,-20},{200,-20}}, color={191,0,0}));
        connect(capGla.portUns, glaUns_b) annotation (Line(points={{150,44},{156,44},{
                156,20},{200,20}}, color={191,0,0}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,200}})),
          Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-200},{200,200}}),
            graphics={
              Polygon(
                visible = glaSys.haveInteriorShade,
                points={{48,160},{48,60},{116,-4},{116,96},{48,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-74,-88},{28,-88}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{28,160},{28,-88},{90,-152},{90,96},{28,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-184,176},{-134,140}},
                lineColor={0,0,127},
                textString="uSha"),            Text(
                extent={{-60,238},{38,190}},
                lineColor={0,0,255},
                textString="%name"),
              Polygon(
                points={{38,138},{38,-84},{78,-124},{78,96},{38,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,160},{48,160}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-12,-152},{90,-152}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-20,160},{-20,-88},{42,-152},{42,96},{-20,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,138},{-10,-84},{30,-124},{30,96},{-10,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,160},{-74,-88},{-12,-152},{-12,96},{-74,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-64,136},{-64,-86},{-24,-126},{-24,94},{-64,136}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible = glaSys.haveExteriorShade,
                points={{-102,160},{-102,60},{-34,-4},{-34,96},{-102,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-34,96},{116,96}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{-198,-160},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{84,-160},{200,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{56,20},{198,20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{-200,20},{-56,20}},
                color={160,0,0},
                smooth=Smooth.None), Ellipse(
                extent={{-226,234},{-164,170}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{-198,-20},{-44,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{56,-20},{198,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{-60,-100},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible = glaSys.haveExteriorShade,
                points={{84,-118},{84,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Text(
                extent={{36,-162},{126,-202}},
                lineColor={0,0,127},
                textString="QAbsSha"),
              Text(
                visible = haveShade,
                extent={{-124,-164},{-34,-204}},
                lineColor={0,0,127},
                textString="QAbsUns")}),
          defaultComponentName="win",
          Documentation(info="<html>
<h4>Overview</h4>
<p>
This is a model for a window system. The equations are similar to the
equations used in the Window 5 model and described in TARCOG 2006.
The model computes
the heat balance from the exterior surface to
the room-facing surface for a window system.
The window system can have
an exterior or an interior shade, but not both, or it can
have no shade.
The convective heat transfer between the window system and the outside air
or the room is <em>not</em> computed by this model.
They can be computed using the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>,
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransferConvective\">
Buildings.HeatTransfer.Windows.InteriorHeatTransferConvective</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.ShadeRadiation\">
Buildings.HeatTransfer.Windows.BaseClasses.ShadeRadiation</a>.
</p>

<h4>Limitations</h4>
<p>
To calculate the angular transmittance, reflectance and absorptance of a glazing system, Window 5 model first calculates the value for each wave length, then calculate the weighted value over entire wave lengths.
Current window model in Buildings library only uses the weighted value of each glass.
As a result, there are some differences in prediciton between the current Modelica window model and WINDOW 5.
The difference is small for single layer window or multi-layer window with the same glasses.
But it can be large for multi-layer window with different glasses.
</p>

<h4>Parameters</h4>
<p>
This model takes as the parameter <code>glaSys</code> a data record
from the package
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a>.
This data record specifies the properties of the glasses,
the gas fills, the frame and of
the shades, if any shade is present.
Whether a shade is present or not is determined by the parameters
<code>glaSys.haveExteriorShade</code> and
<code>glaSys.haveInteriorShade</code>.
</p>
<p>
The parameter <code>linearize</code> can be used
to linearize the model equations.
</p>
<p>
If the parameter <code>steadyState</code> is set to <code>false</code>
then state variables are added at the heat ports that face
the room side.
For simulation of
<a href=\"modelica://Buildings.ThermalZones.Detailed.MixedAir\">
Buildings.ThermalZones.Detailed.MixedAir</a>, adding states
avoids large nonlinear system of equations, and generally
leads to faster simulation. Default values are used
for the states.
</p>
<h4>Ports</h4>
<p>
If a shade is present, then the input port <code>u</code> is used
to determine the
shade position. Set <code>u=0</code> to have the window in the
unshaded mode,
and set <code>u=1</code> to have the window shade completely deployed.
Any intermediate value is possible.
If no shade is present, then this port will be removed.
</p>
<p>
For the heat ports, the suffix <code>_a</code> is used for the exterior, outside-facing side
of the window, and the suffix <code>_b</code> is used for the interior, room-facing surface
of the window.
Each side has heat ports that connect to the glass, to the frame, and, optionally, to the
shade. If no shade is present, then the heat port to the shade will be removed.
</p>

<h4>Description of the Physics</h4>
<p>
The model has three main submodels that implement the relevant
heat balances:</p>
<ol>
<li>
The model <code>frame</code> computes heat conduction
through the frame.
</li>
<li>
The model <code>glaUns</code> computes the heat balance of the part of the
window that is unshaded. For example, if <code>u=0.2</code>, then this model accounts for
the 80% of the window that is not behind the shade or blind.
</li>
<li>
The model <code>glaSha</code> computes the heat balance of the part of the
window that is shaded. For example, if <code>u=0.2</code>, then this model accounts for
the 20% of the window that is behind the shade or blind.
If the parameter <code>glaSys</code> specifies that the window has no exterior
and no interior shade, then the model <code>glaSha</code> will be removed.
</li>
</ol>

<p>
The models <code>glaUns</code> and <code>glaSha</code>
compute the solar radiation that is absorbed by each
glass pane and the solar radiation that is transitted
through the window as a function of the solar incidence angle.
They then compute a heat balance that takes into account heat conduction through the glass,
heat convection through the gas layer,
and infrared radiation from the exterior and the room through the glass and gas layers.
The infrared radiative heat exchange is computed using a radiosity balance.
Heat conduction through the frame is computed using a heat flow path that is parallel to the
glazing system, i.e., there is no heat exchange between the frame
and the glazing layer.
</p>

<h4>Validation</h4>
<p>
The window model has been validated by using measurement data at LBNL's Test Cell 71T and by using
a comparative model validation with the WINDOW 6 program. These validations are described in Nouidui et al. (2012).
The window model has also been validated as part of the BESTEST validations that are implemented in
<a href=\"modelica://Buildings.ThermalZones.Detailed.Validation.BESTEST\">
Buildings.ThermalZones.Detailed.Examples.BESTEST</a>.
</p>

<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with or without
shading devices, Technical Report, Oct. 17, 2006.
</p>

<p>
Thierry Stephane Nouidui, Michael Wetter, and Wangda Zuo.
<a href=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/2012-simBuild-windowValidation.pdf\">
Validation of the window model of the Modelica Buildings library.</a>
<i>Proc. of the 5th SimBuild Conference</i>, Madison, WI, USA, August 2012.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 11, 2021, by Michael Wetter:<br/>
Added start value for <code>frame.dT</code> to avoid a warning about missing start value in OCT
when translating <code>Buildings.Examples.VAVReheat.Guideline36</code>.
</li>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Added option to place a state at the surface.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 25, 2014, by Michael Wetter:<br/>
Propagated parameter <code>homotopyInitialization</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 19, 2011, by Wangda Zuo:<br/>
Add a warning note to remind users that the model does not count wave length dependence for calculation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Window;

      package Functions "Functions used in window radiation model"
        extends Modelica.Icons.Package;

        function devAbsExteriorIrradiationInteriorShading
          "Angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrIntShaDev[HEM, NSta](each min=0, each max=1)
            "Absorptance of a shading device for exterior irradiation with interior shading";

        algorithm
          for iSta in 1:NSta loop
            for iD in 1:HEM loop
              absExtIrrIntShaDev[iD, iSta] := traRef[TRA, 1, N, iD, iSta]*(1 - traIntShaDev -
                refIntShaDev)/(1 - refIntShaDev*traRef[Rb, N, 1, HEM, iSta])
                "Equation (A.4.91)";
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end devAbsExteriorIrradiationInteriorShading;

        function devAbsInteriorIrradiationInteriorShading
          "Hemiperical absorptance of a shading device for interior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntShaDev[NSta](each min=0, each max=1)
            "Hemiperical absorbtance of a shading device for interior irradiation with interior shading";
      protected
          Real rRho;
          Real rTau;
          Real c;

        algorithm
          for iSta in 1:NSta loop
            rRho:=traRef[3, N, 1, HEM, iSta]*refIntShaDev "Part of equation (A.4.103)";
            rTau:=traRef[3, N, 1, HEM, iSta]*traIntShaDev "Part of equation (A.4.103)";
            c:=traIntShaDev*(1 - rRho/(1 - rRho)) "Equation (4.99)";

            absIntIrrIntShaDev[iSta] := (1 - traIntShaDev - refIntShaDev)*(1 + rTau/(1 - rRho))
              "Equation (4.103)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemiperical absorbtance of a shading device for interior irradiation with interior shading.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 24, 2016, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end devAbsInteriorIrradiationInteriorShading;

        function getAngle "Generate incident angles"
          input Integer NDIR "Number of incident angles";
          output Modelica.SIunits.Angle psi[NDIR] "Array of incident angles";

      protected
          Real deltaX=0.5*Modelica.Constants.pi/(NDIR - 1);

        algorithm
          for i in 1:NDIR loop
            psi[i] := (i - 1)*deltaX;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes discrete incident angles for the window radiation calculation. The range is from 0 to 90 degree.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 21, 2016, by Michael Wetter:<br/>
Removed wrong <code>constant</code> attribute.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getAngle;

        function getGlassTR "Transmittance and reflectance of glass"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

          input Real layer[3, N, HEM, NSta] "Property of glass pane";
          output Real traRef[3, N, N, HEM, NSta](each min=0, each max=1)
            "Glass transmittance, front and back reflectance";

      protected
          Real traRefIntIrr[3, N, N, HEM, NSta](each min=0, each max=1)
            "temporary array for glass transmittance, front and back reflectance for interior irradiation";

        algorithm
          traRef :=
              Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
              N=N,
              NSta=NSta,
              HEM=HEM,
              layer=layer) "property for exterior irradiation";
          traRefIntIrr :=
              Buildings.HeatTransfer.Windows.Functions.glassTRInteriorIrradiationNoShading(
              N=N,
              NSta=NSta,
              HEM=HEM,
              layer=layer) "property for interior irradiation";

          // Copy the property for interior irradiation to glass property
          for k in TRA:Rb loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                for iD in 1:HEM loop
                  traRef[k, N + 1 - i, N + 1 - j, iD, 1:NSta] :=
                    traRefIntIrr[k, N + 1 - i, N + 1 - j, iD, 1:NSta];
                end for;
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
For instance, <code>traRef[TRA, 1, N, iD]</code> means transmittance between layer <code>1</code> to <code>N</code> for exterior irradiation and
<code>traRef[TRA, N, 1, iD]</code> means the transmittance for interior irradiation.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getGlassTR;

        function glassAbsExteriorIrradiationExteriorShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading"
          input Real absExtIrrNoSha[N, HEM, NSta](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrExtSha[N, HEM, NSta](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading";

      protected
          Real c "Intermediate variable";

        algorithm
          for iSta in 1:NSta loop
            for iD in 1:HEM loop
              c := traExtShaDev*(1 + traRef[Ra, 1, N, iD, iSta]*refExtShaDev/
                (1 - traRef[Ra, 1, N, HEM, iSta]*refExtShaDev));
              for i in 1:N loop
                absExtIrrExtSha[i, iD, iSta] := c*absExtIrrNoSha[i, iD, iSta];
               end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationExteriorShading;

        function glassAbsExteriorIrradiationInteriorShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading"
          input Real absExtIrrNoSha[N, HEM, NSta](each min=0, each max=1)
            "Absorptance for exterior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real absExtIrrNoShaIntSha[N, HEM, NSta](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading";

      protected
          Real fac;
          Real absFro "Front (outside-facing) absorptance";
          Real absBac "Back (room-facing) absorptance";
          Integer i "Index of glass pane";

        algorithm
          for iSta in 1:NSta loop
            for iD in 1:HEM loop
              i := 1;
              fac := traRef[TRA, 1, N, iD, iSta]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM, iSta]*
                refIntShaDev) "Equation (A.4.90)";
              absBac := 1 - traRef[TRA, i, i, iD, iSta] - traRef[Rb, i, i, iD, iSta]
                "Equation (A.4.81b)";

              if N >= 2 then
                absExtIrrNoShaIntSha[i, iD, iSta] := absExtIrrNoSha[i, iD, iSta] + fac*traRef[TRA, N,
                  i + 1, HEM, iSta]*absBac "Equation (A.4.90)";

                for i in 2:N - 1 loop
                  fac := traRef[TRA, 1, N, iD, iSta]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM, iSta]*
                    refIntShaDev) "Equation (A.4.90)";
                  absFro := 1 - traRef[TRA, i, i, iD, iSta] - traRef[Ra, i, i, iD, iSta]
                    "Equaiton (A.4.81a)";
                  absBac := 1 - traRef[TRA, i, i, iD, iSta] - traRef[Rb, i, i, iD, iSta]
                    "Equation (A.4.81b)";
                  absExtIrrNoShaIntSha[i, iD, iSta] := absExtIrrNoSha[i, iD, iSta] + fac*(traRef[TRA,
                      N, i, HEM, iSta]*traRef[Rb, i - 1, 1, HEM, iSta]*absFro + traRef[TRA, N, i + 1,
                    HEM, iSta]*absBac) "Equation (A.4.90)";
                end for;

                i := N;
                fac := traRef[TRA, 1, N, iD, iSta]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM, iSta]*
                  refIntShaDev) "Equation (A.4.90)";
                absFro := 1 - traRef[TRA, i, i, iD, iSta] - traRef[Ra, i, i, iD, iSta]
                  "Equaiton (A.4.81a)";
                absBac := 1 - traRef[TRA, i, i, iD, iSta] - traRef[Rb, i, i, iD, iSta]
                  "Equation (A.4.81b)";
                absExtIrrNoShaIntSha[i, iD, iSta] := absExtIrrNoSha[i, iD, iSta] + fac*(traRef[TRA, N,
                  i, HEM, iSta]*traRef[Rb, i - 1, 1, HEM, iSta]*absFro + absBac)
                  "Equation (A.4.90)";

              else
                absExtIrrNoShaIntSha[i, iD, iSta] := absExtIrrNoSha[i, iD, iSta] + fac*absBac
                  "Equation (A.4.90)";
              end if;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationInteriorShading;

        function glassAbsExteriorIrradiationNoShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;
          output Real[N, HEM, NSta] abs(each min=0, each max=1) "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading.
     Indices: abs[1 to N : ] -> pane 1 to N;
     abs[ : 1 to HEM] -> angular (1:HEM-1) and hemispherical (HEM)";

      protected
          Real af "Front (outside-facing side) absorptance of a pane";
          Real ab "Back (room-facing side) absorptance of a pane";
          Real deno1 "Denominantor";
          Real deno2 "Denominantor";
          Integer j;
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          if N == 1 then
            j := 1;
            for iSta in 1:NSta loop
              for iD in 1:HEM loop
                abs[j, iD, iSta] := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Ra, j, j, iD, iSta]
                  "Equation (A.4.79)";
              end for;
            end for;
          else
            for iSta in 1:NSta loop
              for iD in 1:HEM loop
                j := 1;
                af := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Ra, j, j, iD, iSta]
                  "Equation (A.4.81a)";
                ab := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Rb, j, j, iD, iSta]
                  "Equation (A.4.81b)";
                deno2 := 1 - traRef[Rb, j, 1, iD, iSta]*traRef[Ra, j + 1, N, iD, iSta];
                if deno2 < SMALL then
                  abs[j, iD, iSta] := 0;
                else
                  abs[j, iD, iSta] := af + ab*traRef[TRA, 1, j, iD, iSta]*traRef[Ra, j + 1, N, iD, iSta]/
                    deno2 "Equation (A.4.82) and (A.4.83b)";
                end if;

                for j in 2:N - 1 loop
                  af := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Ra, j, j, iD, iSta]
                    "Equation (A.4.81a)";
                  ab := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Rb, j, j, iD, iSta]
                    "Equation (A.4.81b)";
                  deno1 := 1 - traRef[Ra, j, N, iD, iSta]*traRef[Rb, j - 1, 1, iD, iSta];
                  deno2 := 1 - traRef[Rb, j, 1, iD, iSta]*traRef[Ra, j + 1, N, iD, iSta];
                  if deno1 < SMALL or deno2 < SMALL then
                    abs[j, iD, iSta] := 0;
                  else
                    abs[j, iD, iSta] := af*traRef[TRA, 1, j - 1, iD, iSta]/deno1 + ab*traRef[TRA, 1,
                      j, iD, iSta]*traRef[Ra, j + 1, N, iD, iSta]/deno2
                      "Equation (A.4.83b)";
                  end if;
                end for;

                j := N;
                af := 1 - traRef[TRA, j, j, iD, iSta] - traRef[Ra, j, j, iD, iSta]
                  "Equation (A.4.81a)";
                deno1 := 1 - traRef[Ra, j, N, iD, iSta]*traRef[Rb, j - 1, 1, iD, iSta];
                if deno1 < SMALL then
                  abs[j, iD, iSta] := 0;
                else
                  abs[j, iD, iSta] := af*traRef[TRA, 1, j - 1, iD, iSta]/deno1;
                end if;
              end for;
            end for; // iSta in 1:NSta
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes specular and hemispherical absorptance of each glass pane for exterior irradiation without shading.
It counts the transmittance and reflectance among different panes.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationNoShading;

        function glassAbsInteriorIrradiationExteriorShading
          "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading"
          input Real absIntIrrNoSha[N, NSta]
            "Absorptance for interior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrExtSha[N, NSta](each min=0, each max=1)
            "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading";

      protected
          Real fac;
          Real absFro "Front absorptance";
          Real absBac "Back absorptance";
          Integer i "Pane index";

        algorithm
          for iSta in 1:NSta loop
            fac := traRef[TRA, N, 1, HEM, iSta]*refExtShaDev/(1 - traRef[Ra, 1, N, HEM, iSta]*
              refExtShaDev);

            i := 1;
            absFro := 1 - traRef[TRA, i, i, HEM, iSta] - traRef[Ra, i, i, HEM, iSta]
              "Equaiton (A.4.81a)";
            absBac := 1 - traRef[TRA, i, i, HEM, iSta] - traRef[Rb, i, i, HEM, iSta]
              "Equation (A.4.81b)";

            if N >= 2 then
              absIntIrrExtSha[i, iSta] := absIntIrrNoSha[i, iSta] + fac*absFro + fac*traRef[TRA, 1, i,
                HEM, iSta]*traRef[Ra, i + 1, N, HEM, iSta]*absBac "Equation (A.4.94)";

              for i in 2:N - 1 loop
                absFro := 1 - traRef[TRA, i, i, HEM, iSta] - traRef[Ra, i, i, HEM, iSta]
                  "Equaiton (A.4.81a)";
                absBac := 1 - traRef[TRA, i, i, HEM, iSta] - traRef[Rb, i, i, HEM, iSta]
                  "Equation (A.4.81b)";
                absIntIrrExtSha[i, iSta] := absIntIrrNoSha[i, iSta] + fac*traRef[TRA, 1, i - 1, HEM, iSta]*
                  absFro + fac*traRef[TRA, 1, i, HEM, iSta]*traRef[Ra, i + 1, N, HEM, iSta]*absBac
                  "Equation (A.4.94)";
              end for;

              i := N;
              absFro := 1 - traRef[TRA, i, i, HEM, iSta] - traRef[Ra, i, i, HEM, iSta]
                "Equaiton (A.4.81a)";
              absIntIrrExtSha[i, iSta] := absIntIrrNoSha[i, iSta] + fac*traRef[TRA, 1, i - 1, HEM, iSta]*
                absFro "Equation (A.4.94)";
            else
              absIntIrrExtSha[i, iSta] := absIntIrrNoSha[i, iSta] + fac*absFro
                "Equation (A.4.94)";
            end if;
          end for;
          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane for interior irradiation with exterior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationExteriorShading;

        function glassAbsInteriorIrradiationInteriorShading
          "Hemispherical absorptance of each glass pane for interior irradiation with interior shading"
          input Real absIntIrrNoSha[N, NSta](each min=0, each max=1)
            "Hemispherical absorptance wfor interior irradiation without interior shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntSha[N, NSta](each min=0, each max=1)
            "Hemispherical absorbtance of each glass pane for interior irradiation with interior shading";

      protected
          Real rRho;
          Real c;

        algorithm
          for iSta in 1:NSta loop
            rRho :=traRef[Rb, N, 1, HEM, iSta]*refIntShaDev "Part of Equation (4.99)";
            c :=traIntShaDev*(1 + rRho/(1 - rRho)) "Equation (4.99)";
            for i in 1:N loop
              absIntIrrIntSha[i, iSta] := c*absIntIrrNoSha[i, iSta]
                "Equation (A4.100a)";
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorbtance of each glass pane for interior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationInteriorShading;

        function glassAbsInteriorIrradiationNoShading
          "Hemispherical absorptance of each glass pane for interior irradiation without shading"

          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;

          output Real[N, NSta] absIntIrrNoSha(each min=0, each max=1)
            "Hemispherical absorptance of each glass layer for interior irradiation without shading";

      protected
          Real dTraRef[3, N, N, HEM, NSta](each min=0, each max=1)
            "Dummy transmittance and reflectance with exterior irradiation without shading";
          Real dAbs[N, HEM, NSta](each min=0, each max=1)
            "Dummy absorptance with exterior irradiation and no shading";

        algorithm
            // Reverse the data structure for exterior irradiation and no shading
          for i in 1:N loop
            for j in 1:N loop
              for iD in 1:HEM loop
                dTraRef[TRA, i, j, iD, 1:NSta] := traRef[TRA, N + 1 - i, N + 1 - j, iD, 1:NSta];
                dTraRef[Ra, i, j, iD, 1:NSta] := traRef[Rb, N + 1 - i, N + 1 - j, iD, 1:NSta];
                dTraRef[Rb, i, j, iD, 1:NSta] := traRef[Ra, N + 1 - i, N + 1 - j, iD, 1:NSta];
              end for;
            end for;
          end for;

          dAbs :=
            Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
            traRef=dTraRef,
            N=N,
            NSta=NSta,
            HEM=HEM) "Dummmy absorptance with exterior irradiation";

          // Only output hemispherical absorptance. Need to change order for interior irradiation.
          for i in 1:N loop
            absIntIrrNoSha[i, 1:NSta] := dAbs[N + 1 - i, HEM, 1:NSta];
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane
for interior irradiation without no shading.
The angular irradiation is not considered since the interior irradiation (from the room)
is assumed to be diffusive.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
September 7, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationNoShading;

        function glassProperty
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for each glass pane without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real glass[3, N, NSta] "Propertry of each glass pane";
          input Real xGla[N] "Thickness of each glass pane";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";

          output Real layer[3, N, HEM, NSta]
            "Transmittance, front and back reflectance";

      protected
          parameter Real tol=0.005
            "Tolerance for difference between front and back reflectance to decide a glass is uncoated or coated";
          Real oneLay[3, HEM, NSta] "Temporary storage for glass property of one pane";
          Real oneGla[3, NSta];

        algorithm
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N]) and panes from 1 to N
          for i in 1:N loop
            // Copy data to temporary place
            for j in 1:3 loop
              oneGla[j, 1:NSta] := glass[j, i, 1:NSta];
            end for;

            for iSta in 1:NSta loop
              //uncoated galss
              if (abs(glass[Ra, i, iSta] - glass[Rb, i, iSta]) < tol) then
                oneLay[:,:,iSta] := Buildings.HeatTransfer.Windows.Functions.glassPropertyUncoated(
                  HEM,
                  oneGla[:,iSta],
                  xGla[i],
                  psi);

               else
                //coated glass
                oneLay[:,:,iSta] := Buildings.HeatTransfer.Windows.Functions.glassPropertyCoated(
                  HEM,
                  oneGla[:, iSta],
                  psi);
               end if;
             end for; // iSta

            for j in 1:3 loop
              for k in 1:HEM loop
                layer[j, i, k, 1:NSta] := oneLay[j, k, 1:NSta];
              end for;
            end for;
          end for; // i in 1:N
          annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for each glass pane.
There are two schemes for the calculation. One is for coated glass and the other is for uncoated glass.
The function checks the difference between front and back reflectances.
If the difference is less than the tolerance (0.005), it uses the formula for uncoated glass.
Otherwise, the formula for coated glass will be used.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Calculate the property using formula for coated (existing) and uncoated glass (newly added).
</li>
<li>
August 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassProperty;

        function glassPropertyCoated
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for a coated glass pane without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;
          input Real glass[3] "Propertry of one glass pane";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";

          output Real layer[3, HEM] "Transmittance, front and back reflectance";

      protected
          constant Real a[4, 5]={{-0.0015,3.355,-3.840,1.460,0.0288},{0.999,-0.563,
              2.043,-2.532,1.054},{-0.002,2.813,-2.341,-0.05725,0.599},{0.997,-1.868,
              6.513,-7.862,3.225}} "Coeffcients in Table A.2";

          Integer NDIR "Number of incident angles";

          Real psi_c "cos(psi), psi is incident angle";
          Real psi_cs "cos(psi)*sin(psi)";
          Real angT "Angular variation of transmittance";
          Real angR "Angular variation of reflectance";
          Real f[3, HEM-1]
            "Temporary variables for integration in hemispherical transmittance and reflectance";
          Real deltaX;

          Integer id1 "Index of coefficients for transmittance";
          Integer id2 "Index of coefficients for reflectance";

        algorithm
          NDIR:=HEM - 1;
          deltaX := 0.5*Modelica.Constants.pi/(NDIR - 1);
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N])
            for k in TRA:Rb loop
              layer[k, 1] := glass[k] "Copy the data at 0 degree (normal incidence)";
            end for;

            for j in 2:HEM-2 loop
              psi_c := Modelica.Math.cos(psi[j]);
               if layer[TRA, 1] > 0.645 then
                id1 := 1;
                id2 := 2;
              else
                id1 := 3;
                id2 := 4;
              end if;
              angT := a[id1, 1] + psi_c*(a[id1, 2] + psi_c*(a[id1, 3] + psi_c*(a[id1, 4]
                 + psi_c*a[id1, 5]))) "Equation (A.4.68a)";
              angR := a[id2, 1] + psi_c*(a[id2, 2] + psi_c*(a[id2, 3] + psi_c*(a[id2, 4]
                 + psi_c*a[id2, 5]))) - angT "Equation (A.4.68b)";
              layer[TRA, j] := layer[TRA, 1]*angT "Equation (A4.69a)";
              layer[Ra, j] := layer[Ra, 1]*(1 - angR) + angR "Equation (A4.69b)";
              layer[Rb, j] := layer[Rb, 1]*(1 - angR) + angR "Equation (A4.69b)";

            end for;

            layer[TRA, NDIR] := 0;
            layer[Ra, NDIR] := 1.0;
            layer[Rb, NDIR] := 1.0;

          // Computer hemispherical value: HEM.
            for j in 1:HEM-1 loop
              psi_cs := Modelica.Math.cos(psi[j])*Modelica.Math.sin(psi[j]);
              for k in TRA:Rb loop
                f[k, j] := 2*layer[k, j]*psi_cs;
              end for;
            end for;

            for k in TRA:Rb loop
              layer[k, HEM] :=
                Buildings.Utilities.Math.Functions.trapezoidalIntegration(
                NDIR,
                f[k, :],
                deltaX) "Equation (A.4.70a) and (A.4.70b)";
            end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for one coated glass pane.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed use of <code>NDIR</code> for OpenModelica.
</li>
<li>
December 09, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassPropertyCoated;

        function glassPropertyUncoated
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for a uncoated glass pane without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;

          input Real glass[3] "Propertry of one glass pane";
          input Modelica.SIunits.Length x "Thickness";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";
          output Real layer[3, HEM] "Transmittance, front and back reflectance";

      protected
          Integer NDIR "Number of incident angles";
          Real psi_c "cos(psi), psi is incident angle in air";
          Real psi1_c "cos(psi1), psi1 is incident angle in glass";
          Real angT "Angular variation of transmittance";
          Real angR "Angular variation of reflectance";
          Real f[3, HEM-1]
            "Temporary variables for integration in hemispherical transmittance and reflectance";
          Real beta "Temporary coefficient defined in (7.2.1i)";
          Real rho0
            "Spectral reflectivity at incident angle of 0 degree at the interface";
          Real rho "Spectral reflectivity at the interface";
          Real rho1;
          Real rho2;
          Real tau "Spectral transmissivity at the interface";
          Real tau1;
          Real tau2;
          Real angT1;
          Real angT2;
          Real angR1;
          Real angR2;
          Real tmp;
          Real alpha "Spectral absorption coefficient defined in (7.2.1e)";
          Real n
            "Ratio of spectral index of refraction of glass to the index of refraction of air";
          Real psi1 "The angle od incident angle in glass";
          Real deltaX;

        algorithm
          // Check the data
          assert(glass[TRA] >= 0,
            "Glass property is not correct with solar transmittance less than 0");
          assert(glass[Ra] >= 0,
            "Glass property is not correct with solar reflectance less than 0");
          assert(glass[TRA] + glass[Ra] <= 1,
            "Glass property is not correct since the summation of solar reflectance and transmittance is larger than 1");

          NDIR := HEM-1;
          deltaX := 0.5*Modelica.Constants.pi/(NDIR-1);
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N])
          for k in TRA:Rb loop
            layer[k, 1] := glass[k] "Copy the data at 0 degree (normal incidence)";
          end for;

          beta := glass[TRA]^2 - glass[Ra]^2 + 2*glass[Ra] + 1 "(2)";

          tmp := beta^2 - 4*(2 - glass[Ra])*glass[Ra] "part of (1)";
          assert(tmp >= 0,
            "Glass property is wrong. It is not possible to calculate the spectral reflectivity at 0 degree for uncoated glass.");

          rho0 := 0.5*(beta - sqrt(tmp))/(2 - glass[Ra]) "(1)";
          assert(rho0 >= 0,
            "Glass property is wrong. The spectral reflectivity at 0 degree for uncoated glass is less than zero.");

          tmp := (glass[Ra] - rho0)/(rho0*glass[TRA]) "part of (3)";
          assert(tmp > 0,
            "Glass property is wrong. It is not possible to calculate the spectral extinction coefficient for uncoated glass.");

          alpha := -log(tmp)/x "(3)";
          tmp := sqrt(rho0);
          assert(tmp <> 1,
            "Glass property is wrong. It is not possible to calculate the spectral index of refraction for uncoated glass.");
          n := (1 + tmp)/(1 - tmp) "(4)";

          for j in 2:HEM-2 loop
            psi1 := asin(sin(psi[j])/n) "(5)";
            psi_c := cos(psi[j]);
            psi1_c := cos(psi1);

            rho1 := ((n*psi_c - psi1_c)/(n*psi_c + psi1_c))^2 "(6)";
            rho2 := ((n*psi1_c - psi_c)/(n*psi1_c + psi_c))^2 "(7)";

            tau1 := 1 - rho1 "(8)";
            tau2 := 1 - rho2 "(9)";

            tmp := exp(-alpha*x/psi1_c);

            angT1 := tau1^2*tmp/(1 - rho1^2*tmp^2) "(10)";
            angR1 := rho1*(1 + angT1*tmp) "(13)";
            angT2 := tau2^2*tmp/(1 - rho2^2*tmp^2) "(11)";
            angR2 := rho2*(1 + angT2*tmp) "(14)";

            layer[TRA, j] := 0.5*(angT1 + angT2) "Tansmittance in (12)";
            layer[Ra, j] := 0.5*(angR1 + angR2) "Front reflectance (15)";
            layer[Rb, j] := layer[Ra, j] "Back reflectance in (15)";
          end for;

          // When incident angle is equal to 90 degree
          layer[TRA, NDIR] := 0 "(16)";
          layer[Ra, NDIR] := 1.0 "(16)";
          layer[Rb, NDIR] := 1.0 "(16)";

          // Computer hemispherical value: HEM.
          for j in 1:HEM-1 loop
            for k in TRA:Rb loop
              f[k, j] := 2*layer[k, j]*Modelica.Math.cos(psi[j])*Modelica.Math.sin(psi[
                j]);
            end for;
          end for;

          for k in TRA:Rb loop
            layer[k, HEM] := Buildings.Utilities.Math.Functions.trapezoidalIntegration(
              NDIR,
              f[k, :],
              deltaX)
              "Equation (A.4.70a) and (A.4.70b) in M. Wetter 's Thesis or (7.3) in Finlayson 1993.";
          end for
        annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for one uncoated glass pane.
The equations are mainly based on Finlayson et al. (1990) and Fuler et al. (1991) with some modifications.
</p>
<h4>Implementation</h4>
<p>
Step 1: Compute the reflectivity at normal incidence
</p>
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
   &rho;(0) = {&beta; &minus; sqrt[&beta;<sup>2</sup> &minus; 4(2 &minus; R(0))R(0)]}
      &frasl;
   [2(2&minus;R(0))],
</p></td>
<td>(1)</td>
</tr>
</table>
where
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &beta; = T(0)<sup>2</sup> &minus; R(0)<sup>2</sup> + 2R(0) + 1.
</p></td>
<td>(2)</td>
</tr>
</table>

<p>
Step 2: Compute the spectral absorption coefficient &alpha; and spectral index of refraction n
</p>
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &alpha; = 4 &pi; &kappa;<sub>&lambda;</sub> &frasl;  &lambda;
  = - ln[(R(0) &minus; &rho;(0)) &frasl; (&rho;(0)T(0))] &frasl; d,
</p></td>
<td>(3)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  n = (1 + sqrt(&rho;(0))) &frasl;
        (1 &minus; sqrt(&rho;(0))).
</p></td>
<td>(4)</td>
</tr>
</table>

<p>
Step 3: For each angle of incidence measured in air &phi; (0 &lt; &phi; &lt; 90)
</p>
<table summary=\"summary\">
<tr>
<td> a. Compute the angle of incidence measured in glass &phi;'</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &phi;' = asin(sin&phi; &frasl;  n).
</p></td>
<td>(5)</td>
</tr>
<tr>
<td> b. Compute spectral reflectivities at surface</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&rho;<sub>1</sub>(&phi;)=[(n cos&phi; &minus; cos&phi;') &frasl;
(n cos&phi; + cos&phi;')] <sup>2</sup>,
</p></td>
<td>(6)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&rho;<sub>2</sub>(&phi;)=[(n cos&phi;' &minus; cos&phi;) &frasl;
(n cos&phi;' + cos&phi;)] <sup>2</sup>.
</p></td>
<td>(7)</td>
</tr>
<tr>
<td>c. Compute spectral tansmissivities at surface</td>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&tau;<sub>1</sub>(&phi;)= 1 &minus; &rho;<sub>1</sub>(&phi;),
</p></td>
<td>(8)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&tau;<sub>2</sub>(&phi;)= 1 &minus; &rho;<sub>2</sub>(&phi;).
</p></td>
<td>(9)</td>
</tr>
<tr>
<td>d. Compute spectral tansmittance of the glass</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T<sub>1</sub>(&phi;)= &tau;<sub>1</sub>(&phi;)<sup>2</sup> exp(-&alpha; d/cos&phi;') &frasl;
(1 &minus; &rho;<sub>1</sub>(&phi;)<sup>2</sup> exp(-2&alpha; d/cos&phi;')),
</p></td>
<td>(10)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T<sub>2</sub>(&phi;)= &tau;<sub>2</sub>(&phi;)<sup>2</sup> exp(-&alpha; d/cos&phi;') &frasl;
(1 &minus; &rho;<sub>2</sub>(&phi;)<sup>2</sup> exp(-2&alpha; d/cos&phi;')),
</p></td>
<td>(11)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T(&phi;)= (T<sub>1</sub>(&phi;) + T<sub>2</sub>(&phi;)) / 2.
</p></td>
<td>(12)</td>
</tr>
<tr>
<td>e. Compute spectral reflectance of the glass</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R<sub>1</sub>(&phi;)= &rho;<sub>1</sub>(&phi;)(1+ T<sub>1</sub>(&phi;)exp(-&alpha; d/cos&phi;')),
</p></td>
<td>(13)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R<sub>2</sub>(&phi;)= &rho;<sub>2</sub>(&phi;)(1+ T<sub>2</sub>(&phi;)exp(-&alpha; d/cos&phi;')),
</p></td>
<td>(14)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R(&phi;)= (R<sub>1</sub>(&phi;) + R<sub>2</sub>(&phi;)) / 2.
</p></td>
<td>(15)</td>
</tr>
</table>
<p>
Step 4: T(90)=0, R(90)=1. (16)

<h4>Limitations</h4>
WINDOW program calculates the angular property for each wave length based on the spectral data.
It uses different <code>R<sub>&lambda;</sub>(0)</code> and <code>T<sub>&lambda;</sub>(0)</code> for each wave length.
Then it integrates the properties over the wave length to get averaged property of <code>R(0)</code> and <code>T(0)</code>.
<p>
The current window model in the Buildings library uses averaged <code>R(0)</code> and <code>T(0)</code> directly.
It can generate the same results as WINDOW for a single pane window and multi-pane window with the same glass.
However, the results may be slightly different for multi-pane window with different glasses.
The reason is that different glasses may have different angular properties for the same wave length.
To precisely calculate the angular properties of the entire window system, one has to calculate the property for each wave length and integrate them as WINDOW does.
For more details, see the paper of Nouidui et al. (2012).

<h4>References</h4>
<p>
Finlayson, E. U., D. K. Arasteh, C. Huizenga, M.D. Rubin, M.S. Reily. 1993. WINDOW 4.0: Documentation of Calcualtion Precedures. <i>Technical Report LBL-33943</i>. Lawrence Berkeley National Laboratory.
</p>
<p>
Fuler, Reto A., Angular dependence of optical properties of homogeneous glasses, <i>ASHRAE Transaction</i>, V.97 Part 2, 1991.
</p>
<p>
Thierry Stephane Nouidui, Michael Wetter, and Wangda Zuo.
<a href=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/2012-simBuild-windowValidation.pdf\">
Validation of the window model of the Modelica Buildings library.</a>
<i>Proc. of the 5th SimBuild Conference</i>, Madison, WI, USA, August 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed use of <code>NDIR</code> for OpenModelica.
</li>
<li>
August 06, 2012, by Wangda Zuo:<br/>
Improved the documentation for implementation and added comments for model limitations.
</li>
<li>
December 09, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

        end glassPropertyUncoated;

        function glassTRExteriorIrradiationNoShading
          "Transmittance and reflectance of glass panes for exterior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM, NSta] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM, NSta](each min=0, each max=1)
            "Transmittance and reflectance of each glass pane for exterior irradiation without shading";

      protected
          Real aij "Temporary variable";
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          // Property for single pane of glass or the first pane of multiple panes glass
          for iD in 1:HEM loop
            for k in TRA:Rb loop
              traRef[k, 1, 1, iD, 1:NSta] := layer[k, 1, iD, 1:NSta]
                "Equation (A.4.71)";
            end for;
          end for;

          // Property for multiple panes glass
          if N > 1 then
            for iD in 1:HEM loop
              for i in 1:N - 1 loop
                for j in i + 1:N loop
                  for k in TRA:Rb loop
                    traRef[k, j, j, iD, 1:NSta] := layer[k, j, iD, 1:NSta];
                  end for;

                  for iSta in 1:NSta loop
                    aij := 1 - traRef[Ra, j, j, iD, iSta]*traRef[Rb, j - 1, i, iD, iSta]
                      "Equation (A.4.77)";
                    assert(aij > -SMALL,
                      "Glass transmittance and reflectance data was not correct.\n");
                    if aij < SMALL then
                      traRef[TRA, i, j, iD, iSta] := 0;
                      traRef[Ra, i, j, iD, iSta] := 1;
                      traRef[Rb, j, i, iD, iSta] := 1;
                    else
                      aij := 1/aij;
                      traRef[TRA, i, j, iD, iSta] := aij*traRef[TRA, i, j - 1, iD, iSta]*traRef[TRA,
                        j, j, iD, iSta] "Equation (A.4.78a)";
                      traRef[Ra, i, j, iD, iSta] := traRef[Ra, i, j - 1, iD, iSta] + aij*traRef[TRA,
                        i, j - 1, iD, iSta]*traRef[TRA, i, j - 1, iD, iSta]*traRef[Ra, j, j, iD, iSta]
                        "Equation (A.4.78b)";
                      traRef[Rb, j, i, iD, iSta] := traRef[Rb, j, j, iD, iSta] + aij*traRef[TRA, j, j,
                        iD, iSta]*traRef[TRA, j, j, iD, iSta]*traRef[Rb, j - 1, i, iD, iSta]
                        "Equation (A.4.78c)";
                    end if;
                  end for; // iSta in 1:NSta
                end for;
              end for;
            end for;
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for exteior irradiation without shading.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassTRExteriorIrradiationNoShading;

        function glassTRInteriorIrradiationNoShading
          "Transmittance and reflectance of each glass pane for interior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM, NSta] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM, NSta](each min=0, each max=1)
            "Glass transmittance, front and back reflectance";

      protected
          Real dLayer[3, N, HEM, NSta]
            "Dummy glass property with Pane 1 facing inside and Pane N facing outside";
          Real dTraRef[3, N, N, HEM, NSta]
            "Dummy transmittance and reflectance for exterior irradiation";

        algorithm
          // Copy the dummy glass property
          for iD in 1:HEM loop
            for j in 1:N loop
              dLayer[TRA, j, iD, 1:NSta] := layer[TRA, N + 1 - j, iD, 1:NSta];
              dLayer[Ra, j, iD, 1:NSta] := layer[Rb, N + 1 - j, iD, 1:NSta]
                "swap the front and back reflectance";
              dLayer[Rb, j, iD, 1:NSta] := layer[Ra, N + 1 - j, iD, 1:NSta]
                "swap the front and back reflectance";
            end for;
          end for;

          // Calculate transmittance and reflectance of dummy glass for exterior irradiation without shading
          dTraRef :=
            Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
            N=N,
            NSta=NSta,
            HEM=HEM,
            layer=dLayer);

          // Convert the dummy data to real glass
          for iD in 1:HEM loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                traRef[TRA, N + 1 - i, N + 1 - j, iD, 1:NSta] := dTraRef[TRA, i, j, iD, 1:NSta];
                traRef[Ra, N + 1 - i, N + 1 - j, iD, 1:NSta] := dTraRef[Rb, i, j, iD, 1:NSta]
                  "swap the front and back reflectance";
                traRef[Rb, N + 1 - i, N + 1 - j, iD, 1:NSta] := dTraRef[Ra, i, j, iD, 1:NSta]
                  "swap the front and back reflectance";
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for interior irradiation without shading.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassTRInteriorIrradiationNoShading;

        function winTExteriorIrradiationInteriorShading
          "Angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traExtIrrIntSha[HEM, NSta](each min=0, each max=1)
            "Angular and hemispherical transmittance of a window system (glass and shading device) forh exterior irradiation with interior shading";

        algorithm
          for iSta in 1:NSta loop
            for iD in 1:HEM loop
              traExtIrrIntSha[iD, iSta] := traRef[TRA, 1, N, iD, iSta]*traIntShaDev/(1 - refIntShaDev
                *traRef[Rb, N, 1, HEM, iSta]) "Equation (A.4.92)";
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiationInteriorShading;

        function winTExteriorIrradiatrionExteriorShading
          "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traExtIrrExtSha[HEM, NSta](each min=0, each max=1)
            "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading";

      protected
          Real c;

        algorithm
          for iSta in 1:NSta loop
            for iD in 1:HEM loop
              c := traExtShaDev*(1 + traRef[Ra, 1, N, iD, iSta]*refExtShaDev/
                   (1 - traRef[Ra, 1, N, HEM, iSta]*refExtShaDev)) "Equation (A.4.88a)";
              traExtIrrExtSha[iD, iSta] := c*traRef[TRA, 1, N, iD, iSta]
                "Equation (A.4.88c)";
             end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiatrionExteriorShading;

        function winTRInteriorIrradiationExteriorShading
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traRefIntIrrExtSha[3, NSta](each min=0, each max=1)
            "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading";
        algorithm
          for iSta in 1:NSta loop
            traRefIntIrrExtSha[TRA, iSta] := traRef[TRA, N, 1, HEM, iSta]*traExtShaDev/(1 -
              refExtShaDev*traRef[Ra, 1, N, HEM, iSta]) "Equation (A.4.95)";
            traRefIntIrrExtSha[Rb, iSta] := traRef[Rb, N, 1, HEM, iSta] + traRef[TRA, N, 1, HEM, iSta]*
              refExtShaDev*traRef[1, 1, N, HEM, iSta]/(1 - traRef[Ra, 1, N, HEM, iSta]*refExtShaDev)
              "Equation (A.4.97)";
            traRefIntIrrExtSha[Ra, iSta] := 0 "Dummy value";
          end for;
          annotation (Documentation(info="<html>
This function computes hemispherical transmittance and back reflectance of a window for interior irradiation with exterior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
The variables are<br/>
<pre>
traRefIntIrrExtSha[1]: Transmittance;
traRefIntIrrExtSha[2]: Back reflectance;
traRefIntIrrExtSha[3]: Dummy value
</pre>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationExteriorShading;

        function winTRInteriorIrradiationInteriorShading
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traRefIntIrrIntSha[3, NSta](each min=0, each max=1)
            "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading";

      protected
          Real rRho;
          Real rTau;
          Real c;

        algorithm
          for iSta in 1:NSta loop
            rRho:=traRef[Rb, N, 1, HEM, iSta]*refIntShaDev "Part of Equation (A.4.99)";
            rTau:=traRef[Rb, N, 1, HEM, iSta]*traIntShaDev "Part of Equation (A.4.105)";
            c:=traIntShaDev*(1 + rRho/(1 - rRho)) "Equation (A.4.99)";

            traRefIntIrrIntSha[TRA, iSta] := c*traRef[TRA, N, 1, HEM, iSta]
              "Equation (A.4.100b)";
            traRefIntIrrIntSha[Rb, iSta] := refIntShaDev + c*rTau "Equation (A.4.105)";
            traRefIntIrrIntSha[Ra, iSta] := 0 "Dummy value";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationInteriorShading;

        package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Windows.Functions"
          extends Modelica.Icons.BasesPackage;

          partial function partialGlassRadiation
            "Partial function for glass radiation property"

            input Integer N(min=1) "Number of glass layers";
            input Integer NSta(min=1)
              "Number of window states for electrochromic windows (set to 1 for regular windows)";

            extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;
            annotation (preferredView="info", Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants.
</html>",           revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
December 19 2011, by Wangda Zuo:<br/>
Separate part of definitions to particalSingleGlassRadiation.mo.
</li>
</ul>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialGlassRadiation;

          partial function partialSingleGlassRadiation
            "Partial function for single glass radiation property"

            input Integer HEM "Index of hemispherical integration";
        protected
            constant Integer TRA=1 "Index of Transmittance";
            constant Integer Ra=2 "Index of front reflectance (outside facing side)";
            constant Integer Rb=3 "Index of back reflectance (room-facing side)";

            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic constants.
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialSingleGlassRadiation;

          partial function partialWindowRadiation
            "Partial function for window radiation property"
            input Real traRef[3, N, N, HEM, NSta](each min=0, each max=0)
              "Transmittance and reflectance with exterior irradiation and no shading";
            extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants.
</html>",           revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowRadiation;

          partial function partialWindowShadingRadiation
            "Partial function for window radiation property with shading device"
            input Real traRef[3, N, N, HEM, NSta](each min=0, each max=1)
              "Transmittance and reflectance with exterior irradiation and no shading";
            input Real traRefShaDev[2, 2](each min=0, each max=1)
              "Transmittance and reflectance of shading device";
            extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
        protected
            Real traExtShaDev=traRefShaDev[1, 1]
              "Transmittance of the exterior shading device";
            Real refExtShaDev=traRefShaDev[2, 1]
              "Reflectance of the exterior shading device";
            Real traIntShaDev=traRefShaDev[1, 2]
              "Transmittance of the interior shading device";
            Real refIntShaDev=traRefShaDev[2, 2]
              "Reflectance of the interior shading device";
            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and parameters.
</html>",           revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected wrong <code>max</code> value for <code>traRef</code> and
<code>traRefShaDev</code>.
</li>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowShadingRadiation;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows.Functions\">Buildings.HeatTransfer.Windows.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions that are used to compute
heat transfer in the window model.
</p>
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Windows"
        extends Modelica.Icons.BasesPackage;

        block AbsorbedRadiation "Absorbed radiation by window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput HRoo(
            quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow[NSta](
            each final quantity="Power",
            each final unit="W")
            "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,70},{120,90}}),
                iconTransformation(extent={{100,70},{120,90}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow[NSta](
            each final quantity="Power",
            each final unit="W")
            "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N, NSta](
            each quantity="Power",
            each final unit="W")
            "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,30},{120,50}}),
                iconTransformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N, NSta](
            each quantity="Power",
            each final unit="W")
            "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));

          output Modelica.SIunits.Power absRad[2, N + 2, NSta]
            "Absorbed interior and exterior radiation.
      (absRad[2,1,iSta]: exterior shading device,
      absRad[1,2 to N+1,iSta]: glass (unshaded part),
      absRad[2,2 to N+1,iSta]: glass (shaded part),
      absRad[2,N+2,iSta]: interior shading device)
      with iSta being the state of the (electrochromic) window";

      protected
          final parameter Integer NDIR=radDat.NDIR "Number of incident angles";
          final parameter Integer HEM=radDat.HEM "Index of hemispherical integration";
          constant Integer NoShade=1 "Index for data for no shade";
          constant Integer Shade=2 "Index for data with shade";
          final parameter Real coeAbsEx[2, radDat.N, radDat.HEM + 2, NSta](each fixed=false);
          final parameter Real coeRefExtPan1[radDat.HEM + 2, NSta](each fixed=false)
            "Reflectivity of pane 1";
          final parameter Real coeAbsIn[2, radDat.N, NSta](each fixed=false);
          final parameter Real coeAbsDevExtIrrIntSha[radDat.HEM + 2, NSta](each fixed=false)
            "Absorptivity of interior shading device for exterior radiation";
          final parameter Real coeAbsDevExtIrrExtSha=1 - radDat.traRefShaDev[1, 1] -
              radDat.traRefShaDev[2, 1]
            "Absorptivity of exterior shading device for exterior radiation";
          final parameter Real coeAbsDevIntIrrIntSha[NSta]=radDat.devAbsIntIrrIntSha
            "Absorptivity of interior shading device for interior radiation";
          final parameter Real coeAbsDevIntIrrExtSha[NSta]=
            {1 - radDat.winTraRefIntIrrExtSha[1, iSta]
               - radDat.winTraRefIntIrrExtSha[2, iSta] for iSta in 1:NSta}
            "Absorptivity of exterior shading device for interior radiation";

          Real x "Intermediate variable, x=(index-1)*incAng/(0.5pi)+2, 0<=x<=NDIR";

          Real incAng2;

        initial equation
          //**************************************************************
          // Assign coefficients.
          // Data dimension changes from Original ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for i in 1:N loop
            coeAbsIn[NoShade, i, 1:NSta] =  radDat.absIntIrrNoSha[i, 1:NSta];
            // Properties for glass with shading
            if haveInteriorShade then
              coeAbsIn[Shade, i, 1:NSta] =  radDat.absIntIrrIntSha[i, 1:NSta];
            elseif haveExteriorShade then
              coeAbsIn[Shade, i, 1:NSta] =  radDat.absIntIrrExtSha[i, 1:NSta];
            else
              // No Shade
              coeAbsIn[Shade, i, 1:NSta] =  zeros(NSta);
            end if;

            for j in 1:HEM loop
              // Properties for glass without shading
              coeAbsEx[NoShade, i, j + 1, 1:NSta] =  radDat.absExtIrrNoSha[i, j, 1:NSta];
              // Properties for glass with shading
              if haveInteriorShade then
                coeAbsEx[Shade, i, j + 1, 1:NSta] =  radDat.absExtIrrIntSha[i, j, 1:NSta];
              elseif haveExteriorShade then
                coeAbsEx[Shade, i, j + 1, 1:NSta] =  radDat.absExtIrrExtSha[i, j, 1:NSta];
              else
                // No Shade
                coeAbsEx[Shade, i, j + 1, 1:NSta] =  zeros(NSta);
              end if;
            end for;
            // Dummy variables at 1 and HEM+2
            for k in NoShade:Shade loop
              coeAbsEx[k, i, 1, 1:NSta] =  coeAbsEx[k, i, 2, 1:NSta];
              coeAbsEx[k, i, HEM + 2, 1:NSta] =  coeAbsEx[k, i, HEM + 1, 1:NSta];
            end for;
          end for;

          // Glass Pane 1: Reflectivity
          for j in 1:HEM loop
            coeRefExtPan1[j + 1, 1:NSta] =  radDat.traRef[2, 1, N, j, 1:NSta];
          end for;

          // Interior shades
          for j in 1:HEM loop
            coeAbsDevExtIrrIntSha[j + 1, 1:NSta] =  radDat.devAbsExtIrrIntShaDev[j, 1:NSta];
          end for;

          // Dummy variables at 1 and HEM+2
          coeRefExtPan1[1, 1:NSta] =  coeRefExtPan1[2, 1:NSta];
          coeRefExtPan1[HEM + 2, 1:NSta] =  coeRefExtPan1[HEM + 1, 1:NSta];
          coeAbsDevExtIrrIntSha[1, 1:NSta] =  coeAbsDevExtIrrIntSha[2, 1:NSta];
          coeAbsDevExtIrrIntSha[HEM + 2, 1:NSta] =  coeAbsDevExtIrrIntSha[HEM + 1, 1:NSta];

        algorithm
          absRad[NoShade, 1,     1:NSta] := zeros(NSta);
          absRad[NoShade, N + 2, 1:NSta] := zeros(NSta);
          absRad[Shade,   1,     1:NSta] := zeros(NSta);
          absRad[Shade,   N + 2, 1:NSta] := zeros(NSta);

          // **************************************************************
          // Glass: absorbed diffusive radiation from exterior and interior sources
          // **************************************************************
          for i in 1:N loop
            absRad[NoShade, i + 1, 1:NSta] := AWin*(1 - uSha_internal)*
               (HDif*coeAbsEx[NoShade, i, HEM + 1, 1:NSta] + HRoo*coeAbsIn[NoShade, i, 1:NSta]);
            absRad[Shade, i + 1, 1:NSta] := AWin*uSha_internal*(HDif*coeAbsEx[Shade, i, HEM + 1, 1:NSta]
               + HRoo*coeAbsIn[Shade, i, 1:NSta]);
          end for;

          // **************************************************************
          // Shading device: absorbed radiation from exterior source
          // **************************************************************
          // Exterior Shading Device:
          // direct radiation: 1. direct absorption;
          // diffusive radiation: 1. direct absorption 2. absorption from back reflection
          for iSta in 1:NSta loop
            if haveExteriorShade then
              absRad[Shade, 1, iSta] := AWin*uSha_internal*coeAbsDevExtIrrExtSha*
                (HDif + HDir + HDif*radDat.traRefShaDev[1, 1]*radDat.traRef[2, 1, N, HEM, iSta]);
            // Interior Shading Device: diffusive radiation from both interior and exterior
             elseif haveInteriorShade then
             absRad[Shade, N + 2, iSta] := AWin*uSha_internal*
                (HDif*radDat.devAbsExtIrrIntShaDev[HEM, iSta] + HRoo*coeAbsDevIntIrrIntSha[iSta]);
            end if;
          end for;

          // **************************************************************
          // Glass, Device: add absorbed direct radiation from exterior sources
          // **************************************************************
          // Use min() instead of if() to avoid event
          incAng2 := min(incAng, 0.5*Modelica.Constants.pi);

          x := 2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi + 2
            "x=(index-1)*incAng/(0.5pi)+2, 0<=x<=NDIR";

          for i in 1:N loop
            // Glass without shading: Add absorbed direct radiation
            for iSta in 1:NSta loop
              absRad[NoShade, i + 1, iSta] := absRad[NoShade, i + 1, iSta] +
                AWin*HDir*(1 - uSha_internal)*
                  Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
                  {coeAbsEx[NoShade, i, k, iSta] for k in 1:(HEM + 2)}, x);

              // Glass with shading: add absorbed direct radiation
              absRad[Shade, i + 1, iSta] := absRad[Shade, i + 1, iSta]
                                         + AWin*HDir*uSha_internal
                *Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
                   {coeAbsEx[Shade, i, k, iSta] for k in 1:(HEM + 2)}, x);
            end for;
          end for;

          // Interior shading device: add absorbed direct radiation
          if haveInteriorShade then
            for iSta in 1:NSta loop
              absRad[Shade, N + 2, iSta] := absRad[Shade, N + 2, iSta]
                                          + AWin*HDir*uSha_internal
                  *Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
                      {coeAbsDevExtIrrIntSha[k, iSta] for k in 1:(HEM + 2)}, x);
            end for;
          end if;

          // Exterior shading device: add absorbed reflection of direct radiation from exterior source
          if haveExteriorShade then
            for iSta in 1:NSta loop
              absRad[Shade, 1, iSta] := absRad[Shade, 1, iSta]
                                      + AWin*HDir*uSha_internal*coeAbsDevExtIrrExtSha
                                      *Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
                  {coeRefExtPan1[k, iSta] for k in 1:(HEM + 2)}, x);
            end for;
          end if;

          // Assign quantities to output connectors
          QAbsExtSha_flow[1:NSta]    := absRad[2, 1,       1:NSta];
          QAbsIntSha_flow[1:NSta]    := absRad[2, N + 2,   1:NSta];
          QAbsGlaUns_flow[:, 1:NSta] := absRad[1, 2:N + 1, 1:NSta];
          QAbsGlaSha_flow[:, 1:NSta] := absRad[2, 2:N + 1, 1:NSta];
          annotation (
            Documentation(info="<html>
<p>
The model calculates absorbed solar radiation on the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The absorbed radiation by exterior shades includes:
</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
<p>
The output is <code>absRad[2, 1]</code>
</p>

<p>
The absorbed radiation by interior shades includes:
</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
<p>
The output is <code>absRad[2, N+2]</code>
</p>

<p>
The absorbed radiation by glass includes:
</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angular part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
<p>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code>
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
October 22, 2016, by Michael Wetter:<br/>
Added range for loop variable for JModelica.<br/>
Made units of <code>HRoo</code> final.<br/>
Removed unused protected constants <code>k</code>,
<code>Interior</code> and <code>Exterior</code>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
January 21, 2015, by Michael Wetter:<br/>
Changed <code>initial algorithm</code> to
<code>initial equation</code> section and removed
dublicate assignments.
This is required for OpenModelica.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Added missing <code>each</code> keywords in parameter declarations.
</li>
<li>
March 4, 2011, by Wangda Zuo:<br/>
Removed the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Separate transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{26,86},{102,74}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-101,-73},{-54,-82}},
                  lineColor={0,0,127},
                  textString="HRoo"),
                Text(
                  extent={{24,-68},{102,-80}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{34,46},{94,32}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{30,-32},{104,-44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha")}));
        end AbsorbedRadiation;

        model CenterOfGlass "Model for center of glass of a window construction"
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt (only 90 degrees=vertical is implemented)";

          parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
            "Glazing system"
            annotation (HideResult=true, choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          parameter Boolean linearize=false "Set to true to linearize emissive power"
            annotation(Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer[nGlaLay] glass(
            each final A=A,
            final x=glaSys.glass.x,
            final k=glaSys.glass.k,
            final absIR_a=glaSys.glass.absIR_a,
            final absIR_b=glaSys.glass.absIR_b,
            final tauIR=glaSys.glass.tauIR,
            each final linearize=linearize,
            each final homotopyInitialization=homotopyInitialization)
            "Window glass layer"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          Buildings.HeatTransfer.Windows.BaseClasses.GasConvection gas[nGlaLay-1](
            each final A=A,
            final gas=glaSys.gas,
            each final til=til,
            each linearize=linearize,
            each final homotopyInitialization=homotopyInitialization)
            "Window gas layer"
            annotation (Placement(transformation(extent={{20,10},{40,30}})));

          // Note that the interior shade is flipped horizontally. Hence, surfaces a and b are exchanged,
          // i.e., surface a faces the room, while surface b faces the window

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glass_a
            "Heat port connected to the outside facing surface of the glass"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass_b
            "Heat port connected to the room-facing surface of the glass"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          Modelica.Blocks.Interfaces.RealInput QAbs_flow[nGlaLay](
            each unit="W",
            each quantity = "Power") "Solar radiation absorbed by glass"
                                                annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
      protected
          final parameter Integer nGlaLay = size(glaSys.glass, 1)
            "Number of glass layers";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          for i in 1:nGlaLay-1 loop
            connect(glass[i].port_b, gas[i].port_a)                        annotation (Line(
              points={{5.55112e-16,6.10623e-16},{0,0},{10,0},{10,20},{20,20}},
              color={191,0,0},
              smooth=Smooth.None));
            connect(gas[i].port_b, glass[i+1].port_a)                         annotation (Line(
              points={{40,20},{52,20},{52,36},{-40,36},{-40,0},{-20,0},{-20,6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

            connect(glass[i].JOut_b, glass[i+1].JIn_a)
            annotation (Line(
              points={{1,4},{8,4},{8,-24},{-30,-24},{-30,4},{-21,4}},
              color={0,127,0},
              smooth=Smooth.None));
            connect(glass[i].JIn_b, glass[i+1].JOut_a)
            annotation (Line(
              points={{1,-4},{6,-4},{6,-20},{-28,-20},{-28,-4},{-21,-4}},
              color={0,0,0},
              smooth=Smooth.None));

            connect(u, gas[i].u)   annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-8,44},{-8,28},{19,28}},
              color={0,0,127},
              smooth=Smooth.None));

          end for;

          for i in 1:nGlaLay loop
            connect(u, glass[i].u)  annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-48,44},{-48,8},{-21,8}},
              color={0,0,127},
              smooth=Smooth.None));
          end for;

          connect(glass_b, glass[nGlaLay].port_b) annotation (Line(
              points={{100,5.55112e-16},{100,5.55112e-16},{0,0}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(glass_a, glass[1].port_a) annotation (Line(
              points={{-100,5.55112e-16},{-71,5.55112e-16},{-71,6.10623e-16},{-20,
                  6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(JIn_a, glass[1].JIn_a) annotation (Line(
              points={{-110,40},{-60,40},{-60,4},{-21,4}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(glass[1].JOut_a, JOut_a) annotation (Line(
              points={{-21,-4},{-60,-4},{-60,-40},{-110,-40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(glass[nGlaLay].JOut_b, JOut_b) annotation (Line(
              points={{1,4},{80,4},{80,40},{110,40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(JIn_b, glass[nGlaLay].JIn_b) annotation (Line(
              points={{110,-40},{80,-40},{80,-4},{1,-4}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(glass.QAbs_flow, QAbs_flow) annotation (Line(
              points={{-10,-11},{-10,-60},{1.11022e-15,-60},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),       graphics={Text(
                  extent={{-82,100},{-32,86}},
                  lineColor={0,0,255},
                  textString="outside"),
                                       Ellipse(
                  extent={{-108,110},{-88,90}},
                  lineColor={255,255,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Sphere),
                                                 Text(
                  extent={{44,98},{94,84}},
                  lineColor={0,0,255},
                  textString="room-side")}),      Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-56,50},{-44,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-8,50},{4,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{42,50},{54,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),       Text(
                  extent={{-90,86},{-78,74}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
This is a model for the heat transfer through the center of the glass.
The properties of the glazing system is defined by the parameter
<code>glaSys</code>.
The model contains these main component models:
<ul>
<li>
an array of models <code>glass</code> for the heat conduction and the
infrared radiative heat balance of the glass layers.
There can be an arbitrary number of glass layers, which are all modeled using
instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer\">
Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer</a>.
</li>
<li>
an array of models <code>gas</code> for the gas layers. There is one model of a
gas layer between each window panes. The gas layers are modeled using instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GasConvection\">
Buildings.HeatTransfer.Windows.BaseClasses.GasConvection</a>.
</li>
</ul>
Note that this model does <em>not</em> compute heat conduction through the frame and
it does <em>not</em> model the convective heat transfer at the exterior and interior
surface. These models are implemented in
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>,
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>, and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransferConvective\">
Buildings.HeatTransfer.Windows.InteriorHeatTransferConvective</a>.
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed assignment of <code>nLay</code> to avoid a translation error
in OpenModelica.
</li>
<li>
July 25, 2014, by Michael Wetter:<br/>
Propagated parameter <code>homotopyInitialization</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 9 2012, by Wangda Zuo:<br/>
Fixed a bug in the parameter assignment of the instance <code>glass</code>.
Previously, the infrared emissivity of surface a was assigned to the surface b.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end CenterOfGlass;

        model ExteriorConvectionCoefficient
          "Model for the heat transfer coefficient at the outside of the window"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
            "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        equation
          GCon = A*(4+4*Buildings.Utilities.Math.Functions.smoothMax(v, -v, 0.1));
          annotation ( Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="v"),
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the outside of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4+4 v
</p>
where <i>v</i> is the wind speed in <i>m/s</i> and
<i>h</i> is the convective heat transfer coefficient in <i>W/(m2*K)</i>.
<br/>
<h4>References</h4>

TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ExteriorConvectionCoefficient;

        model GasConvection
          "Model for heat convection through gas in a window assembly"
          extends Modelica.Thermal.HeatTransfer.Interfaces.Element1D(
             port_a(T(start=293.15)),
             port_b(T(start=293.15)),
             dT(start=0));
          extends Buildings.BaseClasses.BaseIcon;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Area h(min=0) = sqrt(A) "Height of window";

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt (only 0, 90 and 180 degrees are implemented)";
          parameter Boolean linearize=false "Set to true to linearize emissive power";

          parameter Modelica.SIunits.Temperature T0 = 293.15
            "Temperature used to compute thermophysical properties";

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0, start=3)
            "Convective heat transfer coefficient";
          Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
          Real Nu(min=0) "Nusselt number";
          Real Ra(min=0) "Rayleigh number";

      protected
          Modelica.SIunits.Temperature T_a
            "Temperature used for thermophysical properties at port_a";
          Modelica.SIunits.Temperature T_b
            "Temperature used for thermophysical properties at port_b";
          Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";

          Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          Real deltaRa(min=0.01) = 100
            "Small value for Rayleigh number, used for smoothing";
          final parameter Real cosTil=Modelica.Math.cos(til) "Cosine of window tilt";
          final parameter Real sinTil=Modelica.Math.sin(til) "Sine of window tilt";
          final parameter Boolean isVertical = abs(cosTil) < 10E-10
            "Flag, true if the window is in a wall";
          final parameter Boolean isHorizontal = abs(sinTil) < 10E-10
            "Flag, true if the window is horizontal";
          // Quantities that are only used in linearized model

          parameter Modelica.SIunits.CoefficientOfHeatTransfer hCon0(fixed=false)
            "Convective heat transfer coefficient";
          parameter Real Nu0(fixed=false, min=0) "Nusselt number";
          parameter Real Ra0(fixed=false, min=0) "Rayleigh number";

        initial equation
          // This assertion is required to ensure that the default value of
          // in Buildings.HeatTransfer.Data.Gases.Generic is overwritten.
          assert(gas.x > 0, "The gas thickness must be non-negative. Obtained gas.x = " + String(gas.x) + ".
  Check the parameter for the gas thickness of the window model.");

          assert(isVertical or isHorizontal, "Only vertical and horizontal windows are implemented.");

          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

          // Computations that are used in the linearized model only
          Ra0 = Buildings.HeatTransfer.Convection.Functions.HeatFlux.rayleigh(
            x=gas.x,
            rho=Buildings.HeatTransfer.Data.Gases.density(gas=gas, T=T0),
            c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas=gas, T=T0),
            mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas=gas, T=T0),
            k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas=gas, T=T0),
            T_a=T0-5,
            T_b=T0+5,
            Ra_min=100);
          (Nu0, hCon0) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                    gas=gas, Ra=Ra0, T_m=T0, dT=10, h=h, deltaNu=deltaNu, deltaRa=deltaRa);

        equation
          T_a = port_a.T;
          T_b = port_b.T;
          T_m = (port_a.T+port_b.T)/2;
          if linearize then
            Ra=Ra0;
            Nu=Nu0;
            hCon=hCon0;
            q_flow = hCon0 * dT;
          else
            Ra = Buildings.HeatTransfer.Convection.Functions.HeatFlux.rayleigh(
              x=gas.x,
              rho=Buildings.HeatTransfer.Data.Gases.density(gas, T_m),
              c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas, T_m),
              mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas, T_m),
              k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m),
              T_a=T_a,
              T_b=T_b,
              Ra_min=100);
            if isVertical then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, h=h, deltaNu=deltaNu, deltaRa=deltaRa);
            elseif isHorizontal then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionHorizontalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, til=til, sinTil=sinTil, cosTil=cosTil,
                      h=h, deltaNu=deltaNu, deltaRa=deltaRa);

            else
               Nu = 0;
               hCon=0;
               q_flow=0;
            end if; // isVertical or isHorizontal
          end if; // linearize
          if homotopyInitialization then
            Q_flow = u*A*homotopy(actual=q_flow,
                                  simplified=hCon0*dT);
          else
            Q_flow = u*A*q_flow;
          end if;
          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
               graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,78},{-76,-80}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-51,42},{-21,20}},
                  lineColor={127,0,0},
                  textString="Q_flow"),
                Line(points={{-68,20},{68,20}}, color={191,0,0}),
                Line(points={{-68,-20},{68,-20}}, color={191,0,0}),
                Line(points={{-56,80},{-56,-80}}, color={0,127,255}),
                Line(points={{-16,80},{-16,-80}},
                                              color={0,127,255}),
                Line(points={{18,80},{18,-80}}, color={0,127,255}),
                Line(points={{54,80},{54,-80}}, color={0,127,255}),
                Line(points={{-56,-80},{-66,-60}}, color={0,127,255}),
                Line(points={{-56,-80},{-46,-60}}, color={0,127,255}),
                Line(points={{-16,-80},{-26,-60}},
                                                color={0,127,255}),
                Line(points={{-16,-80},{-6,-60}},
                                                color={0,127,255}),
                Line(points={{18,-80},{8,-60}},  color={0,127,255}),
                Line(points={{18,-80},{28,-60}}, color={0,127,255}),
                Line(points={{54,-80},{44,-60}}, color={0,127,255}),
                Line(points={{54,-80},{64,-60}}, color={0,127,255}),
                Line(points={{48,-30},{68,-20}}, color={191,0,0}),
                Line(points={{48,-10},{68,-20}}, color={191,0,0}),
                Line(points={{48,10},{68,20}}, color={191,0,0}),
                Line(points={{48,30},{68,20}}, color={191,0,0}),
                Rectangle(
                  extent={{76,80},{90,-78}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-100,86},{-86,76}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model for convective heat tranfer in a single layer of window gas.
Currently, the model only implements equations for vertical windows
and for horizontal windows.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
<p>
To use this model, set the parameter <code>til</code>
to a value defined in
<a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>.
</p>
<br/>

<p>
If the parameter <code>linearize</code> is set to <code>true</code>,
then all equations are linearized.
</p>
<h4>References</h4>

TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Added assertion as the gas layer is now by
default assigned a dummy layer with negative thickness.
This has been done to avoid a translation error
in OpenModelica.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Removed duplicate <code>initial equation</code> section.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GasConvection;

        model GlassLayer "Model for a glass layer of a window assembly"
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.ParametersTwoSurfaces(
            final rhoIR_a=1-absIR_a-tauIR,
            final rhoIR_b=1-absIR_b-tauIR);

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.Length x "Material thickness";

          parameter Modelica.SIunits.ThermalConductivity k "Thermal conductivity";

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a(T(start=293.15))
            "Heat port at surface a"
            annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b(T(start=293.15))
            "Heat port at surface b"
            annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
          Modelica.Blocks.Interfaces.RealInput QAbs_flow(unit="W", quantity="Power")
            "Solar radiation absorbed by glass" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));

      protected
         Real T4_a(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
            "4th power of temperature at surface a";
         Real T4_b(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
            "4th power of temperature at surface b";
         Modelica.SIunits.HeatFlowRate E_a(min=0, nominal=1E2)
            "Emissive power of surface a";
         Modelica.SIunits.HeatFlowRate E_b(min=0, nominal=1E2)
            "Emissive power of surface b";
         final parameter Modelica.SIunits.ThermalResistance R = x/2/k/A
            "Thermal resistance from surface of glass to center of glass";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          // Heat balance of surface node
          // These equations are from Window 6 Technical report, (2.1-14) to (2.1-17)
          0 = port_a.Q_flow + port_b.Q_flow + QAbs_flow + JIn_a  + JIn_b - JOut_a - JOut_b;
          u * (port_b.T-port_a.T) = 2*R * (-port_a.Q_flow-QAbs_flow/2-JIn_a+JOut_a + tauIR * (JIn_a - JIn_b));
          // Radiosity balance
          if linearize then
            T4_a = 4*T03*port_a.T - 3*T04;
            T4_b = 4*T03*port_b.T - 3*T04;
          else
            if homotopyInitialization then
              T4_a = homotopy(actual=port_a.T^4, simplified=4*T03*port_a.T - 3*T04);
              T4_b = homotopy(actual=port_b.T^4, simplified=4*T03*port_b.T - 3*T04);
            else
              T4_a = port_a.T^4;
              T4_b = port_b.T^4;
            end if;
          end if;
          // Emissive power
          E_a = u * A * absIR_a * Modelica.Constants.sigma * T4_a;
          E_b = u * A * absIR_b * Modelica.Constants.sigma * T4_b;
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
          JOut_a = E_a + rhoIR_a * JIn_a + tauIR * JIn_b;
          JOut_b = E_b + rhoIR_b * JIn_b + tauIR * JIn_a;
          annotation (    Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-4,2},{4,-100}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{8,-70},{60,-98}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Text(
                  extent={{-96,88},{-64,70}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model of a single layer of window glass. The input port <code>QAbs_flow</code>
needs to be connected to the solar radiation that is absorbed
by the glass pane.
The model computes the heat conduction between the two glass surfaces.
The heat flow <code>QAbs_flow</code> is added at the center of the glass.
<br/>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
October 24, 2016, by Michael Wetter:<br/>
Removed declarations of <code>A</code>,
<code>absIR_a</code>,
<code>absIR_b</code> and
<code>tauIR</code>, which are already declared
in the base class.
</li>
<li>
December 8, 2014, by Michael Wetter:<br/>
Added term <code>tauIR * (JIn_a - JIn_b)</code>
to heat balance. This is to correct
issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/304\">#304</a>
that led to an error in the glass temperatures if the glass conductance
is very small.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Removed nominal value for heat ports as the default is already
<i>300</i> Kelvin.
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Changed type of <code>tauIR</code> from
<code>Modelica.SIunits.Emissivity</code> to
<code>Modelica.SIunits.TransmissionCoefficient</code>.
This avoids a type error in OpenModelica.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
March 20, 2012 by Wangda Zuo:<br/>
Fixed bug for heat flow reported by Pierre Tittelein and fixed bug for temperature linearization.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GlassLayer;

        model HeatCapacity
          extends Buildings.BaseClasses.BaseIcon;

          parameter Boolean haveShade
            "Parameter, equal to true if the window has a shade"
            annotation(Evaluate=true);

          parameter Modelica.SIunits.HeatCapacity C
            "Heat capacity of element (= cp*m)";

          Modelica.Blocks.Interfaces.RealInput ySha if
               haveShade
            "Control signal for shade"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          Modelica.Blocks.Interfaces.RealInput yCom if
             haveShade
          "Input 1-y"
          annotation (Placement(transformation(
                  extent={{-140,-60},{-100,-20}}),
                  iconTransformation(extent={{-140,-60},{-100,-20}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portUns
            "Heat port to unshaded part of the window"
             annotation (
              Placement(transformation(extent={{95,-45},{105,-35}}),
                iconTransformation(extent={{95,-45},{105,-35}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portSha(
            T = TSha,
            Q_flow = QSha_flow) if
               haveShade
            "Heat port to shaded part of the window"
           annotation (Placement(transformation(extent={{95,35},{105,45}}),
                iconTransformation(extent={{95,35},{105,45}})));

          Modelica.SIunits.Temperature TUns(
            start=293.15)
            "Temperature of unshaded part of window";

          Modelica.SIunits.Temperature TSha(
            start=293.15)
            "Temperature of unshaded part of window";

          Modelica.SIunits.TemperatureSlope der_TUns(start=0)
            "Time derivative of temperature (= der(T))";

          Modelica.SIunits.TemperatureSlope der_TSha(start=0)
            "Time derivative of temperature (= der(T))";

      protected
          final parameter Real CInv(unit="K/J") = 1/C
            "Inverse of heat capacity";

          Modelica.Blocks.Interfaces.RealInput ySha_internal
            "Internal connector";

          Modelica.Blocks.Interfaces.RealInput yCom_internal
            "Internal connector";

          Modelica.SIunits.HeatFlowRate QSha_flow
            "Heat flow rate for shaded part of the window";

        equation
          connect(ySha, ySha_internal);
          connect(yCom, yCom_internal);
          portUns.T = TUns;

          if haveShade then
            der_TUns = der(TUns);
            der_TSha = der(TSha);

            // Energy balance of window
            yCom_internal * der_TUns = CInv * portUns.Q_flow;
            ySha_internal * der_TSha = CInv * QSha_flow;
          else
            der_TUns = der(TUns);
            der_TSha = 0;

            der_TUns = portUns.Q_flow * CInv;
            TSha = 293.15;
            QSha_flow = 0;

            ySha_internal = 0;
            yCom_internal = 1;
          end if;

          annotation (Icon(graphics={
                Rectangle(
                  extent={{-20,60},{20,-60}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,45},{6,34}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  visible=haveShade,
                  fillPattern=FillPattern.Solid),
                Line(points={{0,40},{100,40}},
                     visible=haveShade,
                     color={255,0,0}),
                Text(
                  extent={{-94,64},{-60,22}},
                  lineColor={0,0,127},
                  textString="ySha"),
                Text(
                  extent={{-92,-16},{-58,-58}},
                  lineColor={0,0,127},
                  textString="yCom"),
                Ellipse(
                  extent={{-6,-35},{6,-46}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{100,-40},{0,-40}},
                     color={255,0,0}),
                Rectangle(
                  extent={{-52,76},{-48,4}},
                  fillColor={0,0,0},
                  visible=haveShade,
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-70,18},{-70,10},{-30,22},{-30,30},{-70,18}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  visible=haveShade,
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-70,38},{-70,30},{-30,42},{-30,50},{-70,38}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  visible=haveShade,
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-70,58},{-70,50},{-30,62},{-30,70},{-70,58}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  visible=haveShade,
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Heat capacitor in which the capacity is scaled based on the input signal <code>u</code>.
</p>
<p>
This model is similar to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.HeatCapacitor\">
Modelica.Thermal.HeatTransfer.Components.HeatCapacitor</a>.
However, it has, depending on the parameterization, either
one or two heat capacities. Depending on the input signal <code>ySha</code>,
the size of one of the capacity is decreased, and the size of the other capacity
is increased.
This model is used to add a state variable on the room-facing surface of a window.
The window implementation in the <code>Buildings</code> library is such that
there are two parts of a window, one for the unshaded part, and one for the
shaded part.
This model allows adding heat capacity to such a window with variable
areas, while conserving energy when one area shrinks and the other expands
accordingly.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 29, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HeatCapacity;

        model InteriorConvection
          "Model for a interior (room-side) convective heat transfer with variable surface area"
          extends
          Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Buildings.HeatTransfer.Types.InteriorConvection conMod=
            Buildings.HeatTransfer.Types.InteriorConvection.Fixed
            "Convective heat transfer model"
          annotation(Evaluate=true);

          parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3
            "Constant convection coefficient"
           annotation (Dialog(enable=(conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

          parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt"
            annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

      protected
          constant Modelica.SIunits.Temperature dT0 = 2
            "Initial temperature used in homotopy method";

          final parameter Real cosTil=Modelica.Math.cos(til) "Cosine of window tilt";
          final parameter Real sinTil=Modelica.Math.sin(til) "Sine of window tilt";
          final parameter Boolean isCeiling = abs(sinTil) < 10E-10 and cosTil > 0
            "Flag, true if the surface is a ceiling";
          final parameter Boolean isFloor = abs(sinTil) < 10E-10 and cosTil < 0
            "Flag, true if the surface is a floor";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          if (conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed) then
            q_flow = u*hFixed * dT;
          else
            // Even if hCon is a step function with a step at zero,
            // the product hCon*dT is differentiable at zero with
            // a continuous first derivative
            if homotopyInitialization then
              if isCeiling then
                 q_flow = u*homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT),
                              simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT0));
              elseif isFloor then
                 q_flow = u*homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT),
                              simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT0));
              else
                 q_flow = u*homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT),
                              simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT0));
              end if;
            else
              if isCeiling then
                 q_flow = u*Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT);
              elseif isFloor then
                 q_flow = u*Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT);
              else
                 q_flow = u*Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT);
              end if;
            end if;

          end if;

          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-35,42},{-5,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}),
            defaultComponentName="con",
            Documentation(info="<html>
<p>
This is a model for a convective heat transfer for interior, room-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>
<ul>
<li>If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Fixed</a></code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</li>
<li>
If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Temperature</a></code>, then
the convective heat tranfer coefficient is a function of the temperature difference.
The convective heat flux is computed using
<ul>
<li>
for floors the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor</a>
</li>
<li>
for ceilings the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling</a>
</li>
<li>
for walls the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall</a>
</li>
</ul>
</li>
</ul>
<p>
This model is identical to
<a href=\"modelica://Buildings.HeatTransfer.Convection.Interior\">
Buildings.HeatTransfer.Convection.Interior</a>
except that it has an input <code>u</code> that is used to scale the
heat transfer.
This can be used if the heat transfer area is variable.
An example usage is for a window with shade, in which
the surface area of a shaded part of a window changes depending on the shading
control signal.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
March 2, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end InteriorConvection;

        model InteriorConvectionCoefficient
          "Model for the heat transfer coefficient at the inside of the window"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
            "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          GCon = 4*A;
          annotation ( Icon(graphics={
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the room-facing surface of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4 W &frasl; (m<sup>2</sup> K).
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end InteriorConvectionCoefficient;

        block Overhang
          "For a window with an overhang, outputs the fraction of the area that is sun exposed"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.ThermalZones.Detailed.BaseClasses.Overhang;

          Modelica.Blocks.Interfaces.RealInput verAzi(
            quantity="Angle",
            unit="rad",
            displayUnit="deg")
            "Wall solar azimuth angle (angle between projection of sun's rays and normal to vertical surface)"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

           Modelica.Blocks.Interfaces.RealInput alt(
             quantity="Angle",
             unit="rad",
             displayUnit="deg") "Altitude angle"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of window area exposed to the sun"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Angle lat "Latitude";

          parameter Modelica.SIunits.Angle azi(displayUnit="deg")
            "Surface azimuth; azi= -90 degree East; azi= 0 degree South";

        // Window dimensions
          parameter Modelica.SIunits.Length hWin "Window height"
            annotation(Dialog(tab="General",group="Window"));
          parameter Modelica.SIunits.Length wWin "Window width"
            annotation(Dialog(tab="General",group="Window"));

          Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather data"
           annotation (Placement(transformation(extent={{-112,-10},{-92,10}})));

      protected
          constant Modelica.SIunits.Angle delSolAzi = 0.005
            "Half-width of transition interval between left and right formulation for overhang";

          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          parameter Modelica.SIunits.Length tmpH[4](each fixed=false)
            "Height rectangular sections used for superposition";
          Modelica.SIunits.Length w
            "Either wL or wR, depending on the sun relative to the wall azimuth";
          Modelica.SIunits.Length tmpW[4]
            "Width of rectangular sections used for superpositions";
          Modelica.SIunits.Length del_L = wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          Modelica.SIunits.Length x1
            "Horizontal distance between window side edge and shadow corner";
          Modelica.SIunits.Length x2[4]
            "Horizontal distance between window side edge and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length y1
            "Vertical distance between overhang and shadow lower edge";
          Modelica.SIunits.Length y2[4]
            "Window height (vertical distance corresponding to x2)";
          Real shdwTrnglRtio "Ratio of y1 and x1";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area calculated from equations";
          Modelica.SIunits.Area crShdArea "Final value for shaded area";
          Modelica.SIunits.Area crShdArea1
            "Corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2 "Corrected for the sun below horizon";

          Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth solAzi(lat=lat)
            "Solar azimuth"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

        initial equation
          assert(wL >= 0,  "Overhang must cover complete window
    Received overhang width on left hand side, wL = "         + String(wL));
          assert(wR >= 0,  "Overhang must cover complete window
    Received overhang width on right hand side, wR = "         + String(wR));

          for i in 1:4 loop
            tmpH[i] = gap + mod((i - 1), 2)*hWin;
          end for;

        equation
          // if dep=0, then the equation
          //   y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          // is singular. Hence, we treat this special case with an
          // if-then construct.
          // This also increases computing efficiency in
          // Buildings.HeatTransfer.Windows.FixedShade in case the window has no overhang.

          if haveOverhang then
            //Temporary height and widths are for the areas below the overhang
            //These areas are used in superposition
            w = Buildings.Utilities.Math.Functions.spliceFunction(
                    pos=wL,
                    neg=wR,
                    x=solAzi.solAzi-azi,
                    deltax=delSolAzi);
            tmpW[1] = w + wWin;
            tmpW[2] = w;
            tmpW[3] = w;
            tmpW[4] = w + wWin;
            y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
            x1 = dep*Modelica.Math.tan(verAzi);
            shdwTrnglRtio*x1 = y1;
            for i in 1:4 loop
              y2[i] = tmpH[i];
              // For the equation below, Dymola generated the following code in MixedAirFreeResponse.
              // This led to a division by zero as y1 crosses zero. The problem occurred in an
              // FMU simulation. Therefore, we guard against division by zero when computing
              // x2[i].
              //  roo.bouConExtWin.sha[1].ove.x2[1] := roo.bouConExtWin.sha[1].ove.x1*
              //  roo.bouConExtWin.sha[1].ove.tmpH[1]/roo.bouConExtWin.sha[1].ove.y1;
              // x2[i]*y1 = x1*tmpH[i];

              x2[i] = x1*tmpH[i]/Buildings.Utilities.Math.Functions.smoothMax(
                x1=y1, x2=1E-8*hWin, deltaX=1E-9*hWin);
              area[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y1,
                x2=y2[i],
                  deltaX=del_L)*tmpW[i] - (Buildings.Utilities.Math.Functions.smoothMin(
                y1,
                tmpH[i],
                del_L)*Buildings.Utilities.Math.Functions.smoothMin(
                x1=x2[i],
                x2=y1,
                deltaX=del_L)/2) + Buildings.Utilities.Math.Functions.smoothMax(
                x1=shdwTrnglRtio*(Buildings.Utilities.Math.Functions.smoothMin(
                  x1=x1,
                  x2=x2[i],
                  deltaX=del_L) - tmpW[i]),
                x2=0,
                deltaX=del_L)*Buildings.Utilities.Math.Functions.smoothMax(
                x1=(Buildings.Utilities.Math.Functions.smoothMin(
                  x1=x1,
                  x2=x2[i],
                  deltaX=del_L) - tmpW[i]),
                x2=0,
                deltaX=del_L)/2;
            end for;
            shdArea = area[4] + area[3] - area[2] - area[1];
          // correction case: Sun not in front of the wall
            crShdArea1 = Buildings.Utilities.Math.Functions.spliceFunction(
              pos=shdArea,
              neg=AWin,
              x=(Modelica.Constants.pi/2)-verAzi,
              deltax=0.01);
          // correction case: Sun not above horizon
            crShdArea2 = Buildings.Utilities.Math.Functions.spliceFunction(
              pos=shdArea,
              neg=AWin,
              x=alt,
              deltax=0.01);
            crShdArea=Buildings.Utilities.Math.Functions.smoothMax(x1=crShdArea1,
                                                                   x2=crShdArea2,
                                                                   deltaX=0.01);
            fraSun = Buildings.Utilities.Math.Functions.smoothMin(
                x1=Buildings.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),
                x2=1.0,
                deltaX=0.01);
          else
            w = 0;
            tmpW=fill(0.0, 4);
            y1 = 0;
            x1 = 0;
            shdwTrnglRtio = 0;
            for i in 1:4 loop
              y2[i] = 0;
              x2[i] = 0;
              area[i] = 0;
            end for;
            shdArea = 0;
            crShdArea1 = 0;
            crShdArea2 = 0;
            crShdArea  = 0;
            fraSun     = 0;
           end if;

          connect(weaBus.solTim, solAzi.solTim) annotation (Line(
              points={{-102,5.55112e-16},{-88,5.55112e-16},{-88,-6},{-62,-6}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solZen, solAzi.zen) annotation (Line(
              points={{-102,5.55112e-16},{-79,5.55112e-16},{-79,6},{-62,6}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solDec, solAzi.decAng) annotation (Line(
              points={{-102,5.55112e-16},{-92,5.55112e-16},{-92,1.22125e-15},{-82,
                  1.22125e-15},{-82,6.66134e-16},{-62,6.66134e-16}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));

          annotation ( Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                            graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,127},
                  fillPattern=FillPattern.Solid,
                  fillColor={255,255,255}),
                                      Bitmap(extent={{-114,98},{122,-94}},
        fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/Overhang.png")}),
        defaultComponentName="overhang",
        Documentation(info="<html>
<p>
For a window with an overhang, this block outputs the fraction of
the area that is exposed to the sun.
This models can also be used for doors with an overhang.
</p>
<p>
Input to this block are the
wall solar azimuth angle and the altitude angle of the sun.
These angles can be calculated using blocks from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses</a>.
</p>
<p>
The overhang can be asymmetrical (i.e. <code>wR &ne; wL</code>)
about the vertical centerline
of the window.
The overhang must completely cover the window (i.e.,
<code>wL &ge; 0</code> and
<code>wR &ge; 0</code>).
<code>wL</code> and <code>wR</code> are measured from the left and right edge of the window.
</p>
<p>
The surface azimuth <code>azi</code> is as defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>.
</p>
<h4>Implementation</h4>
<p>
The method of super position is used to calculate the window shaded area.
The area below the overhang is divided as shown in the figure.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/OverhangSuperPosition.png\" />
</p>
<p>
Dimensional variables used in code for the rectangle <i>DEGI, AEGH, CFGI</i> and <i>BFGH</i>
are shown in the figure below:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/OverhangVariables.png\" />
</p>
<p>
The rectangles <i>DEGI, AEGH, CFGI</i> and <i>BFGH</i> have the same geometric configuration
with respect to the overhang.
Thus, the same algorithm can be used to calculate the shaded portion in these areas.
A single equation in the <code>for</code> loop improves the total calculation time,
as compared to <code>if-then-else</code>
conditions, considering the various shapes of the shaded portions.
To find the shaded area in window <i>ABCD</i>, the shaded portion of <i>AEGD</i> and <i>CFGI</i>
should be subtracted from that of <i>DEGI</i> and <i>BFGH</i>.
This shaded area of the window is then divided by the total window area
to calculate the shaded fraction of the window.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 28, 2014, by Michael Wetter:<br/>
Reformulated <code>shdwTrnglRtio*x1 = y1</code> to avoid a division by
zero if the model is exported as an FMU.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/234\">#234</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of <code>wL</code> and <code>wR</code> to be
measured from the corner of the window instead of the centerline.
This allows changing the window width without having to adjust the
overhang parameters.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Revised implementation to avoid state events when horizontal projection
of the sun beam is perpendicular to window.
</li>
<li>
May 7, 2012, by Kaustubh Phalak:<br/>
Modified for use of asymmetrical overhang.
</li>
<li>
Feb 23, 2012, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Overhang;

        partial block PartialRadiation
          "Partial model for variables and data used in radiation calculation"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;

          ////////////////// Parameters that are not used by RadiationData
          parameter Boolean haveExteriorShade
            "Set to true if window has an exterior shade";
          parameter Boolean haveInteriorShade
            "Set to true if window has an interior shade";
          parameter Modelica.SIunits.Area AWin "Area of window";

          ////////////////// Derived parameters
          final parameter Boolean haveShade=haveExteriorShade or haveInteriorShade
            "Set to true if window has a shade" annotation (Evaluate=true);
          final parameter Buildings.HeatTransfer.Windows.BaseClasses.RadiationData
            radDat(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b)
            "Optical properties of window for different irradiation angles" annotation (
             Placement(transformation(extent={{60,20},{80,40}})));
          Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if haveShade
            "Control signal for shading (0: unshaded; 1: fully shaded)" annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={-2,-116})));
          Modelica.Blocks.Interfaces.RealInput HDif(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive solar radiation" annotation (Placement(
                transformation(extent={{-140,60},{-100,100}}),iconTransformation(extent=
                   {{-130,65},{-100,95}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incident angle" annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-130,-25},
                    {-100,5}})));
          Modelica.Blocks.Interfaces.RealInput HDir(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Direct solar radiation" annotation (Placement(
                transformation(extent={{-140,20},{-100,60}}),iconTransformation(extent=
                    {{-130,25},{-100,55}})));

      protected
          Modelica.Blocks.Interfaces.RealInput uSha_internal(min=0, max=1)
            "Control signal for shading (0: unshaded; 1: fully shaded)";
        initial equation
          /* Current model assumes that the window only has either an interior or exterior shade.
     Warn user if it has an interior and exterior shade.
     Allowing both shades at the same time would require rewriting part of the model. */
          assert(not (haveExteriorShade and haveInteriorShade),
            "Window radiation model does not support an exterior and interior shade at the same time.");
        equation
          // Connect statement for conditionally removed connector uSha
          connect(uSha, uSha_internal);
          if (not haveShade) then
            uSha_internal = 0;
          end if;
          annotation (
            Documentation(info="<html>
The model calculates solar absorbance on the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for radDat. It is needed by the claculation of property for uncoated glass.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 16, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{-92,0},{-62,-20}},
                  lineColor={0,0,127},
                  textString="incAng"),
                Text(
                  extent={{-94,84},{-70,70}},
                  lineColor={0,0,127},
                  textString="HDif"),
                Text(
                  extent={{-96,42},{-62,30}},
                  lineColor={0,0,127},
                  textString="HDir"),
                Text(
                  extent={{-32,-82},{22,-94}},
                  lineColor={0,0,127},
                  textString="uSha"),
                Polygon(
                  points={{-46,66},{-46,-10},{-6,-50},{-6,22},{-46,66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{18,64},{18,-12},{58,-52},{58,20},{18,64}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-28,2},{-18,10},{-8,0},{2,10},{12,0},{22,10},{32,-2},{40,4},
                      {34,4},{38,-2},{40,4},{38,4}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{38,-2},{34,4},{40,4},{38,-2}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{38,-4},{46,-14},{58,-4},{66,-14},{66,-14},{76,-4},{86,-16},{
                      94,-10},{88,-10},{92,-16},{94,-10},{92,-10}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{92,-16},{88,-10},{94,-10},{92,-16}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,8},{-30,14},{-24,14},{-26,8}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,20},{-72,10},{-60,20},{-52,10},{-52,10},{-42,20},{-32,8},
                      {-24,14},{-30,14},{-26,8},{-24,14},{-26,14}},
                  color={255,128,0},
                  smooth=Smooth.None)}));
        end PartialRadiation;

        partial model PartialWindowBoundaryCondition
          "Partial model for heat convection or radiation between a possibly shaded window that can be outside or inside the room"
          parameter Modelica.SIunits.Area A "Heat transfer area of frame and window";
          parameter Real fFra "Fraction of window frame divided by total window area";
          final parameter Modelica.SIunits.Area AFra = fFra * A "Frame area";
          final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";

          parameter Boolean haveExteriorShade
            "Set to true if window has exterior shade (at surface a)"
            annotation (Dialog(group="Shading"));
          parameter Boolean haveInteriorShade
            "Set to true if window has interior shade (at surface b)"
            annotation (Dialog(group="Shading"));

          final parameter Boolean haveShade = haveExteriorShade or haveInteriorShade
            "Set to true if window system has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);
          parameter Boolean thisSideHasShade
            "Set to true if this side of the model has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput uSha if haveShade
            "Input connector, used to scale the surface area to take into account an operable shading device, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-116,72},{-100,88}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
            "Port that connects to the air (room or outside)"        annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns
            "Heat port that connects to unshaded part of glass"
              annotation (Placement(transformation(extent={{90,10},{110,30}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha if haveShade
            "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{90,-30},{110,-10}})));

      protected
          Modelica.Blocks.Math.Product proSha if haveShade
            "Product for shaded part of window"
            annotation (Placement(transformation(extent={{-50,20},{-30,40}})));

          ShadingSignal shaSig(final haveShade=haveShade)
            "Conversion for shading signal"
            annotation (Placement(transformation(extent={{-90,70},{-70,90}})));
      public
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a frame
            "Heat port at window frame"  annotation (Placement(transformation(extent={{60,-110},
                    {80,-90}})));
        initial equation
          assert(( thisSideHasShade and haveShade)  or (not thisSideHasShade),
            "Parameters \"thisSideHasShade\" and \"haveShade\" are not consistent. Check parameters");

        equation
           connect(uSha, shaSig.u)
                               annotation (Line(
              points={{-120,80},{-92,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(proSha.u2, shaSig.y) annotation (Line(
              points={{-52,24},{-60,24},{-60,80},{-69,80}},
              color={0,0,127},
              smooth=Smooth.None));

            annotation (Dialog(group="Shading"),
            Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{84,-2}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-94,88},{-86,74}},
                  lineColor={0,0,127},
                  textString="u"),              Text(
                extent={{-160,144},{140,104}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,48},{-20,40},{20,52},{20,60},{-20,48}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,8},{-20,0},{20,12},{20,20},{-20,8}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,28},{-20,20},{20,32},{20,40},{-20,28}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-32},{-20,-40},{20,-28},{20,-20},{-20,-32}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-12},{-20,-20},{20,-8},{20,0},{-20,-12}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-72},{-20,-80},{20,-68},{20,-60},{-20,-72}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-52},{-20,-60},{20,-48},{20,-40},{-20,-52}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,94},{2,-86}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{56,72},{84,-74}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                Rectangle(
                  extent={{56,-74},{84,-90}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-20,86},{84,72}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model for boundary conditions for convection and radiation for a window surface with or without shade,
that is outside or inside the room.
</p>
<p>
This allows using the model as a base class for windows with inside shade, outside shade, or no shade.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2015, by Michael Wetter:<br/>
Refactored model to allow a temperature dependent convective heat transfer
on the room side.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/52\">52</a>.
</li>
<li>
August 25 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialWindowBoundaryCondition;

        model ShadeConvection
          "Model for convective heat balance of a layer that may or may not have a shade"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Boolean thisSideHasShade
            "Set to true if this side of the window has a shade";

          parameter Real k(min=0, max=1)=1
            "Coefficient used to scale convection between shade and glass";

          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                origin={-120,30}), iconTransformation(extent={{-10,-10},{10,10}},
                  origin={-110,40})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
            "Port that connects to the air (room or outside)"        annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass
            "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{84,-10},{104,10}}),
                iconTransformation(extent={{84,-10},{104,10}})));
         Modelica.Blocks.Interfaces.RealInput QRadAbs_flow(unit="W")
            "Total net radiation that is absorbed by the shade (positive if absorbed)"
             annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                               rotation=270,
                origin={-60,-110}),         iconTransformation(extent={{10,-10},{-10,10}},
                rotation=270,
                origin={-60,-110})));

          Modelica.Blocks.Interfaces.RealOutput TSha(quantity="ThermodynamicTemperature",
              unit="K") "Shade temperature"
            annotation (Placement(transformation(
                origin={58,-120},
                extent={{20,-20},{-20,20}},
                rotation=90), iconTransformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={60,-110})));
        equation
          if thisSideHasShade then
            // Convective heat balance of shade.
            // The term 2*Gc is to combine the parallel convective heat transfer resistances,
            // see figure in info section.
         //   2*(air.T-TSha) = k*(glass.T-TSha);
            // Convective heat flow at air node
            air.Q_flow   = Gc*(2*(air.T-TSha) + (air.T-glass.T));
            // Convective heat flow at glass node
            glass.Q_flow = Gc*((glass.T-air.T)+k*(glass.T-TSha));
            air.Q_flow + glass.Q_flow + QRadAbs_flow = 0;
          else
            air.Q_flow   = Gc*(air.T-glass.T);
            air.Q_flow + glass.Q_flow = 0;
            TSha = (air.T+glass.T)/2;
          end if;

          annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-100,132},{100,102}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,54},{-20,46},{20,58},{20,66},{-20,54}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,14},{-20,6},{20,18},{20,26},{-20,14}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,34},{-20,26},{20,38},{20,46},{-20,34}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-26},{-20,-34},{20,-22},{20,-14},{-20,-26}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-6},{-20,-14},{20,-2},{20,6},{-20,-6}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-66},{-20,-74},{20,-62},{20,-54},{-20,-66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-46},{-20,-54},{20,-42},{20,-34},{-20,-46}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,90},{2,-80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,94},{40,80}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-100,52},{-66,34}},
                  lineColor={0,0,127},
                  textString="Gc"),
                Rectangle(
                  extent={{88,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-68,-80},{-34,-98}},
                  lineColor={0,0,127},
                  textString="QAbsNet"),
                Text(
                  extent={{42,-82},{76,-100}},
                  lineColor={0,0,127},
                  textString="T")}),
            Documentation(info="<html>
<p>
Model for the convective heat balance
of a shade that is in the outside or the room-side of a window.
</p>
<p>
The convective heat balance is based on the model described by Wright (2008), which can
be shown as a convective heat resistance model as follows:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/convection.png\" border=\"1\"/>
</p>
<p>
Wright (2008) reports that if the shading layer is far enough from the window,
the boundary layers associated with each surface will not interfere with
each other. In this case, it is reasonable to consider each surface on an
individual basis by setting the convective heat transfer coefficient shown in grey to zero,
and setting the black depicted convective heat transfer coefficients
to <i>h=4 W/m<sup>2</sup> K</i>.
In the here implemented model, the grey depicted convective heat transfer coefficient
is set set to <i>h' = k &nbsp; h</i>, where <i>0 &le; k &le; 1</i> is a parameter.
</p>
<h4>References</h4>
<ul>
<li>
Jon L. Wright.<br/>
Calculating Center-Glass Performance Indices
of Glazing Systems with Shading Devices.<br/>
<i>ASHRAE Transactions</i>, SL-08-020. 2008.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 11, 2013, by Michael Wetter:<br/>
Redesigned model to separate convection from radiation, which is
required for the implementation of a CFD model.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port and in heat balance of shade.
</li>
<li>
January 28 2011, by Michael Wetter:<br/>
Fixed computation of convective heat balance between air, shade and glass.
</li>
<li>
November 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeConvection;

        partial model ShadeInterface_weatherBus
          "Base class for models of window shade and overhangs"
          extends Modelica.Blocks.Icons.Block;

          Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          Modelica.Blocks.Interfaces.RealInput incAng(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="rad")
            "Solar incidence angle"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Modelica.Blocks.Interfaces.RealInput HDirTilUns(
                                 quantity="RadiantEnergyFluenceRate",
                                 unit="W/m2")
            "Direct solar irradiation on tilted, unshaded surface"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Modelica.Blocks.Interfaces.RealOutput HDirTil(
                                 quantity="RadiantEnergyFluenceRate",
                                 unit="W/m2")
            "Direct solar irradiation on tilted, shaded surface"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of the area that is unshaded"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (Documentation(info="<html>
<p>
Partial model to implement overhang and side fin model with weather bus as a connector.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeInterface_weatherBus;

        model ShadeRadiation
          "Model for infrared radiative heat balance of a layer that may or may not have a shade"

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Emissivity absIR_air
            "Infrared absorptivity of surface that faces air";
          parameter Modelica.SIunits.Emissivity absIR_glass
            "Infrared absorptivity of surface that faces glass";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_air
            "Infrared transmissivity of shade for radiation coming from the exterior or the room";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_glass
            "Infrared transmissivity of shade for radiation coming from the glass";
          parameter Boolean thisSideHasShade
            "Set to true if this side of the window has a shade";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_air=1-absIR_air-tauIR_air
            "Infrared reflectivity of surface that faces air";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_glass=1-absIR_glass-tauIR_glass
            "Infrared reflectivity of surface that faces glass";
          parameter Boolean linearize = false "Set to true to linearize emissive power"
          annotation (Evaluate=true);

          parameter Modelica.SIunits.Temperature T0=293.15
            "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize));

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Modelica.Blocks.Interfaces.RealInput QSolAbs_flow(unit="W", quantity="Power")
            "Solar radiation absorbed by shade"
            annotation (Placement(transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));

          Interfaces.RadiosityInflow JIn_air(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
          Interfaces.RadiosityInflow JIn_glass(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
          Interfaces.RadiosityOutflow JOut_air
            "Outgoing radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-100,-90},{-120,-70}})));
          Interfaces.RadiosityOutflow JOut_glass
            "Outgoing radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

         Modelica.Blocks.Interfaces.RealOutput QRadAbs_flow(unit="W")
            "Total net radiation that is absorbed by the shade (positive if absorbed)"
             annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                               rotation=270,
                origin={-50,-110}),         iconTransformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-50,-110})));

          Modelica.Blocks.Interfaces.RealInput TSha(quantity="ThermodynamicTemperature",
              unit="K",
              start=293.15) if
                 thisSideHasShade "Shade temperature"
            annotation (Placement(transformation(
                origin={60,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,-110})));

      protected
           Modelica.Blocks.Interfaces.RealInput TSha_internal(quantity="ThermodynamicTemperature",
              unit="K",
              start=293.15) "Internal connector for shade temperature";

         final parameter Real T03(min=0, final unit="K3")=T0^3
            "3rd power of temperature T0";
         Real T4(min=1E8, start=293.15^4, nominal=1E10, final unit="K4")
            "4th power of temperature";
         Modelica.SIunits.RadiantPower E_air "Emissive power of surface that faces air";
         Modelica.SIunits.RadiantPower E_glass
            "Emissive power of surface that faces glass";

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(TSha_internal, TSha);
          if thisSideHasShade then
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
            if linearize then
              T4 = T03 * TSha_internal;
            else
              if homotopyInitialization then
                T4 = homotopy(actual=(TSha_internal)^4, simplified=T03 * TSha_internal);
              else
                T4 = TSha_internal^4;
              end if;
            end if;

            E_air   = u * A * absIR_air   * Modelica.Constants.sigma * T4;
            E_glass = u * A * absIR_glass * Modelica.Constants.sigma * T4;
            // Radiosity outgoing from shade towards air side and glass side
            JOut_air   = E_air   + tauIR_glass * JIn_glass + rhoIR_air*JIn_air;
            JOut_glass = E_glass + tauIR_air   * JIn_air   + rhoIR_glass*JIn_glass;
            // Radiative heat balance of shade.
            QSolAbs_flow + absIR_air*JIn_air + absIR_glass*JIn_glass
              = E_air+E_glass+QRadAbs_flow;
          else
            QRadAbs_flow = 0;
            T4 = T03 * T0;
            E_air = 0;
            E_glass = 0;
            JOut_air = JIn_glass;
            JOut_glass = JIn_air;
            TSha_internal = T0;
          end if;

          annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-100,132},{100,102}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,54},{-20,46},{20,58},{20,66},{-20,54}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,14},{-20,6},{20,18},{20,26},{-20,14}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,34},{-20,26},{20,38},{20,46},{-20,34}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-26},{-20,-34},{20,-22},{20,-14},{-20,-26}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-6},{-20,-14},{20,-2},{20,6},{-20,-6}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-66},{-20,-74},{20,-62},{20,-54},{-20,-66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-46},{-20,-54},{20,-42},{20,-34},{-20,-46}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-18,-82},{16,-100}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Rectangle(
                  extent={{-2,90},{2,-80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,94},{40,80}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-102,90},{-68,72}},
                  lineColor={0,0,127},
                  textString="u"),
                Rectangle(
                  extent={{88,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{42,-82},{76,-100}},
                  lineColor={0,0,127},
                  textString="T"),
                Text(
                  extent={{-68,-80},{-34,-98}},
                  lineColor={0,0,127},
                  textString="QAbsNet")}),
            Documentation(info="<html>
<p>
Model for the infrared radiative heat balance
of a shade that is at the outside or the room-side of a window.
The model also includes the absorbed solar radiation.
</p>
<p>
The input port <code>QAbs_flow</code> needs to be connected to the solar radiation
that is absorbed by the shade.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 11, 2013, by Michael Wetter:<br/>
Redesigned model to separate convection from radiation, which is
required for the implementation of a CFD model.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port and in heat balance of shade.
</li>
<li>
January 28 2011, by Michael Wetter:<br/>
Fixed computation of convective heat balance between air, shade and glass.
</li>
<li>
November 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeRadiation;

        block ShadingSignal
          "Converts the shading signal to be strictly bigger than 0 and smaller than 1"
          extends Modelica.Blocks.Interfaces.SO;
          parameter Boolean haveShade "Set to true if a shade is present"
            annotation (Evaluate=true);
          Modelica.Blocks.Interfaces.RealInput u if haveShade
            "Shading control signal, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput yCom "1-u"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}), iconTransformation(extent={{100,-70},{120,-50}})));
      protected
          constant Real y0 = 1E-6 "Smallest allowed value for y if a shade is present";
          constant Real k = 1-2*y0 "Gain for shading signal";
          Modelica.Blocks.Interfaces.RealInput u_in_internal
            "Needed to connect to conditional connector";
        equation
          connect(u, u_in_internal);
          if not haveShade then
            u_in_internal = 0;
          end if;
          if haveShade then
            y = y0 + k *  u_in_internal;
            yCom = 1-y;
          else
            y = 0;
            yCom = 1;
          end if;
          annotation ( Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="u"),
                Text(
                  extent={{48,22},{90,-22}},
                  lineColor={0,0,127},
                  textString="u'"),
                Text(
                  extent={{-14,-40},{92,-80}},
                  lineColor={0,0,127},
                  textString="1-u'")}),
                   Documentation(info="<html>
This model changes the shading control signal to avoid a singularity
in the window model if the input signal is zero or one.
Since the window heat balance multiplies the area of the window by <code>u</code>
or by <code>1-u</code> (if a shade is present), the heat balance can be singular
for <code>u=0</code> or for <code>u=1</code>.
This model avoids this singularity by slightly changing the control signal.
</html>",         revisions="<html>
<ul>
<li>
October 28 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadingSignal;

        block SideFins
          "For a window with side fins, outputs the fraction of the area that is sun exposed"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.ThermalZones.Detailed.BaseClasses.SideFins;
          Modelica.Blocks.Interfaces.RealInput alt(quantity="Angle",
                                                   unit="rad",
                                                   displayUnit="deg")
            "Solar altitude angle (angle between sun ray and horizontal surface)"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput verAzi(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="deg")
            "Angle between projection of sun's rays and normal to vertical surface"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of window area exposed to the sun"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        // Window dimensions
          parameter Modelica.SIunits.Length hWin "Window height"
            annotation(Dialog(tab="General",group="Window"));
          parameter Modelica.SIunits.Length wWin "Window width"
            annotation(Dialog(tab="General",group="Window"));
        // Other calculation variables
      protected
          final parameter Modelica.SIunits.Length tmpH[4]=
                          {h+hWin, h, h+hWin, h}
            "Height of rectangular sections used for superposition";
          final parameter Modelica.SIunits.Length tmpW[4]=
                          {gap + wWin,gap + wWin,gap, gap}
            "Width of rectangular sections used for superpositions; c1,c2 etc";
          final parameter Modelica.SIunits.Length deltaL=wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          final parameter Modelica.SIunits.Area AWin=hWin*wWin "Window area";
          Modelica.SIunits.Length x1[4]
            "Horizontal distance between side fin and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length x2
            "Horizontal distance between side fin and shadow corner";
          Modelica.SIunits.Length x3[4] "Window width";
          Modelica.SIunits.Length y1[4] "Window height";
          Modelica.SIunits.Length y2
            "Vertical distance between window upper edge and shadow corner";
          Modelica.SIunits.Length y3[4]
            "Vertical distance between window upper edge and point where shadow line and window side edge intersects";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area";
          Modelica.SIunits.Area crShdArea "Final value of shaded area";
          Modelica.SIunits.Area crShdArea1
            "Shaded area, corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2
            "Shaded area, corrected for the sun below horizon";
          Modelica.SIunits.Length minX[4];
          Modelica.SIunits.Length minY[4];
          Modelica.SIunits.Length minX2X3[4];
          Modelica.SIunits.Length minY2Y3[4];
          Real delta=1e-6 "Small number to avoid division by zero";
          Real tanLambda
            "Tangent of angle between horizontal and sun ray projection on vertical wall";
          Real verAzi_t;
          Real lambda_t;
          Real verAzi_c;
          Real alt_t;
        initial equation
          assert(h >= 0, "Sidefin parameter 'h' must be at least zero.
  It is measured from the upper edge of the window to the top of the side fin.
  Received h = "         + String(h));
        equation
          // This if-then construct below increases computing efficiency in
          // Buildings.HeatTransfer.Windows.FixedShade in case the window has no overhang.
          if haveSideFins then
          //avoiding division by zero
            lambda_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=tanLambda,
              x2=delta,
              deltaX=delta/10);
            verAzi_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.tan(verAzi),
              x2=delta,
              deltaX=delta/10);
            verAzi_c = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.cos(verAzi),
              x2=delta,
              deltaX=delta/10);
            alt_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.tan(alt),
              x2=delta,
              deltaX=delta/10);
            tanLambda = alt_t / verAzi_t;
            y2 = dep*alt_t/verAzi_c;
            x2 = dep*verAzi_t;
            for i in 1:4 loop
              x1[i] = tmpH[i]/lambda_t;
              x3[i] = tmpW[i];
              y1[i] = tmpH[i];
              y3[i] = tmpW[i]*lambda_t;
              minX2X3[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=x2,
                x2=x3[i],
                deltaX=deltaL);
              minX[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=x1[i],
                x2=minX2X3[i],
                deltaX=deltaL);
              minY2Y3[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y2,
                x2=y3[i],
                deltaX=deltaL);
              minY[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y1[i],
                x2=minY2Y3[i],
                deltaX=deltaL);
              area[i] = tmpH[i]*minX[i] - minX[i]*minY[i]/2;
            end for;
          //by superposition
            shdArea = area[1] + area[4] - area[2] - area[3];
            // The corrections below ensure that the shaded area is 1 if the
            // sun is below the horizon or behind the wall.
            // This correction is not required (because the direct solar irradiation
            // will be zero in this case), but it leads to more realistic time series
            // of this model.
          //correction case: Sun not in front of the wall
            crShdArea1 = Buildings.Utilities.Math.Functions.spliceFunction(
               pos=shdArea,
               neg=AWin,
               x=(Modelica.Constants.pi/2)-verAzi,
               deltax=0.01);
          //correction case: Sun below horizon
            crShdArea2 = Buildings.Utilities.Math.Functions.spliceFunction(
               pos=shdArea,
               neg=AWin,
               x=alt,
               deltax=0.01);
            crShdArea=Buildings.Utilities.Math.Functions.smoothMax(
               x1=crShdArea1,
               x2=crShdArea2,
               deltaX=0.0001*AWin);
            fraSun = 1-crShdArea/AWin;
          else
            lambda_t = 0;
            verAzi_t = 0;
            verAzi_c = 0;
            alt_t =    0;
            tanLambda = 0;
            y2 = 0;
            x2 = 0;
            x1 = fill(0.0, 4);
            x3 = fill(0.0, 4);
            y1 = fill(0.0, 4);
            y3 = fill(0.0, 4);
            minX2X3 = fill(0.0, 4);
            minX = fill(0.0, 4);
            minY2Y3 = fill(0.0, 4);
            minY = fill(0.0, 4);
            area = fill(0.0, 4);
            shdArea = 0;
            crShdArea1 = 0;
            crShdArea2 = 0;
            crShdArea  = 0;
            fraSun     = 0;
          end if;
          annotation ( Icon(graphics={Bitmap(extent={{-92,92},{92,-92}},
                    fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFins.png")}),
        defaultComponentName="fin",
        Documentation(info="<html>
<p>
For a window with side fins, this block outputs the fraction of
the area that is exposed to the sun.
This models can also be used for doors with side fins.
</p>
<p>
Input to this block are the
wall solar azimuth angle and the altitude angle of the sun.
These angles can be calculated using blocks from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses</a>.
</p>

<h4>Limitations</h4>
<p>
The model assumes that
</p>
<ul>
<li>
the side fins are placed symmetrically to the left and right of the window,
</li>
<li>
the top of the side fins must be at an equal or greater height than the window, and
</li>
<li>
the bottom of the side fins must be at an equal or lower height than the
bottom of the window.
</li>
</ul>

<h4>Implementation</h4>
<p>
The method of super position is used to calculate the shaded area of the window.
The area besides the side fin is divided as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"imaghe\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFinsSuperPosition.png\" />
</p>

<p>
Variables used in the code for the rectangle <i>AEGI, BEGH, DFGI</i> and <i>CFGH</i> are shown in figure below.
</p>
<p align=\"center\">
<img alt=\"imaghe\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFinsVariables.png\" />
</p>

<p>
The rectangles <i>AEGI, BEGH, DFGI</i> and <i>CFGH</i>  have the same geometric configuration
with respect to the side fin.
Thus, the same algorithm is used to calculate the shaded portion in these areas.
A single equation in the <code>for</code> loop improves the total calculation time,
as compared to <code>if-then-else</code>
conditions, considering the various shapes of the shaded portions.
To find the shaded area in the window <i>ABCD</i>, the shaded portion of
<i>BEGH</i> and <i>DFGI</i> is subtracted from <i>AEGI</i> and <i>CFGH</i>.
This shaded area of the window is then divided by the total window area
to calculate the shaded fraction of the window.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of side fin height <code>h</code> to be
measured from the top of the window.
This allows changing the window height without having to adjust the
side fin parameters.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SideFins;

        block StateInterpolator "Block to interpolate between different window states"
          extends Modelica.Blocks.Icons.Block;

          parameter Integer NSta(min=1)
            "Number of window states for electrochromic windows"
            annotation (Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput uSta(min=0, max=1, unit="1") if
               NSta > 1 "Control signal for window state"
                                               annotation (Placement(
                transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput HSta[NSta]
            "Radiation for each window state"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput H "Interpolated radiation" annotation (
              Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          parameter Real uSup[NSta] = {(i-1.0)/max(1.0, (NSta-1)) for i in 1:NSta}
            "Support points for the radiations HSta";
          Modelica.Blocks.Interfaces.RealInput uSta_internal(min=0, max=1, unit="1")
            "Control signal for window state";
        equation
          if NSta == 1 then
            uSta_internal = 0;
            H = HSta[1];
          else
            connect(uSta, uSta_internal);
            // Linear interpolation. y=0 means off-state, in which case HSta[1] needs to
            // be assigned to the output.
            H = uSta_internal*HSta[2]+(1-uSta_internal)*HSta[1];
              Buildings.Utilities.Math.Functions.smoothInterpolation(
                x=uSta_internal,
                xSup=uSup,
                ySup=HSta,
                ensureMonotonicity=true);
          end if;

          annotation (
          defaultComponentName="staInt",
          Documentation(info="<html>
<p>
This block interpolates the radiation data for the actual
state of the window.
For windows with only one state, e.g., conventional windows,
this block outputs <code>H=HSta[1]</code>.
For windows with multiple states, it outputs the
interpolated radiation using cubic spline interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end StateInterpolator;

        block TransmittedRadiation "Transmitted radiation through window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;
          Modelica.Blocks.Interfaces.RealOutput QTraDif_flow[NSta](
            each final quantity="Power",
            each final unit="W")
            "Transmitted exterior diffuse radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,10},{120,30}}),
                iconTransformation(extent={{100,10},{120,30}})));
          Modelica.Blocks.Interfaces.RealOutput QTraDir_flow[NSta](
            each final quantity="Power",
            each final unit="W")
            "Transmitted exterior direct radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-30},{120,-10}}),
                iconTransformation(extent={{100,-30},{120,-10}})));

          final parameter Real traCoeRoo[NSta](each fixed=false)
            "Transmitivity of the window glass for interior radiation without shading";

          output Modelica.SIunits.Power QTraDifUns_flow[NSta]
            "Transmitted diffuse solar radiation through unshaded part of window";
          output Modelica.SIunits.Power QTraDirUns_flow[NSta]
            "Transmitted direct solar radiation through unshaded part of window";
          output Modelica.SIunits.Power QTraDifSha_flow[NSta]
            "Transmitted diffuse solar radiation through shaded part of window";
          output Modelica.SIunits.Power QTraDirSha_flow[NSta]
            "Transmitted direct solar radiation through shaded part of window";

      protected
          Real x "Intermediate variable";
          final parameter Integer NDIR=radDat.NDIR;
          final parameter Integer HEM=radDat.HEM;
          constant Integer NoShade=1;
          constant Integer Shade=2;
          constant Integer Interior=1;
          constant Integer Exterior=2;
          final parameter Real coeTraWinExtIrr[2, radDat.HEM + 2, NSta](each fixed=false);
          Real incAng2 "=min(incAng, 0.5*Modelica.Constants.pi)";

        initial equation
          //**************************************************************
          // Assign coefficients.
          // Data dimension from Original ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for j in 1:HEM loop
            // Properties for glass without shading
            coeTraWinExtIrr[NoShade, j + 1, 1:NSta] =  radDat.traRef[1, 1, N, j, 1:NSta];
            // Properties for glass with shading
            if haveInteriorShade then
              coeTraWinExtIrr[Shade, j + 1, 1:NSta] =  radDat.winTraExtIrrIntSha[j, 1:NSta];
            elseif haveExteriorShade then
              coeTraWinExtIrr[Shade, j + 1, 1:NSta] =  radDat.winTraExtIrrExtSha[j, 1:NSta];
            else
              // No Shade
              coeTraWinExtIrr[Shade, j + 1, 1:NSta] =  zeros(NSta);
            end if;
          end for;
          // Dummy variables at 1 and HEM+2
          for k in NoShade:Shade loop
            coeTraWinExtIrr[k, 1, 1:NSta] =  coeTraWinExtIrr[k, 2, 1:NSta];
            coeTraWinExtIrr[k, HEM + 2, 1:NSta] =  coeTraWinExtIrr[k, HEM + 1, 1:NSta];
          end for;

          //**************************************************************
          // Glass: transmissivity for interior irradiation
          //**************************************************************
          traCoeRoo =  radDat.traRef[1, N, 1, HEM, 1:NSta];

        equation
          //**************************************************************
          // Glass, Device: add absorbed radiation (angular part) from exterior sources
          //**************************************************************
          // Use min() instead of if() to avoid event
          incAng2 = min(incAng, 0.5*Modelica.Constants.pi);
          x = (2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi)+2
            "x=(index-1)*incAng/(0.5pi)+2, 0<=x<=NDIR-1";

          // Window unshaded parts: add transmitted radiation for angular radiation
          for iSta in 1:NSta loop
            QTraDifUns_flow[iSta] = AWin*HDif*(1 - uSha_internal)*coeTraWinExtIrr[NoShade, HEM + 1, iSta];
            QTraDirUns_flow[iSta] = AWin*HDir*(1 - uSha_internal)*
                         Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
                            coeTraWinExtIrr[NoShade, k, iSta] for k in 1:(HEM + 2)}, x);
          end for;

          // Window shaded parts: add transmitted radiation for angular radiation
          for iSta in 1:NSta loop
            QTraDifSha_flow[iSta] = AWin*HDif*uSha_internal*coeTraWinExtIrr[Shade, HEM + 1, iSta];
            QTraDirSha_flow[iSta] = AWin*HDir*uSha_internal*
                       Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
                         {coeTraWinExtIrr[Shade, k, iSta] for k in 1:(HEM + 2)}, x);
          end for;

          // Assign quantities to output connectors
          QTraDif_flow = QTraDifUns_flow + QTraDifSha_flow;
          QTraDir_flow = QTraDirUns_flow + QTraDirSha_flow;
          annotation (
            Documentation(info="<html>
<p>
The model calculates the solar radiation through the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The transmitted exterior radiation for window system includes:
</p>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
<p>
The outputs are <code>QTraDif_flow = Part1 + Part3</code> and
<code>QTraDir_flow = Part2 + Part4</code>.
</p>
<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
June 7, 2016, by Michael Wetter:<br/>
Removed output <code>QTra_flow</code> and introduced instead
<code>QTraDif_flow</code> and <code>QTraDir_flow</code>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/451\">issue 451</a>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed <code>initial algorithm</code>
to <code>initial equation</code> section
to avoid a translation error in OpenModelica.
</li>
<li>
March 4, 2011, by Wangda Zuo:<br/>
Remove the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Separate transmittance and absorbance models from the window radiation model.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={Text(
                  extent={{-32,-80},{22,-96}},
                  lineColor={0,0,127},
                  textString="uSha"), Text(
                  extent={{56,28},{98,14}},
                  lineColor={0,0,127},
                  textString="QTraDif"),
                                      Text(
                  extent={{54,-14},{96,-28}},
                  lineColor={0,0,127},
                  textString="QTraDir")}));
        end TransmittedRadiation;

        block WindowRadiation "Calculation radiation for window"

          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput uSta(min=0, max=1, unit="1") if
               NSta > 1 "Control signal for window state"
                                              annotation (Placement(
                transformation(extent={{-20,-20},{20,20}},   rotation=90,
                origin={40,-120}), iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={48,-116})));

          Modelica.Blocks.Interfaces.RealInput HRoo(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));
          Modelica.Blocks.Interfaces.RealOutput QTraDif_flow(
            final quantity="Power",
            final unit="W")
            "Transmitted diffuse exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}),
                iconTransformation(extent={{100,-70},{120,-50}})));
          Modelica.Blocks.Interfaces.RealOutput QTraDir_flow(
            final quantity="Power",
            final unit="W")
            "Transmitted direct exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-100},{120,-80}}),
                iconTransformation(extent={{100,-100},{120,-80}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-40},{120,-20}}),
                iconTransformation(extent={{100,-40},{120,-20}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,40},{120,60}}),
                iconTransformation(extent={{100,40},{120,60}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,0},{120,20}}),
                iconTransformation(extent={{100,0},{120,20}})));

          Buildings.HeatTransfer.Windows.BaseClasses.TransmittedRadiation tra(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin,
            final tauShaSol_b=tauShaSol_b)
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          Buildings.HeatTransfer.Windows.BaseClasses.AbsorbedRadiation abs(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin)
            annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
      protected
          final parameter Boolean noShade=not (haveExteriorShade or haveInteriorShade)
            "Flag, true if the window has a shade";

          StateInterpolator staIntQAbsExtSha_flow(
            final NSta=NSta) "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,70},{80,90}})));
          StateInterpolator staIntQAbsGlaUns_flow[N](each final NSta=NSta)
            "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          StateInterpolator staIntQAbsGlaSha_flow[N](each final NSta=NSta)
            "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,-10},{80,10}})));
          StateInterpolator staIntQAbsIntSha_flow(
            final NSta=NSta) "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,-40},{80,-20}})));
          StateInterpolator staIntQTraDif_flow(final NSta=NSta)
            "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,-70},{80,-50}})));
          StateInterpolator staIntQTraDir_flow(final NSta=NSta)
            "Interpolator for the window state"
            annotation (Placement(transformation(extent={{60,-98},{80,-78}})));

          Modelica.Blocks.Routing.Replicator replicator(final nout=N) if
             NSta > 1
            "Signal replicator for signals that have an element for each glass pane"
            annotation (Placement(transformation(extent={{16,-68},{36,-48}})));
        equation
          if noShade then
            assert(uSha_internal < 1E-6,
              "Window has no shade, but control signal is non-zero.\n" +
              "  Received uSha_internal = " + String(uSha_internal));
          end if;
          connect(HDif, tra.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,58},{-41.5,58}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDif, abs.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,-22},{-41.5,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, tra.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,54},{-41.5,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, abs.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,-26},{-41.5,-26}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, tra.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,49},{-41.5,49}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, abs.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,-31},{-41.5,-31}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HRoo, abs.HRoo) annotation (Line(
              points={{-120,-80},{-54,-80},{-54,-37.6},{-41.5,-37.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tra.uSha, uSha) annotation (Line(
              points={{-30.2,38.4},{-30.2,24},{1.11022e-15,24},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.uSha, uSha) annotation (Line(
              points={{-30.2,-41.6},{-30.2,-48},{1.11022e-15,-48},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsExtSha_flow, staIntQAbsExtSha_flow.HSta) annotation (Line(
                points={{-19,-22},{8,-22},{36,-22},{36,74},{58,74}},         color={0,0,
                  127}));
          connect(staIntQAbsExtSha_flow.H, QAbsExtSha_flow) annotation (Line(points={{81,
                  80},{92,80},{92,90},{110,90}}, color={0,0,127}));
          connect(abs.QAbsGlaUns_flow, staIntQAbsGlaUns_flow.HSta) annotation (Line(
                points={{-19,-26},{14,-26},{40,-26},{40,44},{58,44}}, color={0,0,127}));
          connect(staIntQAbsGlaUns_flow.H, QAbsGlaUns_flow)
            annotation (Line(points={{81,50},{110,50}},          color={0,0,127}));
          connect(staIntQAbsGlaSha_flow.HSta, abs.QAbsGlaSha_flow) annotation (Line(
                points={{58,-6},{44,-6},{44,-34},{-19,-34}}, color={0,0,127}));
          connect(staIntQAbsGlaSha_flow.H, QAbsGlaSha_flow) annotation (Line(points={{81,
                  0},{92,0},{92,10},{110,10}}, color={0,0,127}));
          connect(abs.QAbsIntSha_flow, staIntQAbsIntSha_flow.HSta) annotation (Line(
                points={{-19,-38},{18,-38},{18,-36},{58,-36}}, color={0,0,127}));
          connect(staIntQAbsIntSha_flow.H, QAbsIntSha_flow)
            annotation (Line(points={{81,-30},{110,-30}},           color={0,0,127}));
          connect(staIntQTraDif_flow.H, QTraDif_flow)
            annotation (Line(points={{81,-60},{96,-60},{110,-60}},
                                                          color={0,0,127}));
          connect(uSta, staIntQAbsExtSha_flow.uSta) annotation (Line(points={{40,-120},{
                  40,-120},{40,-96},{40,86},{58,86}},          color={0,0,127}));
          connect(staIntQTraDif_flow.uSta, uSta) annotation (Line(points={{58,-54},{58,-54},
                  {40,-54},{40,-120}}, color={0,0,127}));
          connect(staIntQAbsIntSha_flow.uSta, uSta)
            annotation (Line(points={{58,-24},{40,-24},{40,-120}}, color={0,0,127}));

          connect(uSta, replicator.u) annotation (Line(points={{40,-120},{40,-74},{8,-74},
                  {8,-58},{14,-58}}, color={0,0,127}));
          connect(replicator.y, staIntQAbsGlaUns_flow.uSta) annotation (Line(points={{37,
                  -58},{48,-58},{48,56},{58,56}}, color={0,0,127}));
          connect(replicator.y, staIntQAbsGlaSha_flow.uSta) annotation (Line(points={{37,
                  -58},{44,-58},{48,-58},{48,6},{58,6}}, color={0,0,127}));
          connect(uSta, staIntQTraDir_flow.uSta)
            annotation (Line(points={{40,-120},{40,-82},{58,-82}}, color={0,0,127}));
          connect(tra.QTraDif_flow, staIntQTraDif_flow.HSta) annotation (Line(points={{-19,
                  52},{6,52},{6,-76},{48,-76},{48,-66},{58,-66}}, color={0,0,127}));
          connect(tra.QTraDir_flow, staIntQTraDir_flow.HSta) annotation (Line(points={{-19,
                  48},{-10,48},{4,48},{4,-94},{58,-94}}, color={0,0,127}));
          connect(staIntQTraDir_flow.H, QTraDir_flow) annotation (Line(points={{81,-88},
                  {88,-88},{88,-90},{110,-90}}, color={0,0,127}));
          annotation (
            Documentation(info="<html>
<p>
The model calculates solar radiation through the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
with the difference that this implementation allows a window to have
multiple states, thereby allowing to model electrochromic windows.
</p>
<p>
The absorbed radiation by exterior shades includes:
</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
<p>
The output is <code>absRad[2, 1]</code>
</p>

<p>
The absorbed radiation by interior shades includes:</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
<p>
The output is <code>absRad[2, N+2]</code></p>

<p>
The absorbed radiation by glass includes:</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angualr part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
<p>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code></p>

<p>
The transmitted exterior radiation for window system includes:</p>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
<p>
The outputs are <code>QTraDif_flow = Part1 + Part3</code> and
<code>QTraDir_flow = Part2 + Part4</code>.
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
June 7, 2016, by Michael Wetter:<br/>
Removed output <code>QTra_flow</code> and introduced instead
<code>QTraDif_flow</code> and <code>QTraDir_flow</code>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/451\">issue 451</a>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Removed duplicate text annotation.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for tra and abs. It is needed by the claculation of property for uncoated glass.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
January 4, 2011, by Michael Wetter:<br/>
Added assert statement to check that <code>uSha=0</code> if no shade is present.
This is needed to avoid wrong results in the room model.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Revise the model by separating transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{0,86},{90,72}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-4,-22},{92,-36}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{2,58},{94,44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{-2,20},{92,6}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha"),
                Text(
                  extent={{42,-52},{106,-66}},
                  lineColor={0,0,127},
                  textString="QTraDif"),
                Text(
                  extent={{-104,-70},{-50,-84}},
                  lineColor={0,0,127},
                  textString="HRoo"),
                Text(
                  extent={{8,-82},{62,-94}},
                  lineColor={0,0,127},
                  textString="uSta"),
                Text(
                  extent={{44,-80},{108,-94}},
                  lineColor={0,0,127},
                  textString="QTraDir")}));
        end WindowRadiation;

        function convectionHorizontalCavity "Free convection in horizontal cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real sinTil "Sine of window tilt";
          input Real cosTil "Cosine of the window tilt";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
            "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
      protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
          constant Real dx=0.1 "Half-width of interval used for smoothing";
        algorithm
          if cosTil > 0 then
          Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            x=dT+dx,
            deltax=dx);
          else
            Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            x=dT-dx,
            deltax=dx);
          end if;
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end convectionHorizontalCavity;

        function convectionVerticalCavity "Free convection in vertical cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
            "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
      protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
        algorithm

          Nu_1 :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.0673838*Ra^(1/3),
            neg=Buildings.Utilities.Math.Functions.spliceFunction(
              pos=0.028154*Ra^(0.4134),
              neg=1 + 1.7596678E-10*Ra^(2.2984755),
              x=Ra - 1E4,
              deltax=deltaRa),
            x=Ra - 5E4,
            deltax=deltaRa);
          /*
  if ( Ra <= 1E4) then
    Nu_1 = 1 + 1.7596678E-10*Ra^(2.2984755);
  elseif ( Ra <= 5E4) then
    Nu_1 = 0.028154*Ra^(0.4134);
  else
    Nu_1 = 0.0673838*Ra^(1/3);
  end if;
  */
          Nu_2 :=0.242*(Ra/(h/gas.x))^(0.272);
          Nu :=Buildings.Utilities.Math.Functions.smoothMax(
            x1=Nu_1,
            x2=Nu_2,
            deltaX=deltaNu);
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas=gas, T=T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in vertical window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end convectionVerticalCavity;

        function nusseltHorizontalCavityEnhanced
          "Nusselt number for horizontal cavity, bottom surface warmer than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real cosTil(min=0) "Cosine of the window tilt";
          output Real Nu(min=0) "Nusselt number";
      protected
          Real k1 "Auxiliary variable";
          Real k2 "Auxiliary variable";
          Real k11 "Auxiliary variable";
          Real k22 "Auxiliary variable";
        algorithm
          // Windows inclined from 0 to 60 deg (eqn. 3.1-42 to 3.1-43)
          k1 :=1 - 1708/Ra/cosTil;
          k2 :=(Ra*cosTil/5830)^(1/3) - 1;
          k11 :=(k1 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k1,
            x2=-k1,
            deltaX=1E-1))/2;
          k22 :=(k2 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k2,
            x2=-k2,
            deltaX=1E-1))/2;
          Nu :=1 + 1.44*k11*(1 - 1708*abs(Modelica.Math.sin(1.8*til*180/Modelica.Constants.pi))
            ^(1.6)/Ra/cosTil) + k22;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityEnhanced;

        function nusseltHorizontalCavityReduced
          "Nusselt number for horizontal cavity, bottom surface colder than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real sinTil "Sine of window tilt";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
      protected
          Real NuVer(min=0) "Nusselt number for vertical window";
        algorithm
          NuVer :=Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
            gas=gas,
            Ra=Ra,
            T_m=T_m,
            dT=dT,
            h=h,
            deltaNu=deltaNu,
            deltaRa=deltaRa);
          Nu :=1 + (NuVer - 1)*sinTil;

            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityReduced;

        function smoothInterpolation "Get interpolated data without triggering events"
          input Real y[:] "Data array";
          input Real x "x value";
          output Real val "Interpolated value";

      protected
          Integer k1 "Integer value of x";
          Integer k2 "=k1+1";
          Real y1d "Slope";
          Real y2d "Slope";
        algorithm
          k1 := integer(x);
          k2 := k1 + 1;

          y1d := (y[k2] - y[k1 - 1])/2;
          y2d := (y[k2 + 1] - y[k1])/2;
          val := Modelica.Fluid.Utilities.cubicHermite(
            x,
            k1,
            k2,
            y[k1],
            y[k2],
            y1d,
            y2d);

          annotation (
            smoothOrder=1,
            Inline=false,
            Documentation(info="<html>
<p>
Function to interpolate within a data array without triggerring events.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed function to be <code>Inline=false</code>, as otherwise
OpenModelica fails to translate
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Examples.AbsorbedRadiation\">
Buildings.HeatTransfer.Windows.BaseClasses.Examples.AbsorbedRadiation</a>.
For
<a href=\"modelica://Buildings.ThermalZones.Detailed.Examples.MixedAirFreeResponse\">
Buildings.ThermalZones.Detailed.Examples.MixedAirFreeResponse</a>,
this change does not affect the computing time.
</li>
<li>
March 4, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothInterpolation;

        partial record RadiationBaseData
          "Basic parameters for window radiation calculation"

          parameter Integer N(min=1) "Number of glass layers"
            annotation (Dialog(group="Glass"));

          final parameter Integer NSta(min=1, start=1) = size(tauGlaSol, 2)
            "Number of window states for electrochromic windows (set to 1 for regular windows)"
            annotation (Evaluate=true);

          parameter Modelica.SIunits.Length xGla[N] "Thickness of glass"
          annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.TransmissionCoefficient tauGlaSol[N, :]
            "Solar transmissivity of glass" annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_a[N, NSta]
            "Solar reflectivity of glass at surface a (facing outside)"
            annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_b[N, NSta]
            "Solar reflectivity of glass at surface b (facing room-side)"
            annotation (Dialog(group="Glass"));

          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_a
            "Solar transmissivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_b
            "Solar transmissivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_a
            "Solar reflectivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_b
            "Solar reflectivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));

          annotation (Documentation(info="<html>
<p>
Record that defines basic parameters for the window radiation calculation.
The parameter <code>NSta</code> is the number of states. Regular glass
has <code>NSta=1</code>, whereas electrochromic windows have <code>NSta &gt; 1</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter. It is needed by the calculation of property
for uncoated glass.
</li>
<li>
December 16, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationBaseData;

        record RadiationData "Radiation data of a window"
          extends Modelica.Icons.Record;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;
          final parameter Real glass[3, N, NSta]={tauGlaSol, rhoGlaSol_a, rhoGlaSol_b}
            "Glass solar transmissivity, solar reflectivity at surface a and b, at normal incident angle";
          final parameter Real traRefShaDev[2, 2]={{tauShaSol_a,tauShaSol_b},{
              rhoShaSol_a,rhoShaSol_b}} "Shading device property";
          final parameter Integer NDIR=10 "Number of incident angles";
          final parameter Integer HEM=NDIR + 1 "Index of hemispherical integration";
          final parameter Modelica.SIunits.Angle psi[NDIR]=
              Buildings.HeatTransfer.Windows.Functions.getAngle(NDIR)
            "Incident angles used for solar radiation calculation";
          final parameter Real layer[3, N, HEM, NSta]=
            Buildings.HeatTransfer.Windows.Functions.glassProperty(
              N=N,
              NSta=NSta,
              HEM=HEM,
              glass=glass,
              xGla=xGla,
              psi=psi) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity
      of each glass pane";
          final parameter Real traRef[3, N, N, HEM, NSta]=
            Buildings.HeatTransfer.Windows.Functions.getGlassTR(
              N=N,
              NSta=NSta,
              HEM=HEM,
              layer=layer) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity
      between glass panes for exterior or interior irradiation without shading";
          final parameter Real absExtIrrNoSha[N, HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
              traRef=traRef,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass pane
      for exterior irradiation without shading";
          final parameter Real absIntIrrNoSha[N, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationNoShading(
              traRef=traRef,
              N=N,
              NSta=NSta,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation without shading";
          final parameter Real winTraExtIrrExtSha[HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiatrionExteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical transmissivity of a window system (glass + exterior shading device)
     for exterior irradiation";
          final parameter Real absExtIrrExtSha[N, HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationExteriorShading(
              absExtIrrNoSha=absExtIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass pane
      for exterior irradiation with exterior shading";
          final parameter Real winTraExtIrrIntSha[HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical transmissivity of a window system (glass and interior shading device)
      for exterior irradiation";
          final parameter Real absExtIrrIntSha[N, HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationInteriorShading(
              absExtIrrNoSha=absExtIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass layer
     for exterior irradiation with interior shading";
          final parameter Real devAbsExtIrrIntShaDev[HEM, NSta]=
              Buildings.HeatTransfer.Windows.Functions.devAbsExteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Angular and hemispherical absorptivity of an interior shading device
      for exterior irradiation";
          final parameter Real winTraRefIntIrrExtSha[3, NSta]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationExteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Hemisperical transmissivity and reflectivity of a window system (glass and exterior shadig device)
      for interior irradiation. traRefIntIrrExtSha[1]: transmissivity,
      traRefIntIrrExtSha[2]: Back reflectivity; traRefIntIrrExtSha[3]: dummy value";
          final parameter Real absIntIrrExtSha[N, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationExteriorShading(
              absIntIrrNoSha=absIntIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation with exterior shading";
          final parameter Real absIntIrrIntSha[N, NSta]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationInteriorShading(
              absIntIrrNoSha=absIntIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation with interior shading";
          final parameter Real winTraRefIntIrrIntSha[3, NSta]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM) "Hemisperical transmissivity and back reflectivity of a window system (glass and interior shadig device)
      for interior irradiation";
          final parameter Real devAbsIntIrrIntSha[NSta]=
              Buildings.HeatTransfer.Windows.Functions.devAbsInteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              NSta=NSta,
              HEM=HEM)
            "Hemiperical absorptivity of an interior shading device for interior irradiation";
          annotation (Documentation(info="<html>
Record that computes the solar radiation data for a glazing system.
</html>",         revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for glassProperty(). It is needed by the calculation of property for uncoated glass.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationData;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows\">Buildings.HeatTransfer.Windows</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (
    preferredView="info", Documentation(info="<html>
<p>
This package contains models for heat transfer in windows.
</p>
</html>"));
    end Windows;

    package Data "Data for heat transfer models"
        extends Modelica.Icons.MaterialPropertiesPackage;

      package BaseClasses "Base classes for package Data"
        extends Modelica.Icons.BasesPackage;

        record Material "Thermal properties of materials w/o storage"
          extends Modelica.Icons.Record;
          parameter Modelica.SIunits.Length x "Material thickness";
          parameter Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
          parameter Modelica.SIunits.SpecificHeatCapacity c "Specific heat capacity";
          parameter Modelica.SIunits.Density d "Mass density";
          parameter Real R(unit="m2.K/W")
            "Thermal resistance of a unit area of material";
          parameter Integer nStaRef(min=0) = 3
            "Number of state variables in a reference material of 0.2 m concrete";
          parameter Integer nSta(min=1)=max(1, integer(ceil(nStaReal)))
            "Actual number of state variables in material"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean steadyState= (c < Modelica.Constants.eps or d < Modelica.Constants.eps)
            "Flag, if true, then material is computed using steady-state heat conduction"
            annotation(Evaluate=true);
          parameter Real piRef=331.4
            "Ratio x/sqrt(alpha) for reference material of 0.2 m concrete"
            annotation (Dialog(tab="Advanced"));
          parameter Real piMat=if steadyState then piRef else x*sqrt(c*d/k)
            "Ratio x/sqrt(alpha)"
            annotation(Dialog(tab="Advanced"));
          parameter Real nStaReal(min=0) = nStaRef*piMat/piRef
            "Number of states as a real number"
            annotation (Dialog(tab="Advanced"));

          parameter Modelica.SIunits.Temperature TSol
            "Solidus temperature, used only for PCM."
            annotation (Dialog(group="Properties for phase change material"));
          parameter Modelica.SIunits.Temperature TLiq
            "Liquidus temperature, used only for PCM"
            annotation (Dialog(group="Properties for phase change material"));
          parameter Modelica.SIunits.SpecificInternalEnergy LHea
            "Latent heat of phase change"
            annotation (Dialog(group="Properties for phase change material"));

          constant Boolean ensureMonotonicity = false
            "Set to true to force derivatives dT/du to be monotone";

          constant Boolean phasechange = false
            "Flag, true if the material is a phase change material"
                annotation (Dialog(group="Properties for phase change material"));

          annotation (preferredView="info",
          defaultComponentPrefixes="parameter",
          defaultComponentName="datMat",
          Documentation(info="<html>
Base record for materials that declares the thermal properties.
<br/>
<p>
The specific heat capacity can be zero, in which case the material
will be modeled as a thermal resistor that does not store energy.
</p>
<p>
Note that the thermal resistance is in units of
<i>m<sup>2</sup> K &frasl; W</i> and not <i>K &frasl; W</i>
because this record does not have the surface area as a parameter.
The surface area
will be defined in the model of the construction that uses this material.
This allows use of the same material in walls, floors
and ceilings of different surface area.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 1, 2016, by Michael Wetter:<br/>
Removed test for equality of <code>Real</code> variables.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/493\">issue 493</a>.
</li>
<li>
May 21, 2015, by Michael Wetter:<br/>
Reformulated to reduce use of the division macro
in Dymola.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/417\">issue 417</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 3 2010, by Michael Wetter:<br/>
Implemented adaptive computation of number of states based on a reference construction of <i>0.2 m</i> concrete.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Text(
                  extent={{-94,44},{-16,12}},
                  lineColor={0,0,0},
                  textString="x=%x"),
                Text(
                  extent={{8,40},{86,8}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Text(
                  extent={{-90,-58},{-12,-90}},
                  lineColor={0,0,0},
                  textString="R=%R"),
                Text(
                  extent={{-92,-10},{-14,-42}},
                  lineColor={0,0,0},
                  textString="U=%U"),
                Rectangle(
                  visible=(c == 0),
                  extent={{0,0},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,170,170},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,-50},{100,-50}}, color={0,0,0}),
                Text(
                  visible=not (c == 0),
                  extent={{8,-8},{86,-40}},
                  lineColor={0,0,0},
                  textString="d=%d"),
                Text(
                  visible=not (c == 0),
                  extent={{10,-56},{88,-88}},
                  lineColor={0,0,0},
                  textString="c=%c")}));
        end Material;
      end BaseClasses;

      package Gases
      "Package with thermophysical properties for window fill gases"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of fill gas for windows"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Length x "Gas layer thickness";
            parameter Modelica.SIunits.ThermalConductivity a_k
            "Constant coefficient for thermal conductivity";
            parameter Real b_k(unit="W/(m.K2)")
            "Temperature dependent coefficient for thermal conductivity";
            parameter Modelica.SIunits.DynamicViscosity a_mu
            "Constant coefficient for dynamic viscosity";
            parameter Real b_mu(unit="N.s/(m2.K)")
            "Temperature dependent coefficient for dynamic viscosity";
            parameter Modelica.SIunits.SpecificHeatCapacity a_c
            "Constant coefficient for specific heat capacity";
            parameter Real b_c(unit="J/(kg.K2)")
            "Temperature dependent coefficient for specific heat capacity";

            parameter Modelica.SIunits.MolarMass MM
            "Molar mass (of mixture or single fluid)";

            parameter Modelica.SIunits.Pressure P0 = 101325 "Normal pressure";

          annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datGas",
          Documentation(info="<html>
Generic record for thermophysical properties for window
gas fills.
The implementation is according to
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003,
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed <code>P0</code> from a <code>constant</code> to a
<code>parameter</code> to avoid a compilation error in
OpenModelica.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Air = Generic(a_k= 2.873E-3, b_k= 7.760E-5,
                             a_mu=3.723E-6, b_mu=4.940E-8,
                             a_c=1002.737,  b_c= 1.2324E-2,
                             MM=28.97E-3) "Thermophysical properties for air"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datGas");

       function thermalConductivity
          "Function to compute the thermal conductivity of gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
       algorithm
        k := gas.a_k + gas.b_k*T;
       end thermalConductivity;

      function density "Function to compute the mass density"
        input Buildings.HeatTransfer.Data.Gases.Generic gas "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.Density rho "Mass density";
      algorithm
          rho := gas.P0*gas.MM/Modelica.Constants.R/T;
      end density;

      function dynamicViscosity "Function to compute the dynamic viscosity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
      algorithm
          mu := gas.a_mu + gas.b_mu*T;
      end dynamicViscosity;

      function specificHeatCapacity
          "Function to compute the specific heat capacity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.SpecificHeatCapacity c_p "Specific heat capacity";
      algorithm
        c_p := gas.a_c + gas.b_c*T;
      end specificHeatCapacity;
        annotation (Documentation(info="<html>
Package with records for thermophysical properties for window
gas fills.
The implementation is according to
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003,
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Gases;

      package Glasses "Package with thermophysical properties for window glas"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window glass"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Length x=0.003 "Thickness";
         parameter Modelica.SIunits.ThermalConductivity k=1 "Thermal conductivity";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol[:] = {0.6}
            "Solar transmittance";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a[:] = {0.075}
            "Solar reflectance of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b[:] = {0.075}
            "Solar reflectance of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR = 0
            "Infrared transmissivity of glass";
         parameter Modelica.SIunits.Emissivity absIR_a = 0.84
            "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b = 0.84
            "Infrared absorptivity of surface b (usually room-facing surface)";
          annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datGla",
          Documentation(info="<html>
<p>
This record implements thermophysical properties for window glass.
See
<a href=\"modelica://Buildings.HeatTransfer.Data.Glasses\">
Buildings.HeatTransfer.Data.Glasses</a>
for instructions.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
December 09, 2011, by Wangda Zuo:<br/>
Compare the variable names with those in Window 6 and correct the variable names <i>Emis1</i> and <i>Emis2</i> in documentation.
</li>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record ID102 = Buildings.HeatTransfer.Data.Glasses.Generic (
            x=0.003,
            k=1.0,
            tauSol={0.834},
            rhoSol_a={0.075},
            rhoSol_b={0.075},
            tauIR=0,
            absIR_a=0.84,
            absIR_b=0.84) "Generic Clear Glass 3.048mm. Manufacturer: Generic."
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datGla");
      annotation(preferredView="info",
      Documentation(info="<html>
<p>
This package implements thermophysical properties for window glass.
</p>
<p>
Since the infrared transmissivity is part of the Window 6 data and since
it depends on the glass thickness, the glass thickness is a parameter
that is set for all glass layers.
This configuration is different from the records for gas properties,
which do not yet set the value for the thickness of the gas gap.
</p>
<p>
The table below compares the data of this record with the variables used in the WINDOW 6 output file.
</p>
Note that
<ul>
<li>the surface <code>a</code> is usually the outside-facing surface, and the surface
<code>b</code> is usually the room-facing surface.
</li>
<li>by the term <i>solar</i>, we mean the whole solar spectrum.
Data in the solar spectrum are used for computing solar heat gains.
</li>
<li>by the term <i>infrared</i> (or <i>infrared</i>), we mean the infrared spectrum.
Data in the infrared spectrum are used for thermal radiation that is emitted by surfaces that are
around room or ambient temperature.
</li>
<li>WINDOW 6 uses spectral data in the calculation of optical properties of window systems,
whereas the model in this library uses averages over the whole solar or infrared spectrum.
</li>
</ul>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<thead>
 <tr>
   <th>Buildings library variable name</th>
   <th>WINDOW 6 variable name</th>
 </tr>
</thead>
<tbody>
<tr>
  <td>tauSol</td>  <td>Tsol</td>
</tr>
<tr>
  <td>rhoSol_a</td>  <td>Rsol1</td>
</tr>
<tr>
  <td>rhoSol_b</td>  <td>Rsol2</td>
</tr>
<tr>
  <td>tauIR</td>  <td>Tir</td>
</tr>
<tr>
  <td>absIR_a</td>  <td>Emis1</td>
</tr>
<tr>
  <td>absIR_b</td>  <td>Emis2</td>
</tr>
</tbody>
</table>
<p>
The solar transmittance <code>tauSol</code> and the solar reflectances
<code>rhoSol_a</code> and <code>rhoSol_b</code> are vectors.
For regular glass, these vectors have only one element.
For electrochromic glass, users can enter an arbitrary number of elements,
where each element is for a particular window state.
The dimension of the three vectors <code>tauSol</code>,
<code>rhoSol_a</code> and <code>rhoSol_b</code> must be equal.
</p>
<p>
The example
<a href=\"modelica://Buildings.ThermalZones.Detailed.Examples.ElectroChromicWindow\">
Buildings.ThermalZones.Detailed.Examples.ElectroChromicWindow</a> shows
how these data can be used to darken the window.
A control signal of <code>uWin=0</code> in the room model corresponds
to the first entry of the data, which typically is the clear state,
whereas <code>uWin=1</code> corresponds to the last entry, which
typically is the dark states. For intermediate control signals,
the optical properties are interpolated using the
model
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.StateInterpolator\">
Buildings.HeatTransfer.Windows.BaseClasses.StateInterpolator</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Glasses;

      package GlazingSystems
      "Package with thermophysical properties for glazing systems"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of glazing systems"
            extends Modelica.Icons.Record;
        //  parameter Integer nLay(min=1, fixed=true) "Number of glass layers"
        //    annotation (Evaluate=true);
          parameter Boolean haveExteriorShade = false
            "Set to true if window has an exterior shade (at surface a)"
            annotation (Evaluate=true);
          parameter Boolean haveInteriorShade = false
            "Set to true if window has an interior shade (at surface b)"
            annotation (Evaluate=true);

          parameter Glasses.Generic glass[:]
            "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true,
                        Placement(transformation(extent={{60,60},{80,80}})));
          // Zero array sizes are not supported in Dymola. Therefore, we assign
          // a dummy layer. The model for heat conduction in gases will
          // write an assert if the thickness is negative.
          // Therefore, we ensure that any model overwrites this default setting.
          parameter Gases.Generic gas[:] = {Buildings.HeatTransfer.Data.Gases.Air(x=-1)}
            "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true, Placement(transformation(extent={{60,20},{80,40}})));
          parameter Shades.Generic shade "Shade"
            annotation (choicesAllMatching=true,
            Dialog(enable=haveInteriorShade or haveExteriorShade));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer UFra
            "U-value of frame";
          parameter Modelica.SIunits.Emissivity absIRFra=0.8
            "Infrared absorptivity of window frame";
          parameter Modelica.SIunits.Emissivity absSolFra=0.5
            "Solar absorptivity of window frame";
          final parameter Boolean haveShade = haveInteriorShade or haveExteriorShade
            "Parameter that is true if the construction has a shade";
          final parameter Boolean haveControllableWindow=
            Modelica.Math.BooleanVectors.anyTrue(
              {size(glass[iGla].tauSol, 1) > 1 for iGla in 1:size(glass,1)})
            "Flag, true if the window allows multiple states, such as for electrochromic windows"
            annotation(Evalute=true);
          annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datGlaSys",
            Documentation(info="<html>
Generic record that implements thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
March 13, 2015, by Michael Wetter:<br/>
Refactored model to avoid a translation error
in OpenModelica.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 15, 2013, by Michael Wetter:<br/>
Removed parameter <code>windowHasShade</code> which is redundant with <code>haveShade</code>.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record SingleClear3 =
            Buildings.HeatTransfer.Data.GlazingSystems.Generic (
               glass={Glasses.ID102()},
               UFra=3) "Single pane, clear glass 3mm"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datGlaSys");

        record DoubleClearAir13Clear =
            Buildings.HeatTransfer.Data.GlazingSystems.Generic (
            final glass={Glasses.ID102(), Glasses.ID102()},
            final gas={Gases.Air(x=0.0127)},
            UFra=1.4) "Double pane, clear glass 3mm, air 12.7, clear glass 3mm"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datGlaSys");
      annotation (preferredView="info",
      Documentation(info="<html>
Package with generic records that implement thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
May 15, 2013, by Michael Wetter:<br/>
In <a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear\">
Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear</a>,
corrected the glass layer thickness, which was <i>5.7</i> mm instead of
<i>3</i> mm, as the documentation states.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GlazingSystems;

      package OpaqueConstructions
      "Package with opaque constructions for floors, walls, etc."
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque constructions"

         parameter Integer nLay(min=1) "Number of layers";

         parameter Buildings.HeatTransfer.Data.BaseClasses.Material material[nLay]
            "Layer by layer declaration of material, starting from outside to room-side"
            annotation (choicesAllMatching=true, Evaluate=true, Placement(transformation(extent={{60,60},{80,80}})));
         final parameter Real R(unit="m2.K/W")=sum(material[i].R for i in 1:nLay)
            "Thermal resistance per unit area";
         final parameter Integer nSta[nLay](each min=1) = {material[i].nSta for i in 1:nLay}
            "Number of states in each layer"
            annotation (HideResult=true, Dialog(tab="Advanced"));
         parameter Modelica.SIunits.Emissivity absIR_a=0.9
            "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.9
            "Infrared absorptivity of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_a=0.5
            "Solar absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_b=0.5
            "Solar absorptivity of surface b (usually room-facing surface)";
         parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness_a=
            Buildings.HeatTransfer.Types.SurfaceRoughness.Medium
            "Exterior surface roughness";

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,50},{100,-100}},
                  lineColor={0,0,255},
                  fillColor={255,255,85},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,42},{-36,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Forward),
                Rectangle(
                  extent={{4,42},{54,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.CrossDiag),
                Text(
                  extent={{-127,113},{127,53}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-36,42},{4,-92}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward)}),
            defaultComponentPrefixes="parameter",
            defaultComponentName="datOpaCon",
            Documentation(info="<html>
<p>
Generic record with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.
</p>
<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>
<p>
The parameter <code>roughness_a</code> is used if the convective heat transfer
coefficient of the exterior surface is computed based on the wind-speed, wind-direction
and temperature difference. See
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 10, 2018, by Michael Wetter:<br/>
Declared <code>nSta</code> to be <code>final</code>
as the user is not supposed to change its value.
</li>
<li>
January 05, 2017, by Thierry S. Nouidui:<br/>
Added parameter <code>nSta</code> to avoid translation error
in Dymola 2107. This is a work-around for a bug in Dymola
which will be addressed in future releases.
</li>
<li>
July 1, 2013, by Michael Wetter:<br/>
Changed the annotation of the instance <code>material</code>
from
<code>Evaluate=true</code> to <code>Evaluate=false</code>.
This is required to allow changing the material properties after compilation.
Note, however, that the number of state variables in
<a href=\"modelica://Buildings.HeatTransfer.Data.BaseClasses.Material\">
Buildings.HeatTransfer.Data.BaseClasses.Material</a>
are only computed when the model is translated, because
the number of state variables is fixed at compilation time.
</li>
<li>
March 13, 2013, by Michael Wetter:<br/>
Replaced <code>Buildings.HeatTransfer.Data.Solids.Generic</code>
with
<code>Buildings.HeatTransfer.Data.OpaqueConstructions.Generic</code>
to allow use of phase change material.
</li>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end Generic;

        record Brick120 =
            Buildings.HeatTransfer.Data.OpaqueConstructions.Generic (
              material={Solids.Brick(x=0.12)},
              final nLay=1) "Construction with 120mm brick"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datOpaCon");
        annotation (preferredView="info",
      Documentation(info="<html>
<p>
Package with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.
</p>
<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueConstructions;

      package OpaqueSurfaces
      "Package with thermophysical properties for opaque surfaces"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque surfaces"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Area A "Area";
         parameter Modelica.SIunits.Angle til
            "Surface tilt (0: ceiling, pi/2: wall, pi: floor";
         parameter Modelica.SIunits.Emissivity absIR=0.84 "Infrared absorptivity";
         parameter Modelica.SIunits.Emissivity absSol=0.84 "Solar absorptivity";
         final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
            "Flag, true if construction is a floor" annotation (Evaluate=true);

         annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datOpaSur",
          Documentation(info="<html>
<p>
This record implements thermophysical properties for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;
        annotation (
      preferredView="info",
      Documentation(info="<html>
<p>
Package with records for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueSurfaces;

      package Resistances "Package with thermal resistances"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of heat resistances"
            extends Buildings.HeatTransfer.Data.BaseClasses.Material(
            final c=0,
            final d=0,
            final k=0,
            final x=0,
            final nStaRef=0,
            final nSta=1,
            final steadyState=true,
            final TSol=293.15,
            final TLiq=293.15,
            final LHea=0,
            final phasechange=false);

          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,50},{100,-100}},
                  fillColor={255,255,127},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}), Text(
                  extent={{-98,-72},{96,-94}},
                  lineColor={0,0,255},
                  textString="R=%R")}),
          defaultComponentPrefixes="parameter",
          defaultComponentName="datTheRes",
          Documentation(info=
                         "<html>
Generic record for thermal properties of
heat resistances.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Carpet = Buildings.HeatTransfer.Data.Resistances.Generic (R=0.2165) "Carpet"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datTheRes");
      annotation (
      Documentation(info="<html>
Package with records that implement thermal properties of
heat resistances.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Resistances;

      package Shades "Package with thermophysical properties for window shades"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window shades"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_a=0.1
            "Solar transmissivity of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_b=0.1
            "Solar transmissivity of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a=0.8
            "Solar reflection coefficient of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b=0.8
            "Solar reflection coefficient of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.Emissivity absIR_a=0.84
            "Infrared absorptivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.84
            "Infrared absorptivity of surface b (surface that faces the glass)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_a=0
            "Infrared transmissivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_b=0
            "Infrared transmissivity of surface b (surface that faces the glass)";

          annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datSha",
          Documentation(info="<html>
Records that implements thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Gray=Buildings.HeatTransfer.Data.Shades.Generic (
            tauSol_a = 0.25,
            tauSol_b = 0.25,
            rhoSol_a = 0.25,
            rhoSol_b = 0.25,
            absIR_a = 0.25,
            absIR_b = 0.25) "Gray"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSha");
      annotation (
      preferredView="info",
      Documentation(info="<html>
Package with records that implement thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Shades;

      package Solids
      "Package with solid material, characterized by thermal conductance, density and specific heat capacity"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of solids with heat storage"
            extends Buildings.HeatTransfer.Data.BaseClasses.Material(final R=x/k,
                                                                     final TSol=293.15,
                                                                     final TLiq=293.15,
                                                                     final LHea=0,
                                                                     final phasechange=false);
          annotation (
          defaultComponentPrefixes="parameter",
          defaultComponentName="datSol",
          Documentation(info="<html>
<p>
Generic record for solid materials.
The material is characterized by its
thermal conductivity, mass density and specific
heat capacity.
</p>
</html>", revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Brick = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.89,
            d=1920,
            c=790) "Brick (k=0.89)"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSol");

        record Concrete = Buildings.HeatTransfer.Data.Solids.Generic (
            k=1.4,
            d=2240,
            c=840) "Concrete (k=1.4)"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSol");

        record Glass = Buildings.HeatTransfer.Data.Solids.Generic (
            k=1.0,
            d=2500,
            c=700) "Glass"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSol");

        record GypsumBoard = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.16,
            d=800,
            c=1090) "Gypsum board (k=0.58)"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSol");

        record Plywood = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.12,
            d=540,
            c=1210) "Plywood (k=0.12)"
          annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="datSol");
      annotation (
      Documentation(
      info="<html>
<p>
Package with records for solid materials.
The material is characterized by its
thermal conductivity, mass density and specific
heat capacity.
</p>
<p>
These material records automatically compute the spatial grid
that is used to compute transient heat conduction.
In building materials, the thermal diffusivity of adjacent layer materials can differ by an order of magnitude. If the spatial grid generation were not to account for the material properties, then the time rate of change of the different temperature nodes would be significantly different from each other.
Therefore, records in the packages
<a href=\"Buildings.HeatTransfer.Data.Solids\">
Buildings.HeatTransfer.Data.Solids</a>
and
<a href=\"Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>
generate the spatial grid so that under the assumption of equal heat transfer, each node temperature has a similar time rate of change.
</p>
<p>
The computation is as follows:
</p>
<p>
From dimensionless analysis, one can obtain a characteristic time, called the <em>Fourier</em> number, as
</p>
<p align=\"center\" style=\"font-style:italic;\">
Fo = &alpha; t &frasl; L<sup>2</sup>
</p>
<p>
where <i>&alpha;</i> denotes the thermal diffusivity, <i>t</i> denotes time and <i>L</i> denotes the characteristic length.
We like to generate the spatial grid so that the ratio
<i>t &frasl; Fo</i>
is equal to an arbitrary constant
<i>&Pi;</i>, which we define as
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Pi; = ( t &frasl; Fo )<sup>1/2</sup>
</p>

<p>and hence</p>

<p align=\"center\" style=\"font-style:italic;\">
&Pi; = L &frasl; &radic; &alpha;.
</p>

<p>
Now, let <i>x</i>
denote the thickness of the material layer.
Then, we compute the time constant of the material layer as
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Pi;<sub>x</sub> = x &frasl; &radic; &alpha;,
</p>
<p>
and we compute the estimated number of elements <i>N' &isin; &#8477;</i>
for the material layer as</p>

<p align=\"center\" style=\"font-style:italic;\">
N' = N<sub>ref</sub> &Pi;<sub>x</sub> &frasl; &Pi;<sub>ref</sub>
</p>

<p>
where <i>&Pi;<sub>ref</sub> &isin; &#8469;</i> is a user-specified number of elements
for a reference material, which is equal to the parameter
<code>nStaRef</code>, and defined as a concrete construction with thickness
<i>L<sub>ref</sub> = 0.20</i> meter and thermal diffusivity
<i>&alpha;<sub>ref</sub> = 3.64E-7</i> m<sup>2</sup>/s.
Hence,
<i>&Pi;<sub>ref</sub> = L<sub>ref</sub>/ &radic; &alpha;<sub>ref</sub> = 331.4</i>
&radic;s.
</p>

<p>
Next, we define the number of elements for the material layer as
<p align=\"center\" style=\"font-style:italic;\">
<i>N<sub>x</sub> = &lceil;  N' &rceil;</i>
</p>

<p>
where the notation <i>&lceil; &#8901; &rceil;</i> is defined, for
<i>s &isin; &#8477;</i>, as
<p align=\"center\" style=\"font-style:italic;\">
&lceil; s &rceil; = min{ k &isin; &#8484; | k &ge; s }.
</p>
<p>
Finally, we divide the material layer in compartments of length
<i>&Delta; = x &frasl; N<sub>x</sub></i>.
</p>

</html>",
      revisions="<html>
<ul>
<li>
October 31, 2016, by Michael Wetter:<br/>
Added thermal properties of glass.
</li>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Solids;
      annotation (Documentation(info="<html>
Package with thermal properties of solid materials.
</html>"));
    end Data;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type ExteriorConvection = enumeration(
        Fixed   "Fixed coefficient (a user-specified parameter is used)",
        TemperatureWind   "Wind speed and temperature dependent")
        "Enumeration defining the convective heat transfer model for exterior surfaces"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for exterior (outside-side facing) surfaces.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type InteriorConvection = enumeration(
        Fixed   "Fixed coefficient (a user-specified parameter is used)",
        Temperature   "Temperature dependent")
        "Enumeration defining the convective heat transfer model for interior surfaces"
        annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for interior (room-side facing) surfaces.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SurfaceRoughness = enumeration(
        VeryRough   "Very rough",
        Rough   "Rough",
        Medium   "Medium rough",
        MediumSmooth   "Medium smooth",
        Smooth   "Smooth",
        VerySmooth   "Very smooth") "Enumeration defining the surface roughness"
        annotation (Documentation(info="<html>
<p>
This enumeration is used to define the surface roughness
which may be used to compute the convective heat transfer coefficients of
building construction.
</p>
<p>
The surface roughness will be used to compute the
wind-driven convective heat transfer coefficient in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
The possible surface roughness are
</p>
<table summary=\"summary\" border=\"1\">
<tr>
<th>Roughness index</th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>     <td>Stucco</td></tr>
<tr><td>Rough</td>         <td>Brick</td></tr>
<tr><td>MediumRough</td>   <td>Concrete</td></tr>
<tr><td>MediumSmooth</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>        <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>    <td>Glass</td></tr>
</table>
</html>",
        revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for heat transfer models"
      extends Modelica.Icons.InterfacesPackage;

      connector RadiosityInflow = input Real(min=0, final unit="W", nominal=419)
        "Connector for inflowing radiosity"
        annotation(defaultComponentName = "JIn", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                    Text(
              extent={{-38,120},{38,100}},
              lineColor={0,127,0},
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid,
              textString="%name"),                              Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Removed <code>flow</code> attribute as this violates the Modelica Language Standard.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
September 3, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      connector RadiosityOutflow = output Real(min=0, final unit="W", nominal=419)
        "Connector for outflowing radiosity"
        annotation(defaultComponentName = "JOut", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                                       Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-42,122},{34,102}},
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="%name")}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Removed <code>flow</code> attribute as this violates the Modelica Language Standard.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
September 3, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains interfaces for the heat transfer models.
</html>"));
    end Interfaces;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for heat transfer elements.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}),
  graphics={
        Polygon(
          origin = {13.758,27.517},
          lineColor = {128,128,128},
          fillColor = {192,192,192},
          fillPattern = FillPattern.Solid,
          points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
      Polygon(
          origin = {13.758,27.517},
          fillColor = {160,160,164},
          fillPattern = FillPattern.Solid,
          points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {160,160,164},
          fillColor = {192,192,192},
          fillPattern = FillPattern.Solid,
          points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
        Polygon(
          origin = {13.758,27.517},
          fillColor = {160,160,164},
          fillPattern = FillPattern.Solid,
          points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {191,0,0},
          fillColor = {191,0,0},
          fillPattern = FillPattern.Solid,
          points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
        Line(
          origin = {13.758,27.517},
          points = {{-41,-17},{-9,-17}},
          color = {191,0,0},
          thickness = 0.5),
        Line(
          origin = {13.758,27.517},
          points = {{-17,-40},{15,-40}},
          color = {191,0,0},
          thickness = 0.5),
        Polygon(
          origin = {13.758,27.517},
          lineColor = {191,0,0},
          fillColor = {191,0,0},
          fillPattern = FillPattern.Solid,
          points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}));
  end HeatTransfer;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package Air
      "Package with moist air model that decouples pressure and temperature"
      extends Modelica.Media.Interfaces.PartialCondensingGases(
         mediumName="Air",
         final substanceNames={"water", "air"},
         final reducedX=true,
         final singleState = false,
         reference_X={0.01,0.99},
         final fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                                 Modelica.Media.IdealGases.Common.FluidData.N2},
         reference_T=273.15,
         reference_p=101325,
         AbsolutePressure(start=p_default),
         Temperature(start=T_default));
      extends Modelica.Icons.Package;

      constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";
      constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

      // In the assignments below, we compute cv as OpenModelica
      // cannot evaluate cv=cp-R as defined in GasProperties.
      constant GasProperties dryair(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.Air.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
        cp =   Buildings.Utilities.Psychrometrics.Constants.cpAir,
        cv =   Buildings.Utilities.Psychrometrics.Constants.cpAir
                 -Modelica.Media.IdealGases.Common.SingleGasesData.Air.R)
        "Dry air properties";
      constant GasProperties steam(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
        cp =   Buildings.Utilities.Psychrometrics.Constants.cpSte,
        cv =   Buildings.Utilities.Psychrometrics.Constants.cpSte
                 -Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R)
        "Steam properties";

      constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

      constant Modelica.SIunits.MolarMass[2] MMX={steam.MM,dryair.MM}
        "Molar masses of components";

      constant AbsolutePressure pStp = reference_p
        "Pressure for which fluid density is defined";
      constant Density dStp = 1.2 "Fluid density at pressure pStp";

      // Redeclare ThermodynamicState to avoid the warning
      // "Base class ThermodynamicState is replaceable"
      // during model check
      redeclare record extends ThermodynamicState
        "ThermodynamicState record for moist air"
      end ThermodynamicState;
      // There must not be any stateSelect=StateSelect.prefer for
      // the pressure.
      // Otherwise, translateModel("Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ResistanceVolume")
      // will fail as Dymola does an index reduction and outputs
      //   Differentiated the equation
      //   vol.dynBal.medium.p+res.dp-inlet.p = 0.0;
      //   giving
      //   der(vol.dynBal.medium.p)+der(res.dp) = der(inlet.p);
      //
      //   The model requires derivatives of some inputs as listed below:
      //   1 inlet.m_flow
      //   1 inlet.p
      // Therefore, the statement
      //   p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
      // has been removed.
      redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"

      parameter Boolean preferredMediumStates=false
        "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
        annotation (Evaluate=true, Dialog(tab="Advanced"));
      final parameter Boolean standardOrderComponents=true
        "If true, and reducedX = true, the last element of X will be computed from the other ones";

      InputAbsolutePressure p "Absolute pressure of medium";
      InputMassFraction[1] Xi(
        start=reference_X[1:1],
        each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
        "Structurally independent mass fractions";
      InputSpecificEnthalpy h "Specific enthalpy of medium";
      Modelica.Media.Interfaces.Types.Density d "Density of medium";
      Modelica.Media.Interfaces.Types.Temperature T(
       stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
       "Temperature of medium";
      Modelica.Media.Interfaces.Types.MassFraction[2] X(start=reference_X)
        "Mass fractions (= (component mass)/total mass  m_i/m)";
      Modelica.Media.Interfaces.Types.SpecificInternalEnergy u
        "Specific internal energy of medium";
      Modelica.Media.Interfaces.Types.SpecificHeatCapacity R
        "Gas constant (of mixture if applicable)";
      Modelica.Media.Interfaces.Types.MolarMass MM
        "Molar mass (of mixture or single fluid)";
      ThermodynamicState state
        "Thermodynamic state record for optional functions";

      Modelica.SIunits.Conversions.NonSIunits.Temperature_degC T_degC=
        Modelica.SIunits.Conversions.to_degC(T) "Temperature of medium in [degC]";
      Modelica.SIunits.Conversions.NonSIunits.Pressure_bar p_bar=
        Modelica.SIunits.Conversions.to_bar(p) "Absolute pressure of medium in [bar]";

      // Local connector definition, used for equation balancing check
      connector InputAbsolutePressure = input Modelica.SIunits.AbsolutePressure
        "Pressure as input signal connector";
      connector InputSpecificEnthalpy = input Modelica.SIunits.SpecificEnthalpy
        "Specific enthalpy as input signal connector";
      connector InputMassFraction = input Modelica.SIunits.MassFraction
        "Mass fraction as input signal connector";

        // Declarations for Air only
    protected
      Modelica.SIunits.TemperatureDifference dT(start=T_default-reference_T)
        "Temperature difference used to compute enthalpy";

      equation
        MM = 1/(X[1]/steam.MM+(X[2])/dryair.MM);

        dT = T - reference_T;
        h = dT*dryair.cp * X[2] +
           (dT * steam.cp + h_fg) * X[1];
        R = dryair.R*X[2] + steam.R*X[1];

        // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
        // u = h-R*T;
        // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
        // u= h-p*v = h-p/d = h-pStp/dStp
        u = h-pStp/dStp;

        // In this medium model, the density depends only
        // on temperature, but not on pressure.
        //  d = p/(R*T);
        d/dStp = p/pStp;

        state.p = p;
        state.T = T;
        state.X = X;

        X[1] = Xi[1];
        X[2] = 1 - X[1];

        // Assertions to test for bounds
        assert(noEvent(X[1] >= -1.e-5) and noEvent(X[1] <= 1 + 1.e-5), "Mass fraction X[1] = " + String(X[1]) + " of substance water"
          + "\nof medium \"Buildings.Media.Air\" is not in the range 0..1");

        assert(noEvent(T >= 200.0), "In "   + getInstanceName() + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \"Buildings.Media.Air\".");
        assert(noEvent(T <= 423.15), "In "   + getInstanceName() + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \"Buildings.Media.Air\".");

      assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"Buildings.Media.Air\" is negative\n(Temperature = " + String(T) + " K)");
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}), Text(
              extent={{-152,164},{152,102}},
              textString="%name",
              lineColor={0,0,255})}), Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>",     revisions="<html>
<ul>
<li>
September 22, 2020, by Michael Wetter:<br/>
First implementation based on Modelica Standard Library,
but with <code>noEvent</code> added to check of bounds.
</li>
</ul>
</html>"));
      end BaseProperties;

    redeclare function density "Gas density"
      extends Modelica.Icons.Function;
      input ThermodynamicState state;
      output Density d "Density";
    algorithm
      d :=state.p*dStp/pStp;
      annotation(smoothOrder=5,
      Inline=true,
      Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
    end density;

    redeclare function extends dynamicViscosity
        "Return the dynamic viscosity of dry air"
    algorithm
      eta := 4.89493640395e-08 * state.T + 3.88335940547e-06;
      annotation (
      smoothOrder=99,
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the dynamic viscosity.
</p>
<h4>Implementation</h4>
<p>
The function is based on the 5th order polynomial
of
<a href=\"modelica://Modelica.Media.Air.MoistAir.dynamicViscosity\">
Modelica.Media.Air.MoistAir.dynamicViscosity</a>.
However, for the typical range of temperatures encountered
in building applications, a linear function sufficies.
This implementation is therefore the above 5th order polynomial,
linearized around <i>20</i>&deg;C.
The relative error of this linearization is
<i>0.4</i>% at <i>-20</i>&deg;C,
and less then
<i>0.2</i>% between  <i>-5</i>&deg;C and  <i>+50</i>&deg;C.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 19, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end dynamicViscosity;

    redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "steam enthalpy";
    algorithm
      h := (T-reference_T) * steam.cp + h_fg;
      annotation(smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfCondensingGas);
    end enthalpyOfCondensingGas;

    redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
    algorithm
      h := enthalpyOfCondensingGas(T)*X[Water]
           + enthalpyOfDryAir(T)*(1.0-X[Water]);
    annotation (
      Inline=true);
    end enthalpyOfGas;

    redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"
    algorithm
      h := (T - reference_T)*cpWatLiq;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfLiquid);
    end enthalpyOfLiquid;

    redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "enthalpy";
    algorithm
      h := enthalpyOfDryAir(T);
      annotation (
      smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfNonCondensingGas);
    end enthalpyOfNonCondensingGas;

    redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
    algorithm
      r0 := h_fg;
      annotation (
        Inline=true);
    end enthalpyOfVaporization;

    redeclare function extends gasConstant
        "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

    algorithm
        R := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
      annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
    end gasConstant;

    redeclare function extends pressure
        "Returns pressure of ideal gas as a function of the thermodynamic state record"

    algorithm
      p := state.p;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end pressure;

    redeclare function extends isobaricExpansionCoefficient
        "Isobaric expansion coefficient beta"
    algorithm
      beta := 0;
      annotation (
        smoothOrder=5,
        Inline=true,
    Documentation(info="<html>
<p>
This function returns the isobaric expansion coefficient at constant pressure,
which is zero for this medium.
The isobaric expansion coefficient at constant pressure is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&beta;<sub>p</sub> = - 1 &frasl; v &nbsp; (&part; v &frasl; &part; T)<sub>p</sub> = 0,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isobaricExpansionCoefficient;

    redeclare function extends isothermalCompressibility
        "Isothermal compressibility factor"
    algorithm
      kappa := -1/state.p;
      annotation (
        smoothOrder=5,
        Inline=true,
        Documentation(info="<html>
<p>
This function returns the isothermal compressibility coefficient.
The isothermal compressibility is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&kappa;<sub>T</sub> = -1 &frasl; v &nbsp; (&part; v &frasl; &part; p)<sub>T</sub>
  = -1 &frasl; p,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isothermalCompressibility;

    redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

    algorithm
      psat := Buildings.Utilities.Psychrometrics.Functions.saturationPressure(Tsat);
      annotation (
      smoothOrder=5,
      Inline=true);
    end saturationPressure;

    redeclare function extends specificEntropy
        "Return the specific entropy, only valid for phi<1"

    protected
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
    algorithm
        Y := massToMoleFractions(
             state.X, {steam.MM,dryair.MM});
        s := specificHeatCapacityCp(state) * Modelica.Math.log(state.T/reference_T)
             - Modelica.Constants.R *
             sum(state.X[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)*state.p/reference_p) for i in 1:2);
      annotation (
      Inline=true,
        Documentation(info="<html>
<p>
This function computes the specific entropy.
</p>
<p>
The specific entropy of the mixture is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = s<sub>s</sub> + s<sub>m</sub>,
</p>
<p>
where
<i>s<sub>s</sub></i> is the entropy change due to the state change
(relative to the reference temperature) and
<i>s<sub>m</sub></i> is the entropy change due to mixing
of the dry air and water vapor.
</p>
<p>
The entropy change due to change in state is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(v/v<sub>0</sub>) <br/>
= c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(&rho;<sub>0</sub>/&rho;)
</p>
<p>If we assume <i>&rho; = p<sub>0</sub>/(R T)</i>,
and because <i>c<sub>p</sub> = c<sub>v</sub> + R</i>,
we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(T/T<sub>0</sub>) <br/>
=c<sub>p</sub> ln(T/T<sub>0</sub>).
</p>
<p>
Next, the entropy of mixing is obtained from a reversible isothermal
expansion process. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  s<sub>m</sub> = -R &sum;<sub>i</sub>( X<sub>i</sub> &frasl; M<sub>i</sub>
  ln(Y<sub>i</sub> p/p<sub>0</sub>)),
</p>
<p>
where <i>R</i> is the gas constant,
<i>X</i> is the mass fraction,
<i>M</i> is the molar mass, and
<i>Y</i> is the mole fraction.
</p>
<p>
To obtain the state for a given pressure, entropy and mass fraction, use
<a href=\"modelica://Buildings.Media.Air.setState_psX\">
Buildings.Media.Air.setState_psX</a>.
</p>
<h4>Limitations</h4>
<p>
This function is only valid for a relative humidity below 100%.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end specificEntropy;

    redeclare function extends density_derp_T
        "Return the partial derivative of density with respect to pressure at constant temperature"
    algorithm
      ddpT := dStp/pStp;
      annotation (
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to pressure at constant temperature.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derp_T;

    redeclare function extends density_derT_p
        "Return the partial derivative of density with respect to temperature at constant pressure"
    algorithm
      ddTp := 0;

      annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info=
    "<html>
<p>
This function computes the derivative of density with respect to temperature
at constant pressure.
</p>
</html>",     revisions=
    "<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derT_p;

    redeclare function extends density_derX
        "Return the partial derivative of density with respect to mass fractions at constant pressure and temperature"
    algorithm
      dddX := fill(0, nX);
    annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to mass fraction.
This value is zero because in this medium, density is proportional
to pressure, but independent of the species concentration.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derX;

    redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
    algorithm
      cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation (
      smoothOrder=99,
      Inline=true,
      derivative=der_specificHeatCapacityCp);
    end specificHeatCapacityCp;

    redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
    algorithm
      cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
      annotation (
        smoothOrder=99,
        Inline=true,
        derivative=der_specificHeatCapacityCv);
    end specificHeatCapacityCv;

    redeclare function setState_dTX
        "Return thermodynamic state as function of density d, temperature T and composition X"
      extends Modelica.Icons.Function;
      input Density d "Density";
      input Temperature T "Temperature";
      input MassFraction X[:]=reference_X "Mass fractions";
      output ThermodynamicState state "Thermodynamic state";

    algorithm
        // Note that d/dStp = p/pStp, hence p = d*pStp/dStp
        state := if size(X, 1) == nX then
                   ThermodynamicState(p=d*pStp/dStp, T=T, X=X)
                 else
                   ThermodynamicState(p=d*pStp/dStp,
                                      T=T,
                                      X=cat(1, X, {1 - sum(X)}));
        annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
<p>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">thermodynamic state record</a>
    is computed from density <code>d</code>, temperature <code>T</code> and composition <code>X</code>.
</p>
</html>"));
    end setState_dTX;

    redeclare function extends setState_phX
        "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
    algorithm
      state := if size(X, 1) == nX then
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=X)
     else
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=cat(1, X, {1 - sum(X)}));
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
    end setState_phX;

    redeclare function extends setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
    algorithm
        state := if size(X, 1) == nX then
                    ThermodynamicState(p=p, T=T, X=X)
                 else
                    ThermodynamicState(p=p, T=T, X=cat(1, X, {1 - sum(X)}));
        annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
    end setState_pTX;

    redeclare function extends setState_psX
        "Return the thermodynamic state as function of p, s and composition X or Xi"
    protected
        Modelica.SIunits.MassFraction[2] X_int "Mass fraction";
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
        Modelica.SIunits.Temperature T "Temperature";
    algorithm
        if size(X, 1) == nX then
          X_int:=X;
        else
          X_int :=cat(
            1,
            X,
            {1 - sum(X)});
        end if;
       Y := massToMoleFractions(
             X_int, {steam.MM,dryair.MM});
        // The next line is obtained from symbolic solving the
        // specificEntropy function for T.
        // In this formulation, we can set T to any value when calling
        // specificHeatCapacityCp as cp does not depend on T.
        T := 273.15 * Modelica.Math.exp((s + Modelica.Constants.R *
               sum(X_int[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)) for i in 1:2))
                 / specificHeatCapacityCp(setState_pTX(p=p,
                                                       T=273.15,
                                                       X=X_int)));

        state := ThermodynamicState(p=p,
                                    T=T,
                                    X=X_int);

    annotation (
    Inline=true,
    Documentation(info="<html>
<p>
This function returns the thermodynamic state based on pressure,
specific entropy and mass fraction.
</p>
<p>
The state is computed by symbolically solving
<a href=\"modelica://Buildings.Media.Air.specificEntropy\">
Buildings.Media.Air.specificEntropy</a>
for temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end setState_psX;

    redeclare replaceable function extends specificEnthalpy
        "Compute specific enthalpy from pressure, temperature and mass fraction"
    algorithm
      h := (state.T - reference_T)*dryair.cp * (1 - state.X[Water]) +
           ((state.T-reference_T) * steam.cp + h_fg) * state.X[Water];
      annotation (
       smoothOrder=5,
       Inline=true);
    end specificEnthalpy;

    redeclare replaceable function specificEnthalpy_pTX "Specific enthalpy"
      extends Modelica.Icons.Function;
      input Modelica.SIunits.Pressure p "Pressure";
      input Modelica.SIunits.Temperature T "Temperature";
      input Modelica.SIunits.MassFraction X[:] "Mass fractions of moist air";
      output Modelica.SIunits.SpecificEnthalpy h "Specific enthalpy at p, T, X";

    algorithm
      h := specificEnthalpy(setState_pTX(p, T, X));
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(T=temperature_phX(p, h, X)),
                 Documentation(info="<html>
Specific enthalpy as a function of temperature and species concentration.
The pressure is input for compatibility with the medium models, but the specific enthalpy
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end specificEnthalpy_pTX;

    redeclare replaceable function extends specificGibbsEnergy
        "Specific Gibbs energy"
    algorithm
      g := specificEnthalpy(state) - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificGibbsEnergy;

    redeclare replaceable function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
    algorithm
      f := specificEnthalpy(state) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificHelmholtzEnergy;

    redeclare function extends isentropicEnthalpy "Return the isentropic enthalpy"
    algorithm
      h_is := specificEnthalpy(setState_psX(
                p=p_downstream,
                s=specificEntropy(refState),
                X=refState.X));
    annotation (
      Inline=true,
      Documentation(info="<html>
<p>
This function computes the specific enthalpy for
an isentropic state change from the temperature
that corresponds to the state <code>refState</code>
to <code>reference_T</code>.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isentropicEnthalpy;

    redeclare function extends specificInternalEnergy "Specific internal energy"
      extends Modelica.Icons.Function;
    algorithm
      u := specificEnthalpy(state) - pStp/dStp;
      annotation (
        Inline=true);
    end specificInternalEnergy;

    redeclare function extends temperature
        "Return temperature of ideal gas as a function of the thermodynamic state record"
    algorithm
      T := state.T;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end temperature;

    redeclare function extends molarMass "Return the molar mass"
    algorithm
        MM := 1/(state.X[Water]/MMX[Water]+(1.0-state.X[Water])/MMX[Air]);
        annotation (
    Inline=true,
    smoothOrder=99,
    Documentation(info="<html>
<p>
This function returns the molar mass.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end molarMass;

    redeclare replaceable function temperature_phX
        "Compute temperature from specific enthalpy and mass fraction"
        extends Modelica.Icons.Function;
      input AbsolutePressure p "Pressure";
      input SpecificEnthalpy h "specific enthalpy";
      input MassFraction[:] X "mass fractions of composition";
      output Temperature T "temperature";
    algorithm
      T := reference_T + (h - h_fg * X[Water])
           /((1 - X[Water])*dryair.cp + X[Water] * steam.cp);
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(h=specificEnthalpy_pTX(p, T, X)),
                 Documentation(info="<html>
Temperature as a function of specific enthalpy and species concentration.
The pressure is input for compatibility with the medium models, but the temperature
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end temperature_phX;

    redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
    algorithm
      lambda := Modelica.Media.Incompressible.TableBased.Polynomials_Temp.evaluate(
          {(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
       Modelica.SIunits.Conversions.to_degC(state.T));
    annotation(LateInline=true);
    end thermalConductivity;
    //////////////////////////////////////////////////////////////////////
    // Protected classes.
    // These classes are only of use within this medium model.
    // Models generally have no need to access them.
    // Therefore, they are made protected. This also allows to redeclare the
    // medium model with another medium model that does not provide an
    // implementation of these classes.
  protected
      record GasProperties
        "Coefficient data record for properties of perfect gases"
        extends Modelica.Icons.Record;

        Modelica.SIunits.MolarMass MM "Molar mass";
        Modelica.SIunits.SpecificHeatCapacity R "Gas constant";
        Modelica.SIunits.SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
        Modelica.SIunits.SpecificHeatCapacity cv = cp-R
          "Specific heat capacity at constant volume";
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2014, by Michael Wetter:<br/>
Corrected the wrong location of the <code>preferredView</code>
and the <code>revisions</code> annotation.
</li>
<li>
November 21, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GasProperties;

      constant Modelica.SIunits.SpecificEnergy h_fg=
        Buildings.Utilities.Psychrometrics.Constants.h_fg
        "Latent heat of evaporation of water";
      constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq=
        Buildings.Utilities.Psychrometrics.Constants.cpWatLiq
        "Specific heat capacity of liquid water";

    replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of liquid enthalpy";
    algorithm
      der_h := cpWatLiq*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfLiquid;

    function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := steam.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfCondensingGas;

    replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;

      input Temperature T "Temperature";
      output SpecificEnthalpy h "Dry air enthalpy";
    algorithm
      h := (T - reference_T)*dryair.cp;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfDryAir);
    end enthalpyOfDryAir;

    replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of dry air enthalpy";
    algorithm
      der_h := dryair.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfDryAir;

    replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := der_enthalpyOfDryAir(T, der_T);
      annotation (
        Inline=true);
    end der_enthalpyOfNonCondensingGas;

    replaceable function der_specificHeatCapacityCp
        "Derivative of specific heat capacity of gas mixture at constant pressure"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cp(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCp;

    replaceable function der_specificHeatCapacityCv
        "Derivative of specific heat capacity of gas mixture at constant volume"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cv(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCv;
      annotation(Documentation(info="<html>
<p>
This medium package models moist air using a gas law in which pressure and temperature
are independent, which often leads to significantly faster and more robust computations.
The specific heat capacities at constant pressure and at constant volume are constant.
The air is assumed to be not saturated.
</p>
<p>
This medium uses the gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho;/&rho;<sub>stp</sub> = p/p<sub>stp</sub>,
</p>
<p>
where
<i>p<sub>std</sub></i> and <i>&rho;<sub>stp</sub></i> are constant reference
temperature and density, rathern than the ideal gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho; = p &frasl;(R T),
</p>
<p>
where <i>R</i> is the gas constant and <i>T</i> is the temperature.
</p>
<p>
This formulation often leads to smaller systems of nonlinear equations
because equations for pressure and temperature are decoupled.
Therefore, if air inside a control volume such as room air is heated, it
does not increase its specific volume. Consequently, merely heating or cooling
a control volume does not affect the air flow calculations in a duct network
that may be connected to that volume.
Note that multizone air exchange simulation in which buoyancy drives the
air flow is still possible as the models in
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a> compute the mass density using the function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.density_pTX\">
Buildings.Utilities.Psychrometrics.Functions.density_pTX</a> in which density
is a function of temperature.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
<p>
where
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
<p>
from which follows that
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
<p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C and no water vapor is present.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
January 11, 2019 by Michael Wetter:<br/>
Reforulated assignment of <code>X_int</code> in <code>setState_psX</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1079\">#1079</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
November 4, 2016, by Michael Wetter:<br/>
Set default value for <code>dT.start</code> in base properties.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/575\">#575</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>.
Note that the default is <code>preferredMediumState=false</code>
and hence the same states are used as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
May 11, 2015, by Michael Wetter:<br/>
Removed
<code>p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)</code>
in declaration of <code>BaseProperties</code>.
Otherwise, when models that contain a fluid volume
are exported as an FMU, their pressure would be
differentiated with respect to time. This would require
the time derivative of the inlet pressure, which is not available,
causing the translation to stop with an error.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
March 20, 2015, by Michael Wetter:<br/>
Added missing term <code>state.p/reference_p</code> in function
<code>specificEntropy</code>.
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/193\">#193</a>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
Changed implementation to use
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Constants\">
Buildings.Utilities.Psychrometrics.Constants</a>.
This was done to use consistent values throughout the library.
</li>
<li>
November 16, 2013, by Michael Wetter:<br/>
Revised and simplified the implementation.
</li>
<li>
November 14, 2013, by Michael Wetter:<br/>
Removed function
<code>HeatCapacityOfWater</code>
which is neither needed nor implemented in the
Modelica Standard Library.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed non-used computations in <code>specificEnthalpy_pTX</code> and
in <code>temperature_phX</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...)</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
August 3, 2011, by Michael Wetter:<br/>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases.
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br/>
Added implementation of function
<a href=\"modelica://Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
            Ellipse(
              extent={{-78,78},{-34,34}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-18,86},{26,42}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{48,58},{92,14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-22,32},{22,-12}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{36,-32},{80,-76}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-36,-30},{8,-74}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-90,-6},{-46,-50}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120})}));
    end Air;

    package Water "Package with model for liquid water with constant density"
       extends Modelica.Media.Water.ConstantPropertyLiquidWater(
         p_default=300000,
         reference_p=300000,
         reference_T=273.15,
         reference_X={1},
         AbsolutePressure(start=p_default),
         Temperature(start=T_default),
         Density(start=d_const),
         final cv_const=cp_const);
      // cp_const and cv_const have been made final because the model sets u=h.
      extends Modelica.Icons.Package;

      redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        final parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.SIunits.Density d=d_const "Density of medium";
        Temperature T(stateSelect=
          if preferredMediumStates then StateSelect.prefer else StateSelect.default)
          "Temperature of medium";
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi=fill(0, 0)
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Modelica.SIunits.SpecificInternalEnergy u
          "Specific internal energy of medium";

        Modelica.SIunits.MassFraction[nX] X={1}
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        final Modelica.SIunits.SpecificHeatCapacity R=0
          "Gas constant (of mixture if applicable)";
        final Modelica.SIunits.MolarMass MM=MM_const
          "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";


        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        Modelica.SIunits.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input
          Modelica.SIunits.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input
          Modelica.SIunits.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input Modelica.SIunits.MassFraction
          "Mass fraction as input signal connector";

      equation
        h = cp_const*(T-reference_T);
        u = h;
        state.T = T;
        state.p = p;

        // Assertions to test for bounds
        assert(noEvent(T >= T_min), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its minimum allowed value of " +
      String(T_min-273.15) + " degC (" + String(T_min) + " Kelvin) as required from medium model \"Buildings.Media.Water\".");

        assert(noEvent(T <= T_max), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its maximum allowed value of " +
      String(T_max-273.15) + " degC (" + String(T_max) + " Kelvin) as required from medium model \"Buildings.Media.Water\".");

        assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"Buildings.Media.Water\" is negative\n(Temperature = " + String(T) + " K)");

        annotation(Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This base properties model is identical to
<a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
except that the equation
<code>u = cv_const*(T - reference_T)</code>
has been replaced by <code>u=h</code> because
<code>cp_const=cv_const</code>.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>"));
      end BaseProperties;

    function enthalpyOfLiquid "Return the specific enthalpy of liquid"
      extends Modelica.Icons.Function;
      input Modelica.SIunits.Temperature T "Temperature";
      output Modelica.SIunits.SpecificEnthalpy h "Specific enthalpy";
    algorithm
      h := cp_const*(T-reference_T);
    annotation (
      smoothOrder=5,
      Inline=true,
    Documentation(info="<html>
<p>
Enthalpy of the water.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 16, 2014 by Michael Wetter:<br/>
First implementation.
This function is used by
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</li>
</ul>
</html>"));
    end enthalpyOfLiquid;
      annotation(Documentation(info="<html>
<p>
This medium package models liquid water.
</p>
<p>
The mass density is computed using a constant value of <i>995.586</i> kg/s.
For a medium model in which the density is a function of temperature, use
<a href=\"modelica://Buildings.Media.Specialized.Water.TemperatureDependentDensity\">
Buildings.Media.Specialized.Water.TemperatureDependentDensity</a> which may have considerably higher computing time.
</p>
<p>
For the specific heat capacities at constant pressure and at constant volume,
a constant value of <i>4184</i> J/(kg K), which corresponds to <i>20</i>&deg;C
is used.
The figure below shows the relative error of the specific heat capacity that
is introduced by this simplification.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Media/Water/plotCp.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
Water is modeled as an incompressible liquid.
There are no phase changes.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
Buildings.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
(if used with water instead of air)
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure and density.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Changed type of <code>BaseProperties.T</code> from
<code>Modelica.SIunits.Temperature</code> to <code>Temperature</code>.
Otherwise, it has a different start value than <code>Medium.T</code>, which
causes an error if
<a href=\"Buildings.Media.Examples.WaterProperties\">
Buildings.Media.Examples.WaterProperties</a>
is translated in pedantic mode.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>,
and set <code>preferredMediumState=false</code>
to keep the same states as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Removed <code>ThermodynamicState</code> declaration as this lead to
the error
\"Attempting to redeclare record ThermodynamicState when the original was not replaceable.\"
in Dymola 2016 using the pedantic model check.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
February 25, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect</code> attribute on pressure as this caused
<a href=\"modelica://Buildings.Examples.Tutorial.SpaceCooling.System3\">
Buildings.Examples.Tutorial.SpaceCooling.System3</a>
to fail with the error message
\"differentiated if-then-else was not continuous\".
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Reimplemented media based on
<a href=\"https://github.com/ibpsa/modelica-ibpsa/blob/446aa83720884052476ad6d6d4f90a6a29bb8ec9/Buildings/Media/Water.mo\">446aa83</a>.
</li>
<li>
November 15, 2013, by Michael Wetter:<br/>
Complete new reimplementation because the previous version
had the option to add a compressibility to the medium, which
has never been used.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Polygon(
              points={{16,-28},{32,-42},{26,-48},{10,-36},{16,-28}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Polygon(
              points={{10,34},{26,44},{30,36},{14,26},{10,34}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{-82,52},{24,-54}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={0,0,0}),
            Ellipse(
              extent={{22,82},{80,24}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{20,-30},{78,-88}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95})}));
    end Water;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package ThermalZones "Models for BuildingPhysics"
      extends Modelica.Icons.Package;

    package Detailed "Package with models for rooms"
      extends Modelica.Icons.Package;

      model MixedAir "Model of a room in which the air is completely mixed"
        extends Buildings.ThermalZones.Detailed.BaseClasses.RoomHeatMassBalance(
        redeclare Buildings.ThermalZones.Detailed.BaseClasses.MixedAirHeatMassBalance air(
          final energyDynamics=energyDynamics,
          final massDynamics = massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final mSenFac=mSenFac,
          final m_flow_nominal=m_flow_nominal,
          final homotopyInitialization=homotopyInitialization,
          final conMod=intConMod,
          final hFixed=hIntFixed,
          final use_C_flow = use_C_flow),
          datConExt(
            each T_a_start = T_start,
            each T_b_start = T_start),
          datConExtWin(
            each T_a_start = T_start,
            each T_b_start = T_start),
          datConBou(
            each T_a_start = T_start,
            each T_b_start = T_start),
          datConPar(
            each T_a_start = T_start,
            each T_b_start = T_start));

        ////////////////////////////////////////////////////////////////////////////
        // Media declaration. This is identical to
        // Buildings.Fluid.Interfaces.LumpedVolumeDeclarations, except
        // that the comments have been changed to avoid a confusion about
        // what energyDynamics refers to.
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        // Ports
        parameter Boolean use_C_flow=false
          "Set to true to enable input connector for trace substance that is connected to room air"
          annotation (Dialog(group="Ports"));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance for zone air: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Zone air"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance for zone air: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Zone air"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance for zone air: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Zone air"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance for zone air: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Zone air"));

        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the zone air volume"
          annotation(Dialog(tab="Dynamics", group="Zone air"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of zone air pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of zone air temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of zone air mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of zone air trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of zone air trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

        ////////////////////////////////////////////////////////////////////////////
        // Input connectors
        Modelica.Blocks.Interfaces.RealInput uSha[nConExtWin](each min=0, each max=1) if
             haveShade
          "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-300,160},{-260,200}}),
              iconTransformation(extent={{-232,164},{-200,196}})));

        Modelica.Blocks.Interfaces.RealInput C_flow[Medium.nC] if use_C_flow
          "Trace substance mass flow rate added to the room air. Enable if use_C_flow = true"
          annotation (Placement(transformation(extent={{-300,-130},{-260,-90}}),
              iconTransformation(extent={{-232,12},{-200,44}})));

      equation
        connect(uSha, conExtWin.uSha) annotation (Line(
            points={{-280,180},{308,180},{308,62},{281,62}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, bouConExtWin.uSha) annotation (Line(
            points={{-280,180},{308,180},{308,64},{351,64}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, conExtWinRad.uSha) annotation (Line(
            points={{-280,180},{422,180},{422,-40},{310.2,-40},{310.2,-25.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(irRadGai.uSha,uSha)
          annotation (Line(
            points={{-100.833,-22.5},{-110,-22.5},{-110,180},{-280,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, radTem.uSha) annotation (Line(
            points={{-280,180},{-110,180},{-110,-62},{-100.833,-62},{-100.833,-62.5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, shaSig.u) annotation (Line(
            points={{-280,180},{-248,180},{-248,160},{-222,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(air.uSha,uSha)  annotation (Line(
            points={{39.6,-120},{8,-120},{8,180},{-280,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(C_flow, air.C_flow) annotation (Line(points={{-280,-110},{-200,-110},{
                -200,-114},{-200,-114},{-200,-202},{-18,-202},{-18,-141},{39,-141}},
              color={0,0,127}));
        annotation (
          Documentation(info="<html>
<p>
Room model that assumes the air to be completely mixed.
</p>
<p>
See
<a href=\"modelica://Buildings.ThermalZones.Detailed.UsersGuide\">Buildings.ThermalZones.Detailed.UsersGuide</a>
for detailed explanations.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 8, 2019, by Michael Wetter:<br/>
Propagated parameter <code>mSenFac</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1405\">Buildings #1405</a>.
</li>
<li>
September 8, 2017, by Michael Wetter:<br/>
Enabled input connector <code>C_flow</code> to allow adding trace substances.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/481\">issue 481</a>.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Removed inheritance from
<a href=\"modelica://Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>
to provide better comments.
</li>
<li>
May 2, 2016, by Michael Wetter:<br/>
Refactored implementation of latent heat gain.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/515\">issue 515</a>.
</li>
<li>
February 12, 2015, by Michael Wetter:<br/>
Propagated initial states to the fluid volume.
</li>
<li>
August 1, 2013, by Michael Wetter:<br/>
Introduced base class
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.RoomHeatMassBalance\">
Buildings.ThermalZones.Detailed.BaseClasses.RoomHeatMassBalance</a>
as the latent heat gains are treated differently in the mixed air and in the CFD model.
</li>
<li>
July 16, 2013, by Michael Wetter:<br/>
Redesigned implementation to remove one level of model hierarchy on the room-side heat and mass balance.
This change was done to facilitate the implementation of non-uniform room air heat and mass balance,
which required separating the convection and long-wave radiation models.<br/>
Changed assignment
<code>solRadExc(tauGla={0.6 for i in 1:NConExtWin})</code> to
<code>solRadExc(tauGla={datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol for i in 1:NConExtWin})</code> to
better take into account the solar properties of the glass.
</li>
<li>
March 7 2012, by Michael Wetter:<br/>
Added optional parameters <code>ove</code> and <code>sidFin</code> to
the parameter <code>datConExtWin</code>.
This allows modeling windows with an overhang or with side fins.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for conExtWinRad. It is needed by the claculation of property for uncoated glass.
</li>
<li>
December 6, 2011, by Michael Wetter:<br/>
Fixed bug that caused convective heat gains to be
removed from the room instead of added to the room.
This error was caused by a wrong sign in
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.HeatGain\">
Buildings.ThermalZones.Detailed.BaseClasses.HeatGain</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/46\">issue 46</a>.
</li>
<li>
August 9, 2011, by Michael Wetter:<br/>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and the parameter <code>absIRFra</code> to the
model
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/36\">issue 36</a>.
</li>
<li>
August 9, 2011 by Michael Wetter:<br/>
Changed assignment of tilt in instances <code>bouConExt</code> and <code>bouConExtWin</code>.
This fixes the bug in <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/35\">issue 35</a>
that led to the wrong solar radiation gain for roofs and floors.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Propagated convection model to exterior boundary condition models.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,-200},
                  {200,200}}), graphics={
              Text(
                extent={{-198,198},{-122,166}},
                lineColor={0,0,127},
                textString="uSha"),
              Text(
                extent={{-190,44},{-128,14}},
                lineColor={0,0,127},
                textString="C_flow",
                visible=use_C_flow)}));
      end MixedAir;

      package Constructions
      "Package with models for constructions that are used in the room model"
        extends Modelica.Icons.VariantsPackage;

        model Construction "Model for an opaque construction that has no window"
          extends
          Buildings.ThermalZones.Detailed.Constructions.BaseClasses.PartialConstruction(
            final AOpa=A);

          annotation (
        defaultComponentName="conOpa",
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                    {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-300,-300},{300,300}}), graphics={
                Rectangle(
                  extent={{-290,202},{298,198}},
                  lineColor={0,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{0,260},{60,60}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,260},{0,60}},
                  lineColor={0,0,0},
                  fillColor={183,183,121},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-80,260},{-56,60}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-56,260},{-70,274},{-18,274},{0,260},{-56,260}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={183,183,121},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-80,260},{-88,274},{-70,274},{-56,260},{-80,260}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,260},{-18,274},{40,274},{60,260},{0,260}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-88,274},{-88,82},{-80,60},{-80,260},{-88,274}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(
            info="<html>
This model is used to compute heat transfer through opaque constructions inside the
room model.
The model uses the record <code>layers</code> to access the material properties
of the opaque construction. The heat transfer is computed in the instance
<code>opa</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a>.
</html>",
        revisions="<html>
<ul>
<li>
December 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Construction;

        model ConstructionWithWindow
          "Model for an opaque construction that has one window embedded in the construction"
          extends
          Buildings.ThermalZones.Detailed.Constructions.BaseClasses.PartialConstruction(
            final AOpa=A-AWin);

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.Area AWin "Heat transfer area of window"
              annotation (Dialog(group="Glazing system"));
          parameter Real fFra(
            min=0,
            max=1) = 0.1 "Fraction of window frame divided by total window area"
            annotation (Dialog(group="Glazing system"));
          final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
            annotation (Dialog(group="Glazing system"));
          final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
            annotation (Dialog(group="Glazing system"));
          parameter Boolean linearizeRadiation = true
            "Set to true to linearize emissive power"
            annotation (Dialog(group="Glazing system"));

          parameter Boolean steadyStateWindow = false
            "Set to false to add thermal capacity at window, which generally leads to faster simulation"
            annotation (Dialog(group="Glazing system"));

         replaceable parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
            "Material properties of glazing system"
            annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{140,80},
                    {160,100}})));

          HeatTransfer.Windows.Window win(
            final glaSys=glaSys,
            final A=AWin,
            final fFra=fFra,
            final linearize = linearizeRadiation,
            final steadyState = steadyStateWindow,
            final til=til,
            final homotopyInitialization=homotopyInitialization) "Window model"
            annotation (Placement(transformation(extent={{-114,-184},{112,42}})));

          HeatTransfer.Interfaces.RadiosityOutflow JOutUns_a
            "Outgoing radiosity that connects to unshaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
                iconTransformation(extent={{-300,-30},{-320,-10}})));
          HeatTransfer.Interfaces.RadiosityInflow JInUns_a
            "Incoming radiosity that connects to unshaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
                iconTransformation(extent={{-320,10},{-300,30}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutSha_a if haveShade
            "Outgoing radiosity that connects to shaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
                iconTransformation(extent={{-300,-210},{-320,-190}})));
          HeatTransfer.Interfaces.RadiosityInflow JInSha_a if haveShade
            "Incoming radiosity that connects to shaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
                iconTransformation(extent={{-320,-170},{-300,-150}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
            "Heat port at unshaded glass of exterior-facing surface"
                                                            annotation (Placement(transformation(extent={{-310,
                    -90},{-290,-70}}), iconTransformation(extent={{-310,-90},{-290,
                    -70}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
            "Heat port at shaded glass of exterior-facing surface"
            annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}),
                iconTransformation(extent={{-310,-130},{-290,-110}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
            "Heat port at frame of exterior-facing surface"
             annotation (Placement(transformation(extent={{-310,
                    -270},{-290,-250}}), iconTransformation(extent={{-310,-270},{-290,
                    -250}})));
          Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
               haveShade
            "Control signal for the shading device, 0: unshaded; 1: fully shaded (removed if no shade is present)"
            annotation (Placement(transformation(extent={{-340,40},{-300,80}}),
                iconTransformation(extent={{-340,40},{-300,80}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutUns_b
            "Outgoing radiosity that connects to unshaded part of glass at room-side"
            annotation (Placement(transformation(extent={{300,10},{320,30}}),
                iconTransformation(extent={{300,10},{320,30}})));
          HeatTransfer.Interfaces.RadiosityInflow JInUns_b
            "Incoming radiosity that connects to unshaded part of glass at room-side"
            annotation (Placement(transformation(extent={{320,-30},{300,-10}}),
                iconTransformation(extent={{320,-30},{300,-10}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutSha_b if haveShade
            "Outgoing radiosity that connects to shaded part of glass at room-side"
            annotation (Placement(transformation(extent={{300,-170},{320,-150}}),
                iconTransformation(extent={{300,-170},{320,-150}})));
          HeatTransfer.Interfaces.RadiosityInflow JInSha_b if haveShade
            "Incoming radiosity that connects to shaded part of glass at room-side"
            annotation (Placement(transformation(extent={{320,-210},{300,-190}}),
                iconTransformation(extent={{320,-210},{300,-190}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
            "Heat port at unshaded glass of room-facing surface"
            annotation (Placement(transformation(extent={{290,-90},
                    {310,-70}}), iconTransformation(extent={{290,-90},{310,-70}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
            "Heat port at shaded glass of room-facing surface"
          annotation (Placement(transformation(extent={{290,-130},{310,-110}}),
                iconTransformation(extent={{290,-130},{310,-110}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
            "Heat port at frame of room-facing surface"
            annotation (Placement(transformation(extent={{292,-270},{312,-250}}), iconTransformation(extent={{292,-270},{312,-250}})));

          Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[size(glaSys.glass, 1)](
            each unit="W",
            each quantity="Power") "Solar radiation absorbed by unshaded part of glass"
                                                               annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-40,-320}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-80,-320})));
          Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[size(glaSys.glass, 1)](
            each unit="W",
            each quantity="Power") if haveShade
            "Solar radiation absorbed by shaded part of glass"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={100,-320}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-320})));

      protected
          final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
            "Parameter, equal to true if the window has a shade"
            annotation(Evaluate=true);

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(win.uSha, uSha) annotation (Line(
              points={{-125.3,19.4},{-178.75,19.4},{-178.75,60},{-320,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(JInUns_a, win.JInUns_a) annotation (Line(
              points={{-310,20},{-200,20},{-200,-3.2},{-119.65,-3.2}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(JOutUns_a, win.JOutUns_a) annotation (Line(
              points={{-310,-20},{-220,-20},{-220,-25.8},{-119.65,-25.8}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(win.glaUns_a, glaUns_a) annotation (Line(
              points={{-114,-59.7},{-200,-59.7},{-200,-80},{-300,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.glaSha_a, glaSha_a) annotation (Line(
              points={{-114,-82.3},{-180,-82.3},{-180,-120},{-300,-120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.JInSha_a, JInSha_a) annotation (Line(
              points={{-119.65,-104.9},{-162,-104.9},{-162,-160},{-310,-160}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(win.JOutSha_a, JOutSha_a) annotation (Line(
              points={{-119.65,-127.5},{-139.375,-127.5},{-139.375,-200},{-310,-200}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(win.fra_a, fra_a) annotation (Line(
              points={{-114,-161.4},{-128,-161.4},{-128,-260},{-300,-260}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.JOutUns_b, JOutUns_b) annotation (Line(
              points={{117.65,-3.2},{225.375,-3.2},{225.375,20},{310,20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(win.JInUns_b, JInUns_b) annotation (Line(
              points={{117.65,-25.8},{233.375,-25.8},{233.375,-20},{310,-20}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(win.glaUns_b, glaUns_b) annotation (Line(
              points={{112,-59.7},{239,-59.7},{239,-80},{300,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.glaSha_b, glaSha_b) annotation (Line(
              points={{112,-82.3},{220,-82.3},{220,-120},{300,-120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.JOutSha_b, JOutSha_b) annotation (Line(
              points={{117.65,-104.9},{201.375,-104.9},{201.375,-160},{310,-160}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(win.JInSha_b, JInSha_b) annotation (Line(
              points={{117.65,-127.5},{178.375,-127.5},{178.375,-200},{310,-200}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(win.fra_b, fra_b) annotation (Line(
              points={{113.13,-161.4},{159.675,-161.4},{159.675,-260},{302,-260}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(opa.port_a, opa_a)                 annotation (Line(
              points={{-52,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(opa.port_b, opa_b)                 annotation (Line(
              points={{52,200},{302,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(win.QAbsUns_flow, QAbsUns_flow) annotation (Line(
              points={{-46.2,-195.3},{-46.2,-280},{-40,-280},{-40,-320}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(win.QAbsSha_flow, QAbsSha_flow) annotation (Line(
              points={{44.2,-195.3},{44.2,-280},{100,-280},{100,-320}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,
                    -300},{300,300}})),
                                  Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-300,-300},{300,300}}), graphics={
                Rectangle(
                  extent={{-290,202},{298,198}},
                  lineColor={0,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  visible = glaSys.haveInteriorShade,
                  points={{48,60},{48,-40},{116,-104},{116,-4},{48,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.CrossDiag,
                  fillColor={215,215,215}),
                Line(
                  points={{-74,-188},{28,-188}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{28,60},{28,-188},{90,-252},{90,-4},{28,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{38,38},{38,-184},{78,-224},{78,-4},{38,38}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-102,60},{48,60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{-20,60},{-20,-188},{42,-252},{42,-4},{-20,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-10,38},{-10,-184},{30,-224},{30,-4},{-10,38}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-74,60},{-74,-188},{-12,-252},{-12,-4},{-74,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-64,36},{-64,-186},{-24,-226},{-24,-6},{-64,36}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  visible = glaSys.haveExteriorShade,
                  points={{-102,60},{-102,-40},{-34,-104},{-34,-4},{-102,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.CrossDiag,
                  fillColor={215,215,215}),
                Line(
                  points={{-34,-4},{116,-4}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{56,-80},{290,-80}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{-290,-80},{-56,-80}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{-294,-120},{-44,-120}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{60,-120},{296,-120}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{-60,-200},{-60,-260}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{84,-218},{84,-260}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{84,-260},{302,-260}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Line(
                  visible = glaSys.haveExteriorShade,
                  points={{-292,-260},{-60,-260}},
                  color={160,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-62,270},{-44,156}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Rectangle(
                  extent={{42,270},{60,156}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Rectangle(
                  extent={{8,276},{68,76}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-48,276},{8,76}},
                  lineColor={0,0,0},
                  fillColor={183,183,121},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-72,276},{-48,76}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-48,276},{-62,290},{-10,290},{8,276},{-48,276}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={183,183,121},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-72,276},{-80,290},{-62,290},{-48,276},{-72,276}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{8,276},{-10,290},{48,290},{68,276},{8,276}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-80,290},{-80,98},{-72,76},{-72,276},{-80,290}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                                       Ellipse(
                  extent={{-222,68},{-160,4}},
                  lineColor={255,255,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Sphere)}),
        defaultComponentName="conWin",
        Documentation(revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Added optional capacity at the room-facing surface
to reduce the dimension of the nonlinear system of equations,
which generally decreases computing time.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 25, 2014, by Michael Wetter:<br/>
Propagated parameter <code>homotopyInitialization</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This model is used to compute heat transfer through constructions with windows inside the
room model.
</p>
<p>
The model consists of the following two main submodels:
</p>
<ul>
<li>
The instance <code>opa</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> to compute
the heat transfer through the opaque part of the construction.
This model uses the record <code>layers</code> to access the material properties
of the opaque construction.
</li>
<li>
The instance <code>win</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a> to compute
the heat transfer through the glazing system.
This model uses the record <code>glaSys</code> to access the material properties
of the glazing system.
</li>
</ul>
<p>
The parameter <code>A</code> is the area of the opaque construction plus the window.
The parameter <code>AWin</code> is the area of the glazing system, including the frame.
The area of the opaque construction is assigned internally as <code>AOpa=A-AWin</code>.
</p>
</html>"));
        end ConstructionWithWindow;

        package BaseClasses
        "Package with base classes for Buildings.ThermalZones.Detailed.Constructions"
          extends Modelica.Icons.BasesPackage;

          partial model PartialConstruction
            "Partial model for exterior construction that has no window"

            parameter Modelica.SIunits.Area A "Heat transfer area";
            parameter Modelica.SIunits.Area AOpa
              "Heat transfer area of opaque construction"
              annotation (Dialog(group="Opaque construction"));

            parameter Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
              layers "Material properties of opaque construction"
              annotation(Dialog(group="Opaque construction"),
                         choicesAllMatching=true, Placement(transformation(extent={{146,258},
                      {166,278}})));

            parameter Modelica.SIunits.Angle til "Surface tilt";

            final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
              "Flag, true if construction is a floor" annotation (Evaluate=true);
            final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
              "Flag, true if construction is a floor" annotation (Evaluate=true);

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a
              "Heat port at surface a of opaque construction"
              annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b opa_b
              "Heat port at surface b of opaque construction"
              annotation (Placement(transformation(extent={{292,190},{312,210}})));

            final parameter Integer nLay(min=1, fixed=true) = size(layers.material, 1)
              "Number of layers";
            final parameter Integer nSta[nLay](each min=1)=
              {layers.material[i].nSta for i in 1:nLay} "Number of states"
                                  annotation(Evaluate=true);
            parameter Boolean steadyStateInitial=false
              "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                  annotation (Dialog(group="Initialization"), Evaluate=true);
            parameter Modelica.SIunits.Temperature T_a_start=293.15
              "Initial temperature at port_a, used if steadyStateInitial = false"
              annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
            parameter Modelica.SIunits.Temperature T_b_start=293.15
              "Initial temperature at port_b, used if steadyStateInitial = false"
              annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

            parameter Boolean stateAtSurface_a=true
              "=true, a state will be at the surface a"
              annotation (Dialog(tab="Dynamics"),
                          Evaluate=true);
            parameter Boolean stateAtSurface_b=true
              "=true, a state will be at the surface b"
              annotation (Dialog(tab="Dynamics"),
                          Evaluate=true);

            HeatTransfer.Conduction.MultiLayer opa(
              final A=AOpa,
              final layers=layers,
              final steadyStateInitial=steadyStateInitial,
              final stateAtSurface_a = stateAtSurface_a,
              final stateAtSurface_b = stateAtSurface_b,
              final T_a_start=T_a_start,
              final T_b_start=T_b_start)
              "Model for heat transfer through opaque construction"
              annotation (Placement(transformation(extent={{-52,148},{52,252}})));

          equation
            connect(opa.port_a, opa_a) annotation (Line(
                points={{-52,200},{-300,200}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(opa.port_b, opa_b) annotation (Line(
                points={{52,200},{302,200}},
                color={191,0,0},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                      {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                    extent={{-300,-300},{300,300}}), graphics={
                  Rectangle(
                    extent={{-290,202},{298,198}},
                    lineColor={0,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-70,254},{-52,140}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward),
                  Polygon(
                    points={{2,208},{4,208},{6,204},{8,198},{8,194},{6,188},{0,184},{-4,180},
                        {-12,178},{-16,182},{-22,188},{-24,198},{-22,204},{-20,208},{-18,210},
                        {-16,212},{-12,214},{-8,214},{-2,212},{2,208}},
                    lineColor={0,0,0},
                    smooth=Smooth.None,
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{34,254},{52,140}},
                    lineColor={0,0,0},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward),
                  Text(
                    extent={{-314,336},{286,302}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(info="<html>
<p>
This is the base class that is used to model opaque constructions in the room model.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
October 29, 2016, by Michael Wetter:<br/>
Propagated parameters for optionally adding states at the surface.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PartialConstruction;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.ThermalZones.Detailed.Constructions\">Buildings.ThermalZones.Detailed.Constructions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (
        preferredView="info", Documentation(info="<html>
This package contains models for constructions that are
used in the room model.
</html>"));
      end Constructions;

      package Types "Package with type definitions"
        extends Modelica.Icons.TypesPackage;

        type CFDBoundaryConditions = enumeration(
          Temperature   "Temperature specified",
          HeatFlowRate   "Heat flow rate specified")
          "Enumeration to define boundary conditions for the CFD simulation";
      annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
      end Types;

      package BaseClasses
      "Package with base classes for Buildings.ThermalZones.Detailed"
        extends Modelica.Icons.BasesPackage;

        model ExteriorBoundaryConditions
          "Model for convection and radiation bounary condition of exterior constructions"
          parameter Integer nCon(min=1) "Number of exterior constructions"
          annotation (Dialog(group="Exterior constructions"));
          parameter Modelica.SIunits.Angle lat "Latitude";

          parameter Boolean linearizeRadiation
            "Set to true to linearize emissive power";

          replaceable parameter ParameterConstruction conPar[nCon] constrainedby
          ParameterConstruction   "Records for construction"
            annotation (Placement(transformation(extent={{174,-214},{194,-194}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a[nCon]
            "Heat port at surface a of opaque construction"
            annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
          parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
          Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
            "Convective heat transfer model for opaque part of the constructions"
            annotation (Dialog(group="Convective heat transfer"));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=10.0
            "Constant convection coefficient for opaque part of the constructions"
            annotation (Dialog(group="Convective heat transfer",
                               enable=(conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));

          // The convection coefficients are not final to allow a user to individually
          // assign them.
          // We reassign the tilt since a roof has been declared in the room model as the
          // ceiling (of the room)
          HeatTransfer.Convection.Exterior conOpa[nCon](
            A=AOpa,
            final til=Modelica.Constants.pi*ones(nCon) .- conPar[:].til,
            final azi=conPar[:].azi,
            each conMod=conMod,
            each hFixed=hFixed) "Convection model for opaque part of the wall"
            annotation (Placement(transformation(extent={{-180,160},{-140,200}})));

          SkyRadiationExchange skyRadExc(
            final n=nCon,
            final A=AOpa,
            final absIR=conPar[:].layers.absIR_a,
            vieFacSky={(Modelica.Constants.pi - conPar[i].til)./Modelica.Constants.pi for i in 1:nCon})
            "Infrared radiative heat exchange with sky"
            annotation (Placement(transformation(extent={{-140,240},{-180,280}})));
          BoundaryConditions.WeatherData.Bus weaBus
            annotation (Placement(transformation(extent={{234,32},{254,52}}),
                iconTransformation(extent={{192,-10},{254,52}})));

          BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil[
                    nCon](
            each final lat=lat,
            final til=conPar[:].til,
            final azi=conPar[:].azi) "Direct solar irradiation on the surface"
            annotation (Placement(transformation(extent={{220,120},{200,140}})));
          BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil[nCon](
            each final lat=lat,
            final til=conPar[:].til,
            final azi=conPar[:].azi) "Diffuse solar irradiation"
            annotation (Placement(transformation(extent={{220,80},{200,100}})));
          Modelica.Blocks.Math.Add HTotConExt[nCon](
            final k1=conPar[:].layers.absSol_a .* AOpa,
            final k2=conPar[:].layers.absSol_a .* AOpa) "Total solar irradiation"
            annotation (Placement(transformation(extent={{40,100},{20,120}})));
          Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConExt[nCon]
            "Total solar heat gain of the surface"
            annotation (Placement(transformation(extent={{0,100},{-20,120}})));

      protected
          parameter Modelica.SIunits.Area AOpa[nCon]=conPar[:].A
            "Area of opaque construction";

          Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExt[
            nCon] "Outside air temperature for exterior constructions"
            annotation (Placement(transformation(extent={{8,160},{-32,200}})));
          Modelica.Blocks.Routing.Replicator repConExt(nout=nCon) "Signal replicator"
            annotation (Placement(transformation(extent={{100,170},{80,190}})));

          Modelica.Blocks.Routing.Replicator repConExt1(
                                                       nout=nCon) "Signal replicator"
            annotation (Placement(transformation(extent={{130,200},{110,220}})));
          Modelica.Blocks.Routing.Replicator repConExt2(
                                                       nout=nCon) "Signal replicator"
            annotation (Placement(transformation(extent={{180,220},{160,240}})));

        equation
          connect(conOpa.solid, opa_a) annotation (Line(
              points={{-180,180},{-240,180},{-240,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(skyRadExc.port, opa_a) annotation (Line(
              points={{-180,260},{-212,260},{-212,260},{-240,260},{-240,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(TAirConExt.port, conOpa.fluid) annotation (Line(
              points={{-32,180},{-140,180}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(repConExt.y, TAirConExt.T) annotation (Line(
              points={{79,180},{12,180}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExt.u, weaBus.TDryBul) annotation (Line(
              points={{102,180},{244,180},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(skyRadExc.TOut, weaBus.TDryBul) annotation (Line(
              points={{-136,252},{244,252},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(skyRadExc.TBlaSky, weaBus.TBlaSky) annotation (Line(
              points={{-136,268},{244,268},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          for i in 1:nCon loop
          connect(weaBus, HDirTil[i].weaBus) annotation (Line(
              points={{244,42},{244,130},{220,130}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(HDifTil[i].weaBus, weaBus) annotation (Line(
              points={{220,90},{244,90},{244,42}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
           end for;
          connect(HTotConExt.y, solHeaGaiConExt.Q_flow) annotation (Line(
              points={{19,110},{5.55112e-16,110}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(solHeaGaiConExt.port, opa_a) annotation (Line(
              points={{-20,110},{-240,110},{-240,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(HDirTil.H, HTotConExt.u1) annotation (Line(
              points={{199,130},{60,130},{60,116},{42,116}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDifTil.H, HTotConExt.u2) annotation (Line(
              points={{199,90},{60,90},{60,104},{42,104}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExt2.u, weaBus.winDir) annotation (Line(
              points={{182,230},{244,230},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(repConExt1.u, weaBus.winSpe) annotation (Line(
              points={{132,210},{244,210},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(repConExt1.y, conOpa.v) annotation (Line(
              points={{109,210},{-194,210},{-194,200},{-184,200}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExt2.y, conOpa.dir) annotation (Line(
              points={{159,230},{-200,230},{-200,190},{-184,190}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                    {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-300,-300},{300,300}}), graphics={
                Rectangle(
                  extent={{-160,280},{280,-250}},
                  fillColor={230,243,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                                       Ellipse(
                  extent={{164,262},{270,162}},
                  lineColor={255,255,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Sphere),
                Rectangle(
                  extent={{-220,280},{-160,-280}},
                  lineColor={0,0,0},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-160,-250},{280,-280}},
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-168,346},{212,280}},
                  lineColor={0,0,255},
                  textString="%name")}),
                Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions.
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
In this model, the solar radiation data are converted from horizontal irradiation to
irradiation on tilted surfaces using models from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">
Buildings.BoundaryConditions.SolarIrradiation</a>.
The convective heat transfer between the exterior surface of the opaque constructions
is computed using
<a href=\"modelica://Buildings.HeatTransfer.Convection\">
Buildings.HeatTransfer.Convection</a>.
</p>
<p>
The heat transfer of windows are not computed in this model. They are implemented in
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 9, 2011 by Michael Wetter:<br/>
Changed assignment of tilt in instance <code>conOpa</code>.
This fixes the bug in <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/35\">issue 35</a>
that led to the wrong solar radiation gain for roofs and floors.
(Since the tilt has been changed in the model
<a href=\"modelica://Buildings.ThermalZones.Detailed.MixedAir\">
Buildings.ThermalZones.Detailed.MixedAir</a> at the place where it makes an instance of this model,
the change in the tilt parameter of the convective heat transfer model was required.)
</li>
<li>
March 28, 2011, by Michael Wetter:<br/>
Propaged parameter <code>hFixed</code> to top-level of the model.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Removed default value for convection model.
</li>
<li>
November 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ExteriorBoundaryConditions;

        model ExteriorBoundaryConditionsWithWindow
          "Model for exterior boundary conditions for constructions with a window"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditions(
           final AOpa=conPar[:].AOpa,
           redeclare Buildings.ThermalZones.Detailed.BaseClasses.ParameterConstructionWithWindow conPar);

          final parameter Modelica.SIunits.Area AWin[nCon] = conPar[:].hWin .* conPar[:].wWin
            "Window area"
            annotation (Dialog(group="Glazing system"));

          final parameter Boolean haveExteriorShade[nCon] = conPar[:].glaSys.haveExteriorShade
            "Set to true if window has exterior shade (at surface a)"
            annotation (Dialog(group="Shading"));
          final parameter Boolean haveInteriorShade[nCon] = conPar[:].glaSys.haveInteriorShade
            "Set to true if window has interior shade (at surface b)"
            annotation (Dialog(group="Shading"));

          final parameter Boolean haveShade=
            Modelica.Math.BooleanVectors.anyTrue(haveExteriorShade) or
            Modelica.Math.BooleanVectors.anyTrue(haveInteriorShade)
            "Set to true if window system has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);

          final parameter Boolean haveOverhangOrSideFins=
            Modelica.Math.BooleanVectors.anyTrue(conPar.haveOverhangOrSideFins)
            "Flag, true if the room has at least one window with either an overhang or side fins";

          Buildings.HeatTransfer.Windows.FixedShade sha[nCon](
            final conPar=conPar,
            each lat=lat,
            azi=conPar.azi) if
               haveOverhangOrSideFins "Shade due to overhang or side fins"
            annotation (Placement(transformation(extent={{140,100},{120,120}})));

          Modelica.Blocks.Interfaces.RealInput uSha[nCon](
            each min=0,
            each max=1) if haveShade
            "Control signal for the shading device, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-340,80},{-300,120}}),
                iconTransformation(extent={{-340,80},{-300,120}})));

          Modelica.Blocks.Interfaces.RealInput QAbsSolSha_flow[nCon](
            each final unit="W",
            each quantity="Power") "Solar radiation absorbed by shade"
            annotation (Placement(transformation(extent={{-340,40},{-300,80}})));

          HeatTransfer.Windows.ExteriorHeatTransfer conExtWin[nCon](
            final A=conPar[:].AWin,
            final fFra=conPar[:].fFra,
            each final linearizeRadiation = linearizeRadiation,
            final vieFacSky={(Modelica.Constants.pi - conPar[i].til) ./ Modelica.Constants.pi for i in 1:nCon},
            final absIRSha_air=conPar[:].glaSys.shade.absIR_a,
            final absIRSha_glass=conPar[:].glaSys.shade.absIR_b,
            final tauIRSha_air=conPar[:].glaSys.shade.tauIR_a,
            final tauIRSha_glass=conPar[:].glaSys.shade.tauIR_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade)
            "Exterior convection of the window"
            annotation (Placement(transformation(extent={{20,-120},{-40,-60}})));

          SkyRadiationExchange skyRadExcWin(
            final n=nCon,
            final absIR=conPar[:].glaSys.absIRFra,
            vieFacSky={(Modelica.Constants.pi - conPar[i].til) ./ Modelica.Constants.pi for i in
                    1:nCon},
            final A=conPar[:].AWin .* conPar[:].fFra)
            "Infrared radiative heat exchange between window frame and sky"
            annotation (Placement(transformation(extent={{-140,-280},{-180,-240}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutUns[nCon]
            "Outgoing radiosity that connects to unshaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
                iconTransformation(extent={{-300,-30},{-320,-10}})));
          HeatTransfer.Interfaces.RadiosityInflow JInUns[nCon]
            "Incoming radiosity that connects to unshaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
                iconTransformation(extent={{-320,10},{-300,30}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutSha[nCon] if
               haveShade
            "Outgoing radiosity that connects to shaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
                iconTransformation(extent={{-300,-210},{-320,-190}})));
          HeatTransfer.Interfaces.RadiosityInflow JInSha[nCon] if
               haveShade
            "Incoming radiosity that connects to shaded part of glass at exterior side"
            annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
                iconTransformation(extent={{-320,-170},{-300,-150}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[nCon]
            "Heat port at unshaded glass of exterior-facing surface"
                                                            annotation (Placement(transformation(extent={{-310,
                    -90},{-290,-70}}), iconTransformation(extent={{-310,-90},{-290,
                    -70}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[nCon] if
               haveShade "Heat port at shaded glass of exterior-facing surface"
            annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}),
                iconTransformation(extent={{-310,-130},{-290,-110}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra[nCon](T(each nominal=
                  300, each start=283.15))
            "Heat port at frame of exterior-facing surface"                                   annotation (Placement(transformation(extent={{-310,
                    -270},{-290,-250}}), iconTransformation(extent={{-310,-270},{-290,
                    -250}})));
          Modelica.Blocks.Math.Add HTotConExtWinFra[nCon](
             final k1=conPar[:].fFra .* conPar[:].glaSys.absSolFra .* conPar[:].AWin,
             final k2=conPar[:].fFra .* conPar[:].glaSys.absSolFra .* conPar[:].AWin)
            "Total solar irradiation on window frame"
            annotation (Placement(transformation(extent={{40,60},{20,80}})));
          Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConWin[nCon]
            "Total solar heat gain of the window frame"
            annotation (Placement(transformation(extent={{0,60},{-20,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDir[nCon](
             each final quantity="RadiantEnergyFluenceRate",
             each final unit="W/m2") "Direct solar irradition on tilted surface"
            annotation (Placement(transformation(extent={{300,110},{320,130}})));
          Modelica.Blocks.Interfaces.RealOutput HDif[nCon](
             each final quantity="RadiantEnergyFluenceRate",
             each final unit="W/m2") "Diffuse solar irradiation on tilted surface"
            annotation (Placement(transformation(extent={{300,50},{320,70}})));
          Modelica.Blocks.Interfaces.RealOutput inc[nCon](
            each final quantity="Angle",
            each final unit="rad",
            each displayUnit="deg") "Incidence angle"
            annotation (Placement(transformation(extent={{300,170},{320,190}})));

      protected
          Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExtWin[
            nCon] "Outside air temperature for window constructions"
            annotation (Placement(transformation(extent={{160,-90},{120,-50}})));
          Modelica.Blocks.Routing.Replicator repConExtWin(final nout=nCon)
            "Signal replicator"
            annotation (Placement(transformation(extent={{220,-80},{200,-60}})));
          Modelica.Blocks.Routing.Replicator repConExtWinVWin(final nout=nCon)
            "Signal replicator"
            annotation (Placement(transformation(extent={{140,-22},{120,-2}})));
          Modelica.Blocks.Routing.Replicator repConExtWinTSkyBla(final nout=nCon)
            "Signal replicator"
            annotation (Placement(transformation(extent={{220,-112},{200,-92}})));
        equation
          connect(uSha, conExtWin.uSha)
                                  annotation (Line(
              points={{-320,100},{-140,100},{-140,-40},{40,-40},{40,-66},{22.4,-66}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(JInUns,conExtWin. JInUns) annotation (Line(
              points={{-310,20},{-200,20},{-200,-72},{-43,-72}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(conExtWin.JOutUns,JOutUns)  annotation (Line(
              points={{-43,-66},{-196.45,-66},{-196.45,-20},{-310,-20}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(conExtWin.glaUns,glaUns)  annotation (Line(
              points={{-40,-84},{-192,-84},{-192,-80},{-300,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.glaSha,glaSha)  annotation (Line(
              points={{-40,-96},{-190,-96},{-190,-120},{-300,-120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.JOutSha,JOutSha)  annotation (Line(
              points={{-43,-108},{-176,-108},{-176,-200},{-310,-200}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(conExtWin.JInSha,JInSha)  annotation (Line(
              points={{-43,-114},{-184.45,-114},{-184.45,-160},{-310,-160}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(conExtWin.frame,fra)  annotation (Line(
              points={{-31,-120},{-31,-220},{-260,-220},{-260,-260},{-300,-260}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(TAirConExtWin.port,conExtWin. air) annotation (Line(
              points={{120,-70},{90,-70},{90,-90},{20,-90}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(TAirConExtWin.T,repConExtWin. y) annotation (Line(
              points={{164,-70},{199,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExtWin.u, weaBus.TDryBul) annotation (Line(
              points={{222,-70},{244,-70},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(repConExtWinVWin.y,conExtWin. vWin) annotation (Line(
              points={{119,-12},{50,-12},{50,-78},{22.4,-78}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExtWinVWin.u, weaBus.winSpe) annotation (Line(
              points={{142,-12},{192,-12},{192,-14},{244,-14},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(HTotConExtWinFra.y, solHeaGaiConWin.Q_flow) annotation (Line(
              points={{19,70},{0,70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(solHeaGaiConWin.port, fra) annotation (Line(
              points={{-20,70},{-60,70},{-60,-220},{-260,-220},{-260,-260},{-300,-260}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(HDifTil.H, HDif) annotation (Line(
              points={{199,90},{72,90},{72,60},{310,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil.inc, inc) annotation (Line(
              points={{199,126},{180,126},{180,112},{260,112},{260,180},{310,180}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HTotConExtWinFra.u2, HDifTil.H) annotation (Line(
              points={{42,64},{72,64},{72,90},{199,90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(skyRadExcWin.TOut, weaBus.TDryBul)
                                                  annotation (Line(
              points={{-136,-268},{244,-268},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(skyRadExcWin.TBlaSky, weaBus.TBlaSky)
                                                     annotation (Line(
              points={{-136,-252},{244,-252},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(skyRadExcWin.port, fra) annotation (Line(
              points={{-180,-260},{-242,-260},{-242,-260},{-300,-260}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(repConExtWin.y, conExtWin.TOut) annotation (Line(
              points={{199,-70},{180,-70},{180,-114.6},{23,-114.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExtWinTSkyBla.y, conExtWin.TBlaSky) annotation (Line(
              points={{199,-102},{23,-102}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(repConExtWinTSkyBla.u, weaBus.TBlaSky) annotation (Line(
              points={{222,-102},{244,-102},{244,42}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          for i in 1:nCon loop
            connect(sha[i].weaBus, weaBus) annotation (Line(
              points={{140,110},{244,110},{244,42}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          end for;

          connect(HDirTil.inc, sha.incAng) annotation (Line(
              points={{199,126},{168,126},{168,104},{142,104}},
              color={0,0,127},
              smooth=Smooth.None));
          // OpenModelica does not remove the connect statement if conExtWin.QSolAbs_flow
          // is removed.
          if haveShade then
            connect(QAbsSolSha_flow, conExtWin.QSolAbs_flow) annotation (Line(
              points={{-320,60},{-160,60},{-160,-140},{-10,-140},{-10,-123}},
              color={0,0,127},
              smooth=Smooth.None));
          end if;

          connect(sha.HDirTilUns, HDirTil.H) annotation (Line(
              points={{142,116},{160,116},{160,130},{199,130}},
              color={0,0,127},
              smooth=Smooth.None));

          if haveOverhangOrSideFins then
            connect(sha.HDirTil, HTotConExtWinFra.u1) annotation (Line(
              points={{119,116},{100,116},{100,76},{42,76}},
              color={0,0,127},
              smooth=Smooth.None));
            connect(sha.HDirTil, HDir) annotation (Line(
              points={{119,116},{100,116},{100,70},{280,70},{280,120},{310,120}},
              color={0,0,127},
              smooth=Smooth.None));
          else
            connect(HDirTil.H, HTotConExtWinFra.u1) annotation (Line(
                points={{199,130},{100,130},{100,76},{42,76}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(HDirTil.H, HDir) annotation (Line(
              points={{199,130},{100,130},{100,70},{280,70},{280,120},{310,120}},
              color={0,0,127},
              smooth=Smooth.None));
          end if;

          annotation (Icon(graphics={
                Rectangle(
                  extent={{-220,180},{-160,-102}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-212,180},{-202,-102}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                Rectangle(
                  extent={{-180,180},{-170,-102}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash)}),
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-300,-300},{300,
                    300}}), graphics),
            Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions and of windows.
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
This model extends
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditions\">
Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditions</a>,
which models the boundary conditions for the opaque constructions,
and then implements the boundary condition for windows by using
the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>.
</html>",         revisions="<html>
<ul>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica if the connector is conditionally removed.
</li>
<li>
October 28, 2014, by Michael Wetter:<br/>
Replaced
<code>final parameter Boolean haveShade=haveExteriorShade[1] or haveInteriorShade[1]</code>
with a test for all elements of the vector.
This was not possible in earlier versions of Dymola, but now works.
</li>
<li>
October 20, 2014, by Michael Wetter:<br/>
Conditionally removed shade if not present. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/234\">
issue 234</a>.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
August 9, 2011, by Michael Wetter:<br/>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and adding the parameter <code>absIRFra</code>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/36\">issue 36</a>.
</li>
<li>
November 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ExteriorBoundaryConditionsWithWindow;

        model HeatGain "Model to convert internal heat gain signals"
          extends Buildings.BaseClasses.BaseIcon;

          parameter Modelica.SIunits.Area AFlo "Floor area";

          Modelica.Blocks.Interfaces.RealInput qGai_flow[3]
            "Radiant, convective and latent heat input into room (positive if heat gain)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput QRad_flow(unit="W")
            "Radiant heat input into room (positive if heat gain)"
            annotation (Placement(transformation(extent={{100,40},{140,80}}),
                iconTransformation(extent={{100,40},{140,80}})));
          Modelica.Blocks.Interfaces.RealOutput QCon_flow(unit="W")
            "Convective sensible heat input into room (positive if heat gain)"
            annotation (Placement(transformation(extent={{100,-20},{140,20}}),
                iconTransformation(extent={{100,-20},{140,20}})));
          Modelica.Blocks.Interfaces.RealOutput QLat_flow(unit="W")
            "Latent heat input into room (positive if heat gain)"
            annotation (Placement(transformation(extent={{100,-80},{140,-40}}),
                iconTransformation(extent={{100,-80},{140,-40}})));
        equation
          {QRad_flow, QCon_flow, QLat_flow} = AFlo .* qGai_flow;

         annotation(Documentation(info="<html>
This model computes the radiant, convective and latent heat flow rate.
Input into this model are these three components in units of [W/m2].
The inputs need to be positive quantities if heat or moisture is added
to the room.
The outputs are
<ul>
<li>
the radiant heat flow in Watts,
</li>
<li>
the convective heat flow in Watts, and
</li>
<li>
the water vapor released into the air.
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
May 2, 2016, by Michael Wetter:<br/>
Refactored implementation of latent heat gain.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/515\">issue 515</a>.
</li>
<li>
August 1, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                    Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Line(
                  points={{-48,-66},{-24,-18},{0,-68}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-24,-18},{-24,46}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-52,24},{-24,38}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(
                  points={{-24,38},{8,22}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Ellipse(extent={{-40,76},{-8,46}},  lineColor={0,0,255}),
                Text(
                  extent={{-98,30},{-38,-26}},
                  lineColor={0,0,127},
                  textString="q_flow"),
                Text(
                  extent={{20,74},{94,52}},
                  lineColor={0,0,127},
                  textString="QRad_flow"),
                Text(
                  extent={{18,14},{92,-8}},
                  lineColor={0,0,127},
                  textString="QCon_flow"),
                Text(
                  extent={{20,-44},{94,-66}},
                  lineColor={0,0,127},
                  textString="QLat_flow")}),
                Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room,
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",       revisions="<html>
<ul>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
June 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HeatGain;

        model InfraredRadiationExchange
          "Infrared radiation heat exchange between the room facing surfaces"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialSurfaceInterfaceRadiative;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Boolean linearizeRadiation
            "Set to true to linearize emissive power";
          parameter Boolean sampleModel=false
            "Set to true to time-sample the model, which can give shorter simulation time if there is already time sampling in the system model"
            annotation (Evaluate=true, Dialog(tab=
                  "Experimental (may be changed in future releases)"));

          HeatTransfer.Interfaces.RadiosityInflow JInConExtWin[NConExtWin] if
            haveConExtWin
            "Incoming radiosity that connects to non-frame part of the window"
            annotation (Placement(transformation(extent={{260,70},{240,90}})));
          HeatTransfer.Interfaces.RadiosityOutflow JOutConExtWin[NConExtWin]
            "Outgoing radiosity that connects to non-frame part of the window"
            annotation (Placement(transformation(extent={{240,110},{260,130}})));
      protected
          constant Real T30(unit="K3") = 293.15^3 "Nominal temperature";
          constant Real T40(unit="K4") = 293.15^4 "Nominal temperature";

          final parameter Integer NOpa=NConExt + 2*NConExtWin + 2*NConPar + NConBou +
              NSurBou "Number of opaque surfaces, including the window frame";
          final parameter Integer nOpa=nConExt + 2*nConExtWin + 2*nConPar + nConBou +
              nSurBou "Number of opaque surfaces, including the window frame";
          final parameter Integer NWin=NConExtWin "Number of window surfaces";
          final parameter Integer nWin=nConExtWin "Number of window surfaces";
          final parameter Integer NTot=NOpa + NWin "Total number of surfaces";
          final parameter Integer nTot=nOpa + nWin "Total number of surfaces";
          final parameter Real epsOpa[nOpa](
            each min=0,
            each max=1,
            each fixed=false) "Absorptivity of opaque surfaces";
          final parameter Real rhoOpa[nOpa](
            each min=0,
            each max=1,
            each fixed=false) "Reflectivity of opaque surfaces";
          final parameter Modelica.SIunits.Area AOpa[nOpa](each fixed=false)
            "Surface area of opaque surfaces";
          final parameter Modelica.SIunits.Area A[nTot](each fixed=false)
            "Surface areas";
          final parameter Real kOpa[nOpa](each unit="W/K4", each fixed=false)
            "Product sigma*epsilon*A for opaque surfaces";
          final parameter Real kOpaInv[nOpa](each unit="K4/W", each fixed=false)
            "Inverse of kOpa, used to avoid having to use a safe division";
          final parameter Real F[nTot, nTot](
            each min=0,
            each max=1,
            each fixed=false) "View factor from surface i to j";

          parameter Modelica.SIunits.Time t0(fixed=false) "First sample time instant";

          Buildings.HeatTransfer.Interfaces.RadiosityInflow JInConExtWin_internal[
            NConExtWin](start=AConExtWinGla*0.8*Modelica.Constants.sigma*293.15^4,
              each fixed=sampleModel and nConExtWin > 0)
            "Incoming radiosity that connects to non-frame part of the window";

          Modelica.SIunits.HeatFlowRate J[nTot](
            each max=0,
            start=-A .* 0.8*Modelica.Constants.sigma*293.15^4,
            fixed={sampleModel and (i <= nOpa or i > nOpa + nWin) for i in 1:nTot},
            each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
            "Radiosity leaving the surface";

          Modelica.SIunits.HeatFlowRate G[nTot](
            each min=0,
            start=A .* 0.8*Modelica.Constants.sigma*293.15^4,
            each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
            "Radiosity entering the surface";

          Modelica.SIunits.Temperature TOpa[nOpa](each start=293.15, each nominal=
                293.15) "Temperature of opaque surfaces";
          Real T4Opa[nOpa](
            each unit="K4",
            each start=T40,
            each nominal=293.15^4) "Forth power of temperature of opaque surfaces";
          Modelica.SIunits.HeatFlowRate Q_flow[nTot](each start=0, each fixed=
                sampleModel) "Heat flow rate at surfaces";
          parameter Modelica.SIunits.Temperature T0=293.15
            "Temperature used to linearize radiative heat transfer";
          final parameter Real T03(
            min=0,
            unit="K3") = T0^3 "3rd power of temperature T0";
          Modelica.SIunits.HeatFlowRate sumEBal(start=0, fixed=sampleModel)
            "Sum of energy balance, should be zero";
        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

          // The next loops build the array epsOpa, AOpa and kOpa that simplify
          // the model equations.
          // These arrays store the values of the constructios in the following order
          // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
          // where x is epsOpa, AOpa or kOpa.
          // The last two entries are for the opaque wall that contains a window, and for the window frame.
          for i in 1:nConExt loop
            epsOpa[i] = epsConExt[i];
            AOpa[i] = AConExt[i];
            kOpa[i] = Modelica.Constants.sigma*epsConExt[i]*AOpa[i];
          end for;
          for i in 1:nConPar loop
            epsOpa[i + nConExt] = epsConPar_a[i];
            AOpa[i + nConExt] = AConPar[i];
            kOpa[i + nConExt] = Modelica.Constants.sigma*epsConPar_a[i]*AOpa[i +
              nConExt];
            epsOpa[i + nConExt + nConPar] = epsConPar_b[i];
            AOpa[i + nConExt + nConPar] = AConPar[i];
            kOpa[i + nConExt + nConPar] = Modelica.Constants.sigma*epsConPar_b[i]*AOpa[
              i + nConExt + nConPar];
          end for;
          for i in 1:nConBou loop
            epsOpa[i + nConExt + 2*nConPar] = epsConBou[i];
            AOpa[i + nConExt + 2*nConPar] = AConBou[i];
            kOpa[i + nConExt + 2*nConPar] = Modelica.Constants.sigma*epsConBou[i]*AOpa[
              i + nConExt + 2*nConPar];
          end for;
          for i in 1:nSurBou loop
            epsOpa[i + nConExt + 2*nConPar + nConBou] = epsSurBou[i];
            AOpa[i + nConExt + 2*nConPar + nConBou] = ASurBou[i];
            kOpa[i + nConExt + 2*nConPar + nConBou] = Modelica.Constants.sigma*
              epsSurBou[i]*AOpa[i + nConExt + 2*nConPar + nConBou];
          end for;
          for i in 1:nConExtWin loop
            // Opaque part of construction that has a window embedded
            epsOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = epsConExtWinOpa[i];
            AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = AConExtWinOpa[i];
            kOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = Modelica.Constants.sigma
              *epsConExtWinOpa[i]*AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou];
            // Window frame
            epsOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
              epsConExtWinFra[i];
            AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
              AConExtWinFra[i];
            kOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] = Modelica.Constants.sigma
              *epsConExtWinFra[i]*AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou +
              nConExtWin];
          end for;
          // Vector with all surface areas.
          // The next loops build the array A that simplifies
          // the model equations.
          // These array stores the values of the constructios in the following order
          // [AOpa[1:nConExt] AOpa[1:nConPar] AOpa[1: nConPar] AOpa[1: nConBou] AOpa[1: nSurBou]
          //  AOpa[1: nConExtWin] AOpa[1: nConExtWin] AGla[1: nConExtWin]]
          // since nWin=nConExtWin.
          for i in 1:nOpa loop
            A[i] = AOpa[i];
          end for;
          for i in 1:nWin loop
            A[i + nOpa] = AConExtWinGla[i];
          end for;
          // Reflectivity for opaque surfaces
          rhoOpa = 1 .- epsOpa;
          // View factors from surface i to surface j
          for i in 1:nTot loop
            for j in 1:nTot loop
              F[i, j] = A[j]/sum((A[k]) for k in 1:nTot);
            end for;
          end for;
          for i in 1:nOpa loop
            kOpaInv[i] = 1/kOpa[i];
          end for;
          // Test whether the view factors add up to one, or the sum is zero in case there
          // is only one construction
          for i in 1:nTot loop
            assert((abs(1 - sum(F[i, j] for j in 1:nTot))) < 1E-10,
              "Program error: Sum 1 of view factors is " + String(sum(F[i, j] for j in
              1:nTot)));
          end for;

          t0 = time;
          ////////////////////////////////////////////////////////////////////
        equation
          // Conditional connector
          connect(JInConExtWin, JInConExtWin_internal);
          if not haveConExtWin then
            JInConExtWin_internal = fill(0, NConExtWin);
          end if;
          // Assign temperature of opaque surfaces
          for i in 1:nConExt loop
            TOpa[i] = conExt[i].T;
          end for;
          for i in 1:nConPar loop
            TOpa[i + nConExt] = conPar_a[i].T;
            TOpa[i + nConExt + nConPar] = conPar_b[i].T;
          end for;
          for i in 1:nConBou loop
            TOpa[i + nConExt + 2*nConPar] = conBou[i].T;
          end for;
          for i in 1:nSurBou loop
            TOpa[i + nConExt + 2*nConPar + nConBou] = conSurBou[i].T;
          end for;
          for i in 1:nConExtWin loop
            TOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = conExtWin[i].T;
            TOpa[i + nConExt + 2*nConPar + nConBou + nConExtWin + nSurBou] =
              conExtWinFra[i].T;
          end for;
          // Incoming radiosity at each surface
          // is equal to the negative of the outgoing radiosity of
          // all other surfaces times the view factor
          if sampleModel then
            // experimental mode to sample the model which can give shorter
            // simulation time if there is already a sampling in the system model
            when sample(t0, 2*60) then
              G = -transpose(F)*pre(J);
              // Net heat exchange
              Q_flow = -pre(J) - G;
              // Outgoing radiosity
              // Sum of energy balance
              // Remove sumEBal and assert statement for final release
              sumEBal = sum(conExt.Q_flow) + sum(conPar_a.Q_flow) + sum(conPar_b.Q_flow)
                 + sum(conBou.Q_flow) + sum(conSurBou.Q_flow) + sum(conExtWin.Q_flow)
                 + sum(conExtWinFra.Q_flow) + (sum(JInConExtWin_internal) - sum(
                JOutConExtWin));
            end when;
          else
            G = -transpose(F)*J;
            // Net heat exchange
            Q_flow = -J - G;
            // Outgoing radiosity
            // Sum of energy balance
            // Remove sumEBal and assert statement for final release
            sumEBal = sum(conExt.Q_flow) + sum(conPar_a.Q_flow) + sum(conPar_b.Q_flow)
               + sum(conBou.Q_flow) + sum(conSurBou.Q_flow) + sum(conExtWin.Q_flow) +
              sum(conExtWinFra.Q_flow) + (sum(JInConExtWin_internal) - sum(
              JOutConExtWin));
            assert(abs(sumEBal) < 1E-1, "Program error: Energy is not conserved in InfraredRadiationExchange.
    Sum of all energy is "         + String(sumEBal));
          end if;

          // Opaque surfaces.
          // If kOpa[j]=absIR[j]*A[j] < 1E-28, then A < 1E-20 and the surface is
          // from a dummy construction. In this situation, we set T40=293.15^4 to
          // avoid a singularity.
          for j in 1:nOpa loop
            //   T4Opa[j] = if (kOpa[j] > 1E-28) then (Q_flow[j]-epsOpa[j] * G[j])/kOpa[j] else T40;
            T4Opa[j] = (-J[j] - rhoOpa[j]*G[j])*kOpaInv[j];
          end for;
          // 4th power of temperature
          if linearizeRadiation then
            TOpa = (T4Opa .+ 3*T40)/(4*T30);
            // Based on T4 = 4*T30*T-3*T40
          else
            if homotopyInitialization then
              TOpa = homotopy(actual=Buildings.Utilities.Math.Functions.powerLinearized(
                x=T4Opa,
                x0=243.15^4,
                n=0.25), simplified=(T4Opa .+ 3*T40)/(4*T30));
            else
              TOpa = Buildings.Utilities.Math.Functions.powerLinearized(
                x=T4Opa,
                x0=243.15^4,
                n=0.25);
            end if;
          end if;
          // Assign radiosity that comes from window
          // and that leaves window.
          // J < 0 because it leaves the surface
          // G > 0 because it strikes the surface
          for j in 1:nWin loop
            J[j + nOpa] = -JInConExtWin_internal[j];
            G[j + nOpa] = +JOutConExtWin[j];
          end for;

          // Assign heat exchange to connectors
          for i in 1:nConExt loop
            Q_flow[i] = conExt[i].Q_flow;
          end for;
          if nConExt == 0 then
            conExt[1].T = T0;
          end if;
          for i in 1:nConPar loop
            Q_flow[i + nConExt] = conPar_a[i].Q_flow;
            Q_flow[i + nConExt + nConPar] = conPar_b[i].Q_flow;
          end for;
          if nConPar == 0 then
            conPar_a[1].T = T0;
            conPar_b[1].T = T0;
          end if;
          for i in 1:nConBou loop
            Q_flow[i + nConExt + 2*nConPar] = conBou[i].Q_flow;
          end for;
          if nConBou == 0 then
            conBou[1].T = T0;
          end if;
          for i in 1:nSurBou loop
            Q_flow[i + nConExt + 2*nConPar + nConBou] = conSurBou[i].Q_flow;
          end for;
          if nSurBou == 0 then
            conSurBou[1].T = T0;
          end if;
          for i in 1:nConExtWin loop
            Q_flow[i + nConExt + 2*nConPar + nConBou + nSurBou] = conExtWin[i].Q_flow;
            Q_flow[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
              conExtWinFra[i].Q_flow;
          end for;
          if nConExtWin == 0 then
            conExtWin[1].T = T0;
            conExtWinFra[1].T = T0;
            JOutConExtWin[1] = 0;
          end if;

          annotation (
            preferredView="info",
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}})),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}}), graphics={
                Line(
                  points={{-144,-8},{146,-8}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-144,-8},{2,184}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-144,-8},{2,-200}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{2,-200},{2,184}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{2,184},{148,-8}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{2,-200},{148,-8}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5)}),
            Documentation(info="<html>
<p>
This model computes the infrared radiative heat transfer between the interior
surfaces of a room. Each opaque surface emits radiation according to
</p>
<p align=\"center\" style=\"font-style:italic;\">
  E<sup>i</sup> = &sigma; &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp;
(T<sup>i</sup>)<sup>4</sup>,
</p>
<p>
where
<i>&sigma;</i>
is the Stefan-Boltzmann constant,
<i>A<sup>i</sup> </i>
is the surface area,
<i>&epsilon;<sup>i</sup> </i>
is the absorptivity in the infrared spectrum, and
<i>T<sup>i</sup></i>
is the surface temperature.
If the parameter <code>linearizeRadidation</code> is set to <code>true</code>,
then the term <i>(T<sup>i</sup>)<sup>4</sup></i> is replaced with
<i>T<sub>0</sub><sup>3</sup> T<sup>i</sup></i>,
where <i>T<sub>0</sub> = 20&deg;C</i> is a parameter.
</p>
<p>
The incoming radiation at surface <i>i</i> is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  G<sup>i</sup> = -&sum;<sub>j</sub> &nbsp; F<sup>j,i</sup> &nbsp; J<sup>j</sup>
</p>
<p>
where
<i>F<sup>j,i</sup></i>
is the view factor from surface
<i>j</i> to surface <i>i</i>,
<i>J<sup>j</sup></i>
is the radiosity leaving surface <i>j</i>
and the sum is over all surfaces.
For opaque surfaces, it follows from the first law
that the radiosity
<i>J<sup>i</sup></i>
is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>i</sup> = -E<sup>i</sup>  - (1-&epsilon;<sup>i</sup>) &nbsp; G<sup>i</sup>.
</p>
<p>
For windows, the outgoing radiosity is an input into this model
because the window model computes this quantity directly.
</p>
<p>
For each surface <i>i</i>, the heat balance is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  0 = Q<sup>i</sup> + J<sup>i</sup> + G<sup>i</sup>.
</p>
<p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the radiosity outflow at the connector is
set to the radiosity
<i>G<sup>i</sup></i>
that is leaving the surface.
</p>
<p>
The view factor from surface <i>i</i> to <i>j</i> is approximated as
<p align=\"center\" style=\"font-style:italic;\">
  F<sup>i,j</sup> = A<sup>j</sup> &frasl; &sum;<sub>k </sub> A<sup>k</sup>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
January 23, 2017, by Michael Wetter:<br/>
Corrected wrong start value for <code>J</code>.
The start value was positive, but <code>J(each max =0)</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/627\">issue 627</a>.
</li>
<li>
May 21, 2015, by Michael Wetter:<br/>
Reformulated to reduce use of the division macro
in Dymola.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/417\">issue 417</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 18, 2013, by Michael Wetter:<br/>
Removed <code>cardinality</code> function as this is
deprecated in the MSL specification and not correctly implemented in omc.
</li>
<li>
February 10, 2012 by Wangda Zuo:<br/>
Fixed a bug for linearization of T4.
</li>
<li>
April 21, 2011 by Michael Wetter:<br/>
Fixed a bug in the view factor calculation, and rewrote the model to reduce simulation time. The bug caused too much radiosity to flow from large to small surfaces because the law of reciprocity for view factors was not satisfied. This led to low surface temperatures if a surface had a large area compared to other surfaces.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
Feb. 3, 2011, by Michael Wetter:<br/>
Corrected bug in start value of radiosity, reformulated equations to get
smaller system of coupled equations.
</li>
<li>
Dec. 1, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end InfraredRadiationExchange;

        model InfraredRadiationGainDistribution
          "Infrared radiative heat gain distribution between the room facing surfaces"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialSurfaceInterfaceRadiative;
          parameter Boolean haveShade "Set to true if a shade is present";

          Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
               haveShade
            "Control signal for the shading device (removed if no shade is present)"
            annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
                iconTransformation(extent={{-280,160},{-240,200}})));

          Modelica.Blocks.Interfaces.RealInput Q_flow
            "Radiative heat input into room (positive if heat gain)"
                annotation (Placement(transformation(
                origin={-260,0},
                extent={{20,-20},{-20,20}},
                rotation=180)));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow[NConExtWin] JOutConExtWin
            "Outgoing radiosity that connects to shaded and unshaded part of glass"
            annotation (Placement(transformation(extent={{240,110},{260,130}})));
      protected
          Real fraConExt[NConExt] = AEpsConExt*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by exterior constructions";
          Real fraConExtWinOpa[NConExtWin] = AEpsConExtWinOpa*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by opaque part of exterior constructions that have a window";
          Real fraConExtWinGla[NConExtWin] = (AEpsConExtWinSha + AEpsConExtWinUns)*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by opaque part of glass constructions that have a window";
          Real fraConExtWinFra[NConExtWin] = AEpsConExtWinFra*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by window frame of exterior constructions that have a window";

          Real fraConPar_a[NConPar] = AEpsConPar_a*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by partition constructions surface a";
          Real fraConPar_b[NConPar] = AEpsConPar_b*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by partition constructions surface b";
          Real fraConBou[NConBou] = AEpsConBou*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by constructions with exterior boundary conditions exposed to outside of room model";
          Real fraSurBou[NSurBou] = AEpsSurBou*sumAEpsInv
            "Fraction of infrared radiant heat gain absorbed by surface models of constructions that are modeled outside of this room";

         parameter Real AEpsConExt[NConExt] = {AConExt[i]*epsConExt[i] for i in 1:NConExt}
            "Absorptivity times area of exterior constructions";
         parameter Real AEpsConExtWinOpa[NConExtWin] = {AConExtWinOpa[i]*epsConExtWinOpa[i] for i in 1:NConExtWin}
            "Absorptivity times area of opaque part of exterior constructions that contain a window";
         Real AEpsConExtWinUns[NConExtWin] = {shaSig[i].yCom * AConExtWinGla[i]*epsConExtWinUns[i]
             for i in 1:NConExtWin}
            "Absorptivity times area of unshaded window constructions";
         Real AEpsConExtWinSha[NConExtWin] = {shaSig[i].y    * AConExtWinGla[i]*epsConExtWinSha[i]
            for i in 1:NConExtWin}
            "Absorptivity times area of shaded window constructions";
         parameter Real AEpsConExtWinFra[NConExtWin] = {AConExtWinFra[i]*epsConExtWinFra[i] for i in 1:NConExtWin}
            "Absorptivity times area of window frame";
         parameter Real AEpsConPar_a[NConPar] = {AConPar[i]*epsConPar_a[i] for i in 1:NConPar}
            "Absorptivity times area of partition constructions surface a";
         parameter Real AEpsConPar_b[NConPar] = {AConPar[i]*epsConPar_b[i] for i in 1:NConPar}
            "Absorptivity times area of partition constructions surface b";
         parameter Real AEpsConBou[NConBou] = {AConBou[i]*epsConBou[i] for i in 1:NConBou}
            "Absorptivity times area of constructions with exterior boundary conditions exposed to outside of room model";
         parameter Real AEpsSurBou[NSurBou] = {ASurBou[i]*epsSurBou[i] for i in 1:NSurBou}
            "Absorptivity times area of surface models of constructions that are modeled outside of this room";

         parameter Real sumAEpsNoWin(fixed=false)
            "Sum of absorptivity times area of all constructions except for windows";
         Real sumAEpsInv
            "Inverse of sum of absorptivity times area of all constructions including windows";

         Buildings.HeatTransfer.Windows.BaseClasses.ShadingSignal shaSig[NConExtWin](
              each final haveShade=haveShade)
            "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present";
        initial equation
          sumAEpsNoWin = sum(AEpsConExt)+sum(AEpsConExtWinOpa)+sum(AEpsConExtWinFra)
                        +sum(AEpsConPar_a)+sum(AEpsConPar_b)+sum(AEpsConBou)+sum(AEpsSurBou);
        equation
          connect(uSha, shaSig.u);

          sumAEpsInv   = 1.0/(sumAEpsNoWin + sum(AEpsConExtWinUns) + sum(AEpsConExtWinSha));

          // Infrared radiative heat flow
          // If a construction is not present, we assign the temperature of the connector to 20 degC.
          if haveConExt then
            conExt.Q_flow    = -fraConExt*Q_flow;
          else
            conExt[1].T = 293.15;
          end if;

          if haveConExtWin then
            conExtWin.Q_flow = -fraConExtWinOpa*Q_flow;
          else
            conExtWin[1].T = 293.15;
          end if;

          if haveConPar then
            conPar_a.Q_flow  = -fraConPar_a*Q_flow;
            conPar_b.Q_flow  = -fraConPar_b*Q_flow;
          else
            conPar_a[1].T = 293.15;
            conPar_b[1].T = 293.15;
          end if;

          if haveConBou then
            conBou.Q_flow    = -fraConBou*Q_flow;
          else
            conBou[1].T = 293.15;
          end if;

          if haveSurBou then
            conSurBou.Q_flow    = -fraSurBou*Q_flow;
          else
            conSurBou[1].T = 293.15;
          end if;

          // This model makes the simplification that the shade, the glass and the frame have
          // the same absorptivity in the infrared region
          JOutConExtWin        = +fraConExtWinGla*Q_flow;
          if haveConExtWin then
             conExtWinFra.Q_flow  = -fraConExtWinFra*Q_flow;
          else
             conExtWinFra[1].T = 293.15;
          end if;

          // Check for conservation of energy
          assert(abs(1 - sum(fraConExt) - sum(fraConExtWinOpa)- sum(fraConExtWinGla) - sum(fraConExtWinFra)
                   - sum(fraConPar_a) - sum(fraConPar_b)
                   - sum(fraConBou) - sum(fraSurBou))  < 1E-5,
                   "Programming error: Radiation balance is wrong. Check equations.");
          annotation (
        preferredView="info",
        Documentation(info = "<html>
This model computes the distribution of the infrared radiant heat gain
to the room surfaces.
The infrared radiant heat gain <i>Q</i> is an input to this model.
It is distributed to the individual surfaces according to
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup> = Q &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &frasl;
 &sum;<sub>k</sub> A<sup>k</sup> &nbsp; &epsilon;<sup>k</sup>.
</p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sup>i</sup></i>
that will strike the glass or the window shade.
</html>",       revisions="<html>
<ul>
<li>
May 21, 2015, by Michael Wetter:<br/>
Reformulated to reduce use of the division macro
in Dymola.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/417\">issue 417</a>.
</li>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
December 1, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Text(
                  extent={{-234,40},{-178,10}},
                  lineColor={0,0,127},
                  textString="Q_flow"),
                Rectangle(
                  extent={{-242,4},{-2,-4}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-4,4},{2,-8}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-144,-8},{146,-8}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{2,-200},{2,184}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Text(
                  extent={{-230,210},{-174,148}},
                  lineColor={0,0,127},
                  textString="uSha")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                    240}}),
                    graphics));
        end InfraredRadiationGainDistribution;

        model MixedAirHeatMassBalance
          "Heat and mass balance of the air, assuming completely mixed air"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialAirHeatMassBalance;
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));

          parameter Buildings.HeatTransfer.Types.InteriorConvection conMod
            "Convective heat transfer model for opaque constructions"
            annotation (Dialog(group="Convective heat transfer"));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed
            "Constant convection coefficient for opaque constructions"
            annotation (Dialog(group="Convective heat transfer",
                               enable=(conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

          parameter Boolean use_C_flow
            "Set to true to enable input connector for trace substance"
            annotation (Dialog(group="Ports"));

          Modelica.Blocks.Interfaces.RealInput C_flow[Medium.nC] if use_C_flow
            "Trace substance mass flow rate added to the room air. Enable if use_C_flow = true"
            annotation (Placement(transformation(extent={{-280,-240},{-240,-200}})));

          // Mixing volume
          Fluid.MixingVolumes.MixingVolumeMoistAir vol(
            redeclare package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final V=V,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final mSenFac=mSenFac,
            final m_flow_nominal = m_flow_nominal,
            final prescribedHeatFlowRate = true,
            final nPorts=nPorts,
            m_flow_small=1E-4*abs(m_flow_nominal),
            allowFlowReversal=true,
            final use_C_flow=use_C_flow)  "Room air volume"
            annotation (Placement(transformation(extent={{10,-210},{-10,-190}})));

          // Convection models
          HeatTransfer.Convection.Interior convConExt[NConExt](
            final A=AConExt,
            final til = datConExt.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveConExt "Convective heat transfer"
            annotation (Placement(transformation(extent={{120,210},{100,230}})));

          HeatTransfer.Convection.Interior convConExtWin[NConExtWin](
            final A=AConExtWinOpa,
            final til = datConExtWin.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveConExtWin "Convective heat transfer"
            annotation (Placement(transformation(extent={{120,170},{100,190}})));

          HeatTransfer.Windows.InteriorHeatTransferConvective convConWin[NConExtWin](
            final fFra=datConExtWin.fFra,
            final haveExteriorShade={datConExtWin[i].glaSys.haveExteriorShade for i in 1:NConExtWin},
            final haveInteriorShade={datConExtWin[i].glaSys.haveInteriorShade for i in 1:NConExtWin},
            final til=datConExtWin.til,
            each conMod=conMod,
            each hFixed=hFixed,
            final A=AConExtWinGla + AConExtWinFra) if
               haveConExtWin "Model for convective heat transfer at window"
            annotation (Placement(transformation(extent={{98,110},{118,130}})));

          HeatTransfer.Convection.Interior convConPar_a[nConPar](
            final A=AConPar,
            final til=Modelica.Constants.pi .- datConPar.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveConPar "Convective heat transfer"
            annotation (Placement(transformation(extent={{120,-70},{100,-50}})));

          HeatTransfer.Convection.Interior convConPar_b[nConPar](
            final A=AConPar,
            final til = datConPar.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveConPar "Convective heat transfer"
            annotation (Placement(transformation(extent={{120,-110},{100,-90}})));

          HeatTransfer.Convection.Interior convConBou[nConBou](
            final A=AConBou,
            final til = datConBou.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveConBou "Convective heat transfer"
            annotation (Placement(transformation(extent={{120,-170},{100,-150}})));

          HeatTransfer.Convection.Interior convSurBou[nSurBou](
            final A=ASurBou,
            final til = surBou.til,
            each conMod=conMod,
            each hFixed=hFixed,
            each final homotopyInitialization=homotopyInitialization) if
               haveSurBou "Convective heat transfer"
            annotation (Placement(transformation(extent={{122,-230},{102,-210}})));

          // Latent and convective sensible heat gains
      protected
          constant Modelica.SIunits.SpecificEnergy h_fg=
            Buildings.Media.Air.enthalpyOfCondensingGas(273.15+37) "Latent heat of water vapor";

          Modelica.Blocks.Math.Gain mWat_flow(
            final k(unit="kg/J")=1/h_fg,
            u(final unit="W"),
            y(final unit="kg/s")) "Water flow rate due to latent heat gain"
            annotation (Placement(transformation(extent={{-220,-170},{-200,-150}})));

          HeatTransfer.Sources.PrescribedHeatFlow conQCon_flow
            "Converter for convective heat flow rate"
            annotation (Placement(transformation(extent={{-220,-110},{-200,-90}})));

          HeatTransfer.Sources.PrescribedHeatFlow conQLat_flow
            "Converter for latent heat flow rate"
            annotation (Placement(transformation(extent={{-220,-90},{-200,-70}})));

          // Thermal collectors
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExt(final m=nConExt) if
               haveConExt
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={48,220})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExtWin(final m=nConExtWin) if
               haveConExtWin
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={48,180})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConWin(final m=nConExtWin) if
               haveConExtWin
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={50,120})));

          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_a(final m=nConPar) if
               haveConPar
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={52,-60})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_b(final m=nConPar) if
               haveConPar
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={50,-100})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConBou(final m=nConBou) if
               haveConBou
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={50,-160})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConSurBou(final m=nSurBou) if
               haveSurBou
            "Thermal collector to convert from vector to scalar connector"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={52,-220})));
        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(convConPar_a.fluid,theConConPar_a.port_a) annotation (Line(
              points={{100,-60},{62,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConPar_b.fluid,theConConPar_b.port_a) annotation (Line(
              points={{100,-100},{60,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConBou.fluid,theConConBou.port_a) annotation (Line(
              points={{100,-160},{60,-160}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convSurBou.fluid,theConSurBou.port_a) annotation (Line(
              points={{102,-220},{62,-220}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConPar_a.port_b,vol.heatPort) annotation (Line(
              points={{42,-60},{20,-60},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConPar_b.port_b,vol.heatPort) annotation (Line(
              points={{40,-100},{20,-100},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConBou.port_b,vol.heatPort) annotation (Line(
              points={{40,-160},{20,-160},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConSurBou.port_b,vol.heatPort) annotation (Line(
              points={{42,-220},{20,-220},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWinFra,convConWin.frame) annotation (Line(
              points={{242,4.44089e-16},{160,4.44089e-16},{160,100},{115,100},{115,110}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConExt.solid, conExt) annotation (Line(
              points={{120,220},{240,220}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConExt.fluid,theConConExt.port_a) annotation (Line(
              points={{100,220},{58,220}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConExt.port_b,vol.heatPort) annotation (Line(
              points={{38,220},{20,220},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConExtWin.port_b,vol.heatPort) annotation (Line(
              points={{38,180},{20,180},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConExtWin.fluid,theConConExtWin.port_a) annotation (Line(
              points={{100,180},{58,180}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConExtWin.solid, conExtWin) annotation (Line(
              points={{120,180},{240,180}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theConConWin.port_b,vol.heatPort) annotation (Line(
              points={{40,120},{20,120},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConWin.air,theConConWin.port_a) annotation (Line(
              points={{98,120},{60,120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConWin.glaSha, glaSha) annotation (Line(
              points={{118,118},{166,118},{166,80},{240,80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConWin.glaUns, glaUns) annotation (Line(
              points={{118,122},{180,122},{180,120},{240,120}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConPar_a.solid, conPar_a) annotation (Line(
              points={{120,-60},{242,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConPar_b.solid, conPar_b) annotation (Line(
              points={{120,-100},{242,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convConBou.solid, conBou) annotation (Line(
              points={{120,-160},{242,-160}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(convSurBou.solid, conSurBou) annotation (Line(
              points={{122,-220},{241,-220}},
              color={191,0,0},
              smooth=Smooth.None));
          for i in 1:nPorts loop
            connect(vol.ports[i], ports[i]) annotation (Line(
              points={{0,-210},{0,-238}},
              color={0,127,255},
              smooth=Smooth.None));
          end for;
          connect(heaPorAir, vol.heatPort) annotation (Line(
              points={{-240,0},{20,0},{20,-200},{10,-200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(uSha, convConWin.uSha) annotation (Line(
              points={{-260,200},{0,200},{0,150},{82,150},{82,128},{97.2,128}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(convConWin.QRadAbs_flow, QRadAbs_flow) annotation (Line(
              points={{102,109},{102,90},{-260,90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(convConWin.TSha, TSha) annotation (Line(
              points={{108,109},{108,60},{-250,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conQCon_flow.port, vol.heatPort) annotation (Line(points={{-200,-100},
                  {-118,-100},{20,-100},{20,-200},{10,-200}},           color={191,0,0}));
          connect(QCon_flow, conQCon_flow.Q_flow) annotation (Line(points={{-260,-100},{
                  -240,-100},{-220,-100}}, color={0,0,127}));
          connect(QLat_flow, mWat_flow.u)
            annotation (Line(points={{-260,-160},{-222,-160}}, color={0,0,127}));
          connect(mWat_flow.y, vol.mWat_flow) annotation (Line(points={{-199,-160},{-168,
                  -160},{-168,-212},{-30,-212},{-30,-180},{16,-180},{16,-192},{12,-192}},
                color={0,0,127}));
          connect(conQLat_flow.Q_flow, QLat_flow) annotation (Line(points={{-220,-80},{-230,
                  -80},{-230,-160},{-260,-160}}, color={0,0,127}));
          connect(conQLat_flow.port, vol.heatPort) annotation (Line(points={{-200,-80},{
                  -96,-80},{20,-80},{20,-200},{10,-200}}, color={191,0,0}));
          connect(vol.C_flow, C_flow) annotation (Line(points={{12,-206},{16,-206},{16,-220},
                  {-260,-220}}, color={0,0,127}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,
                    240}})),
            Icon(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,240}}),
                            graphics={
                  Rectangle(
                  extent={{-144,184},{148,-200}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Sphere),
                Text(
                  extent={{-228,-244},{-178,-194}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="C_flow",
                  visible = use_C_flow)}),
            Documentation(info="<html>
<p>
This model computes the heat and mass balance of the air.
The model assumes a completely mixed air volume.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
April 8, 2019, by Michael Wetter:<br/>
Propagated parameter <code>mSenFac</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1405\">Buildings #1405</a>.
</li>
<li>
December 14, 2018, by Michael Wetter:<br/>
Replaced call to <code>Medium.enthalpyOfCondensingGas</code> with
<code>Buildings.Media.Air.enthalpyOfCondensingGas</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1285\">Buildings #1285</a>.
</li>
<li>
April 12, 2017, by Michael Wetter:<br/>
Removed temperature connection that is no longer needed.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
May 2, 2016, by Michael Wetter:<br/>
Refactored implementation of latent heat gain.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/515\">issue 515</a>.
</li>
<li>
March 2, 2015, by Michael Wetter:<br/>
Refactored model to allow a temperature dependent convective heat transfer
on the room side.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/52\">52</a>.
</li>
<li>
July 17, 2013, by Michael Wetter:<br/>
Separated the model into a partial base class and a model that uses the mixed air assumption.
</li>
<li>
July 12, 2013, by Michael Wetter:<br/>
First implementation to facilitate the implementation of non-uniform room air models.
</li>
</ul>
</html>"));
        end MixedAirHeatMassBalance;

        partial model PartialAirHeatMassBalance
          "Partial model for heat and mass balance of the air"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.ConstructionRecords;

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

          parameter Boolean haveShade
            "Set to true if at least one window has an interior or exterior shade";

          parameter Modelica.SIunits.Volume V "Volume";

          // Input/output signals
          Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin] if haveShade
            "Input connector, used to scale the surface area to take into account an operable shading device, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-280,180},{-240,220}}),
                iconTransformation(extent={{-256,192},{-240,208}})));
          Modelica.Blocks.Interfaces.RealInput QRadAbs_flow[NConExtWin](
          each final unit="W") if
             haveShade
            "Total net radiation that is absorbed by the shade (positive if absorbed)"
            annotation (Placement(transformation(extent={{-280,70},{-240,110}}),
                iconTransformation(extent={{-260,90},{-240,110}})));

          Modelica.Blocks.Interfaces.RealInput QCon_flow
            "Convective sensible heat gains of the room"
            annotation (Placement(transformation(extent={{-280,-120},{-240,-80}})));
          Modelica.Blocks.Interfaces.RealInput QLat_flow
            "Latent heat gains for the room"
            annotation (Placement(transformation(extent={{-280,-180},{-240,-140}})));

          Modelica.Blocks.Interfaces.RealOutput TSha[NConExtWin](
           each final unit="K",
           each final quantity="ThermodynamicTemperature") if
              haveShade "Shade temperature"
            annotation (Placement(transformation(extent={{-240,50},{-260,70}})));

          // Fluid port
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each final package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-238})));

          // Heat ports
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
            "Heat port to air volume"
            annotation (Placement(transformation(extent={{-250,-10},{-230,10}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExt[NConExt] if
             haveConExt
            "Heat port that connects to room-side surface of exterior constructions"
                                      annotation (Placement(transformation(extent={{230,210},
                    {250,230}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWin[NConExtWin] if
             haveConExtWin
            "Heat port that connects to room-side surface of exterior constructions that contain a window"
                                      annotation (Placement(transformation(extent={{230,170},
                    {250,190}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
             haveConExtWin
            "Heat port that connects to room-side surface of unshaded glass"
                                      annotation (Placement(transformation(extent={{230,110},
                    {250,130}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
               haveShade "Heat port that connects to room-side surface of shaded glass"
                                      annotation (Placement(transformation(extent={{230,70},
                    {250,90}}), iconTransformation(extent={{230,70},
                    {250,90}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWinFra[NConExtWin] if
             haveConExtWin
            "Heat port that connects to room-side surface of window frame"
                                      annotation (Placement(transformation(extent={{232,-10},
                    {252,10}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_a[NConPar] if
             haveConPar
            "Heat port that connects to room-side surface a of partition constructions"
                                      annotation (Placement(transformation(extent={{232,-70},
                    {252,-50}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_b[NConPar] if
             haveConPar
            "Heat port that connects to room-side surface b of partition constructions"
                                      annotation (Placement(transformation(extent={{232,
                    -110},{252,-90}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conBou[NConBou] if
             haveConBou
            "Heat port that connects to room-side surface of constructions that expose their other surface to the outside"
                                      annotation (Placement(transformation(extent={{232,
                    -170},{252,-150}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conSurBou[NSurBou] if
             haveSurBou
            "Heat port to surfaces of models that compute the heat conduction outside of this room"
                                      annotation (Placement(transformation(extent={{231,
                    -230},{251,-210}})));

          // Surface areas
      protected
          final parameter Modelica.SIunits.Area AConExt[NConExt] = datConExt.A
            "Areas of exterior constructions";
          final parameter Modelica.SIunits.Area AConExtWinOpa[NConExtWin] = datConExtWin.AOpa
            "Opaque areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConExtWinGla[NConExtWin] = (1 .- datConExtWin.fFra) .* datConExtWin.AWin
            "Glass areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConExtWinFra[NConExtWin] = datConExtWin.fFra .* datConExtWin.AWin
            "Frame areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConPar[NConPar] = datConPar.A
            "Areas of partition constructions";
          final parameter Modelica.SIunits.Area AConBou[NConBou] = datConBou.A
            "Areas of constructions with exterior boundary conditions exposed to outside of room model";
          final parameter Modelica.SIunits.Area ASurBou[NSurBou] = surBou.A
            "Area of surface models of constructions that are modeled outside of this room";
          annotation (
            preferredView="info",
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,
                    240}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,240}}),
                            graphics={
                Text(
                  extent={{-230,182},{-188,216}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="uSha"),
                Text(
                  extent={{-232,82},{-190,116}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="QRadAbs"),
                Text(
                  extent={{-228,44},{-186,78}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="TSha"),
                  Rectangle(
                  extent={{-144,184},{148,-200}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Sphere),
                Text(
                  extent={{-84,232},{94,282}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name"),
                Text(
                  extent={{-230,-124},{-180,-74}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="QCon"),
                Text(
                  extent={{-228,-184},{-178,-134}},
                  lineColor={0,0,127},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  textString="QLat")}),
            Documentation(info="<html>
<p>
This is a partial model that is used to implement the heat and mass balance of the air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
May 2, 2016, by Michael Wetter:<br/>
Refactored implementation of latent heat gain.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/515\">issue 515</a>.
</li>
<li>
July 17, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialAirHeatMassBalance;

        partial model PartialSurfaceInterface
          "Partial model that is used for infrared radiation balance"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.ConstructionRecords;

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExt[NConExt]
            "Heat port that connects to room-side surface of exterior constructions"
                                      annotation (Placement(transformation(extent={{230,210},
                    {250,230}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWin[NConExtWin]
            "Heat port that connects to room-side surface of exterior constructions that contain a window"
                                      annotation (Placement(transformation(extent={{230,170},
                    {250,190}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWinFra[NConExtWin]
            "Heat port that connects to room-side surface of window frame"
                                      annotation (Placement(transformation(extent={{232,-10},
                    {252,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_a[NConPar]
            "Heat port that connects to room-side surface a of partition constructions"
                                      annotation (Placement(transformation(extent={{232,-70},
                    {252,-50}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_b[NConPar]
            "Heat port that connects to room-side surface b of partition constructions"
                                      annotation (Placement(transformation(extent={{232,
                    -110},{252,-90}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conBou[NConBou]
            "Heat port that connects to room-side surface of constructions that expose their other surface to the outside"
                                      annotation (Placement(transformation(extent={{232,
                    -170},{252,-150}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conSurBou[NSurBou]
            "Heat port to surfaces of models that compute the heat conduction outside of this room"
                                      annotation (Placement(transformation(extent={{231,
                    -230},{251,-210}})));
      protected
          final parameter String instanceName = getInstanceName() "Name of the instance";
          final parameter Modelica.SIunits.Area AConExt[NConExt] = datConExt.A
            "Areas of exterior constructions";
          final parameter Modelica.SIunits.Area AConExtWinOpa[NConExtWin] = datConExtWin.AOpa
            "Opaque areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConExtWinGla[NConExtWin] = (1 .- datConExtWin.fFra) .* datConExtWin.AWin
            "Glass areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConExtWinFra[NConExtWin] = datConExtWin.fFra .* datConExtWin.AWin
            "Frame areas of exterior construction that have a window";
          final parameter Modelica.SIunits.Area AConPar[NConPar] = datConPar.A
            "Areas of partition constructions";
          final parameter Modelica.SIunits.Area AConBou[NConBou] = datConBou.A
            "Areas of constructions with exterior boundary conditions exposed to outside of room model";
          final parameter Modelica.SIunits.Area ASurBou[NSurBou] = surBou.A
            "Area of surface models of constructions that are modeled outside of this room";

      protected
          function checkSurfaceAreas
            input Integer n "Number of surfaces";
            input Modelica.SIunits.Area A[:] "Surface areas";
            input String name "Name of the surface data record, used in error message";
          algorithm
            if n == 0 then
              assert(Modelica.Math.Vectors.norm(v=A, p=1) < 1E-10,
              "Error in declaration of room model: Construction record '" +
              name +
              "' has the following areas: " +
              Modelica.Math.Vectors.toString(A) +
              "However, the room model is declared as having zero surfaces.
Check the parameters of the room model.");
            else
              for i in 1:n loop
                assert(A[i] > 0, "Error in declaration of room model: Construction record '" + name + "' has the following areas: " +
              Modelica.Math.Vectors.toString(A) +
              "However, the surface areas must be bigger than zero.
Check the parameters of the room model.");
              end for;
            end if;
          end checkSurfaceAreas;
        initial algorithm
          checkSurfaceAreas(nConExt,    datConExt.A,       instanceName + ".datConExt");
          checkSurfaceAreas(nConExtWin, datConExtWin.AWin, instanceName + ".datConExtWin");
          checkSurfaceAreas(nConPar,    datConPar.A,       instanceName + ".datConPar");
          checkSurfaceAreas(nConBou,    datConBou.A,       instanceName + ".datConBou");
          checkSurfaceAreas(nSurBou,    surBou.A,          instanceName + ".surBou");
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                    -240},{240,240}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-240,-240},{240,240}}),
                                              graphics={
                Rectangle(
                  extent={{-240,240},{240,-240}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{148,206},{174,-206}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-170,-200},{172,-224}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-170,206},{-144,-224}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-170,208},{174,184}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-234,328},{242,244}},
                  lineColor={0,0,127},
                  textString="%name"),
                Rectangle(
                  extent={{-144,184},{148,-198}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid)}),
                Documentation(info="<html>
<p>
This partial model is used as a base class for models that need to exchange
heat with room-facing surfaces. It defines parameters for the surface areas.
The model is used as a base class to implement the convective model, and the various
radiation models.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 12, 2013, by Michael Wetter:<br/>
Removed the radiation related declarations
to facilitate the separation of the convective and radiative model.
</li>
<li>
July 17, 2012, by Michael Wetter:<br/>
Added validity check of surface areas.
This helped catching a bug in an early implementation of BESTEST Case960
in which the extending class set <code>nConExtWin=0</code>,
but did not set the area to zero.
Because the radiation balance model computes exchange among
<code>NConExtWin=max(nConExtWin, 1)</code> areas, its result was wrong.
</li>
<li>
November 6, 2011, by Michael Wetter:<br/>
Changed parameters that contain radiative properties from final to non-final, as
they need to be overwritten by
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.SolarRadiationExchange\">
Buildings.ThermalZones.Detailed.BaseClasses.SolarRadiationExchange</a>.
</li>
<li>
November 16 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialSurfaceInterface;

        partial model PartialSurfaceInterfaceRadiative
          "Partial model that is used for infrared radiation balance"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialSurfaceInterface;

      protected
          parameter Modelica.SIunits.Emissivity epsConExt[NConExt] = datConExt.layers.absIR_b
            "Absorptivity of exterior constructions";
          parameter Modelica.SIunits.Emissivity epsConExtWinOpa[NConExtWin] = datConExtWin.layers.absIR_b
            "Absorptivity of opaque part of exterior constructions that contain a window";
          parameter Modelica.SIunits.Emissivity epsConExtWinUns[NConExtWin]=
            {(datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].absIR_b) for i in 1:NConExtWin}
            "Absorptivity of unshaded part of window constructions";
          parameter Modelica.SIunits.Emissivity epsConExtWinSha[NConExtWin] = datConExtWin.glaSys.shade.absIR_a
            "Absorptivity of shaded part of window constructions";
          parameter Modelica.SIunits.Emissivity epsConExtWinFra[NConExtWin] = datConExtWin.glaSys.absIRFra
            "Absorptivity of window frame";
          parameter Modelica.SIunits.Emissivity epsConPar_a[NConPar] = datConPar.layers.absIR_a
            "Absorptivity of partition constructions surface a";
          parameter Modelica.SIunits.Emissivity epsConPar_b[NConPar] = datConPar.layers.absIR_b
            "Absorptivity of partition constructions surface b";
          parameter Modelica.SIunits.Emissivity epsConBou[NConBou] = datConBou.layers.absIR_b
            "Absorptivity of constructions with exterior boundary conditions exposed to outside of room model";
          parameter Modelica.SIunits.Emissivity epsSurBou[NSurBou] = surBou.absIR
            "Absorptivity of surface models of constructions that are modeled outside of this room";

          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                    -240},{240,240}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-240,-240},{240,240}}),
                                              graphics={
                Text(
                  extent={{-234,328},{242,244}},
                  lineColor={0,0,127},
                  textString="%name")}),
                Documentation(info="<html>
<p>
This partial model is used as a base class for models that need to exchange
heat with room-facing surfaces by radiation. It declares parameters that are
needed for the radiative balance.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 12, 2013, by Michael Wetter:<br/>
First implementation to facilitate the separation of the convective and radiative model.
</li>
</ul>
</html>"));
        end PartialSurfaceInterfaceRadiative;

        model RadiationAdapter
          "Model to connect between signals and heat port for radiative gains of the room"
          extends Buildings.BaseClasses.BaseIcon;

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a rad
            "Port for radiative heat gain and radiation temperature"    annotation (Placement(transformation(extent={{-10,
                    -110},{10,-90}}), iconTransformation(extent={{-12,
                    -110},{8,-90}})));
      public
          Modelica.Blocks.Interfaces.RealInput TRad "Radiation temperature of room"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput QRad_flow "Radiative heat gain"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));
        equation
          QRad_flow = rad.Q_flow;
          rad.T = TRad;
         annotation (Placement(transformation(extent={{-140,-20},{-100,20}})),
                    Documentation(info="<html>
This model can be used as a thermal adapter in situations where the temperature
and the heat flow rate are computed in separate models.
For example, this thermal adapter is used in the room model, which computes
the distribution of radiative heat gains (such as due to a radiator) in
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.InfraredRadiationGainDistribution\">
Buildings.ThermalZones.Detailed.BaseClasses.InfraredRadiationGainDistribution</a>
and computes the radiative temperature in
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.RadiationTemperature\">
Buildings.ThermalZones.Detailed.BaseClasses.RadiationTemperature</a>.
This adapter combines the heat flow rate and the temperatures that are computed in these
separate models, and exposes these two quantities at its heat port.

</html>",       revisions="<html>
<ul>
<li>
Feb. 2, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                    Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  extent={{-90,24},{-40,-26}},
                  lineColor={0,0,127},
                  textString="TRad"),
                Text(
                  extent={{50,14},{92,-12}},
                  lineColor={0,0,127},
                  textString="Q")}),
                Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room,
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",       revisions="<html>
<ul>
<li>
June 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationAdapter;

        model RadiationTemperature "Radiative temperature of the room"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialSurfaceInterfaceRadiative;

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
             haveConExtWin
            "Heat port that connects to room-side surface of unshaded glass"
                                      annotation (Placement(transformation(extent={{230,110},
                    {250,130}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
            haveShade "Heat port that connects to room-side surface of shaded glass"
                                      annotation (Placement(transformation(extent={{230,70},
                    {250,90}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha[NConExtWin] if
            haveShade "Heat port that connects to shade"
                                               annotation (Placement(transformation(extent={{230,28},
                    {250,48}})));
          parameter Boolean haveShade "Set to true if the windows have a shade"
          annotation(HideResult=true);

          Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
               haveShade
            "Control signal for the shading device (removed if no shade is present)"
            annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
                iconTransformation(extent={{-280,160},{-240,200}})));

          Modelica.Blocks.Interfaces.RealOutput TRad(min=0, unit="K", displayUnit="degC")
            "Radiative temperature"
            annotation (Placement(transformation(extent={{-240,-190},{-260,-170}}),
                iconTransformation(extent={{-240,-194},{-260,-174}})));

      protected
          final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
            "Number of opaque surfaces, including the window frame";
          final parameter Integer NWin = NConExtWin "Number of window surfaces";
          final parameter Integer NTot = NOpa + NWin "Total number of surfaces";

          final parameter Modelica.SIunits.Area AGla[NWin] = datConExtWin.AGla
            "Surface area of opaque surfaces";
          final parameter Real epsGla[NWin](each min=0, each max=1)=
            {datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].absIR_b for i in 1:NWin}
            "Absorptivity of glass";
          final parameter Real epsSha[NWin](each min=0, each max=1)=
            {datConExtWin[i].glaSys.shade.absIR_a for i in 1:NWin}
            "Absorptivity of shade";
          final parameter Real tauSha[NWin](each min=0, each max=1)=
            {(if datConExtWin[i].glaSys.haveInteriorShade then
              datConExtWin[i].glaSys.shade.tauIR_a else 1) for i in 1:NWin}
            "Transmissivity of shade";
          final parameter Modelica.SIunits.Area epsAOpa[NOpa](each fixed=false)
            "Product of area times absorptivity of opaque surfaces";
          final parameter Modelica.SIunits.Area epsAGla[NWin](each fixed=false)
            "Product of area times absorptivity of window surfaces";
          final parameter Modelica.SIunits.Area epsASha[NWin](each fixed=false)
            "Product of area times absorptivity of window shade";
          final parameter Modelica.SIunits.Area epsTauASha[NWin](each fixed=false)
            "Product of area times glass absorptivity times shade transmittance";
          Modelica.SIunits.Temperature TOpa[NOpa](each start=293.15, each nominal=293.15)
            "Temperature of opaque surfaces";
          Modelica.SIunits.Temperature TGlaUns[NWin](each start=293.15, each nominal=293.15)
            "Temperature of unshaded part of glass";
          Modelica.SIunits.Temperature TGlaSha[NWin](each start=293.15, each nominal=293.15)
            "Temperature of shaded part of glass";
          Modelica.SIunits.Temperature TSha[NWin](each start=293.15, each nominal=293.15)
            "Temperature of shade";
          // Internal connectors, used because of the conditionally removed connectors
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_internal[NConExtWin]
            "Heat port that connects to room-side surface of unshaded glass";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_internal[NConExtWin]
            "Heat port that connects to room-side surface of shaded glass";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha_internal[NConExtWin]
            "Heat port that connects to shade";
          Modelica.Blocks.Interfaces.RealInput uSha_internal[NConExtWin](each min=0, each max=1)
            "Control signal for the shading device";

        initial equation
          // The next loops build the array epsAOpa that simplifies
          // the model equations.
          // The arrays stores the values of the constructios in the following order
          // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
          // where x is epsOpa, AOpa or kOpa.
          // The last two entries are for the opaque wall that contains a window, and for the window frame.
          for i in 1:NConExt loop
            epsAOpa[i] = epsConExt[i] * AConExt[i];
          end for;
          for i in 1:NConPar loop
            epsAOpa[i+NConExt]         = epsConPar_a[i] * AConPar[i];
            epsAOpa[i+NConExt+NConPar] = epsConPar_b[i] * AConPar[i];
          end for;
          for i in 1:NConBou loop
            epsAOpa[i+NConExt+2*NConPar] = epsConBou[i] * AConBou[i];
          end for;
          for i in 1:NSurBou loop
            epsAOpa[i+NConExt+2*NConPar+NConBou] = epsSurBou[i] * ASurBou[i];
          end for;
          for i in 1:NConExtWin loop
            // Opaque part of construction that has a window embedded
            epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou] = epsConExtWinOpa[i] * AConExtWinOpa[i];
            // Window frame
            epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = epsConExtWinFra[i] * AConExtWinFra[i];
          end for;
          // Window glass
          for i in 1:NConExtWin loop
            // Window glass
            epsAGla[i] = AGla[i] * epsGla[i];
            // Window shade
            epsASha[i]    = AGla[i] * epsSha[i];
            // Emitted from glas and transmitted through window shade
            epsTauASha[i] = AGla[i] * epsGla[i] * tauSha[i];
          end for;
        ////////////////////////////////////////////////////////////////////
        equation
          // Conditional connnector
          connect(glaUns, glaUns_internal);
          connect(glaSha, glaSha_internal);
          connect(sha, sha_internal);
          connect(uSha, uSha_internal);
          if not haveConExtWin then
            glaUns_internal.T = fill(293.15, NConExtWin);
          end if;
          if not haveShade then
            glaSha_internal.T = fill(293.15, NConExtWin);
            sha_internal.T = fill(293.15, NConExtWin);
            uSha_internal = fill(0, NConExtWin);
          end if;

          // Assign temperature of opaque surfaces
          for i in 1:NConExt loop
            TOpa[i] = conExt[i].T;
          end for;
          for i in 1:NConPar loop
            TOpa[i+NConExt]         = conPar_a[i].T;
            TOpa[i+NConExt+NConPar] = conPar_b[i].T;
          end for;
          for i in 1:NConBou loop
            TOpa[i+NConExt+2*NConPar] = conBou[i].T;
          end for;
          for i in 1:NSurBou loop
            TOpa[i+NConExt+2*NConPar+NConBou] = conSurBou[i].T;
          end for;
          for i in 1:NConExtWin loop
            TOpa[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].T;
            TOpa[i+NConExt+2*NConPar+NConBou+NConExtWin+NSurBou] = conExtWinFra[i].T;
          end for;
          // Assign temperature of glass and shade
          for i in 1:NConExtWin loop
            TGlaUns[i] = glaUns_internal[i].T;
            TGlaSha[i] = glaSha_internal[i].T;
            TSha[i]    = sha_internal[i].T;
          end for;
          // Compute radiative temperature
          if haveShade then
            TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa)
                + sum(
              ( uSha_internal[i] * (epsASha[i] * TSha[i] + epsTauASha[i] * TGlaSha[i]) +
              (1-uSha_internal[i]) * epsAGla[i] * TGlaUns[i])
                for i in 1:NConExtWin))  /
                (sum(epsAOpa) + sum(
              ( uSha_internal[i] * (epsASha[i] + epsTauASha[i]) + (1-uSha_internal[i]) * epsAGla[i])
                for i in 1:NConExtWin));
              else
            TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa) + sum(epsAGla .* TGlaUns)) / (sum(epsAOpa) + sum(epsAGla));
          end if;

          // Assign heat exchange to connectors
          if haveConExt then
            for i in 1:NConExt loop
              0 = conExt[i].Q_flow;
            end for;
          else
              conExt[1].T = 293.15;
          end if;

          if haveConPar then
            for i in 1:NConPar loop
              0 = conPar_a[i].Q_flow;
              0 = conPar_b[i].Q_flow;
            end for;
          else
              conPar_a[1].T = 293.15;
              conPar_b[1].T = 293.15;
          end if;

          if haveConBou then
            for i in 1:NConBou loop
              0 = conBou[i].Q_flow;
            end for;
          else
             conBou[1].T = 293.15;
          end if;

          if haveSurBou then
            for i in 1:NSurBou loop
              0 = conSurBou[i].Q_flow;
            end for;
          else
              conSurBou[1].T = 293.15;
          end if;

          if haveConExtWin then
            for i in 1:NConExtWin loop
              0 = conExtWin[i].Q_flow;
              0 = conExtWinFra[i].Q_flow;
            end for;
          else
              conExtWin[1].T    = 293.15;
              conExtWinFra[1].T = 293.15;
          end if;

          annotation (
        preferredView="info",
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,240}}),
                              graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-240,-240},{240,240}}),
                                              graphics={
                Line(
                  points={{-144,-8},{146,-8}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{2,-200},{2,184}},
                  color={255,0,0},
                  smooth=Smooth.None,
                  thickness=0.5)}),
        Documentation(
        info="<html>
<p>
This model computes the radiative temperature in the room.
For a room with windows but no shade, the radiative temperature is
computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  T<sub>rad</sub> = &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp; T<sup>i</sup>)
  &frasl;
  &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup>)
</p>
<p>
where
<i>T<sub>rad</sub></i> is the radiative temperature of the room,
<i>A<sup>i</sup></i> are the surface areas of the room,
<i>&epsilon;<sup>i</sup></i> are the infrared emissivities of the surfaces, and
<i>T<sup>i</sup></i> are the surface temperatures.
</p>
<p>
If a the windows have a shade, then the equation is modified to take the actual shaded and non-shaded
surface area into account. In this situation, the shaded part of a window has a infrared radiative power
of</p>
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; ( u &nbsp; &epsilon;<sub>s</sub> &nbsp; T<sub>s</sub> +
   (1-u) &nbsp; &epsilon;<sub>g</sub> &tau;<sub>s</sub> &nbsp; T<sub>gs</sub>)
</p>
<p>
where
<i>A</i> is the surface area of the glass,
<i>u</i> is the control signal of the shade,
<i>&epsilon;<sub>s</sub></i> is the infrared absorptivity of the shade,
<i>T<sub>s</sub></i> is the temperature of the shade,
<i>&epsilon;<sub>g</sub></i> is the infrared absorptivity of the glass,
<i>&tau;<sub>s</sub></i> is the infrared transmittance of the shade, and
<i>T<sub>gs</sub></i> is the glass temperature behind the shade.
</p>
<p>
For the unshaded part of the window, the radiative power is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; (1-u) &nbsp; &epsilon;<sub>g</sub> &nbsp; T<sub>gn</sub>
</p>
<p>where
<i>T<sub>gn</sub></i> is the glass temperature of the non-shaded part of the window.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
March 29 2011, by Michael Wetter:<br/>
Rewrote sum for the radiation temperature.
</li>
<li>
Jan. 18 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationTemperature;

        partial model RoomHeatMassBalance "Base model for a room"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.ConstructionRecords;

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);

          constant Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(HideResult=true);

          parameter Integer nPorts=0 "Number of ports" annotation (Evaluate=true,
              Dialog(
              connectorSizing=true,
              tab="General",
              group="Ports"));
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(
                extent={{-40,-10},{40,10}},
                origin={-260,-60},
                rotation=90), iconTransformation(
                extent={{-40,-10},{40,10}},
                rotation=90,
                origin={-150,-100})));
          parameter Modelica.SIunits.Angle lat "Latitude";
          final parameter Modelica.SIunits.Volume V=AFlo*hRoo "Volume";
          parameter Modelica.SIunits.Area AFlo "Floor area";
          parameter Modelica.SIunits.Length hRoo "Average room height";

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
            "Heat port to air volume" annotation (Placement(transformation(extent={{-270,30},
                    {-250,50}}),   iconTransformation(extent={{-20,-10},{0,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorRad
            "Heat port for radiative heat gain and radiative temperature" annotation (
              Placement(transformation(extent={{-270,-10},{-250,10}}),
                        iconTransformation(extent={{-20,-48},{0,-28}})));
          ////////////////////////////////////////////////////////////////////////
          // Constructions
          Constructions.Construction conExt[NConExt](
            final A=datConExt.A,
            final til=datConExt.til,
            final layers=datConExt.layers,
            final steadyStateInitial=datConExt.steadyStateInitial,
            final T_a_start=datConExt.T_a_start,
            final T_b_start=datConExt.T_b_start,
            final stateAtSurface_a = datConExt.stateAtSurface_a,
            final stateAtSurface_b = datConExt.stateAtSurface_b) if haveConExt
            "Heat conduction through exterior construction that have no window"
            annotation (Placement(transformation(extent={{288,100},{242,146}})));
          Constructions.ConstructionWithWindow conExtWin[NConExtWin](
            final A=datConExtWin.A,
            final til=datConExtWin.til,
            final layers=datConExtWin.layers,
            final steadyStateInitial=datConExtWin.steadyStateInitial,
            final T_a_start=datConExtWin.T_a_start,
            final T_b_start=datConExtWin.T_b_start,
            final AWin=datConExtWin.AWin,
            final fFra=datConExtWin.fFra,
            final glaSys=datConExtWin.glaSys,
            each final homotopyInitialization=homotopyInitialization,
            each final linearizeRadiation=linearizeRadiation,
            each final steadyStateWindow=steadyStateWindow,
            final stateAtSurface_a = datConExtWin.stateAtSurface_a,
            final stateAtSurface_b = datConExtWin.stateAtSurface_b) if haveConExtWin
            "Heat conduction through exterior construction that have a window"
            annotation (Placement(transformation(extent={{280,44},{250,74}})));

          Constructions.Construction conPar[NConPar](
            A=datConPar.A,
            til=datConPar.til,
            final layers=datConPar.layers,
            steadyStateInitial=datConPar.steadyStateInitial,
            T_a_start=datConPar.T_a_start,
            T_b_start=datConPar.T_b_start,
            final stateAtSurface_a = datConPar.stateAtSurface_a,
            final stateAtSurface_b = datConPar.stateAtSurface_b) if haveConPar
            "Heat conduction through partitions that have both sides inside the thermal zone"
            annotation (Placement(transformation(extent={{282,-122},{244,-84}})));

          Constructions.Construction conBou[NConBou](
            A=datConBou.A,
            til=datConBou.til,
            final layers=datConBou.layers,
            steadyStateInitial=datConBou.steadyStateInitial,
            T_a_start=datConBou.T_a_start,
            T_b_start=datConBou.T_b_start,
            final stateAtSurface_a = datConBou.stateAtSurface_a,
            final stateAtSurface_b = datConBou.stateAtSurface_b) if haveConBou
            "Heat conduction through opaque constructions that have the boundary conditions of the other side exposed"
            annotation (Placement(transformation(extent={{282,-156},{242,-116}})));
          parameter Boolean linearizeRadiation=true
            "Set to true to linearize emissive power";

          parameter Boolean steadyStateWindow = false
            "Set to false to add thermal capacity at window, which generally leads to faster simulation"
            annotation (Dialog(tab="Dynamics", group="Glazing system"));
          ////////////////////////////////////////////////////////////////////////
          // Convection
          parameter Buildings.HeatTransfer.Types.InteriorConvection intConMod=Buildings.HeatTransfer.Types.InteriorConvection.Temperature
            "Convective heat transfer model for room-facing surfaces of opaque constructions"
            annotation (Dialog(group="Convective heat transfer"));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hIntFixed=3.0
            "Constant convection coefficient for room-facing surfaces of opaque constructions"
            annotation (Dialog(group="Convective heat transfer", enable=(intConMod ==
                  Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));
          parameter Buildings.HeatTransfer.Types.ExteriorConvection extConMod=Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
            "Convective heat transfer model for exterior facing surfaces of opaque constructions"
            annotation (Dialog(group="Convective heat transfer"));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hExtFixed=10.0
            "Constant convection coefficient for exterior facing surfaces of opaque constructions"
            annotation (Dialog(group="Convective heat transfer", enable=(extConMod ==
                  Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0) = V*1.2/3600
            "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
          parameter Boolean sampleModel = false
            "Set to true to time-sample the model, which can give shorter simulation time if there is already time sampling in the system model"
            annotation (Evaluate=true, Dialog(tab="Experimental (may be changed in future releases)"));
          ////////////////////////////////////////////////////////////////////////
          // Control signals
          Modelica.Blocks.Interfaces.RealInput uWin[nConExtWin](
            each min=0, each max=1, each unit="1") if haveControllableWindow
            "Control signal for window state (used for electrochromic windows, removed otherwise)"
             annotation (Placement(
                transformation(extent={{-20,-20},{20,20}},   origin={-280,140}),
                iconTransformation(
                extent={{-16,-16},{16,16}},
                origin={-216,130})));

          ////////////////////////////////////////////////////////////////////////
          // Models for boundary conditions
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_conBou[nConBou] if
            haveConBou "Heat port at surface b of construction conBou" annotation (
              Placement(transformation(extent={{-270,-190},{-250,-170}}),
                iconTransformation(extent={{50,-170},{70,-150}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_surBou[nSurBou] if
            haveSurBou "Heat port of surface that is connected to the room air"
            annotation (Placement(transformation(extent={{-270,-150},{-250,-130}}),
                iconTransformation(extent={{-48,-150},{-28,-130}})));
          Modelica.Blocks.Interfaces.RealInput qGai_flow[3](each unit="W/m2")
            "Radiant, convective and latent heat input into room (positive if heat gain)"
            annotation (Placement(transformation(extent={{-300,60},{-260,100}}),
                iconTransformation(extent={{-232,64},{-200,96}})));
          // Reassign the tilt since a construction that is declared as a ceiling of the
          // room model has an exterior-facing surface that is a floor
          BaseClasses.ExteriorBoundaryConditions bouConExt(
            final nCon=nConExt,
            final lat=lat,
            linearizeRadiation=linearizeRadiation,
            final conMod=extConMod,
            final conPar=datConExt,
            final hFixed=hExtFixed) if haveConExt
            "Exterior boundary conditions for constructions without a window"
            annotation (Placement(transformation(extent={{352,114},{382,144}})));
          // Reassign the tilt since a construction that is declared as a ceiling of the
          // room model has an exterior-facing surface that is a floor
          BaseClasses.ExteriorBoundaryConditionsWithWindow bouConExtWin(
            final nCon=nConExtWin,
            final lat=lat,
            final conPar=datConExtWin,
            linearizeRadiation=linearizeRadiation,
            final conMod=extConMod,
            final hFixed=hExtFixed) if haveConExtWin
            "Exterior boundary conditions for constructions with a window"
            annotation (Placement(transformation(extent={{352,44},{382,74}})));

          HeatTransfer.Windows.BaseClasses.WindowRadiation conExtWinRad[NConExtWin](
            final AWin=(1 .- datConExtWin.fFra) .* datConExtWin.AWin,
            final N={size(datConExtWin[i].glaSys.glass, 1) for i in 1:NConExtWin},
            final tauGlaSol=datConExtWin.glaSys.glass.tauSol,
            final rhoGlaSol_a=datConExtWin.glaSys.glass.rhoSol_a,
            final rhoGlaSol_b=datConExtWin.glaSys.glass.rhoSol_b,
            final xGla=datConExtWin.glaSys.glass.x,
            final tauShaSol_a=datConExtWin.glaSys.shade.tauSol_a,
            final tauShaSol_b=datConExtWin.glaSys.shade.tauSol_b,
            final rhoShaSol_a=datConExtWin.glaSys.shade.rhoSol_a,
            final rhoShaSol_b=datConExtWin.glaSys.shade.rhoSol_b,
            final haveExteriorShade=datConExtWin.glaSys.haveExteriorShade,
            final haveInteriorShade=datConExtWin.glaSys.haveInteriorShade) if
            haveConExtWin "Model for solar radiation through shades and window"
            annotation (Placement(transformation(extent={{320,-24},{300,-4}})));

          BoundaryConditions.WeatherData.Bus weaBus "Weather data"
            annotation (Placement(
                transformation(extent={{170,150},{190,170}}), iconTransformation(extent=
                   {{166,166},{192,192}})));

          replaceable BaseClasses.PartialAirHeatMassBalance air
           constrainedby BaseClasses.PartialAirHeatMassBalance(
                redeclare final package Medium = Medium,
                nPorts=nPorts,
                final nConExt=nConExt,
                final nConExtWin=nConExtWin,
                final nConPar=nConPar,
                final nConBou=nConBou,
                final nSurBou=nSurBou,
                final datConExt=datConExt,
                final datConExtWin=datConExtWin,
                final datConPar=datConPar,
                final datConBou=datConBou,
                final surBou=surBou,
                final haveShade=haveShade,
                final V=V) "Convective heat and mass balance of air"
            annotation (Placement(transformation(extent={{40,-142},{64,-118}})));

          Buildings.ThermalZones.Detailed.BaseClasses.SolarRadiationExchange solRadExc(
            final nConExt=nConExt,
            final nConExtWin=nConExtWin,
            final nConPar=nConPar,
            final nConBou=nConBou,
            final nSurBou=nSurBou,
            final datConExt = datConExt,
            final datConExtWin = datConExtWin,
            final datConPar = datConPar,
            final datConBou = datConBou,
            final surBou = surBou,
            final isFloorConExt=isFloorConExt,
            final isFloorConExtWin=isFloorConExtWin,
            final isFloorConPar_a=isFloorConPar_a,
            final isFloorConPar_b=isFloorConPar_b,
            final isFloorConBou=isFloorConBou,
            final isFloorSurBou=isFloorSurBou,
            final tauGla={datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].tauSol[1] for i in 1:NConExtWin}) if
               haveConExtWin "Solar radiative heat exchange"
            annotation (Placement(transformation(extent={{-100,40},{-80,60}})));

          Buildings.ThermalZones.Detailed.BaseClasses.InfraredRadiationGainDistribution irRadGai(
            final nConExt=nConExt,
            final nConExtWin=nConExtWin,
            final nConPar=nConPar,
            final nConBou=nConBou,
            final nSurBou=nSurBou,
            final datConExt = datConExt,
            final datConExtWin = datConExtWin,
            final datConPar = datConPar,
            final datConBou = datConBou,
            final surBou = surBou,
            final haveShade=haveShade)
            "Distribution for infrared radiative heat gains (e.g., due to equipment and people)"
            annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));

          Buildings.ThermalZones.Detailed.BaseClasses.InfraredRadiationExchange irRadExc(
            final nConExt=nConExt,
            final nConExtWin=nConExtWin,
            final nConPar=nConPar,
            final nConBou=nConBou,
            final nSurBou=nSurBou,
            final datConExt = datConExt,
            final datConExtWin = datConExtWin,
            final datConPar = datConPar,
            final datConBou = datConBou,
            final surBou = surBou,
            final linearizeRadiation = linearizeRadiation,
            final homotopyInitialization = homotopyInitialization,
            final sampleModel = sampleModel)
            "Infrared radiative heat exchange"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));

          Buildings.ThermalZones.Detailed.BaseClasses.RadiationTemperature radTem(
            final nConExt=nConExt,
            final nConExtWin=nConExtWin,
            final nConPar=nConPar,
            final nConBou=nConBou,
            final nSurBou=nSurBou,
            final datConExt=datConExt,
            final datConExtWin=datConExtWin,
            final datConPar=datConPar,
            final datConBou=datConBou,
            final surBou=surBou,
            final haveShade=haveShade) "Radiative temperature of the room"
            annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));

          HeatTransfer.Windows.BaseClasses.ShadeRadiation shaRad[NConExtWin](
            final A=(1 .- datConExtWin.fFra) .* datConExtWin.AWin,
            final thisSideHasShade=haveInteriorShade,
            final absIR_air=datConExtWin.glaSys.shade.absIR_a,
            final absIR_glass={(datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].absIR_b)
                                 for i in 1:NConExtWin},
            final tauIR_air=tauIRSha_air,
            final tauIR_glass=tauIRSha_glass,
            each final linearize = linearizeRadiation,
            each final homotopyInitialization=homotopyInitialization) if
               haveShade "Radiation model for room-side window shade"
            annotation (Placement(transformation(extent={{-60,90},{-40,110}})));

      protected
          final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air[NConExtWin]=
            datConExtWin.glaSys.shade.tauIR_a
            "Infrared transmissivity of shade for radiation coming from the exterior or the room"
            annotation (Dialog(group="Shading"));
                final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass[NConExtWin]=
            datConExtWin.glaSys.shade.tauIR_b
            "Infrared transmissivity of shade for radiation coming from the glass"
            annotation (Dialog(group="Shading"));

          // If at least one glass layer in the room has mutiple states, then
          // set haveControllableWindow=true. In this case, the input connector for
          // the control signal will be enabled. Otherwise, it is removed.
          final parameter Boolean haveControllableWindow=
          Modelica.Math.BooleanVectors.anyTrue(
            {datConExtWin[i].glaSys.haveControllableWindow for i in 1:NConExtWin})
            "Flag, true if the windows allow multiple states, such as for electrochromic windows"
            annotation(Evaluate=true);

          final parameter Boolean haveExteriorShade[NConExtWin]=
            {datConExtWin[i].glaSys.haveExteriorShade for i in 1:NConExtWin}
            "Set to true if window has exterior shade (at surface a)"
            annotation (Dialog(group="Shading"));
          final parameter Boolean haveInteriorShade[NConExtWin]=
            {datConExtWin[i].glaSys.haveInteriorShade for i in 1:NConExtWin}
            "Set to true if window has interior shade (at surface b)"
            annotation (Dialog(group="Shading"));

          final parameter Boolean haveShade=
            Modelica.Math.BooleanVectors.anyTrue(haveExteriorShade[:]) or
            Modelica.Math.BooleanVectors.anyTrue(haveInteriorShade[:])
            "Set to true if the windows have a shade";

          final parameter Boolean isFloorConExt[NConExt]=
            datConExt.isFloor "Flag to indicate if floor for exterior constructions";
          final parameter Boolean isFloorConExtWin[NConExtWin]=
            datConExtWin.isFloor "Flag to indicate if floor for constructions";
          final parameter Boolean isFloorConPar_a[NConPar]=
            datConPar.isFloor "Flag to indicate if floor for constructions";
          final parameter Boolean isFloorConPar_b[NConPar]=
            datConPar.isCeiling "Flag to indicate if floor for constructions";
          final parameter Boolean isFloorConBou[NConBou]=
            datConBou.isFloor
            "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
          parameter Boolean isFloorSurBou[NSurBou]=
            surBou.isFloor
            "Flag to indicate if floor for constructions that are modeled outside of this room";

          HeatTransfer.Windows.BaseClasses.ShadingSignal shaSig[NConExtWin](
            each final haveShade=haveShade) if
               haveConExtWin "Shading signal"
            annotation (Placement(transformation(extent={{-220,150},{-200,170}})));

          Buildings.ThermalZones.Detailed.BaseClasses.HeatGain heaGai(final AFlo=AFlo)
            "Model to convert internal heat gains"
            annotation (Placement(transformation(extent={{-220,70},{-200,90}})));

          Buildings.ThermalZones.Detailed.BaseClasses.RadiationAdapter radiationAdapter
            annotation (Placement(transformation(extent={{-180,120},{-160,140}})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{-140,110},{-120,130}})));

          Modelica.Blocks.Math.Add sumJToWin[NConExtWin](
            each final k1=1,
            each final k2=1) if
               haveConExtWin
            "Sum of radiosity flows from room surfaces toward the window"
            annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));

          HeatTransfer.Radiosity.RadiositySplitter radShaOut[NConExtWin] if
             haveConExtWin
            "Splitter for radiosity that strikes shading device or unshaded part of window"
            annotation (Placement(transformation(extent={{-100,120},{-80,140}})));

          Modelica.Blocks.Math.Sum sumJFroWin[NConExtWin](each nin=if haveShade then 2
                 else 1) if
               haveConExtWin "Sum of radiosity fom window to room surfaces"
            annotation (Placement(transformation(extent={{-20,4},{-40,24}})));

          Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature TSha[NConExtWin] if
               haveShade "Temperature of shading device"
            annotation (Placement(transformation(extent={{-20,-78},{-40,-58}})));

        initial equation
          assert(homotopyInitialization, "In " + getInstanceName() +
            ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
            level = AssertionLevel.warning);

        equation
          connect(conBou.opa_a, surf_conBou) annotation (Line(
              points={{282,-122.667},{282,-122},{288,-122},{288,-216},{-240,-216},{-240,
                  -180},{-260,-180}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(bouConExtWin.opa_a, conExtWin.opa_a) annotation (Line(
              points={{352,69},{280,69}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.JInUns_a, bouConExtWin.JOutUns) annotation (Line(
              points={{280.5,60},{304,60},{304,58},{351.5,58}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(bouConExtWin.JInUns, conExtWin.JOutUns_a) annotation (Line(
              points={{351.5,60},{316,60},{316,58},{280.5,58}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(conExtWin.glaUns_a, bouConExtWin.glaUns) annotation (Line(
              points={{280,55},{352,55}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(bouConExtWin.glaSha, conExtWin.glaSha_a) annotation (Line(
              points={{352,53},{280,53}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.JInSha_a, bouConExtWin.JOutSha) annotation (Line(
              points={{280.5,51},{286,51},{286,52},{292,52},{292,49},{351.5,49}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(bouConExtWin.JInSha, conExtWin.JOutSha_a) annotation (Line(
              points={{351.5,51},{290,51},{290,49},{280.5,49}},
              color={0,0,0},
              smooth=Smooth.None));
          connect(conExtWin.fra_a, bouConExtWin.fra) annotation (Line(
              points={{280,46},{352,46}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExt.opa_a, bouConExt.opa_a) annotation (Line(
              points={{288,138.333},{334,138.333},{334,139},{352,139}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(weaBus, bouConExtWin.weaBus) annotation (Line(
              points={{180,160},{400,160},{400,60.05},{378.15,60.05}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaBus, bouConExt.weaBus) annotation (Line(
              points={{180,160},{400,160},{400,130},{378.15,130},{378.15,130.05}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(bouConExtWin.QAbsSolSha_flow, conExtWinRad.QAbsExtSha_flow)
            annotation (Line(
              points={{351,62},{312,62},{312,46},{290,46},{290,-5},{299,-5}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bouConExtWin.inc, conExtWinRad.incAng) annotation (Line(
              points={{382.5,68},{390,68},{390,-15},{321.5,-15}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bouConExtWin.HDir, conExtWinRad.HDir) annotation (Line(
              points={{382.5,65},{388,65},{388,-10},{321.5,-10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bouConExtWin.HDif, conExtWinRad.HDif) annotation (Line(
              points={{382.5,62},{392,62},{392,-6},{321.5,-6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conExtWin.QAbsSha_flow, conExtWinRad.QAbsGlaSha_flow) annotation (
              Line(
              points={{261,43},{261,38},{260,38},{260,-12},{280,-12},{280,-13},{299,-13}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conExtWinRad.QAbsGlaUns_flow, conExtWin.QAbsUns_flow) annotation (
              Line(
              points={{299,-9},{284,-9},{284,-10},{268,-10},{268,36},{269,36},{269,43}},
              color={0,0,127},
              smooth=Smooth.None));
         // Connect statements from the model BaseClasses.MixedAir
          connect(conExt.opa_b, irRadExc.conExt) annotation (Line(
              points={{241.847,138.333},{160,138.333},{160,60},{-60,60},{-60,20},{-80,
                  20},{-80,19.1667}},
              color={190,0,0},
              smooth=Smooth.None));
          connect(conExtWin.fra_b, irRadExc.conExtWinFra) annotation (Line(
              points={{249.9,46},{160,46},{160,60},{-60,60},{-60,10},{-79.9167,10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_a, irRadExc.conPar_a) annotation (Line(
              points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                  60},{-60,8},{-80,8},{-80,7.5},{-79.9167,7.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_b, irRadExc.conPar_b) annotation (Line(
              points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,5.83333},
                  {-79.9167,5.83333}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conBou.opa_b, irRadExc.conBou) annotation (Line(
              points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,3.33333},
                  {-79.9167,3.33333}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(surf_surBou, irRadExc.conSurBou) annotation (Line(
              points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                  {-60,0.833333},{-79.9583,0.833333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conExt, conExt.opa_b) annotation (Line(
              points={{-80,-20.8333},{-80,-20},{-60,-20},{-60,60},{160,60},{160,138.333},
                  {241.847,138.333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conExtWinFra, conExtWin.fra_b) annotation (Line(
              points={{-79.9167,-30},{-60,-30},{-60,60},{160,60},{160,46},{249.9,46}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conPar_a, conPar.opa_a) annotation (Line(
              points={{-79.9167,-32.5},{-60,-32.5},{-60,60},{160,60},{160,-106},{288,
                  -106},{288,-90.3333},{282,-90.3333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conPar_b, conPar.opa_b) annotation (Line(
              points={{-79.9167,-34.1667},{-60,-34.1667},{-60,60},{160,60},{160,
                  -90.3333},{243.873,-90.3333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conBou, conBou.opa_b) annotation (Line(
              points={{-79.9167,-36.6667},{-60,-36.6667},{-60,60},{160,60},{160,
                  -122.667},{241.867,-122.667}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(irRadGai.conSurBou, surf_surBou) annotation (Line(
              points={{-79.9583,-39.1667},{-60,-39.1667},{-60,60},{160,60},{160,-210},{
                  -232,-210},{-232,-140},{-260,-140}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conExtWin.opa_b, irRadExc.conExtWin) annotation (Line(
              points={{249.9,69},{160,69},{160,60},{-60,60},{-60,16},{-80,16},{-80,17.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.opa_b, irRadGai.conExtWin) annotation (Line(
              points={{249.9,69},{160,69},{160,60},{-60,60},{-60,-22},{-70,-22},{-70,-22.5},
                  {-80,-22.5}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conExt.opa_b, solRadExc.conExt) annotation (Line(
              points={{241.847,138.333},{160,138.333},{160,60},{-80,60},{-80,59.1667}},
              color={190,0,0},
              smooth=Smooth.None));
          connect(conExtWin.fra_b, solRadExc.conExtWinFra) annotation (Line(
              points={{249.9,46},{160,46},{160,60},{-60,60},{-60,50},{-79.9167,50}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_a, solRadExc.conPar_a) annotation (Line(
              points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                  60},{-60,48},{-79.9167,48},{-79.9167,47.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_b, solRadExc.conPar_b) annotation (Line(
              points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,46},{-70,
                  46},{-70,45.8333},{-79.9167,45.8333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conBou.opa_b, solRadExc.conBou) annotation (Line(
              points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,43.3333},
                  {-79.9167,43.3333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(surf_surBou, solRadExc.conSurBou) annotation (Line(
              points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                  {-60,40},{-70,40},{-70,40.8333},{-79.9583,40.8333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.opa_b, solRadExc.conExtWin) annotation (Line(
              points={{249.9,69},{160,69},{160,60},{-60,60},{-60,57.5},{-80,57.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(solRadExc.JInDifConExtWin, conExtWinRad.QTraDif_flow) annotation (
              Line(
              points={{-79.5833,53.3333},{20,53.3333},{20,-20},{299,-20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(solRadExc.HOutConExtWin,conExtWinRad.HRoo)  annotation (Line(
              points={{-79.5833,55},{10,55},{10,-34},{328,-34},{328,-21.6},{321.5,-21.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conExt.opa_b, radTem.conExt) annotation (Line(
              points={{241.847,138.333},{160,138.333},{160,60},{-60,60},{-60,-60.8333},
                  {-80,-60.8333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.opa_b, radTem.conExtWin) annotation (Line(
              points={{249.9,69},{160,69},{160,60},{-60,60},{-60,-62.5},{-80,-62.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conExtWin.fra_b, radTem.conExtWinFra) annotation (Line(
              points={{249.9,46},{160,46},{160,60},{-60,60},{-60,-70},{-79.9167,-70}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_a, radTem.conPar_a) annotation (Line(
              points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                  60},{-60,-72.5},{-79.9167,-72.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(conPar.opa_b, radTem.conPar_b) annotation (Line(
              points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,-74.1667},
                  {-79.9167,-74.1667}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conBou.opa_b, radTem.conBou) annotation (Line(
              points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,-76.6667},
                  {-79.9167,-76.6667}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(surf_surBou, radTem.conSurBou) annotation (Line(
              points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                  {-60,-79.1667},{-79.9583,-79.1667}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(radTem.glaUns, conExtWin.glaUns_b) annotation (Line(
              points={{-80,-65},{-60,-65},{-60,60},{160,60},{160,55},{250,55}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(radTem.glaSha, conExtWin.glaSha_b) annotation (Line(
              points={{-80,-66.6667},{-60,-66.6667},{-60,60},{160,60},{160,53},{250,53}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(radTem.TRad, radiationAdapter.TRad) annotation (Line(
              points={{-100.417,-77.6667},{-144,-77.6667},{-144,-78},{-186,-78},{-186,
                  130},{-182,130}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(radiationAdapter.rad, heaPorRad)
                                             annotation (Line(
              points={{-170.2,120},{-170,120},{-170,114},{-226,114},{-226,4.44089e-16},
                  {-260,4.44089e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(radiationAdapter.QRad_flow, add.u1) annotation (Line(
              points={{-159,130},{-150,130},{-150,126},{-142,126}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, irRadGai.Q_flow) annotation (Line(
              points={{-119,120},{-116,120},{-116,-30},{-100.833,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(irRadExc.JOutConExtWin, sumJToWin.u1)
                                                   annotation (Line(
              points={{-79.5833,15},{-50,15},{-50,-14},{-42,-14}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(irRadGai.JOutConExtWin, sumJToWin.u2)
                                                   annotation (Line(
              points={{-79.5833,-25},{-46,-25},{-46,-26},{-42,-26}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(shaSig.y, radShaOut.u) annotation (Line(
              points={{-199,160},{-110,160},{-110,124},{-102,124}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(shaSig.y, shaRad.u) annotation (Line(
              points={{-199,160},{-64,160},{-64,108},{-61,108}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(sumJToWin.y, radShaOut.JIn)
                                         annotation (Line(
              points={{-19,-20},{0,-20},{0,148},{-106,148},{-106,136},{-101,136}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(radShaOut.JOut_1, shaRad.JIn_air) annotation (Line(
              points={{-79,136},{-70,136},{-70,96},{-61,96}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(radShaOut.JOut_2, conExtWin.JInUns_b) annotation (Line(
              points={{-79,124},{-20,124},{-20,58},{249.5,58}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(shaRad.JOut_glass, conExtWin.JInSha_b) annotation (Line(
              points={{-39,96},{20,96},{20,72},{220,72},{220,49},{249.5,49}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(conExtWin.JOutSha_b, shaRad.JIn_glass) annotation (Line(
              points={{249.5,51},{222,51},{222,70},{16,70},{16,92},{-39,92}},
              color={0,127,0},
              smooth=Smooth.None));

          connect(irRadExc.JInConExtWin, sumJFroWin.y) annotation (Line(
              points={{-79.5833,13.3333},{-46,13.3333},{-46,14},{-41,14}},
              color={0,127,0},
              smooth=Smooth.None));

          connect(shaRad.QSolAbs_flow, conExtWinRad.QAbsIntSha_flow) annotation (Line(
              points={{-50,89},{-50,86},{148,86},{148,-17},{299,-17}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sumJFroWin.u[1], conExtWin.JOutUns_b) annotation (Line(
              points={{-18,14},{164,14},{164,60},{249.5,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sumJFroWin.u[2], shaRad.JOut_air) annotation (Line(
              points={{-18,14},{-10,14},{-10,40},{-40,40},{-40,64},{-66,64},{-66,92},{
                  -61,92}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(radTem.sha, TSha.port) annotation (Line(
              points={{-80,-68.4167},{-64,-68.4167},{-64,-68},{-40,-68}},
              color={191,0,0},
              smooth=Smooth.None));

          for i in 1:nPorts loop
            connect(ports[i],air. ports[i])
                                          annotation (Line(
              points={{-260,-60},{-218,-60},{-218,-206},{52,-206},{52,-141.9}},
              color={0,127,255},
              smooth=Smooth.None));
          end for;

          connect(air.conExt, conExt.opa_b) annotation (Line(
              points={{64,-119},{160,-119},{160,138.333},{241.847,138.333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conExtWin, conExtWin.opa_b) annotation (Line(
              points={{64,-121},{160,-121},{160,69},{249.9,69}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.glaUns, conExtWin.glaUns_b) annotation (Line(
              points={{64,-124},{160,-124},{160,55},{250,55}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.glaSha, conExtWin.glaSha_b) annotation (Line(
              points={{64,-126},{160,-126},{160,53},{250,53}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conExtWinFra, conExtWin.fra_b) annotation (Line(
              points={{64.1,-130},{160,-130},{160,46},{249.9,46}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conPar_a, conPar.opa_a) annotation (Line(
              points={{64.1,-133},{160,-133},{160,-106},{288,-106},{288,-90.3333},{282,
                  -90.3333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conPar_b, conPar.opa_b) annotation (Line(
              points={{64.1,-135},{160,-135},{160,-90},{243.873,-90},{243.873,-90.3333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conBou, conBou.opa_b) annotation (Line(
              points={{64.1,-138},{160,-138},{160,-122.667},{241.867,-122.667}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.conSurBou, surf_surBou) annotation (Line(
              points={{64.05,-141},{160,-141},{160,-210},{-232,-210},{-232,-140},{-260,-140}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(shaRad.QRadAbs_flow,air. QRadAbs_flow) annotation (Line(
              points={{-55,89},{-55,72},{4,72},{4,-125},{39.5,-125}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(air.TSha, shaRad.TSha) annotation (Line(
              points={{39.5,-127},{2,-127},{2,70},{-45,70},{-45,89}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(air.heaPorAir, heaPorAir) annotation (Line(
              points={{40,-130},{-10,-130},{-10,-88},{-200,-88},{-200,40},{-260,40}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(air.TSha, TSha.T) annotation (Line(
              points={{39.5,-127},{2,-127},{2,-68},{-18,-68}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(uWin, conExtWinRad.uSta) annotation (Line(points={{-280,140},{-240,
                  140},{-240,180},{420,180},{420,-40},{305.2,-40},{305.2,-25.6}}, color=
                 {0,0,127}));
          connect(qGai_flow,heaGai. qGai_flow) annotation (Line(
              points={{-280,80},{-222,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(air.QCon_flow,heaGai. QCon_flow) annotation (Line(
              points={{39,-135},{-14,-135},{-14,-92},{-190,-92},{-190,80},{-198,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(air.QLat_flow,heaGai. QLat_flow) annotation (Line(
              points={{39,-138},{-18,-138},{-18,-96},{-194,-96},{-194,74},{-198,74}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(heaGai.QRad_flow, add.u2) annotation (Line(
              points={{-198,86},{-152,86},{-152,114},{-142,114}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conExtWinRad.QTraDir_flow, solRadExc.JInDirConExtWin) annotation (
              Line(points={{299,-23},{18,-23},{18,51.6667},{-79.5833,51.6667}}, color={
                  0,0,127}));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-260,-220},{460,
                    200}})),
                Icon(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},{200,
                    200}}), graphics={
                Text(
                  extent={{-104,210},{84,242}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name"),
                Text(
                  extent={{-220,100},{-144,68}},
                  lineColor={0,0,127},
                  textString="q"),
                Text(
                  extent={{-14,-160},{44,-186}},
                  lineColor={0,0,0},
                  fillColor={61,61,61},
                  fillPattern=FillPattern.Solid,
                  textString="boundary"),
                Rectangle(
                  extent={{-160,-160},{160,160}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-140,140},{140,-140}},
                  pattern=LinePattern.None,
                  lineColor={117,148,176},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Sphere),
                Rectangle(
                  extent={{140,70},{160,-70}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{146,70},{154,-70}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-60,12},{-22,-10}},
                  lineColor={0,0,0},
                  fillColor={61,61,61},
                  fillPattern=FillPattern.Solid,
                  textString="air"),
                Text(
                  extent={{-72,-22},{-22,-50}},
                  lineColor={0,0,0},
                  fillColor={61,61,61},
                  fillPattern=FillPattern.Solid,
                  textString="radiation"),
                Text(
                  extent={{-104,-124},{-54,-152}},
                  lineColor={0,0,0},
                  fillColor={61,61,61},
                  fillPattern=FillPattern.Solid,
                  textString="surface"),
                Text(
                  extent={{-198,144},{-122,112}},
                  lineColor={0,0,127},
                  visible=haveControllableWindow,
                  textString="uWin"),
                Rectangle(
                  extent={{-140,140},{140,-140}},
                  lineColor={117,148,176},
                  fillPattern=FillPattern.Solid,
                  fillColor=DynamicSelect({170,213,255},
                    min(1, max(0, (1-(heaPorAir.T-295.15)/10)))*{28,108,200}+
                    min(1, max(0, (heaPorAir.T-295.15)/10))*{255,0,0})),
                Text(
                  extent={{134,-84},{14,-134}},
                  lineColor={255,255,255},
                  textString=DynamicSelect("", String(heaPorAir.T-273.15, format=".1f")))}),
            preferredView="info",
            defaultComponentName="roo",
            Documentation(info="<html>
<p>
Partial model for a room heat and mass balance.
</p>
<p>
This is the base class for
<a href=\"modelica://Buildings.ThermalZones.Detailed.CFD\">Buildings.ThermalZones.Detailed.CFD</a>
and for
<a href=\"modelica://Buildings.ThermalZones.Detailed.MixedAir\">Buildings.ThermalZones.Detailed.MixedAir</a>
</p>
<p>
See
<a href=\"modelica://Buildings.ThermalZones.Detailed.UsersGuide\">Buildings.ThermalZones.Detailed.UsersGuide</a>
for detailed explanations.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
November 21, 2016, by Thierry S. Nouidui:<br/>
Removed <code>for loop</code> to avoid translation error
in Dymola 2107. This is a work-around for a bug in Dymola
which will be addressed in future releases.
</li>
<li>
October 29, 2016, by Michael Wetter:<br/>
Added optional capacity at the room-facing surface
to reduce the dimension of the nonlinear system of equations,
which generally decreases computing time.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">issue 565</a>.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Corrected error in annotation to enable the pedantic model check in Dymola 2017 FD01 beta 2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
May 2, 2016, by Michael Wetter:<br/>
Refactored implementation of latent heat gain.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/515\">issue 515</a>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 25, 2014, by Michael Wetter:<br/>
Propagated parameter <code>homotopyInitialization</code>.
</li>
<li>
August 1, 2013, by Michael Wetter:<br/>
Introduced this model as a partial base class because the latent heat gains
are treated differently in the mixed air and in the CFD model.
</li>
<li>
July 16, 2013, by Michael Wetter:<br/>
Redesigned implementation to remove one level of model hierarchy on the room-side heat and mass balance.
This change was done to facilitate the implementation of non-uniform room air heat and mass balance,
which required separating the convection and long-wave radiation models.<br/>
Changed assignment
<code>solRadExc(tauGla={0.6 for i in 1:NConExtWin})</code> to
<code>solRadExc(tauGla={datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol for i in 1:NConExtWin})</code> to
better take into account the solar properties of the glass.
</li>
<li>
March 7 2012, by Michael Wetter:<br/>
Added optional parameters <code>ove</code> and <code>sidFin</code> to
the parameter <code>datConExtWin</code>.
This allows modeling windows with an overhang or with side fins.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for conExtWinRad. It is needed by the claculation of property for uncoated glass.
</li>
<li>
December 6, 2011, by Michael Wetter:<br/>
Fixed bug that caused convective heat gains to be
removed from the room instead of added to the room.
This error was caused by a wrong sign in
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.MixedAirHeatGain\">
Buildings.ThermalZones.Detailed.BaseClasses.MixedAirHeatGain</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/46\">issue 46</a>.
</li>
<li>
August 9, 2011, by Michael Wetter:<br/>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and the parameter <code>absIRFra</code> to the
model
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/36\">issue 36</a>.
</li>
<li>
August 9, 2011 by Michael Wetter:<br/>
Changed assignment of tilt in instances <code>bouConExt</code> and <code>bouConExtWin</code>.
This fixes the bug in <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/35\">issue 35</a>
that led to the wrong solar radiation gain for roofs and floors.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Propagated convection model to exterior boundary condition models.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RoomHeatMassBalance;

        model SkyRadiationExchange
          "Radiative heat exchange with the sky and the ambient"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Integer n(min=1) "Number of constructions";
           parameter Modelica.SIunits.Area A[n] "Area of exterior constructions";
          parameter Real vieFacSky[n](
            each min=0,
            each max=1) "View factor to sky (=1 for roofs)";
          parameter Modelica.SIunits.Emissivity absIR[n]
            "Infrared absorptivity of building surface";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port[n] "Heat port"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                    final unit = "K", min=0)
            "Outside air temperature"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
                iconTransformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput TBlaSky(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min=0) "Black body sky temperature"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,20},{-100,60}})));
      protected
          parameter Real k[n](
            each unit="W/K4") = {4*A[i]*Modelica.Constants.sigma*absIR[i] for i in 1:n}
            "Constant for radiative heat exchange";
          Modelica.SIunits.Temperature TEnv[n] "Environment temperature";
          Real TBlaSky4(unit="K4") "Auxiliary variable for radiative heat exchange";
          Real TOut4(unit="K4") "Auxiliary variable for radiative heat exchange";
          Modelica.SIunits.CoefficientOfHeatTransfer h[n]
            "Radiative heat transfer coefficient";

        equation
          TBlaSky4 = TBlaSky^4;
          TOut4 = TOut^4;
          for i in 1:n loop
            TEnv[i] = (vieFacSky[i] * TBlaSky4 + (1-vieFacSky[i]) * TOut4)^(0.25);
            // h[i] uses TEnv[i] instead of (port[i].T+TEnv[i])/2 to avoid
            // a nonlinear equation system
            h[i]  = k[i] * TEnv[i]^3;
            port[i].Q_flow = h[i] * (port[i].T-TEnv[i]);
          end for;
          annotation ( Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,80},{-40,-60}},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{88,-60},{-74,-74}},
                  fillColor={5,135,13},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{2,82},{86,36}},
                  pattern=LinePattern.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Line(
                  points={{-40,16},{-30,28},{-14,28},{-6,44},{10,42},{12,46}},
                  smooth=Smooth.None,
                  color={255,0,0},
                  thickness=0.5),
                Line(
                  points={{-40,16},{-22,-4},{2,-6},{12,-30},{42,-40},{48,-58}},
                  smooth=Smooth.None,
                  color={255,0,0},
                  thickness=0.5),
                Text(
                  extent={{-128,12},{-78,-34}},
                  lineColor={0,0,127},
                  textString="TOut"),
                Text(
                  extent={{-130,96},{-80,50}},
                  lineColor={0,0,127},
                  textString="TSky"),
                Text(
                  extent={{86,52},{136,6}},
                  lineColor={0,0,127},
                  textString="QIR_flow")}),
                Documentation(info = "<html>
This model computes the infrared radiative heat flow
between exterior building surfaces and the ambient. The ambient consists
of the sky black-body radiation and the outdoor temperature
(which is used as an approximation to the surface temperature of
the ground and neighboring buildings).
</html>",       revisions="<html>
<ul>
<li>
March 13, 2015, by Michael Wetter:<br/>
Added missing <code>each</code> keywords.
</li>
<li>
June 4 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SkyRadiationExchange;

        model SolarRadiationExchange
          "Solar radiation heat exchange between the room facing surfaces"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialSurfaceInterfaceRadiative(
          final epsConExt = datConExt.layers.absSol_b,
          final epsConExtWinOpa = datConExtWin.layers.absSol_b,
          final epsConExtWinUns={(1-datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].tauSol[1]
                             -datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].rhoSol_b[1]) for i in 1:NConExtWin},
          final epsConExtWinSha = {(1-datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].tauSol[1]
                               -datConExtWin[i].glaSys.glass[size(datConExtWin[i].glaSys.glass, 1)].rhoSol_b[1]) for i in 1:NConExtWin},
          final epsConExtWinFra = datConExtWin.glaSys.absSolFra,
          final epsConPar_a = datConPar.layers.absSol_a,
          final epsConPar_b = datConPar.layers.absSol_b,
          final epsConBou = datConBou.layers.absSol_b,
          final epsSurBou = surBou.absSol);
          // In the above declaration, we simplified the assignment of epsConExtWinSha.
          // An exact formulation would need to take into account the transmission and reflection
          // of the shade for the solar radiation that strikes the window from the room-side.
          // The simplification leads to too low a value of epsConExtWinSha. Since epsConExtWinSha
          // is used as a weight for how much solar radiation hits the window from the room-side,
          // underestimating epsConExtWinSha does not seem to cause concerns. The reason is that
          // the model assumes diffuse reflection, whereas in reality, reflection of the solar
          // radiation at the floor is likely specular, and therefore less radiation would hit
          // the window from the room-side.
          parameter Boolean isFloorConExt[NConExt]
            "Flag to indicate if floor for exterior constructions";
          parameter Boolean isFloorConExtWin[NConExtWin]
            "Flag to indicate if floor for constructions";
          parameter Boolean isFloorConPar_a[NConPar]
            "Flag to indicate if floor for constructions";
          parameter Boolean isFloorConPar_b[NConPar]
            "Flag to indicate if floor for constructions";
          parameter Boolean isFloorConBou[NConBou]
            "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
          parameter Boolean isFloorSurBou[NSurBou]
            "Flag to indicate if floor for constructions that are modeled outside of this room";

          parameter Modelica.SIunits.Emissivity tauGla[NConExtWin]
            "Transmissivity of window";

          Modelica.Blocks.Interfaces.RealInput JInDifConExtWin[NConExtWin](each unit="W")
            "Diffuse solar radiation transmitted by window per unit area"
            annotation (Placement(transformation(extent={{260,70},{240,90}})));
          Modelica.Blocks.Interfaces.RealInput JInDirConExtWin[NConExtWin](each unit="W")
            "Direct solar radiation transmitted by window per unit area"
            annotation (Placement(transformation(extent={{260,30},{240,50}})));

          Modelica.Blocks.Interfaces.RealOutput HOutConExtWin[NConExtWin](each unit="W/m2")
            "Outgoing solar radiation that strikes window per unit area"
            annotation (Placement(transformation(extent={{240,110},{260,130}})));

          Modelica.SIunits.HeatFlowRate JOutConExtWin[NConExtWin]
            "Outgoing solar radiation that strikes the window";

      protected
          final parameter Real kDir1(unit="1", fixed=false)
            "Intermediate variable for gain for direct solar radiation distribution";
          final parameter Real kDir2(fixed=false)
            "Intermediate variable for gain for solar radiation distribution";
          Modelica.SIunits.HeatFlowRate Q_flow[NTot]
            "Total solar radiation that is absorbed by the surfaces (or transmitted back through the glass)";
          final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
            "Number of opaque surfaces, including the window frame";
          final parameter Integer NWin = NConExtWin "Number of window surfaces";
          final parameter Integer NTot = NOpa + NWin "Total number of surfaces";
          final parameter Boolean isFlo[NTot](each fixed=false)
            "Flag, true if a surface is a floor";
          final parameter Real eps[NTot](each min=0, each max=1, each fixed=false)
            "Solar absorptivity";
          final parameter Real tau[NTot](each min=0, each max=1, each fixed=false)
            "Solar transmissivity";
          final parameter Modelica.SIunits.Area AFlo(fixed=false) "Total floor area";
          final parameter Modelica.SIunits.Area A[NTot](each fixed=false) "Surface areas";
          final parameter Real kDif[NTot](
            each unit="1",
            each fixed=false)
            "Gain for diffuse solar radiation distribution";
          final parameter Real kDir[NTot](
            each unit="1",
            each fixed=false)
            "Gain for direct solar radiation distribution";
          final parameter Real epsTauA[NTot](
            each unit="m2",
            each fixed=false) "Product (eps[i]+tau[i])*A[i] for all surfaces";
          final parameter Real sumEpsTauA(unit="m2", fixed=false)
            "Sum(epsTauA)";
        initial equation
          // The next loops builds arrays that simplify
          // the model equations.
          // These arrays store the values of the constructios in the following order
          // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
          // where x is epsOpa, AOpa or kOpa.
          // The last two entries are for the opaque wall that contains a window, and for the window frame.
          for i in 1:NConExt loop
            eps[i] = epsConExt[i];
            A[i]      = AConExt[i];
            isFlo[i]  = isFloorConExt[i];
          end for;
          for i in 1:NConPar loop
            eps[i+NConExt]           = epsConPar_a[i];
            A[i+NConExt]             = AConPar[i];
            isFlo[i+NConExt]         = isFloorConPar_a[i];
            eps[i+NConExt+NConPar]   = epsConPar_b[i];
            A[i+NConExt+NConPar]     = AConPar[i];
            isFlo[i+NConExt+NConPar] = isFloorConPar_b[i];
          end for;
          for i in 1:NConBou loop
            eps[i+NConExt+2*NConPar]   = epsConBou[i];
            A[i+NConExt+2*NConPar]     = AConBou[i];
            isFlo[i+NConExt+2*NConPar] = isFloorConBou[i];
          end for;
          for i in 1:NSurBou loop
            eps[i+NConExt+2*NConPar+NConBou]   = epsSurBou[i];
            A[i+NConExt+2*NConPar+NConBou]     = ASurBou[i];
            isFlo[i+NConExt+2*NConPar+NConBou] = isFloorSurBou[i];
          end for;

          for i in 1:NConExtWin loop
            // Opaque part of construction that has a window embedded
            eps[i+NConExt+2*NConPar+NConBou+NSurBou]   = epsConExtWinOpa[i];
            A[i+NConExt+2*NConPar+NConBou+NSurBou]     = AConExtWinOpa[i];
            isFlo[i+NConExt+2*NConPar+NConBou+NSurBou] = isFloorConExtWin[i];
            // Window frame
            eps[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]   = epsConExtWinFra[i];
            A[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]     = AConExtWinFra[i];
            isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = isFloorConExtWin[i];
          end for;
          // Window glass
          for i in 1:NConExtWin loop
            // We simplify and assume that the shaded and unshaded part of the window
            // have the same solar absorbtance.
            // A further simplification is that the window is assumed to have the
            // optical properties of state 1, which for electrochromic windows is
            // the uncontrolled state. The error should be small as in the controlled state,
            // there is little solar radiation entering the room, and with this simplification,
            // the main error is that the radiation that is reflected in the room and hits the
            // window is larger than it otherwise would be.
            // This simplification allows lumping the solar distribution into
            // a parameter.
            eps[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = epsConExtWinUns[i];
            isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = isFloorConExtWin[i];
            A[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = AConExtWinGla[i];
          end for;
          // Vector with all surface areas.
          // The next loops build the array A that simplifies
          // the model equations.
          // These array stores the values of the constructios in the following order
          // [AOpa[1:NConExt] AOpa[1:NConPar] AOpa[1: NConPar] AOpa[1: NConBou] AOpa[1: NSurBou]
          //  AOpa[1: NConExtWin] AOpa[1: NConExtWin] AGla[1: NConExtWin]]
          // since NWin=NConExtWin.

          // Solar transmissivity
          for i in 1:NOpa loop
            tau[i] = 0;
          end for;
          for i in 1:NWin loop
            tau[NOpa+i] = tauGla[i];
          end for;

          // Sum of surface areas and products of emmissivity, transmissivity and area
          AFlo = sum( (if isFlo[i] then A[i] else 0) for i in 1:NTot);
          epsTauA = (eps .+ tau).*A;
          sumEpsTauA = sum(epsTauA[i] for i in 1:NTot);

          // Coefficients for distribution of diffuse solar irradiation inside the room.
          for i in 1:NTot loop
            kDif[i] = (eps[i] + tau[i])*A[i]/sumEpsTauA;
          end for;


          // Coefficients for distribution of direct solar radiation inside the room.
          // Coefficient that is used for non-floor areas.
          // The expression  max(1E-20, AFlo) is used to prevent a division by zero in case AFlo=0.
          // The situation for AFlo=0 is caught by the assert statement.
          kDir1 = sum((if isFlo[i] then (A[i]*(1 - eps[i] - tau[i])) else 0) for i in 1:
            NTot)/max(1E-20, AFlo);

          kDir2 = sum((if isFlo[i] then 0 else epsTauA[i]) for i in 1:NTot);


          if (kDir2 > 1E-10) then
            for i in 1:NTot loop
              if isFlo[i] then
                kDir[i] = epsTauA[i]/AFlo;
              else
                kDir[i] =kDir1/kDir2*epsTauA[i];
              end if;
             end for;
          else
                // This branch only happens if k2=0, i.e., there is no surface other than floors
            for i in 1:NTot loop
              if isFlo[i] then
                kDir[i] = A[i]/AFlo;
              else
                kDir[i] = 0;
              end if;
            end for;
          end if;

          // Test whether there is a floor inside this room
          assert( AFlo > 1E-10,
             "Error in parameters of the room model: The geometry is incorrect:\n" +
             "    The room model must have a construction that is a floor,\n" +
             "    and this construction must not have a window.\n" +
             "    The parameters for the room model are such that there is no such construction.\n" +
             "    Revise the model parameters.");
          // Test whether the distribution factors add up to one
          assert(abs(1 - sum(kDif)) < 1E-5, "Program error: Sum of diffuse solar distribution factors in room is not equal to one. kDif="
             + String(sum(kDif)));
          assert(abs(1 - sum(kDir)) < 1E-5, "Program error: Sum of direct solar distribution factors in room is not equal to one. kDir="
             + String(sum(kDir)));
        ////////////////////////////////////////////////////////////////////
        equation
          // Radiation that is absorbed by the surfaces
          Q_flow =-kDif .* sum(JInDifConExtWin) - kDir .* sum(JInDirConExtWin);
          // Assign heat exchange to connectors
          if haveConExt then
            for i in 1:NConExt loop
              Q_flow[i] = conExt[i].Q_flow;
            end for;
          else
            conExt[1].T = 293.15;
          end if;

          if haveConPar then
            for i in 1:NConPar loop
              Q_flow[i+NConExt]         = conPar_a[i].Q_flow;
              Q_flow[i+NConExt+NConPar] = conPar_b[i].Q_flow;
            end for;
          else
              conPar_a[1].T = 293.15;
              conPar_b[1].T = 293.15;
          end if;

          if haveConBou then
            for i in 1:NConBou loop
              Q_flow[i+NConExt+2*NConPar] = conBou[i].Q_flow;
            end for;
          else
            conBou[1].T = 293.15;
          end if;

          if haveSurBou then
            for i in 1:NSurBou loop
              Q_flow[i+NConExt+2*NConPar+NConBou] = conSurBou[i].Q_flow;
             end for;
          else
              conSurBou[1].T = 293.15;
          end if;

          if haveConExtWin then
            for i in 1:NConExtWin loop
              Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].Q_flow;
              Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = conExtWinFra[i].Q_flow;
            end for;
          else
            conExtWin[1].T    = 293.15;
            conExtWinFra[1].T = 293.15;
          end if;
          // Windows
          for j in 1:NWin loop
            Q_flow[j+NOpa] = JOutConExtWin[j];
            HOutConExtWin[j] = if (AConExtWinGla[j] > 1E-10) then JOutConExtWin[j] / AConExtWinGla[j] else 0;
          end for;

          annotation (
        preferredView="info",
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},
                    {240,240}})),        Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-240,-240},{240,240}}),
                                              graphics={
                Line(
                  points={{-144,-8},{2,-200}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Line(
                  points={{2,-200},{2,184}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Line(
                  points={{2,-200},{148,-8}},
                  color={255,128,0},
                  smooth=Smooth.None,
                  thickness=1),
                Rectangle(
                  extent={{148,74},{174,-78}},
                  lineColor={95,95,95},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{154,74},{158,-78}},
                  lineColor={95,95,95},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{166,74},{170,-78}},
                  lineColor={95,95,95},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid)}),
                Documentation(info="<html>
<p>
This model computes the distribution of the solar radiation gain
to the room surfaces.
Let
<i>N<sup>w</sup></i>
denote the number of windows,
<i>N<sup>f</sup></i>
the number of floor elements and
<i>N<sup>n</sup></i>
the number of non-floor elements such as ceiling, wall and window elements.
Input to the model are the diffuse and direct solar radiosities
<i>J<sup>i</sup><sub>dif</sub>, i &isin; {1, &hellip; , N<sup>w</sup>}</i>
and
<i>J<sup>i</sup><sub>dir</sub>, i &isin; {1, &hellip; , N<sup>w</sup>}</i>
that were transmitted through the window.
The total incoming solar radiation is therefore for the diffuse irradiation
</p>
<p align=\"center\" style=\"font-style:italic;\">
H<sub>dif</sub> = &sum;<sub>i=1</sub><sup>N<sup>w</sup></sup>
J<sub>dif</sub><sup>i</sup>
</p>
<p>
and for the direct irradiation
</p>
<p align=\"center\" style=\"font-style:italic;\">
H<sub>dir</sub> = &sum;<sub>i=1</sub><sup>N<sup>w</sup></sup>
J<sub>dir</sub><sup>i</sup>.
</p>
<p>
It is assumed that the diffuse irradiation is distributed to all
surfaces proportionally to the product of surface emissivity plus transmissivity
(which generally is zero except for windows) times the area.
For the direct irradiation, it is assumed that it
first hits the floor where some of it is absorbed,
and some of it is diffusely reflected to all other surfaces. Only the first
reflection is taken into account and the location of the floor patch
relative to the window is neglected.
</p>
<p>
Hence, the diffuse radiation that is absorbed by each area is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 Q<sup>i</sup><sub>dif</sub> = H<sub>dif</sub> &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>) &nbsp; A<sup>i</sup>
&frasl; &sum;<sub>j=1</sub><sup>N</sup> &nbsp; A<sup>j</sup>,
</p>
<p>
where the sum is over all areas. Hence, this calculation treats the wall
that contains the window identical as any other construction, which is
a simplification.
</p>

<p>Similarly, the direct radiation that is
absorbed by each floor patch <i>i &isin; {1, &hellip;, N<sup>f</sup>}</i>,
and may be partially transmitted in
the unusual case that the floor contains a window, is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 Q<sup>i</sup><sub>dir</sub> = H<sub>dir</sub> &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>) &nbsp; A<sup>i</sup>
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
<p>
The sum of the direct radiation that is reflected by the floor is therefore
</p>
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>f</sup> = H<sub>dir</sub> &nbsp;
&sum;<sub>i=1</sub><sup>N<sup>f</sup></sup>
(1-&epsilon;<sup>i</sup>-&tau;<sup>i</sup>) &nbsp; A<sup>i</sup>
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
<p>
This reflected radiosity is then distributed to all non-floor areas
<i>i &isin; {1, &hellip;, N<sup>n</sup>}</i>
using</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup><sub>dir</sub> = J<sup>f</sup> &nbsp;
A<sup>i</sup> &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>)
&frasl;
&sum;<sub>k=1</sub><sup>N<sup>n</sup></sup>
A<sup>k</sup> &nbsp; (&epsilon;<sup>k</sup>+&tau;<sup>k</sup>)
</p>
<p>
The heat flow rate that is absorbed by each surface is
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q<sup>i</sup> = Q<sup>i</sup><sub>dif</sub> + Q<sup>i</sup><sub>dir</sub>.
</p>
<p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sub>out</sub><sup>i</sup></i>
that will strike the glass or the window shade as diffuse solar
radiation.
</p>
<h4>Main assumptions</h4>
<p>
The main assumptions or simplifications are that the shaded and unshaded part of the window
have the same solar absorbtance.
Furthermore, if the room has electrochromic windows, the optical properties
are taken from the state 1, which generally is
the uncontrolled state. The error should be small as in the controlled state,
there is little solar radiation entering the room, and with this simplification,
the main error is that the radiation that is reflected in the room and hits the
window is larger than it otherwise would be.
This simplification allows lumping the solar distribution into
a parameter.
</p>
<p>
The model also assumes that all radiation first hits the floor from
which it is diffusely distributed to the other surfaces.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 7, 2016, by Michael Wetter:<br/>
Removed <code>HTot</code> as this is not needed, and refactored
the model so that the diffuse irradiation is treated separately
from the direct irradiation.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/451\">issue 451</a>.
</li>
<li>
August 7, 2015, by Michael Wetter:<br/>
Revised model to allow modeling of electrochromic windows.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/445\">issue 445</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
November 6, 2011, by Michael Wetter:<br/>
Fixed bug as in the old version, the absorbtance and reflectance
of the infrared spectrum has been used instead of the solar spectrum.
</li>
<li>
Dec. 1 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SolarRadiationExchange;

        record ConstructionNumbers "Data records for construction data"

          ////////////////////////////////////////////////////////////////////////
          // Number of constructions and surface areas
          parameter Integer nConExt(min=0) "Number of exterior constructions"
            annotation (Dialog(group="Exterior constructions"));
          parameter Integer nConExtWin(min=0) "Number of window constructions"
            annotation (Dialog(group="Exterior constructions"));

          parameter Integer nConPar(min=0) "Number of partition constructions"
          annotation (Dialog(group="Partition constructions"));

          parameter Integer nConBou(min=0)
            "Number of constructions that have their outside surface exposed to the boundary of this room"
          annotation (Dialog(group="Boundary constructions"));

          parameter Integer nSurBou(min=0)
            "Number of surface heat transfer models that connect to constructions that are modeled outside of this room"
          annotation (Dialog(group="Boundary constructions"));

          // Dimensions of components and connectors
          final parameter Integer NConExt(min=1) = max(1, nConExt)
            "Number of elements for exterior constructions"
            annotation (HideResult=true);

          final parameter Integer NConExtWin(min=1)=max(1, nConExtWin)
            "Number of elements for exterior constructions with windows"
            annotation (HideResult=true);

          final parameter Integer NConPar(min=1)=max(1, nConPar)
            "Number of elements for partition constructions"
            annotation (HideResult=true);

          final parameter Integer NConBou(min=1)=max(1, nConBou)
            "Number of elements for constructions that have their outside surface exposed to the boundary of this room"
            annotation (HideResult=true);

          final parameter Integer NSurBou(min=1)=max(1, nSurBou)
            "Number of elements for surface heat transfer models that connect to constructions that are modeled outside of this room"
            annotation (HideResult=true);

          // Flags to conditionally remove components
          final parameter Boolean haveConExt = nConExt > 0
            "Flag to conditionally remove components"
            annotation (HideResult=true);
          final parameter Boolean haveConExtWin = nConExtWin > 0
            "Flag to conditionally remove components"
            annotation (HideResult=true);
          final parameter Boolean haveConPar = nConPar > 0
            "Flag to conditionally remove components"
            annotation (HideResult=true);
          final parameter Boolean haveConBou = nConBou > 0
            "Flag to conditionally remove components"
            annotation (HideResult=true);
          final parameter Boolean haveSurBou = nSurBou > 0
            "Flag to conditionally remove components"
            annotation (HideResult=true);
        annotation (
        Documentation(
        info="<html>
<p>
Record that defines the number of constructions that are
used in the room model.
</p>
<p>
This record also declares parameters that contain the number of constructions,
such as the number of exterior constructions <code>nConExt</code>.
This parameter may take on the value <code>0</code>.
If this parameter were to be used to declare the size of vectors of
component models, then there may be vectors with zero components.
This can cause problems in Dymola 7.4.
Therefore, a parameter is declared in the form
</p>
<pre>
  NConExt = max(1, nConExt)
</pre>
<p>This parameter is the used by models that extend this model
to set the size of the vector of component models.</p>
<p>
There are also parameters that can be used to conditionally remove components,
such as <code>haveConExt</code>, which is set to
</p>
<pre>
  haveConExt = nConExt &gt; 0;
</pre>
</html>",
        revisions="<html>
<ul>
<li>
October 1, 2013, by Michael Wetter:<br/>
Added <code>HideResult=true</code> annotation.
</li>
<li>
January 14, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end ConstructionNumbers;

        record ConstructionRecords "Data records for construction data"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.ConstructionNumbers;

          parameter ParameterConstruction datConExt[NConExt](
            each A=0,
            each layers = dummyCon,
            each til=0,
            each azi=0) "Data for exterior construction"
            annotation (Placement(transformation(extent={{-140,-120},{-120,-100}})), HideResult=true);
          parameter Buildings.ThermalZones.Detailed.BaseClasses.ParameterConstructionWithWindow
            datConExtWin[NConExtWin](
            each A=0,
            each layers = dummyCon,
            each til=0,
            each azi=0,
            each hWin=0,
            each wWin=0,
            each glaSys=dummyGlaSys) "Data for exterior construction with window"
            annotation (Placement(transformation(extent={{-140,-160},{-120,-140}})), HideResult=true);
          parameter Buildings.ThermalZones.Detailed.BaseClasses.ParameterConstruction datConPar[NConPar](
            each A=0,
            each layers = dummyCon,
            each til=0,
            each azi=0) "Data for partition construction"
            annotation (Placement(transformation(extent={{-140,-200},{-120,-180}})), HideResult=true);
          parameter Buildings.ThermalZones.Detailed.BaseClasses.ParameterConstruction datConBou[NConBou](
            each A=0,
            each layers = dummyCon,
            each til=0,
            each azi=0) "Data for construction boundary"
            annotation (Placement(transformation(extent={{-100,-120},{-80,-100}})), HideResult=true);

          parameter Buildings.ThermalZones.Detailed.BaseClasses.OpaqueSurface surBou[NSurBou](
            each A=0,
            each til=0)
            "Record for data of surfaces whose heat conduction is modeled outside of this room"
            annotation (Placement(transformation(extent={{-80,-160},{-100,-140}})), HideResult=true);

          // Dummy constructions to assign values to parameters.
          // The actual assignments will be overwritten by models that extend this model.
          // Note that parameters in records cannot be protected. However, we set the
          // annotation HideResult=true to avoid that they show up in the output file.
          parameter HeatTransfer.Data.OpaqueConstructions.Brick120 dummyCon
            "Dummy construction to assign a parameter to the instance"
            annotation (HideResult=true);
          parameter Buildings.HeatTransfer.Data.GlazingSystems.SingleClear3 dummyGlaSys
            "Dummy construction to assign a parameter to the instance"
            annotation (HideResult=true);
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},
                    {100,100}})),       Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-200,-200},{100,100}})),
        Documentation(
        info="<html>
<p>
Record that defines the number of constructions that are
used in the room model.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 14, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end ConstructionRecords;

        record OpaqueSurface "Record for exterior constructions that have no window"
          extends Buildings.HeatTransfer.Data.OpaqueSurfaces.Generic;
          parameter String name = ""
            "Surface name. Optional for MixedAir, required for CFD.";

          parameter Buildings.ThermalZones.Detailed.Types.CFDBoundaryConditions boundaryCondition=
            Buildings.ThermalZones.Detailed.Types.CFDBoundaryConditions.Temperature
            "Boundary condition used in the CFD simulation"
            annotation(Dialog(group="Boundary condition"));

          annotation (
        Documentation(info="<html>
<p>
This data record is used to set the parameters of opaque surfaces.
</p>
<p>
The surface tilt is defined in <a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
July 30, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end OpaqueSurface;

        record Overhang "Record for window overhang"
          extends Modelica.Icons.Record;

          parameter Modelica.SIunits.Length wL(min=0)
            "Overhang width left to the window, measured from the window corner"
            annotation(Dialog(tab="General",group="Overhang"));
          parameter Modelica.SIunits.Length wR(min=0)
            "Overhang width right to the window, measured from the window corner"
            annotation(Dialog(tab="General",group="Overhang"));

          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth (measured perpendicular to the wall plane)"
            annotation(Dialog(tab="General",group="Overhang"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(tab="General",group="Overhang"));

          final parameter Boolean haveOverhang= dep > Modelica.Constants.eps
            "Flag, true if the window has an overhang"
            annotation(Evaluate=true);

          annotation (
        Documentation(info="<html>
<p>
This record declares parameters for window overhangs.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Windows.Overhang\">
Buildings.HeatTransfer.Windows.Overhang</a>
for an explanation of the parameters, and
for the assumptions and limitations
of the overhang model.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of <code>wL</code> and <code>wR</code> to be
measured from the corner of the window instead of the centerline.
This allows changing the window width without having to adjust the
overhang parameters.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Removed <code>gap &gt; 0</code> as a necessary condition.
There can be an overhang with no gap.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end Overhang;

        record ParameterConstruction
          "Record for exterior constructions that have no window"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialParameterConstruction;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          annotation (
        Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end ParameterConstruction;

        record ParameterConstructionWithWindow
          "Record for exterior constructions that have a window"
          extends
          Buildings.ThermalZones.Detailed.BaseClasses.PartialParameterConstruction;

          parameter Modelica.SIunits.Area A
            "Heat transfer area of opaque construction and window combined";
          parameter Modelica.SIunits.Length hWin "Window height"
            annotation (Dialog(group="Glazing system"));
          parameter Modelica.SIunits.Length wWin "Window width"
            annotation (Dialog(group="Glazing system"));
          final parameter Modelica.SIunits.Area AWin=hWin*wWin
            "Heat transfer area of window"
              annotation (Dialog(group="Glazing system"));

          final parameter Modelica.SIunits.Area AOpa = A-AWin
            "Heat transfer area of opaque construction"
            annotation (Dialog(group="Opaque construction"));

          parameter Real fFra(
            final min=0,
            final max=1) = 0.1 "Fraction of window frame divided by total window area"
            annotation (Dialog(group="Glazing system"));

         parameter Buildings.ThermalZones.Detailed.BaseClasses.Overhang ove(
            wR=0,
            wL=0,
            dep=0,
            gap=0) "Geometry of overhang"
            annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{60,20},
                    {80,40}})));
         parameter Buildings.ThermalZones.Detailed.BaseClasses.SideFins sidFin(h=0, dep=0, gap=0)
            "Geometry of side fins"
            annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{60,-20},
                    {80,0}})));

          final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
            annotation (Dialog(group="Glazing system"));
          final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
            annotation (Dialog(group="Glazing system"));

          parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
            "Material properties of glazing system"
            annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{58,62},
                    {78,82}})));
          final parameter Boolean haveOverhangOrSideFins = (ove.dep > 1E-8) or (sidFin.dep > 1E-8)
            "Flag, true if the construction has either an overhang or side fins"
            annotation(Evaluate=true);

          annotation (
        Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 28, 2014, by Michael Wetter:<br/>
Removed <code>replacable</code> keyword for parameters that are records as this is not needed.
</li>
<li>
October 27, 2014, by Michael Wetter:<br/>
Introduced the parameter <code>haveOverhangOrSideFins</code> which is needed by
<a href=\"modelica://Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.ThermalZones.Detailed.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end ParameterConstructionWithWindow;

        record PartialParameterConstruction "Partial record for constructions"
          extends Modelica.Icons.Record;

          parameter String name = ""
            "Surface name. Optional for MixedAir, required for FFD.";

          parameter Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Material properties of opaque construction"
            annotation(Dialog(group="Opaque construction"),
                       choicesAllMatching=true, Placement(transformation(extent={{146,258},
                    {166,278}})));

          parameter Modelica.SIunits.Angle til "Surface tilt";
          parameter Modelica.SIunits.Angle azi "Surface azimuth";
          final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
            "Flag, true if construction is a floor" annotation (Evaluate=true);
          final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
            "Flag, true if construction is a floor" annotation (Evaluate=true);
        //  final parameter Integer nLay(min=1, fixed=true) = size(layers.material, 1)
        //    "Number of layers";
        //  final parameter Integer nSta[:](each min=1)={layers.material[i].nSta for i in 1:size(layers.material, 1)}
        //    "Number of states"  annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
            "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
            "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
            "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

          parameter Boolean stateAtSurface_a=true
            "=true, a state will be at the surface a"
            annotation (Dialog(tab="Dynamics"),
                        Evaluate=true);
          parameter Boolean stateAtSurface_b=true
            "=true, a state will be at the surface b"
            annotation (Dialog(tab="Dynamics"),
                        Evaluate=true);

          parameter Buildings.ThermalZones.Detailed.Types.CFDBoundaryConditions boundaryCondition=
            Buildings.ThermalZones.Detailed.Types.CFDBoundaryConditions.Temperature
            "Boundary condition used in the CFD simulation"
            annotation(Dialog(group="Boundary condition"));

          annotation (
        Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
December 8, 2016, by Michael Wetter:<br/>
Added parameters <code>stateAtSurface_a</code> and
<code>stateAtSurface_b</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/565\">#565</a>.
</li>
<li>
March 13, 2015, by Michael Wetter:<br/>
Changed model to avoid a translation error
in OpenModelica.
</li>
<li>
October 11, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end PartialParameterConstruction;

        record SideFins "Record for window side fins"
          extends Modelica.Icons.Record;
          parameter Modelica.SIunits.Length h(min=0)
            "Height of side fin that extends above window, measured from top of window"
            annotation(Dialog(tab="General",group="Side fin"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Side fin depth (measured perpendicular to the wall plane)"
            annotation(Dialog(tab="General",group="Side fin"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between side fin and window edge"
            annotation(Dialog(tab="General",group="Side fin"));

          final parameter Boolean haveSideFins= dep > Modelica.Constants.eps
            "Flag, true if the window has side fins" annotation (Evaluate=true);

          annotation (
        Documentation(info="<html>
<p>
This record declares parameters for window side fins.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Windows.SideFins\">
Buildings.HeatTransfer.Windows.SideFins</a>
for an explanation of the parameters, and
for the assumptions and limitations
of the model for side fins.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of side fin height <code>h</code> to be
measured from the top of the window.
This allows changing the window height without having to adjust the
side fin parameters.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Removed <code>gap &gt; 0</code> as a necessary condition. There can be a side fin with no gap.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end SideFins;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.ThermalZones.Detailed\">Buildings.ThermalZones.Detailed</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (
    preferredView="info", Documentation(info="<html>
<p>
This package contains models for the heat transfer in rooms
and through the building envelope.
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Rectangle(
            extent={{-64,34},{64,-74}},
            lineColor={150,150,150},
            fillPattern=FillPattern.Solid,
            fillColor={150,150,150}),
          Polygon(
            points={{0,76},{-78,34},{80,34},{0,76}},
            lineColor={95,95,95},
            smooth=Smooth.None,
            fillPattern=FillPattern.Solid,
            fillColor={95,95,95}),
          Rectangle(
            extent={{16,-8},{44,20}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-42,-8},{-14,20}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-42,-58},{-14,-30}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{16,-58},{44,-30}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid)}));
    end Detailed;

    package EnergyPlus
    "Package with models to connect to the EnergyPlus SOEP thermal zone model"
      extends Modelica.Icons.Package;

      model Building
        "Model that declares a building to which EnergyPlus objects belong to"
        extends Modelica.Blocks.Icons.Block;
        final constant String modelicaNameBuilding=getInstanceName()
          "Name of this instance"
          annotation (HideResult=true);
        constant Real relativeSurfaceTolerance(min=1E-20) = 1E-6
          "Relative tolerance of surface temperature calculations";
        parameter String idfName
          "Name of the IDF file"
          annotation (Evaluate=true);
        parameter String weaName
          "Name of the weather file, in .mos format and with .mos extension (see info section)"
          annotation (Evaluate=true);
        parameter Boolean usePrecompiledFMU=false
          "Set to true to use pre-compiled FMU with name specified by fmuName"
          annotation (Dialog(tab="Debug"));
        parameter String fmuName=""
          "Specify if a pre-compiled FMU should be used instead of EnergyPlus (mainly for development)"
          annotation (Dialog(tab="Debug",enable=usePrecompiledFMU));
        parameter Buildings.ThermalZones.EnergyPlus.Types.LogLevels logLevel=Buildings.ThermalZones.EnergyPlus.Types.LogLevels.Warning
          "Log level of EnergyPlus output"
          annotation (Dialog(tab="Debug"));
        parameter Boolean showWeatherData=true
          "Set to true to enable a connector with the weather data"
          annotation (Dialog(tab="Advanced"));
        parameter Boolean computeWetBulbTemperature=true
          "If true, then this model computes the wet bulb temperature"
          annotation (Dialog(tab="Advanced",enable=showWeatherData));
        parameter Boolean printUnits=true
          "Set to true to print units of OutputVariable instances to log file"
          annotation (Dialog(group="Diagnostics"));
        parameter Boolean generatePortableFMU=false
          "Set to true to include all binaries in the EnergyPlus FMU to allow simulation of without a Buildings library installation (increases translation time)"
          annotation (Dialog(tab="Advanced"));
        BoundaryConditions.WeatherData.Bus weaBus if showWeatherData
          "Weather data bus"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        BaseClasses.Synchronize.SynchronizeConnector synchronize
          "Connector that synchronizes all Spawn objects of this buildings"
          annotation (HideResult=true);
        Real isSynchronized
          "Flag used to synchronize Spawn objects"
          annotation (HideResult=true);

    protected
        Real synchronization_done=synchronize.done
          "Intermediate variable as acausal connectors cannot be used in the algorithm section";
        Linux64Binaries linux64Binaries if generatePortableFMU
          "Record with binaries";
        record Linux64Binaries
          final parameter String spawnLinuxExecutable=Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/bin/spawn-linux64/bin/spawn")
            "Binary for Linux 64, specified so it is packed into the FMU";
          final parameter String spawnLinuxLibrary=Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/bin/spawn-linux64/lib/epfmi.so")
            "Library for Linux 64, specified so it is packed into the FMU";
          final parameter String fmiLinuxLibrary=Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/Library/linux64/libfmilib_shared.so")
            "Library for Linux 64, specified so it is packed into the FMU";
        end Linux64Binaries;
        BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          final filNam=weaName,
          final computeWetBulbTemperature=computeWetBulbTemperature) if showWeatherData
          "Weather data reader"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        synchronize.do=0;
        connect(weaDat.weaBus,weaBus)
          annotation (Line(points={{10,0},{100,0}},color={255,204,51},thickness=0.5),Text(string="%second",index=1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));

      algorithm
        isSynchronized := synchronization_done;
        annotation (
          defaultComponentName="building",
          defaultComponentPrefixes="inner",
          missingInnerMessage="
Your model is using an outer \"building\" component to declare building-level parameters, but
an inner \"building\" component is not defined.
Drag one instance of Buildings.ThermalZones.EnergyPlus.Building into your model,
above all declarations of Buildings.ThermalZones.EnergyPlus.ThermalZone,
to specify building-level parameters. This instance must have the name \"building\".",
          Icon(
            graphics={
              Bitmap(
                extent={{-44,-144},{94,-6}},
                fileName="modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/spawn_icon_darkbluetxmedres.png",
                visible=not usePrecompiledFMU),
              Rectangle(
                extent={{-64,54},{64,-48}},
                lineColor={150,150,150},
                fillPattern=FillPattern.Solid,
                fillColor={150,150,150}),
              Polygon(
                points={{0,96},{-78,54},{80,54},{0,96}},
                lineColor={95,95,95},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={95,95,95}),
              Rectangle(
                extent={{16,12},{44,40}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-42,12},{-14,40}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-42,-32},{-14,-4}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{16,-32},{44,-4}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(
            info="<html>
<p>
Model that declares building-level specifications for Spawn of EnergyPlus.
</p>
<p>
This model is used to configure EnergyPlus.
Each EnergyPlus idf file must have one instance of this model, and the
instance name must be <code>building</code>.
The instance must be placed in the model hierarchy at the same or at a higher level
than the EnergyPlus objects that are related to the EnergyPlus idf file specified in
this model through the parameter <code>idfName</code>.
</p>
<p>
For the parameter <code>weaName</code>, the name of the Modelica weather file must be
provided. This is the file that can be read, for example, with
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
However, both weather files <code>.mos</code> and <code>.epw</code>
must be provided in the same directory. When starting the simulation, EnergyPlus will
be run with the weather file whose name is identical to <code>weaName</code>, but with the
extension <code>.mos</code> replaced with <code>.epw</code>.
</p>
</html>",   revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
January 28, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Building;

      model ThermalZone
        "Model to connect to an EnergyPlus thermal zone"
        extends
        Buildings.ThermalZones.EnergyPlus.BaseClasses.PartialEnergyPlusObject;
        parameter String zoneName
          "Name of the thermal zone as specified in the EnergyPlus input";
        parameter Integer nPorts=0
          "Number of fluid ports (equals to 2 for one inlet and one outlet)"
          annotation (Evaluate=true,Dialog(connectorSizing=true,tab="General",group="Ports"));
        ////////////////////////////////////////////////////////////////////////////
        // Media declaration. This is identical to
        // Buildings.Fluid.Interfaces.LumpedVolumeDeclarations, except
        // that the comments have been changed to avoid a confusion about
        // what energyDynamics refers to.
        replaceable package Medium=Modelica.Media.Interfaces.PartialMedium
          "Medium in the component"
          annotation (choicesAllMatching=true);
        // Ports
        parameter Boolean use_C_flow=false
          "Set to true to enable input connector for trace substance that is connected to room air"
          annotation (Dialog(group="Ports"));
        // Initialization
        parameter Medium.AbsolutePressure p_start=Medium.p_default
          "Start value of zone air pressure"
          annotation (Dialog(tab="Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of zone air temperature"
          annotation (Dialog(tab="Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
          quantity=Medium.substanceNames)=Medium.X_default
          "Start value of zone air mass fractions m_i/m"
          annotation (Dialog(tab="Initialization",enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
          quantity=Medium.extraPropertiesNames)=fill(
          0,
          Medium.nC)
          "Start value of zone air trace substances"
          annotation (Dialog(tab="Initialization",enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
          quantity=Medium.extraPropertiesNames)=fill(
          1E-2,
          Medium.nC)
          "Nominal value of zone air trace substances. (Set to typical order of magnitude.)"
          annotation (Dialog(tab="Initialization",enable=Medium.nC > 0));
        final parameter Modelica.SIunits.Volume V=fmuZon.V
          "Zone volume";
        final parameter Modelica.SIunits.Area AFlo=fmuZon.AFlo
          "Floor area";
        final parameter Real mSenFac(
          min=1)=fmuZon.mSenFac
          "Factor for scaling the sensible thermal mass of the zone air volume"
          annotation (Dialog(tab="Dynamics",group="Zone air"));
        Modelica.Blocks.Interfaces.RealInput qGai_flow[3](
          each unit="W/m2")
          "Radiant, convective and latent heat input into room (positive if heat gain)"
          annotation (Placement(transformation(extent={{-240,80},{-200,120}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),iconTransformation(extent={{-240,-120},{-200,-80}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
          "Heat port to air volume"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
          redeclare each package Medium=Medium)
          "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{40,-10},{-40,10}},rotation=180,origin={0,-150}),iconTransformation(extent={{40,-9},{-40,9}},rotation=180,origin={0,-191})));
        Modelica.Blocks.Interfaces.RealOutput TAir(
          final unit="K",
          displayUnit="degC")
          "Air temperature of the zone"
          annotation (Placement(transformation(extent={{200,-10},{220,10}}),iconTransformation(extent={{200,170},{220,190}})));
        Modelica.Blocks.Interfaces.RealOutput TRad(
          final unit="K",
          displayUnit="degC")
          "Radiative temperature of the zone"
          annotation (Placement(transformation(extent={{200,-50},{220,-30}}),iconTransformation(extent={{200,130},{220,150}})));
        Modelica.Blocks.Interfaces.RealOutput phi(
          final unit="1")
          "Relative humidity"
          annotation (Placement(transformation(extent={{200,-130},{220,-110}}),iconTransformation(extent={{200,90},{220,110}})));

    protected
        constant Modelica.SIunits.SpecificEnergy h_fg=Medium.enthalpyOfCondensingGas(
          273.15+37)
          "Latent heat of water vapor";
        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal=V*3/3600
          "Nominal mass flow rate (used for regularization)";
        Buildings.ThermalZones.EnergyPlus.BaseClasses.ThermalZoneAdapter fmuZon(
          final modelicaNameBuilding=modelicaNameBuilding,
          final modelicaInstanceName=modelicaInstanceName,
          final idfName=idfName,
          final weaName=weaName,
          final relativeSurfaceTolerance=relativeSurfaceTolerance,
          final zoneName=zoneName,
          final nFluPor=nPorts,
          final usePrecompiledFMU=usePrecompiledFMU,
          final fmuName=fmuName,
          final logLevel=logLevel)
          "FMU zone adapter"
          annotation (Placement(transformation(extent={{82,-60},{102,-40}})));
        Buildings.Fluid.Interfaces.ConservationEquation vol(
          redeclare final package Medium=Medium,
          final energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          final massDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final mSenFac=mSenFac,
          final use_mWat_flow=Medium.nXi > 0,
          final use_C_flow=use_C_flow,
          final fluidVolume=V,
          final nPorts=nPorts)
          "Air volume of the thermal zone"
          annotation (Placement(transformation(extent={{-10,-52},{10,-32}})));
        Buildings.ThermalZones.Detailed.BaseClasses.HeatGain heaGai(
          final AFlo=AFlo)
          "Model to convert internal heat gains"
          annotation (Placement(transformation(extent={{-180,90},{-160,110}})));
        Modelica.Blocks.Math.Gain mWat_flow(
          final k(
            unit="kg/J")=1/h_fg,
          u(final unit="W"),
          y(final unit="kg/s"))
          "Water flow rate due to latent heat gain"
          annotation (Placement(transformation(extent={{-82,-64},{-62,-44}})));
        Modelica.Blocks.Math.Add QConLat_flow(
          final k1=1,
          final k2=1)
          "Total latent heat gains of the zone"
          annotation (Placement(transformation(extent={{-120,20},{-100,40}})));
        Modelica.Blocks.Math.Add QGaiSenLat_flow(
          final k1=1,
          final k2=1)
          "Sensible and latent heat gains of the zone"
          annotation (Placement(transformation(extent={{-80,30},{-60,50}})));
        Modelica.Blocks.Math.Add QConTot_flow(
          final k1=1,
          final k2=1)
          "Total convective sensible heat gains of the zone"
          annotation (Placement(transformation(extent={{-120,52},{-100,72}})));
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow conQCon_flow
          "Converter for convective heat flow rate"
          annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
        final parameter String substanceName="CO2"
          "Name of trace substance";
        final parameter Modelica.SIunits.MolarMass MM=Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM
          "Molar mass of the trace substance";
        Modelica.Blocks.Routing.Replicator QPeaRep(
          nout=Medium.nC) if use_C_flow
          "Replicator to convert QPea_flow into a vector"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        Modelica.Blocks.Math.Add CTot_flow[Medium.nC](
          each final k1=1,
          final k2={
            if
              (Modelica.Utilities.Strings.isEqual(
              string1=Medium.extraPropertiesNames[i],
              string2=substanceName,
              caseSensitive=false)) then
              3.82E-8*Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM/Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM
            else
              0 for i in 1:Medium.nC},
          u1(
            each final unit="W")) if use_C_flow
          "Total trace substance flow rate"
          annotation (Placement(transformation(extent={{-80,-100},{-60,-80}})));
        Buildings.Fluid.Sensors.MassFlowRate senMasFlo[nPorts](
          redeclare each final package Medium=Medium,
          each final allowFlowReversal=true)
          "Mass flow rate sensor"
          annotation (Placement(transformation(extent={{-10,10},{10,-10}},rotation=90,origin={0,-100})));
        Modelica.Blocks.Sources.RealExpression TAirIn[nPorts](
          y=Medium.temperature(
            state=Medium.setState_phX(
              p=ports.p,
              h=inStream(ports.h_outflow),
              X=inStream(ports.Xi_outflow)))) if nPorts > 0
          "Temperature that the air has if it were flowing into the room"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
          "Heat flow sensor"
          annotation (Placement(transformation(extent={{-20,-20},{-40,0}})));
        Buildings.HeatTransfer.Sources.PrescribedTemperature preTem
          "Port temperature"
          annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
        Modelica.Blocks.Sources.RealExpression TFlu(
          y=Medium.temperature_phX(
            p=vol.medium.p,
            h=vol.hOut,
            X=cat(1,vol.XiOut,{1-sum(vol.XiOut)})))
          "Air temperature of control volume"
          annotation (Placement(transformation(extent={{20,-10},{40,10}})));
        Modelica.Blocks.Sources.RealExpression pFlu(
          y=vol.medium.p)
          "Air pressure"
          annotation (Placement(transformation(extent={{122,2},{142,22}})));
        Utilities.Psychrometrics.Phi_pTX relHum
          "Relative humidity"
          annotation (Placement(transformation(extent={{156,12},{176,32}})));
        Controls.OBC.CDL.Continuous.Division X_w
          "Water vapor mass fraction per kg total air"
          annotation (Placement(transformation(extent={{40,-32},{60,-12}})));

      initial equation
        assert(
          idfName <> "",
          "Must provide the name of the fmu file.");
        assert(
          zoneName <> "",
          "Must provide the name of the zone.");
      // assert(nPorts >= 2, "The zone must have at least one air inlet and outlet.");

      equation
        connect(heaGai.qGai_flow,qGai_flow)
          annotation (Line(points={{-182,100},{-220,100}},color={0,0,127}));
        connect(fmuZon.TRad,TRad)
          annotation (Line(points={{103,-44},{180,-44},{180,-40},{210,-40}},color={0,0,127}));
        connect(heaGai.QRad_flow,fmuZon.QGaiRad_flow)
          annotation (Line(points={{-158,106},{74,106},{74,-58},{80,-58}},color={0,0,127}));
        connect(QGaiSenLat_flow.u1,QConTot_flow.y)
          annotation (Line(points={{-82,46},{-90,46},{-90,62},{-99,62}},color={0,0,127}));
        connect(QGaiSenLat_flow.u2,QConLat_flow.y)
          annotation (Line(points={{-82,34},{-90,34},{-90,30},{-99,30}},color={0,0,127}));
        connect(QGaiSenLat_flow.y,conQCon_flow.Q_flow)
          annotation (Line(points={{-59,40},{-40,40}},color={0,0,127}));
        connect(conQCon_flow.port,heaPorAir)
          annotation (Line(points={{-20,40},{0,40},{0,0}},color={191,0,0}));
        connect(QConLat_flow.y,mWat_flow.u)
          annotation (Line(points={{-99,30},{-96,30},{-96,-54},{-84,-54}},color={0,0,127}));
        connect(mWat_flow.y,vol.mWat_flow)
          annotation (Line(points={{-61,-54},{-36,-54},{-36,-40},{-12,-40}},color={0,0,127}));
        connect(CTot_flow.y,vol.C_flow)
          annotation (Line(points={{-59,-90},{-26,-90},{-26,-46},{-12,-46}},color={0,0,127}));
        connect(C_flow,CTot_flow.u1)
          annotation (Line(points={{-220,-120},{-142,-120},{-142,-84},{-82,-84}},color={0,0,127}));
        for i in 1:nPorts loop
          connect(ports[i],senMasFlo[i].port_a)
            annotation (Line(points={{0,-150},{0,-110}},color={0,127,255}));
          connect(fmuZon.m_flow[i],senMasFlo[i].m_flow)
            annotation (Line(points={{80,-50},{30,-50},{30,-100},{11,-100}},color={0,0,127}));
          connect(senMasFlo[i].port_b,vol.ports[i])
            annotation (Line(points={{5.55112e-16,-90},{0,-90},{0,-52}},color={0,127,255}));
        end for;
        connect(fmuZon.TInlet,TAirIn.y)
          annotation (Line(points={{80,-54},{64,-54},{64,-70},{61,-70}},color={0,0,127}));
        connect(TFlu.y,preTem.T)
          annotation (Line(points={{41,0},{50,0},{50,18},{-90,18},{-90,-10},{-82,-10}},color={0,0,127}));
        connect(heaFloSen.port_b,preTem.port)
          annotation (Line(points={{-40,-10},{-60,-10}},color={191,0,0}));
        connect(heaFloSen.port_a,heaPorAir)
          annotation (Line(points={{-20,-10},{-10,-10},{-10,0},{0,0}},color={191,0,0}));
        connect(TFlu.y,fmuZon.T)
          annotation (Line(points={{41,0},{70,0},{70,-42},{80,-42}},color={0,0,127}));
        connect(TFlu.y,TAir)
          annotation (Line(points={{41,0},{210,0}},color={0,0,127}));
        connect(heaFloSen.Q_flow,vol.Q_flow)
          annotation (Line(points={{-30,-20},{-30,-36},{-12,-36}},color={0,0,127}));
        connect(vol.XiOut[1],fmuZon.X_w)
          annotation (Line(points={{0,-31},{0,-24},{30,-24},{30,-46},{80,-46}},color={0,0,127}));
        connect(X_w.y,relHum.X_w)
          annotation (Line(points={{62,-22},{64,-22},{64,22},{155,22}},color={0,0,127}));
        connect(vol.mXiOut[1],X_w.u1)
          annotation (Line(points={{11,-44},{20,-44},{20,-16},{38,-16}},color={0,0,127}));
        connect(vol.mOut,X_w.u2)
          annotation (Line(points={{11,-36},{24,-36},{24,-28},{38,-28}},color={0,0,127}));
        connect(TFlu.y,relHum.T)
          annotation (Line(points={{41,0},{120,0},{120,30},{155,30}},color={0,0,127}));
        connect(pFlu.y,relHum.p)
          annotation (Line(points={{143,12},{150,12},{150,14},{155,14}},color={0,0,127}));
        connect(relHum.phi,phi)
          annotation (Line(points={{177,22},{192,22},{192,-120},{210,-120}},color={0,0,127}));
        connect(QPeaRep.y,CTot_flow.u2)
          annotation (Line(points={{-99,-110},{-90,-110},{-90,-96},{-82,-96}},color={0,0,127}));
        connect(QPeaRep.u,fmuZon.QPeo_flow)
          annotation (Line(points={{-122,-110},{-132,-110},{-132,-130},{110,-130},{110,-56},{103,-56}},color={0,0,127}));
        connect(QConTot_flow.u2,heaGai.QCon_flow)
          annotation (Line(points={{-122,56},{-134,56},{-134,100},{-158,100}},color={0,0,127}));
        connect(fmuZon.QCon_flow,QConTot_flow.u1)
          annotation (Line(points={{103,-48},{110,-48},{110,80},{-130,80},{-130,68},{-122,68}},color={0,0,127}));
        connect(fmuZon.QLat_flow,QConLat_flow.u1)
          annotation (Line(points={{103,-52},{114,-52},{114,84},{-140,84},{-140,36},{-122,36}},color={0,0,127}));
        connect(heaGai.QLat_flow,QConLat_flow.u2)
          annotation (Line(points={{-158,94},{-144,94},{-144,24},{-122,24}},color={0,0,127}));
        annotation (
          defaultComponentName="zon",
          Icon(
            coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}}),
            graphics={
              Rectangle(
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                extent={{-200,-200},{200,200}}),
              Rectangle(
                lineColor={117,148,176},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{-176,182},{180,-182}}),
              Bitmap(
                visible=false,
                extent={{62,-190},{164,-88}},
                fileName="modelica://Buildings/Resources/Images/Fluid/FMI/FMI_icon.png"),
              Text(
                visible=false,
                extent={{-144,162},{-40,132}},
                textString="%idfName"),
              Text(
                extent={{-142,130},{-38,100}},
                textString="%zoneName"),
              Rectangle(
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{180,70},{200,-70}}),
              Text(
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                extent={{120,148},{170,120}},
                textString="TRad"),
              Text(
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                extent={{-60,12},{-22,-10}},
                textString="air"),
              Rectangle(
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{186,70},{194,-70}}),
              Text(
                extent={{-202,118},{-126,86}},
                textString="q"),
              Text(
                visible=false,
                lineColor={0,0,127},
                extent={{-188,-94},{-112,-126}},
                textString="C_flow"),
              Text(
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                extent={{124,182},{174,154}},
                textString="TAir",
                horizontalAlignment=TextAlignment.Right),
              Text(
                lineColor={0,0,255},
                extent={{-58,244},{56,204}},
                textString="%name"),
              Text(
                lineColor={255,255,255},
                extent={{174,-126},{54,-176}},
                textString=""),
              Bitmap(
                visible=false,
                extent={{134,-176},{174,-146}},
                fileName="modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/EnergyPlusLogo.png"),
              Text(
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                extent={{132,114},{182,86}},
                textString="phi")}),
          Diagram(
            coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-140},{200,140}})),
          Documentation(
            info="<html>
<p>
Model for a thermal zone that is implemented in EnergyPlus.
</p>
<p>
This model instantiates the FMU with the name <code>idfName</code> and
connects to the thermal zone with name <code>zoneName</code>.
The <code>idfName</code> needs to be specified in an instance of
<a href=\"Buildings.ThermalZones.EnergyPlus.Building\">
Buildings.ThermalZones.EnergyPlus.Building</a>
that is named <code>building</code>, and that is placed at this 
or at a higher hierarchy-level of the model.
If the FMU is already instantiated by another instance of this model,
it will use the already instantiated FMU. Hence, for each thermal zone
in an EnergyPlus FMU, one instance of this model needs to be used.
See <a href=\"modelica://Buildings.ThermalZones.EnergyPlus.UsersGuide\">
Buildings.ThermalZones.EnergyPlus.UsersGuide</a>
for how zones are simulated that are declared in the EnergyPlus input data file
but not in Modelica.
</p>
<p>
If there are two instances that declare the same <code>zoneName</code>
and have in the model hierarchy the same instance of
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Building\">
Buildings.ThermalZones.EnergyPlus.Building</a>,
then the simulation will stop with an error.
</p>
<h4>Main Equations</h4>
<p>
This model computes in Modelica the air energy, mass and species
balance. Outside air infiltration needs to be modeled in Modelica,
because any infiltration that the EnergyPlus model may specify is ignored.
The convective heat transfer with the building fabric,
the long-wave and the short-wave radiation are computed by EnergyPlus.
</p>
<h5>Heat and mass balance</h5>
<p>
The zone uses a volume of air that is fully mixed. The size of this volume,
and its floor area, which is used to scale the heat gains <code>q_flow</code>,
are obtained from the EnergyPlus model.
By default, the air uses a dynamic balance. With the parameter
<code>energyBalance</code>, the type of energy balance can be configured.
The parameter <code>mSenFac</code> is used to increase the sensible heat capacity
of the zone air. By default, <code>mSenFac=1</code>. Higher values can be
used to approximate the sensible heat capacity of furnitures.
The latent heat capacity is not affected by this parameter.
</p>

<h5>Contaminant balance</h5>
<p>
The model has a parameter <code>use_C_flow</code>. If set to <code>true</code>,
then an input connector <code>C_flow</code> is enabled, which allows adding trace substances
to the room air. Note that this requires a medium model that has trace substances enabled.
</p>
<h5>Heat gains and CO2 added by people</h5>
<p>
If the EnergyPlus model computes internal heat gains
such as from people or equipment, then their sensible convective
and latent heat gains are automatically added to this room model,
and the radiant fraction is added to the EnergyPlus envelope and thus
treated correctly.
In addition, if desired, radiant, convective and latent heat gains
in units of <i>W/m<sup>2</sup></i>
can be added using the input connector <code>qGai_flow</code>.
</p>
<p>
Similarly, if people are modeled in EnergyPlus (using the
EnergyPlus <code>People</code> object), <i>and</i> if the
Modelica <code>Medium</code> contains CO2 (e.g., if
<code>Medium.nC &gt; 0</code> and
there is a <code>Medium.substanceName = \"CO2\"</code>),
then the CO2 emitted by the people is automatically added to this volume.
However, the \"Generic Contaminant\" modeled in EnergyPlus is not
added to the air volume. (Because EnergyPlus does not declare the
name of the species or its molar mass and hence it cannot be matched
to species in Modelica or converted to emitted mass flow rate.)
</p>
</html>",   revisions="<html>
<ul>
<li>
November 22, 2019, by Michael Wetter:<br/>
Replaced volume with dynamic balance.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1657\">issue 1657</a>.
</li>
<li>
April 04, 2018, by Thierry S. Nouidui:<br/>
Added additional parameters for parametrizing
the EnergyPlus model.
</li>
<li>
March 21, 2018, by Thierry S. Nouidui:<br/>
Revised implementation for efficiency.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1129\">issue 1129</a>.
</li>
</ul>
</html>"));
      end ThermalZone;

      package Types "Package with type definitions"
        extends Modelica.Icons.TypesPackage;

        type LogLevels = enumeration(
          Error
          "Errors",
          Warning
          "Warnings",
          Info
          "Information",
          Verbose
          "Verbose, log calls in initialization and shut-down",
          Debug
          "Verbose, log everything at each time step")
          "Enumeration for logging"
          annotation (Documentation(info="<html>
<p>
Enumeration for the level of outputs written by EnergyPlus.
The possible values are:
</p>
<table summary=\"log levels\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr><th>LogLevels</th><th>Explanation</th></tr>
<tr><td>Error</td><td>Logs EnergyPlus errors and fatal errors.</td></tr>
<tr><td>Warning</td><td>Logs in addition EnergyPlus warnings.</td></tr>
<tr><td>Info</td><td>Logs in addition EnergyPlus informational messages.</td></tr>
<tr><td>Verbose</td><td>Logs in addition main C function calls during initialization and shut-down.</td></tr>
<tr><td>Debug</td><td>Logs everything, including all calls during time steps which can give large log files.</td></tr>
</table>
</html>",        revisions="<html>
<ul>
<li>
July 23, 2020, by Michael Wetter:<br/>
Revised implementation to combine errors and fatal errors, as they should both be reported always.
</li>
<li>
September 25, 2019, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
August 21, 2019, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(
            graphics={Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100,-100},{100,100}},radius=25.0),
              Polygon(points={{0,76},{-80,-64},{80,-64},{0,76}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,pattern=LinePattern.None,lineColor={0,0,0}),
              Polygon(points={{0,68},{-72,-60},{72,-60},{0,68}},lineColor={0,0,0},
              fillColor={255,255,170},fillPattern=FillPattern.Solid),
              Ellipse(extent={{-6,-36},{4,-46}},pattern=LinePattern.None,
              fillColor={0,0,0},fillPattern=FillPattern.Solid),
              Rectangle(extent={{-4,34},{2,-28}},fillColor={0,0,0},fillPattern=FillPattern.Solid,
              pattern=LinePattern.None)}));
        annotation (
          preferredView="info",
          Documentation(
            info="<html>
<p>
This package contains type definitions.
</p>
</html>",   revisions="<html>
<ul>
<li>
August 21, 2019, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Types;

      package Examples
      "Collection of models that illustrate model use and test models"
        extends Modelica.Icons.ExamplesPackage;

        package SmallOffice
        "Package with VAV models for a small office building"
          extends Modelica.Icons.ExamplesPackage;

          package BaseClasses "Package with base classes"
            extends Modelica.Icons.BasesPackage;

            model Floor
              "Model of a floor of the building"
              extends Buildings.Examples.VAVReheat.BaseClasses.PartialFloor(
                final VRooCor=456.455,
                final VRooSou=346.022,
                final VRooNor=346.022,
                final VRooEas=205.265,
                final VRooWes=205.265,
                final AFloCor=cor.AFlo,
                final AFloSou=sou.AFlo,
                final AFloNor=nor.AFlo,
                final AFloEas=eas.AFlo,
                final AFloWes=wes.AFlo,
                opeWesCor(
                  wOpe=4),
                opeSouCor(
                  wOpe=9),
                opeNorCor(
                  wOpe=9),
                opeEasCor(
                  wOpe=4),
                leaWes(
                  s=18.46/27.69),
                leaSou(
                  s=27.69/18.46),
                leaNor(
                  s=27.69/18.46),
                leaEas(
                  s=18.46/27.69));

              final parameter Modelica.SIunits.Area AFlo=AFloCor+AFloSou+AFloNor+AFloEas+AFloWes
                "Total floor area";
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorSou
                "Heat port to air volume South"
                annotation (Placement(transformation(extent={{106,-46},{126,-26}}),iconTransformation(extent={{128,-36},{148,-16}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorEas
                "Heat port to air volume East"
                annotation (Placement(transformation(extent={{320,42},{340,62}}),iconTransformation(extent={{318,64},{338,84}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorNor
                "Heat port to air volume North"
                annotation (Placement(transformation(extent={{106,114},{126,134}}),iconTransformation(extent={{126,106},{146,126}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorWes
                "Heat port to air volume West"
                annotation (Placement(transformation(extent={{-40,56},{-20,76}}),iconTransformation(extent={{-36,64},{-16,84}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorCor
                "Heat port to air volume corridor"
                annotation (Placement(transformation(extent={{106,36},{126,56}}),iconTransformation(extent={{130,38},{150,58}})));
              Modelica.SIunits.Temperature TAirCor=cor.TAir
                "Air temperature corridor";
              Modelica.SIunits.Temperature TAirSou=sou.TAir
                "Air temperature south zone";
              Modelica.SIunits.Temperature TAirNor=nor.TAir
                "Air temperature north zone";
              Modelica.SIunits.Temperature TAirEas=eas.TAir
                "Air temperature east zone";
              Modelica.SIunits.Temperature TAirWes=wes.TAir
                "Air temperature west zone";
              ThermalZone sou(
                redeclare package Medium=Medium,
                nPorts=5,
                zoneName="Perimeter_ZN_1")
                "South zone"
                annotation (Placement(transformation(extent={{144,-44},{184,-4}})));
              ThermalZone eas(
                redeclare package Medium=Medium,
                nPorts=5,
                zoneName="Perimeter_ZN_2")
                "East zone"
                annotation (Placement(transformation(extent={{300,68},{340,108}})));
              ThermalZone nor(
                redeclare package Medium=Medium,
                nPorts=5,
                zoneName="Perimeter_ZN_3")
                "North zone"
                annotation (Placement(transformation(extent={{144,116},{184,156}})));
              ThermalZone wes(
                redeclare package Medium=Medium,
                nPorts=5,
                zoneName="Perimeter_ZN_4")
                "West zone"
                annotation (Placement(transformation(extent={{12,58},{52,98}})));
              ThermalZone cor(
                redeclare package Medium=Medium,
                nPorts=11,
                zoneName="Core_ZN")
                "Core zone"
                annotation (Placement(transformation(extent={{144,60},{184,100}})));
              ThermalZone att(
                redeclare package Medium=Medium,
                zoneName="Attic",
                T_start=275.15)
                "Attic zone"
                annotation (Placement(transformation(extent={{300,-60},{340,-20}})));

          protected
              parameter String idfName=Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/Data/ThermalZones/EnergyPlus/Examples/RefBldgSmallOffice/RefBldgSmallOfficeNew2004_Chicago.idf")
                "Name of the IDF file";
              parameter String weaName=Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")
                "Name of the weather file";
              inner Buildings.ThermalZones.EnergyPlus.Building building(
                idfName=idfName,
                weaName=weaName,
                computeWetBulbTemperature=false)
                "Building-level declarations"
                annotation (Placement(transformation(extent={{140,460},{160,480}})));
              Buildings.Controls.OBC.CDL.Continuous.Sources.Constant qGai_flow[3](
                k={0,0,0})
                "Internal heat gain (computed already in EnergyPlus"
                annotation (Placement(transformation(extent={{-140,-40},{-120,-20}})));

            initial equation
              assert(
                abs(
                  cor.V-VRooCor) < 0.01,
                "Volumes don't match. These had to be entered manually to avoid using a non-literal value.");
              assert(
                abs(
                  sou.V-VRooSou) < 0.01,
                "Volumes don't match. These had to be entered manually to avoid using a non-literal value.");
              assert(
                abs(
                  nor.V-VRooNor) < 0.01,
                "Volumes don't match. These had to be entered manually to avoid using a non-literal value.");
              assert(
                abs(
                  eas.V-VRooEas) < 0.01,
                "Volumes don't match. These had to be entered manually to avoid using a non-literal value.");
              assert(
                abs(
                  wes.V-VRooWes) < 0.01,
                "Volumes don't match. These had to be entered manually to avoid using a non-literal value.");
              assert(
                abs(
                  opeWesCor.wOpe-4) < 0.01,
                "wOpe in west zone doesn't match");

            equation
              connect(sou.heaPorAir,temAirSou.port)
                annotation (Line(points={{164,-24},{224,-24},{224,100},{264,100},{264,350},{290,350}},color={191,0,0},smooth=Smooth.None));
              connect(eas.heaPorAir,temAirEas.port)
                annotation (Line(points={{320,88},{286,88},{286,320},{292,320}},color={191,0,0},smooth=Smooth.None));
              connect(nor.heaPorAir,temAirNor.port)
                annotation (Line(points={{164,136},{164,136},{164,290},{292,290}},color={191,0,0},smooth=Smooth.None));
              connect(wes.heaPorAir,temAirWes.port)
                annotation (Line(points={{32,78},{70,78},{70,114},{186,114},{186,258},{292,258}},color={191,0,0},smooth=Smooth.None));
              connect(cor.heaPorAir,temAirCor.port)
                annotation (Line(points={{164,80},{164,228},{294,228}},color={191,0,0},smooth=Smooth.None));
              connect(sou.ports[1],portsSou[1])
                annotation (Line(points={{160.8,-43.1},{164,-43.1},{164,-54},{86,-54},{86,-36},{80,-36}},color={0,127,255},smooth=Smooth.None));
              connect(sou.ports[2],portsSou[2])
                annotation (Line(points={{162.4,-43.1},{164,-43.1},{164,-54},{86,-54},{86,-36},{100,-36}},color={0,127,255},smooth=Smooth.None));
              connect(eas.ports[1],portsEas[1])
                annotation (Line(points={{316.8,68.9},{300,68.9},{300,36},{320,36}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(eas.ports[2],portsEas[2])
                annotation (Line(points={{318.4,68.9},{300,68.9},{300,36},{340,36}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(nor.ports[1],portsNor[1])
                annotation (Line(points={{160.8,116.9},{164,116.9},{164,106},{88,106},{88,124},{80,124}},color={0,127,255},smooth=Smooth.None));
              connect(nor.ports[2],portsNor[2])
                annotation (Line(points={{162.4,116.9},{164,116.9},{164,106},{88,106},{88,124},{100,124}},color={0,127,255},smooth=Smooth.None));
              connect(wes.ports[1],portsWes[1])
                annotation (Line(points={{28.8,58.9},{30,58.9},{30,44},{-40,44}},color={0,127,255},smooth=Smooth.None));
              connect(wes.ports[2],portsWes[2])
                annotation (Line(points={{30.4,58.9},{-2,58.9},{-2,44},{-20,44}},color={0,127,255},smooth=Smooth.None));
              connect(cor.ports[1],portsCor[1])
                annotation (Line(points={{160.364,60.9},{164,60.9},{164,26},{90,26},{90,46},{80,46}},color={0,127,255},smooth=Smooth.None));
              connect(cor.ports[2],portsCor[2])
                annotation (Line(points={{161.091,60.9},{164,60.9},{164,26},{90,26},{90,46},{100,46}},color={0,127,255},smooth=Smooth.None));
              connect(leaSou.port_b,sou.ports[3])
                annotation (Line(points={{-22,400},{-2,400},{-2,-72},{134,-72},{134,-54},{164,-54},{164,-43.1}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(leaEas.port_b,eas.ports[3])
                annotation (Line(points={{-22,360},{246,360},{246,68.9},{320,68.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(leaNor.port_b,nor.ports[3])
                annotation (Line(points={{-20,320},{138,320},{138,116.9},{164,116.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(leaWes.port_b,wes.ports[3])
                annotation (Line(points={{-20,280},{2,280},{2,58.9},{32,58.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeSouCor.port_b1,cor.ports[3])
                annotation (Line(points={{104,16},{164,16},{164,34},{161.818,34},{161.818,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeSouCor.port_a2,cor.ports[4])
                annotation (Line(points={{104,4},{164,4},{164,60.9},{162.545,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeSouCor.port_a1,sou.ports[4])
                annotation (Line(points={{84,16},{74,16},{74,-20},{134,-20},{134,-54},{162,-54},{162,-46},{164,-46},{164,-43.1},{165.6,-43.1}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeSouCor.port_b2,sou.ports[5])
                annotation (Line(points={{84,4},{74,4},{74,-20},{134,-20},{134,-54},{164,-54},{164,-43.1},{167.2,-43.1}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeEasCor.port_b1,eas.ports[4])
                annotation (Line(points={{270,54},{290,54},{290,68.9},{321.6,68.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeEasCor.port_a2,eas.ports[5])
                annotation (Line(points={{270,42},{290,42},{290,68.9},{323.2,68.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeEasCor.port_a1,cor.ports[5])
                annotation (Line(points={{250,54},{190,54},{190,34},{142,34},{142,60.9},{163.273,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeEasCor.port_b2,cor.ports[6])
                annotation (Line(points={{250,42},{190,42},{190,34},{142,34},{142,60.9},{164,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeNorCor.port_b1,nor.ports[4])
                annotation (Line(points={{100,90},{108,90},{108,106},{164,106},{164,116.9},{165.6,116.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeNorCor.port_a2,nor.ports[5])
                annotation (Line(points={{100,78},{108,78},{108,106},{164,106},{164,116.9},{167.2,116.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeNorCor.port_a1,cor.ports[7])
                annotation (Line(points={{80,90},{76,90},{76,60},{142,60},{142,60.9},{164.727,60.9}},color={0,127,255},smooth=Smooth.None));
              connect(opeNorCor.port_b2,cor.ports[8])
                annotation (Line(points={{80,78},{76,78},{76,60},{142,60},{142,60.9},{165.455,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeWesCor.port_b1,cor.ports[9])
                annotation (Line(points={{40,-4},{56,-4},{56,26},{164,26},{164,36},{166.182,36},{166.182,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeWesCor.port_a2,cor.ports[10])
                annotation (Line(points={{40,-16},{56,-16},{56,26},{164,26},{164,60.9},{166.909,60.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeWesCor.port_a1,wes.ports[4])
                annotation (Line(points={{20,-4},{14,-4},{14,44},{30,44},{30,58.9},{33.6,58.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(opeWesCor.port_b2,wes.ports[5])
                annotation (Line(points={{20,-16},{14,-16},{14,44},{30,44},{30,58.9},{35.2,58.9}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(cor.ports[11],senRelPre.port_a)
                annotation (Line(points={{167.636,60.9},{164,60.9},{164,24},{128,24},{128,250},{60,250}},color={0,127,255},smooth=Smooth.None,thickness=0.5));
              connect(sou.qGai_flow,qGai_flow.y)
                annotation (Line(points={{142,-14},{64,-14},{64,-30},{-118,-30}},color={0,0,127}));
              connect(wes.qGai_flow,qGai_flow.y)
                annotation (Line(points={{10,88},{-60,88},{-60,-30},{-118,-30}},color={0,0,127}));
              connect(eas.qGai_flow,qGai_flow.y)
                annotation (Line(points={{298,98},{200,98},{200,110},{-60,110},{-60,-30},{-118,-30}},color={0,0,127}));
              connect(cor.qGai_flow,qGai_flow.y)
                annotation (Line(points={{142,90},{130,90},{130,110},{-60,110},{-60,-30},{-118,-30}},color={0,0,127}));
              connect(nor.qGai_flow,qGai_flow.y)
                annotation (Line(points={{142,146},{-60,146},{-60,-30},{-118,-30}},color={0,0,127}));
              connect(att.qGai_flow,qGai_flow.y)
                annotation (Line(points={{298,-30},{240,-30},{240,-80},{-60,-80},{-60,-30},{-118,-30}},color={0,0,127}));
              connect(sou.heaPorAir,heaPorSou)
                annotation (Line(points={{164,-24},{140,-24},{140,-36},{116,-36}},color={191,0,0}));
              connect(eas.heaPorAir,heaPorEas)
                annotation (Line(points={{320,88},{330,88},{330,52}},color={191,0,0}));
              connect(nor.heaPorAir,heaPorNor)
                annotation (Line(points={{164,136},{116,136},{116,124}},color={191,0,0}));
              connect(wes.heaPorAir,heaPorWes)
                annotation (Line(points={{32,78},{-30,78},{-30,66}},color={191,0,0}));
              connect(cor.heaPorAir,heaPorCor)
                annotation (Line(points={{164,80},{116,80},{116,46}},color={191,0,0}));
              annotation (
                Diagram(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-160,-100},{380,500}},
                    initialScale=0.1)),
                Icon(
                  coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-80,-80},{380,180}}),
                  graphics={
                    Rectangle(
                      extent={{-80,-80},{380,180}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-60,160},{360,-60}},
                      pattern=LinePattern.None,
                      lineColor={117,148,176},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Sphere),
                    Rectangle(
                      extent={{0,-80},{294,-60}},
                      lineColor={95,95,95},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{0,-74},{294,-66}},
                      lineColor={95,95,95},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{8,8},{294,100}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{20,88},{280,22}},
                      pattern=LinePattern.None,
                      lineColor={117,148,176},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Sphere),
                    Polygon(
                      points={{-56,170},{20,94},{12,88},{-62,162},{-56,170}},
                      smooth=Smooth.None,
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Polygon(
                      points={{290,16},{366,-60},{358,-66},{284,8},{290,16}},
                      smooth=Smooth.None,
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Polygon(
                      points={{284,96},{360,168},{368,162},{292,90},{284,96}},
                      smooth=Smooth.None,
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-80,120},{-60,-20}},
                      lineColor={95,95,95},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-74,120},{-66,-20}},
                      lineColor={95,95,95},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-64,-56},{18,22},{26,16},{-58,-64},{-64,-56}},
                      smooth=Smooth.None,
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{360,122},{380,-18}},
                      lineColor={95,95,95},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{366,122},{374,-18}},
                      lineColor={95,95,95},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{2,170},{296,178}},
                      lineColor={95,95,95},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{2,160},{296,180}},
                      lineColor={95,95,95},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{2,166},{296,174}},
                      lineColor={95,95,95},
                      fillColor={170,213,255},
                      fillPattern=FillPattern.Solid),
                    Bitmap(
                      extent={{192,-58},{342,-18}},
                      fileName="modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/spawn_icon_darkbluetxmedres.png",
                      visible=not usePrecompiledFMU)}),
                Documentation(
                  info="<html>
<p>
Model of one floor of the DOE reference office building.
</p>
<h4>Implementation</h4>
<p>
Compared to the base class, which has been built for the models in
<a href=\"modelica://Buildings.Examples.VAVReheat\">
Buildings.Examples.VAVReheat</a> which are for a larger building,
the instances of
<a href=\"modelica://Buildings.Airflow.Multizone.DoorOpen\">
Buildings.Airflow.Multizone.DoorOpen</a> are made smaller.
Their length has been reduced proportionally
to the difference in length of the walls of the core zone of the two buildings.
See also <a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>
for a description of the differences in these buildings.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 30, 2021, by Michael Wetter:<br/>
Reformulated replaceable class and introduced floor areas in base class
to avoid access of components that are not in the constraining type.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2471\">issue #2471</a>.
</li>
<li>
November 15, 2019, by Milica Grahovac:<br/>
Added extend from a partial floor model.
</li>
<li>
May 1, 2013, by Michael Wetter:<br/>
Declared the parameter record to be a parameter, as declaring its elements
to be parameters does not imply that the whole record has the variability of a parameter.
</li>
</ul>
</html>"));
            end Floor;
            annotation (
              preferredView="info",
              Documentation(
                info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>.
</p>
</html>"));
          end BaseClasses;
          annotation (
            preferredView="info",
            Documentation(
              info="<html>
<p>
This package contains variable air volume flow models
for a office building.
</p>
<h4>Note</h4>
<p>
The models
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter</a>
and
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.Guideline36Winter\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.Guideline36Winter</a>
appear to be quite similar to
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>
and
<a href=\"modelica://Buildings.Examples.VAVReheat.Guideline36\">
Buildings.Examples.VAVReheat.Guideline36</a>,
respectively, because they all have the same HVAC system, control sequences,
and all have five thermal zones.
However, the models in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>
are from the
<i>DOE Commercial Reference Building,
Small Office, new construction, ASHRAE 90.1-2004,
Version 1.3_5.0</i>,
whereas the models in
<a href=\"modelica://Buildings.Examples.VAVReheat\">
Buildings.Examples.VAVReheat</a>
are from the
<i>DOE Commercial Building Benchmark,
Medium Office, new construction, ASHRAE 90.1-2004,
version 1.2_4.0</i>.
Therefore, the dimensions of the thermal zones in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>
are considerably smaller than in
<a href=\"modelica://Buildings.Examples.VAVReheat\">
Buildings.Examples.VAVReheat</a>.
As the sizing is scaled with the volumes of the thermal zones, the model <i>structure</i>
is the same, but the design capacities are different, as is the energy consumption.
</p>
</html>"));
        end SmallOffice;
        annotation (
          preferredView="info",
          Documentation(
            info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus\">
Buildings.ThermalZones.EnergyPlus</a>.
</p>
</html>"));
      end Examples;

      package BaseClasses
      "Package with base classes for Buildings.ThermalZones.EnergyPlus"
        extends Modelica.Icons.BasesPackage;

        partial block PartialEnergyPlusObject
          "Partial definitions of an EnergyPlus object"
          extends Modelica.Blocks.Icons.Block;
          outer Buildings.ThermalZones.EnergyPlus.Building building
            "Building-level declarations";

      protected
          constant String modelicaNameBuilding=building.modelicaNameBuilding
            "Name of the building to which this output variable belongs to"
            annotation (HideResult=true);
          constant String modelicaInstanceName=getInstanceName()
            "Name of this instance"
            annotation (HideResult=true);
          final parameter String idfName=building.idfName
            "Name of the IDF file that contains this zone";
          final parameter String weaName=building.weaName
            "Name of the EnergyPlus weather file (but with mos extension)";
          final parameter Real relativeSurfaceTolerance=building.relativeSurfaceTolerance
            "Relative tolerance of surface temperature calculations";
          final parameter Boolean usePrecompiledFMU=building.usePrecompiledFMU
            "Set to true to use pre-compiled FMU with name specified by fmuName"
            annotation (Dialog(tab="Debug"));
          final parameter String fmuName=building.fmuName
            "Specify if a pre-compiled FMU should be used instead of EnergyPlus (mainly for development)"
            annotation (Dialog(tab="Debug"));
          final parameter Buildings.ThermalZones.EnergyPlus.Types.LogLevels logLevel=building.logLevel
            "LogLevels of EnergyPlus output"
            annotation (Dialog(tab="Debug"));
          parameter Modelica.SIunits.Time startTime(
            fixed=false)
            "Simulation start time";
          function round
            input Real u;
            input Real accuracy;
            output Real y;

          algorithm
            y :=
              if
                (u > 0) then
                floor(
                  u/accuracy+0.5)*accuracy
              else
                ceil(
                  u/accuracy-0.5)*accuracy;
          end round;

        initial equation
          startTime=time;
          annotation (
            Icon(
              graphics={
                Bitmap(
                  extent={{58,-98},{98,-68}},
                  fileName="modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/EnergyPlusLogo.png",
                  visible=not usePrecompiledFMU)}),
            Documentation(
              info="<html>
<p>
Partial model for an EnergyPlus object.
</p>
</html>",     revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
April 04, 2018, by Thierry S. Nouidui:<br/>
Added additional parameters for parametrizing
the EnergyPlus model.
</li>
<li>
March 21, 2018, by Thierry S. Nouidui:<br/>
Revised implementation for efficiency.
</li>
<li>
November 8, 2019, by Michael Wetter:<br/>
First implementation..
</li>
</ul>
</html>"));
        end PartialEnergyPlusObject;

        class SpawnExternalObject
          "Class used to couple the FMU to interact with a thermal zone"
          extends ExternalObject;
          function constructor
            "Construct to connect to a thermal zone in EnergyPlus"
            extends Modelica.Icons.Function;
            input Integer objectType
              "Type of the object (1: ThermalZone, 2: Schedule, 3: Actuator, 4: Surface)";
            input Modelica.SIunits.Time startTime
              "Start time of the simulation";
            input String modelicaNameBuilding
              "Name of this Modelica building instance that connects to this thermal zone";
            input String modelicaInstanceName
              "Name of the Modelica instance of this object";
            input String idfName
              "Name of the IDF";
            input String weaName
              "Name of the weather file";
            input Real relativeSurfaceTolerance
              "Relative tolerance of surface temperature calculations";
            input String epName
              "Name of the object in EnergyPlus";
            input Boolean usePrecompiledFMU
              "Set to true to use precompiled FMU with name specified by input fmuName";
            input String fmuName
              "Specify if a pre-compiled FMU should be used instead of EnergyPlus (mainly for development)";
            input String buildingsLibraryRoot
              "Root directory of the Buildings library (used to find the spawn executable)";
            input Buildings.ThermalZones.EnergyPlus.Types.LogLevels logLevel
              "LogLevels of EnergyPlus output";
            input Boolean printUnit
              "Set to true to print units for OutputVariable object. Must be false for all other objects";
            input String jsonName
              "Name of the object in the json configuration file";
            input String jsonKeysValues
              "Keys and values string to be written to the json configuration file";
            input String parOutNames[nParOut]
              "Names of parameter in modelDescription.xml file";
            input String parOutUnits[nParOut]
              "Modelica units of the parameters";
            input Integer nParOut
              "Number of parameters";
            input String inpNames[nInp]
              "Names of inputs in modelDescription.xml file";
            input String inpUnits[nInp]
              "Modelica units of the inputs";
            input Integer nInp
              "Size of inpNames";
            input String outNames[nOut]
              "Names of outputs in modelDescription.xml file";
            input String outUnits[nOut]
              "Modelica units of the outputs";
            input Integer nOut
              "Size of outNames";
            input Integer derivatives_structure[nDer,2]
              "List of derivatives (1-based index, [i,j] means dy_i/du_j";
            input Integer nDer
              "Size of derivatives";
            input Real derivatives_delta[nDer]
              "Increments for derivative calculation";
            output SpawnExternalObject adapter;
          external "C" adapter=ModelicaSpawnAllocate(
            objectType,
            startTime,
            modelicaNameBuilding,
            modelicaInstanceName,
            idfName,
            weaName,
            relativeSurfaceTolerance,
            epName,
            usePrecompiledFMU,
            fmuName,
            buildingsLibraryRoot,
            logLevel,
            printUnit,
            jsonName,
            jsonKeysValues,
            parOutNames,
            nParOut,
            parOutUnits,
            nParOut,
            inpNames,
            nInp,
            inpUnits,
            nInp,
            outNames,
            nOut,
            outUnits,
            nOut,
            derivatives_structure,
            2,
            nDer,
            derivatives_delta,
            nDer)
            annotation (
              Include="#include <EnergyPlusWrapper.c>",
              IncludeDirectory="modelica://Buildings/Resources/C-Sources",
              Library={"ModelicaBuildingsEnergyPlus","fmilib_shared"});
            annotation (
              Documentation(
                info="<html>
<p>
The function <code>constructor</code> is a C function that is called by a Modelica simulator
exactly once during the initialization.
The function returns the object <code>adapter</code> that
will be used to store the data structure needed to communicate with EnergyPlus.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end constructor;

          function destructor
            "Release storage"
            extends Modelica.Icons.Function;
            input SpawnExternalObject adapter;
          external "C" ModelicaSpawnFree(adapter)
            annotation (
              Include="#include <EnergyPlusWrapper.c>",
              IncludeDirectory="modelica://Buildings/Resources/C-Sources",
              Library={"ModelicaBuildingsEnergyPlus","fmilib_shared"});
            annotation (
              Documentation(
                info="<html>
<p>
Destructor that frees the memory of the object.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end destructor;
          annotation (
            Documentation(
              info="<html>
<p>
Class derived from <code>ExternalObject</code> having two local external function definition,
named <code>destructor</code> and <code>constructor</code> respectively.
<p>
These functions create and release an external object that allows the storage
of the data structure needed to communicate with the EnergyPlus FMU.

</html>",     revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
April 04, 2018, by Thierry S. Nouidui:<br/>
Added additional parameters for parametrizing
the EnergyPlus model.
</li>
<li>
March 21, 2018, by Thierry S. Nouidui:<br/>
Revised implementation for efficiency.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SpawnExternalObject;

        model ThermalZoneAdapter
          "Block that interacts with this EnergyPlus zone"
          extends Modelica.Blocks.Icons.Block;
          extends
          Buildings.ThermalZones.EnergyPlus.BaseClasses.Synchronize.ObjectSynchronizer;
          constant String modelicaNameBuilding
            "Name of the building to which this thermal zone belongs to"
            annotation (HideResult=true);
          constant String modelicaInstanceName=getInstanceName()
            "Name of this instance"
            annotation (HideResult=true);
          parameter String idfName
            "Name of the IDF file that contains this zone";
          parameter String weaName
            "Name of the Energyplus weather file";
          parameter Real relativeSurfaceTolerance
            "Relative tolerance of surface temperature calculations";
          parameter String zoneName
            "Name of the thermal zone as specified in the EnergyPlus input";
          parameter Boolean usePrecompiledFMU=false
            "Set to true to use pre-compiled FMU with name specified by fmuName"
            annotation (Dialog(tab="Debug"));
          parameter String fmuName=""
            "Specify if a pre-compiled FMU should be used instead of EnergyPlus (mainly for development)"
            annotation (Dialog(tab="Debug",enable=usePrecompiledFMU));
          parameter Buildings.ThermalZones.EnergyPlus.Types.LogLevels logLevel=Buildings.ThermalZones.EnergyPlus.Types.LogLevels.Warning
            "LogLevels of EnergyPlus output"
            annotation (Dialog(tab="Debug"));
          parameter Integer nFluPor
            "Number of fluid ports (Set to 2 for one inlet and one outlet)";
          final parameter Modelica.SIunits.Area AFlo(
            fixed=false)
            "Floor area";
          final parameter Modelica.SIunits.Volume V(
            fixed=false)
            "Zone volume";
          final parameter Real mSenFac(
            fixed=false)
            "Factor for scaling the sensible thermal mass of the zone air volume";
          Modelica.Blocks.Interfaces.RealInput T(
            final unit="K",
            displayUnit="degC")
            "Zone air temperature"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),iconTransformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Interfaces.RealInput X_w(
            final unit="kg/kg")
            "Zone air mass fraction in kg/kg total air"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),iconTransformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput m_flow[nFluPor](
            each final unit="kg/s")
            "Mass flow rate"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput TInlet[nFluPor](
            each final unit="K",
            each displayUnit="degC")
            "Air inlet temperatures"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput QGaiRad_flow(
            final unit="W")
            "Radiative heat gain"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(extent={{-140,-100},{-100,-60}})));
          Modelica.Blocks.Interfaces.RealOutput TRad(
            final unit="K",
            displayUnit="degC")
            "Radiative temperature"
            annotation (Placement(transformation(extent={{100,50},{120,70}}),iconTransformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput QCon_flow(
            final unit="W")
            "Convective sensible heat to be added to zone air"
            annotation (Placement(transformation(extent={{100,10},{120,30}}),iconTransformation(extent={{100,10},{120,30}})));
          Modelica.Blocks.Interfaces.RealOutput QLat_flow(
            final unit="W")
            "Latent heat to be added to zone air"
            annotation (Placement(transformation(extent={{100,-30},{120,-10}}),iconTransformation(extent={{100,-30},{120,-10}})));
          Modelica.Blocks.Interfaces.RealOutput QPeo_flow(
            final unit="W")
            "Total heat gain from people, to be used for optional computation of CO2 released"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}),iconTransformation(extent={{100,-70},{120,-50}})));

      protected
          constant Integer nParOut=3
            "Number of parameter values retrieved from EnergyPlus";
          constant Integer nInp=5
            "Number of inputs";
          constant Integer nOut=4
            "Number of outputs";
          constant Integer nDer=0
            "Number of derivatives";
          constant Integer nY=nOut+nDer+1
            "Size of output vector of exchange function";
          parameter Integer nObj(
            fixed=false,
            start=0)
            "Total number of Spawn objects in building";
          parameter Modelica.SIunits.MassFlowRate m_flow_small(
            fixed=false)
            "Small mass flow rate used to avoid TAveInlet = 0";
          Buildings.ThermalZones.EnergyPlus.BaseClasses.SpawnExternalObject adapter=Buildings.ThermalZones.EnergyPlus.BaseClasses.SpawnExternalObject(
            objectType=1,
            startTime=startTime,
            modelicaNameBuilding=modelicaNameBuilding,
            modelicaInstanceName=modelicaInstanceName,
            idfName=idfName,
            weaName=weaName,
            relativeSurfaceTolerance=relativeSurfaceTolerance,
            epName=zoneName,
            usePrecompiledFMU=usePrecompiledFMU,
            fmuName=fmuName,
            buildingsLibraryRoot=Buildings.ThermalZones.EnergyPlus.BaseClasses.buildingsLibraryRoot,
            logLevel=logLevel,
            printUnit=false,
            jsonName="zones",
            jsonKeysValues="        \"name\": \""+zoneName+"\"",
            parOutNames={"AFlo","V","mSenFac"},
            parOutUnits={"m2","m3","1"},
            nParOut=nParOut,
            inpNames={"T","X","mInlets_flow","TAveInlet","QGaiRad_flow"},
            inpUnits={"K","1","kg/s","K","W"},
            nInp=nInp,
            outNames={"TRad","QConSen_flow","QLat_flow","QPeo_flow"},
            outUnits={"K","W","W","W"},
            nOut=nOut,
            derivatives_structure=fill(fill(nDer,2),nDer),
            nDer=nDer,
            derivatives_delta=fill(0,nDer))
            "Class to communicate with EnergyPlus";
          //////////
          // The derivative structure was:
          //     derivatives_structure={{2,1}},
          //  nDer=nDer,
          //  derivatives_delta={0.1}
          // This has been removed due to numerical noise,
          // see https://github.com/lbl-srg/modelica-buildings/issues/2358#issuecomment-819578850
          //////////
          parameter Modelica.SIunits.Time startTime(
            fixed=false)
            "Simulation start time";
          Real yEP[nY]
            "Output of exchange function";
          Modelica.SIunits.Time tNext(
            start=startTime,
            fixed=true)
            "Next sampling time";
          //Modelica.SIunits.Time tNextEP(start=startTime-1, fixed=true) "Next sampling time requested from EnergyPlus";
          // constant Real dT_dtMax(unit="K/s") = 0.000001 "Bound on temperature derivative to reduce or increase time step";
          //  Modelica.SIunits.Time dtMax(displayUnit="min", start=600, fixed=true) "Maximum time step before next sampling";
          discrete Modelica.SIunits.Time tLast(
            fixed=true,
            start=startTime)
            "Last time of data exchange";
          discrete Modelica.SIunits.Time dtLast
            "Time step since the last synchronization";
          discrete Modelica.SIunits.MassFlowRate mInlet_flow
            "Time averaged inlet mass flow rate";
          discrete Modelica.SIunits.Temperature TAveInlet
            "Time averaged inlet temperature";
          discrete Modelica.SIunits.Temperature TRooLast
            "Room air temperature at last sampling";
        //  discrete Real dQCon_flow_dT(
        //    final unit="W/K")
        //    "Derivative dQCon_flow / dT";
          discrete Modelica.SIunits.HeatFlowRate QConLast_flow(
            fixed=false,
            start=0)
            "Convective sensible heat to be added to zone air if T = TRooLast";
          function round
            input Real u;
            input Real accuracy;
            output Real y;

          algorithm
            y :=
              if
                (u > 0) then
                floor(
                  u/accuracy+0.5)*accuracy
              else
                ceil(
                  u/accuracy-0.5)*accuracy;
          end round;

        initial equation
          if usePrecompiledFMU then
            assert(
              Modelica.Utilities.Strings.length(fmuName) > 1,
              "If usePrecompiledFMU = true, must set parameter fmuName");
          end if;
          startTime=time;
          nObj=Buildings.ThermalZones.EnergyPlus.BaseClasses.initialize(
            adapter=adapter,
            isSynchronized=building.isSynchronized);
          {AFlo,V,mSenFac}=Buildings.ThermalZones.EnergyPlus.BaseClasses.getParameters(
            adapter=adapter,
            nParOut=nParOut,
            isSynchronized=nObj);
          TAveInlet=293.15;
          m_flow_small=V*3*1.2/3600*1E-10;
          assert(
            AFlo > 0,
            "Floor area must not be zero.");
          assert(
            V > 0,
            "Volume must not be zero.");
          assert(
            mSenFac > 0.9999,
            "mSenFac must be bigger or equal than one.");

        equation
          if usePrecompiledFMU then
            // For JModelica, this must be in the equation section rather than the initial equation section
            assert(
              Modelica.Utilities.Strings.length(fmuName) > 1,
              "If usePrecompiledFMU = true, must set parameter fmuName");
          end if;
          when {initial(),time >= pre(tNext)} then
            // Initialization of output variables.
            TRooLast=T;
            dtLast=time-pre(tLast);
            mInlet_flow=noEvent(
              sum(
                if m_flow[i] > 0 then
                  m_flow[i]
                else
                  0 for i in 1:nFluPor));
            TAveInlet=noEvent(
              (sum(
                if m_flow[i] > 0 then
                  TInlet[i]*m_flow[i]
                else
                  0 for i in 1:nFluPor)+m_flow_small*pre(TAveInlet))/(mInlet_flow+m_flow_small));
            // Below, the term X_w/(1.-X_w) is for conversion from kg/kg_total_air (Modelica) to kg/kg_dry_air (EnergyPlus)
            yEP=Buildings.ThermalZones.EnergyPlus.BaseClasses.exchange(
              adapter=adapter,
              initialCall=false,
              nY=nY,
              u={T,X_w/(1.-X_w),mInlet_flow,TAveInlet,QGaiRad_flow,round(time,1E-3)},
              dummy=AFlo);
            TRad=yEP[1];
            QConLast_flow=yEP[2];
            QLat_flow=yEP[3];
            QPeo_flow=yEP[4];
            //dQCon_flow_dT=yEP[5];
            //tNext=yEP[6];
            tNext=yEP[5];
            tLast=time;
          end when;
          //QCon_flow=QConLast_flow+(T-TRooLast)*dQCon_flow_dT;
          QCon_flow=QConLast_flow;
          synBui.synchronize.done=nObj;
          annotation (
            defaultComponentName="fmuZon",
            Icon(
              graphics={
                Bitmap(
                  extent={{-92,-82},{82,92}},
                  fileName="modelica://Buildings/Resources/Images/Fluid/FMI/FMI_icon.png")}),
            Documentation(
              info="<html>
<p>
Block that exchanges data between Modelica and EnergyPlus.
This block is calling the C functions to initialize EnergyPlus,
exchange data with EnergyPlus, and free the memory, through the destructor
of its class <code>adapter</code>, of EnergyPlus.
</p>
</html>",     revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
December 6, 2020, by Michael Wetter:<br/>
Reformulated <code>when</code> condition to avoid using <code>not initial()</code>.
Per the Modelica language definition, <code>when</code> clauses are not meant to contain
<code>not initial()</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2068\">#2068</a>.
</li>
<li>
April 04, 2018, by Thierry S. Nouidui:<br/>
Added additional parameters for parametrizing
the EnergyPlus model.
</li>
<li>
March 21, 2018, by Thierry S. Nouidui:<br/>
Revised implementation for efficiency.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ThermalZoneAdapter;

        function exchange
          "Exchange the values with the EnergyPlus thermal zone"
          extends Modelica.Icons.Function;
          input Buildings.ThermalZones.EnergyPlus.BaseClasses.SpawnExternalObject adapter
            "External object";
          input Boolean initialCall
            "Set to true if initial() is true, false otherwise";
          input Integer nY
            "Size of output y";
          input Real u[:]
            "Input values. First all inputs, then the current model time";
          input Real dummy
            "Dummy value (used to force Modelica tools to call initialize())";
          output Real y[nY]
            "Output values. First all outputs, then all derivatives, then next event time";
        external "C" ModelicaSpawnExchange(
          adapter,initialCall,u,dummy,y)
          annotation (
              Include="#include <EnergyPlusWrapper.c>",
              IncludeDirectory="modelica://Buildings/Resources/C-Sources",
              Library={"ModelicaBuildingsEnergyPlus","fmilib_shared"});
          annotation (
            Documentation(
              info="<html>
<p>
External function that exchanges data with EnergyPlus.
</p>
</html>",     revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
February 14, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end exchange;

        function getParameters
          "Get parameters for an EnergyPlus object"
          extends Modelica.Icons.Function;
          input Buildings.ThermalZones.EnergyPlus.BaseClasses.SpawnExternalObject adapter
            "External object";
          input Integer nParOut
            "Number of elements in parOut";
          input Real isSynchronized
            "Set to variable that is used to synchronize the objects";
          output Real parOut[nParOut]
            "Parameter values returned from EnergyPlus";
        external "C" ModelicaSpawnGetParameters(
          adapter,isSynchronized,parOut)
          annotation (
              Include="#include <EnergyPlusWrapper.c>",
              IncludeDirectory="modelica://Buildings/Resources/C-Sources",
              Library={"ModelicaBuildingsEnergyPlus","fmilib_shared"});
          annotation (
            Documentation(
              info="<html>
<p>
External function that obtains parameters from the EnergyPlus FMU
and returns them to Modelica.
</p>
</html>",     revisions="<html>
<ul><li>
February 18, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getParameters;

        function initialize
          "Initialization for an EnergyPlus thermal zone"
          extends Modelica.Icons.Function;
          input Buildings.ThermalZones.EnergyPlus.BaseClasses.SpawnExternalObject adapter
            "External object";
          input Real isSynchronized
            "Set to variable that is used to synchronize the objects";
          output Integer nObj
            "Returns 1 from C, used to force synchronization";
        external "C" ModelicaSpawnInitialize(
          adapter,isSynchronized,nObj)
          annotation (
              Include="#include <EnergyPlusWrapper.c>",
              IncludeDirectory="modelica://Buildings/Resources/C-Sources",
              Library={"ModelicaBuildingsEnergyPlus","fmilib_shared"});
          annotation (
            Documentation(
              info="<html>
<p>
External function that generates the EnergyPlus FMU.
</p>
</html>",     revisions="<html>
<ul>
<li>
February 18, 2021, by Michael Wetter:<br/>
Refactor synchronization of constructors.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2360\">#2360</a>.
</li>
<li>
March 1, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end initialize;

        package Synchronize "Package with classes to synchronize Spawn objects"

          block ObjectSynchronizer
            "Block that synchronizes an object"
            outer Buildings.ThermalZones.EnergyPlus.Building building
              "Reference to outer building model";
            SynchronizeBuilding synBui
              "Model that synchronize the Spawn objects"
              annotation (HideResult=true);

          equation
            connect(building.synchronize,synBui.synchronize);
            annotation (
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Diagram(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Documentation(
                info="<html>
<p>
Block with <code>outer</code> declaration that is used to synchronize the calls to the Spawn objects.
</p>
</html>",       revisions="<html>
<ul><li>
February 17, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end ObjectSynchronizer;

          model SynchronizeBuilding
            "Model to synchronize the Spawn objects that belong to a building"
            Buildings.ThermalZones.EnergyPlus.BaseClasses.Synchronize.SynchronizeConnector synchronize
              "Connector that is used to synchronize objects";
            annotation (
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Diagram(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Documentation(
                info="<html>
<p>
Model that is used to synchronize the calls to the Spawn objects.
</p>
</html>",       revisions="<html>
<ul><li>
February 17, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end SynchronizeBuilding;

          connector SynchronizeConnector
            "Connector to synchronize Spawn objects"
            Real do
              "Potential variable";
            flow Real done
              "Flow variable";
            annotation (
              Icon(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Diagram(
                coordinateSystem(
                  preserveAspectRatio=false)),
              Documentation(
                info="<html>
<p>
Connector that is used to synchronize the calls to the Spawn objects.
</p>
</html>",       revisions="<html>
<ul><li>
February 17, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end SynchronizeConnector;
          annotation (
            Documentation(
              info="<html>
<p>
This class is used to synchronize the constructor calls
for Spawn.
The implementation is based on
Elmqvist et al. (2015) and
the code provided in
<a href=\"https://github.com/modelica/ModelicaSpecification/issues/2842\">Modelica #2842</a>.
</p>
<h4>References</h4>
<p>
Hilding Elmqvist, Axel Goteman, Vilhelm Roxling and Toheed Ghandriz.<br/>
Generic Modelica Framework for MultiBody Contacts and Discrete Element Method.<br/>
<i>Proceedings of the 11th International Modelica Conference</i>, Versailles, France, September 21-23, 2015.<br/>
<a href=\"https://www.doi.org/10.3384/ecp15118427\">doi: 10.3384/ecp15118427</a>.
</p>
</html>"));
        end Synchronize;

        constant String buildingsLibraryRoot=Modelica.Utilities.Strings.replace(
          string=Modelica.Utilities.Files.fullPathName(Modelica.Utilities.Files.loadResource("modelica://Buildings/legal.html")),
          searchString="/legal.html",
          replaceString="")
          "Root directory of the Buildings library (used to find the spawn executable)";
        annotation (
          preferredView="info",
          Documentation(
            info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus\">Buildings.ThermalZones.EnergyPlus</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (
        Icon(
          graphics={
            Bitmap(
              extent={{-100,-100},{100,100}},
              fileName="modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/spawn_icon_alonelowres.png")}),
        Documentation(
          info="<html>
<p align=\"right\">
<img alt=\"Spawn logo\" src=\"modelica://Buildings/Resources/Images/ThermalZones/EnergyPlus/spawn_icon_darkbluetxlowres.png\"  style=\"float:right;height=203px;width:587px;\"/>
</p>
<p>
Package for Spawn of EnergyPlus that couples Modelica directly
to the EnergyPlus envelope model.<br/>
The models in this package allow simulating the envelope heat transfer
of one or several buildings in EnergyPlus, and simulating HVAC and controls
in Modelica. EnergyPlus objects are represented graphically as any other Modelica
models, and the coupling and co-simulation is done automatically based on these models.
</p>
<p>
Models are provided to connect to EnergyPlus thermal zones, actuators, output variables and schedules.
</p>
<p>
See <a href=\"modelica://Buildings.ThermalZones.EnergyPlus.UsersGuide\">
Buildings.ThermalZones.EnergyPlus.UsersGuide</a>
for more information.
</p>
</html>"));
    end EnergyPlus;
  annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
            {100,100}}), graphics={
        Rectangle(
          extent={{-70,68},{78,-62}},
          lineColor={0,0,0}),
        Line(points={{-70,68},{-38,28},{42,28},{78,68}}, color={0,0,0}),
        Line(points={{-70,-62},{-38,-28},{-38,28}}, color={0,0,0}),
        Line(points={{-38,-28},{42,-28},{78,-62}}, color={0,0,0}),
        Line(points={{42,28},{42,-28}}, color={0,0,0})}), Documentation(info="<html>
<p>This package contains models for building physics of thermal zones.</p>
</html>"));
  end ThermalZones;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      block Average "Average of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = Buildings.Utilities.Math.Functions.average(u=u, nin=nin);
      annotation (defaultComponentName="ave",
      Documentation(info="<html>
<p>This block outputs the average of the vector. </p>
</html>",
      revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Changed block to use function average.
</li>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,46},{66,-58}},
                lineColor={0,0,255},
                textString="ave")}));
      end Average;

      block Min "Minimum element of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = min(u);
      annotation (
      defaultComponentName="min",
      Documentation(info="<html>
<p>
Outputs the minimum of the vector.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-72,88},{72,-72}},
                lineColor={0,0,255},
                textString="min")}));
      end Min;

      block SmoothMax
        "Once continuously differentiable approximation to the maximum function"
        extends Modelica.Blocks.Interfaces.SI2SO;
       parameter Real deltaX "Width of transition interval";
      equation
        y =  Buildings.Utilities.Math.Functions.smoothMax(x1=u1, x2=u2, deltaX=deltaX);
        annotation (Icon(graphics={Text(
                extent={{-88,40},{92,-32}},
                lineColor={160,160,164},
                textString="smoothMax()"), Text(
                extent={{-74,-44},{68,-114}},
                lineColor={0,0,255},
                textString="dX=%deltaX%")}),
      Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <i>max(.,.)</i> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SmoothMax;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function average "Average of a vector"
          extends Modelica.Icons.Function;
          input Integer nin "Number of inputs";
          input Real u[nin] "Input vector";
          output Real y "Result";

        algorithm
          y := sum(u)/nin;

          annotation (Documentation(info="<html>
<p>This function outputs the average of the vector. </p>
</html>",         revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Implementation based on Michael Wetter&apos;s block
<a href=\"modelica://Buildings.Utilities.Math.Average\">
Buildings.Utilities.Math.Average</a>.
</li>
</ul>
</html>"));
        end average;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.CubicHermite\">
Buildings.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real delta(min=Modelica.Constants.eps)
            "Abscissa value below which approximation occurs";
         input Real deltaInv = 1/delta "Inverse value of delta";

         input Real a = -15*deltaInv "Polynomial coefficient";
         input Real b = 119*deltaInv^2 "Polynomial coefficient";
         input Real c = -361*deltaInv^3 "Polynomial coefficient";
         input Real d = 534*deltaInv^4 "Polynomial coefficient";
         input Real e = -380*deltaInv^5 "Polynomial coefficient";
         input Real f = 104*deltaInv^6 "Polynomial coefficient";

         output Real y "Function value";

        algorithm
          y :=if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else
            Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(
               x=x,
               delta=delta, deltaInv=deltaInv,
               a=a, b=b, c=c, d=d, e=e, f=f);

          annotation (smoothOrder=2,
          derivative(order=1,
                  zeroDerivative=delta,
                  zeroDerivative=deltaInv,
                  zeroDerivative=a,
                  zeroDerivative=b,
                  zeroDerivative=c,
                  zeroDerivative=d,
                  zeroDerivative=e,
                  zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                      Inline=true,
        Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.InverseXRegularized\">
Buildings.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.InverseXRegularized\">
Buildings.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end inverseXRegularized;

        function isMonotonic "Returns true if the argument is a monotonic sequence"
          extends Modelica.Icons.Function;
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false "Set to true to test for strict monotonicity";
          output Boolean monotonic "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";

        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;

          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function powerLinearized
          "Power function that is linearized below a user-defined threshold"
          extends Modelica.Icons.Function;

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real x0 "Abscissa value below which linearization occurs";
         output Real y "Function value";
        algorithm
          if x > x0 then
           y := x^n;
          else
           y := x0^n * (1-n) + n * x0^(n-1) * x;
          end if;
          annotation (
            Documentation(info="<html>
Function that approximates <i>y=x<sup>n</sup></i>
where <i>0 &lt; n</i> so that
<ul>
<li>the function is defined and monotone increasing for all <i>x</i>.</li>
<li><i>dy/dx</i> is bounded and continuous everywhere (for <i>n &lt; 1</i>).</li>
</ul>
<p>
For <i>x &lt; x<sub>0</sub></i>, this function replaces
<i>y=x<sup>n</sup></i> by
a linear function that is continuously differentiable everywhere.
</p>
<p>
A typical use of this function is to replace
<i>T = T4<sup>(1/4)</sup></i> in a radiation balance to ensure that the
function is defined everywhere. This can help solving the initialization problem
when a solver may be far from a solution and hence <i>T4 &lt; 0</i>.
</p>
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),          smoothOrder=1, Inline=true);
        end powerLinearized;

        function quinticHermite
          "Quintic Hermite spline function for interpolation between two functions with a continuous second derivative"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower derivative";
          input Real y2d "Upper derivative";
          input Real y1dd "Lower second derivative";
          input Real y2dd "Upper second derivative";
          output Real y "Interpolated ordinate value";
      protected
          Real h = x2 - x1;
          Real hpow2 = h*h;
          Real t = (x - x1)/h;
          Real tpow2 = t*t;
          Real tpow3 = tpow2*t;
          Real tpow4 = tpow3*t;
          Real tpow5 = tpow4*t;
          Real H0 = 1 - 10*tpow3 + 15*tpow4 - 6*tpow5;
          Real H1 = t -  6*tpow3 +  8*tpow4 - 3*tpow5;
          Real H2 = 0.5*(tpow2 - 3*tpow3 + 3 *tpow4 - tpow5);
          Real H3 = 0.5*tpow3 - tpow4 + 0.5*tpow5;
          Real H4 = -4*tpow3 +7*tpow4 -3*tpow5;
          Real H5 = 1-H0;
        algorithm
          y :=H0*y1 + H1*y1d*h  + H2*y1dd*hpow2 + H3*y2dd*hpow2 + H4*y2d*h + H5*y2;

        annotation (smoothOrder=99,
        Documentation(revisions="<html>
<ul>
<li>
April 19, 2017, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Returns the result y of a quintic Hermite spline,
which is a C<sup>2</sup> continuous interpolation between two functions.
The abscissa value <code>x</code> has to be between <code>x1</code> and <code>x2</code>.
Variables <code>y1</code>, <code>y1d</code>, <code>y1dd</code> are the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x1</code>.
Variables <code>y2</code>, <code>y2d</code>, <code>y2dd</code> are respectively the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x2</code>.
</p>
</html>"));
        end quinticHermite;

        function regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"
          extends Modelica.Icons.Function;

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
      protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5>0, "Delta is too small for this exponent.");
          end if;
          annotation (
            Documentation(info="<html>

Function that approximates <i>y=|x|<sup>n</sup></i> where <i>n &gt; 0</i>
so that
<ul>
<li><i>y(0)</i> is not equal to zero.</li>
<li><i>dy/dx</i> is bounded and continuous everywhere.</li>
</ul>

<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&plusmn; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the
function for the convective heat transfer
coefficient for forced or free convection that is of the form
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent
<i>0 &le; n &le; 1</i>.
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and
a non-zero value at the origin. Physically,
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
See the package <code>Examples</code> for the graph.
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function regStep
          "Approximation of a general step, such that the approximation is continuous and differentiable"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real y1 "Ordinate value for x > 0";
          input Real y2 "Ordinate value for x < 0";
          input Real x_small(min=0) = 1e-5
            "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
          output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
        algorithm
          y := smooth(1, if x >  x_small then y1 else
                         if x < -x_small then y2 else
                         if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);

          annotation(Inline=true,
          Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",         info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
        end regStep;

        function round "Round real number to specified digits"
          extends Modelica.Icons.Function;

          input Real x "Argument to be rounded";
          input Integer n "Number of digits being round to";
          output Real y "Connector of Real output signal";

      protected
          parameter Real fac = 10^n "Factor used for rounding";

        algorithm
          y := if (x>0) then floor(x*fac + 0.5)/fac else ceil(x*fac - 0.5)/fac;

        annotation (
        Documentation(info="<html>
<p>
Function that outputs the input after rounding it to <code>n</code> digits.
</p>
<p>
For example,
</p>
<ul>
<li>
set <code>n = 0</code> to round to the nearest integer,
</li>
<li>
set <code>n = 1</code> to round to the next decimal point, and
</li>
<li>
set <code>n = -1</code> to round to the next multiple of ten.
</li>
</ul>
<p>
Hence, the function outputs
</p>
<pre>
    y = floor(x*(10^n) + 0.5)/(10^n)  for  x &gt; 0,
    y = ceil( x*(10^n) - 0.5)/(10^n)  for  x &lt; 0.
</pre>
<p>
To use this function as a block, use
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Round\">
Buildings.Controls.OBC.CDL.Continuous.Round</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
First implementation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2170\">#2170</a>.
</li>
</ul>
</html>"));
        end round;

        function smoothInterpolation
          "Interpolate using a cubic Hermite spline with linear extrapolation for a vector xSup[], ySup[] and independent variable x"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real xSup[:] "Support points (strictly increasing)";
          input Real ySup[size(xSup,1)] "Function values at xSup";
          input Boolean ensureMonotonicity=isMonotonic(ySup, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real yInt "Interpolated ordinate value";

      protected
          Integer n = size(xSup,1) "Number of support points";
          Real dy_dx[size(xSup,1)] "Derivative at xSup";
          Integer i "Integer to select data interval";
        algorithm
          if n > 2 then
            // Most common case with more than 2 data points.
            // Do cubic spline interpolation.
            dy_dx :=Buildings.Utilities.Math.Functions.splineDerivatives(
              x=xSup,
              y=ySup,
              ensureMonotonicity=ensureMonotonicity);

            // i is a counter that is used to pick the derivative
            // that corresponds to the interval that contains x
            i := 1;
            for j in 1:n-1 loop
              if x > xSup[j] then
                i := j;
               end if;
             end for;
             assert(xSup[i] < xSup[i+1], "Support points xSup must be increasing.");
             yInt:=cubicHermiteLinearExtrapolation(
                x=x,
                x1=xSup[i],
                x2=xSup[i+1],
                y1=ySup[i],
                y2=ySup[i+1],
                y1d=dy_dx[i],
                y2d=dy_dx[i+1]);
          elseif n == 2 then
            // Linear interpolation.
            yInt := ySup[1] + (x - xSup[1]) * (ySup[2] - ySup[1])/(xSup[2] - xSup[1]);
          else // n == 1
            yInt :=ySup[1];
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>xSup<sub>1</sub> &le; x &le; xSup<sub>n</sub></i>,
where <i>n</i> is the size of the support points <i>xSup</i>,
which must be strictly monotonically increasing,
this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
If <i>n=2</i>, linear interpolation is used an if <i>n=1</i>, the
function value <i>y<sup>1</sup></i> is returned.
</p>
<p>
Note that if <code>xSup</code> and <code>ySup</code> only depend on parameters
or constants, then
<a href=\"modelica://Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
will be more efficient.
In contrast to the function
<a href=\"modelica://Modelica.Math.Vectors.interpolate\">
Modelica.Math.Vectors.interpolate</a>
which provides linear interpolation, this function does
not trigger events.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.SmoothInterpolation\">
Buildings.Utilities.Math.Functions.Examples.SmoothInterpolation</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothInterpolation;

        function smoothLimit
          "Once continuously differentiable approximation to the limit function"
          extends Modelica.Icons.Function;
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";

      protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := Buildings.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := Buildings.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (smoothOrder = 1,
          Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[l, u]</i>.
</p>
<p>
Note that the limit need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
Sept 1, 2010, by Michael Wetter:<br/>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x1-x2, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x2-x1, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
<p>
Note that the minimum need not be respected, such as illustrated in
<a href=\"modelica://Buildings.Utilities.Math.Examples.SmoothMin\">
Buildings.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
          extends Modelica.Icons.Function;
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -0.999999999 then
              out := neg;
            elseif scaledX1 >= 0.999999999 then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;

            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentiable transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          extends Modelica.Icons.Function;
          input Real x[:] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";

        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;

          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];

            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;

          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
</p>
<p>
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238-246.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        function trapezoidalIntegration "Integration using the trapezoidal rule"
          extends Modelica.Icons.Function;
          input Integer N "Number of integrand points";
          input Real[:] f "Integrands";
          input Real deltaX "Width of interval for Trapezoidal integration";
          output Real result "Result";
        algorithm
          assert(N >= 2, "N must be no less than 2.");
          result := 0;
          for i in 1:N loop
            result := result + f[i];
          end for;

          result := 2*result;
          result := result - f[1] - f[N];
          result := result*deltaX/2;
          annotation (Documentation(info="<html>
<p>
This function computes a definite integral using the trapezoidal rule.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 23, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end trapezoidalIntegration;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           input Real der_2_x;
           output Real der_2_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_2_y := n*(abs(x)^(n-1)*sign(x)*der_2_x
                        + (n-1)*abs(x)^(n-2)*der_x^2);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;

             der_2_y := (12*a1*x2+2*a3)*der_x^2
                        +x * ( 4 * a1 * x2 + 2 * a3)*der_2_x;
            end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the second derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_regNonZeroPower;

          function der_2_smoothTransition
            "Second order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            input Real x_der2 "Second order derivative of x";
            output Real y_der2 "Second order derivative of function value";
        protected
            Real aX "Absolute value of x";
            Real ex "Intermediate expression";
          algorithm
           aX:= abs(x);
           ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
           y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                   + x_der*x_der*( if x > 0 then ex else -ex);

          annotation (
          Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_smoothTransition;

          function der_inverseXRegularized "Derivative of inverseXRegularised function"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
           input Real deltaInv = 1/delta "Inverse value of delta";

           input Real a = -15*deltaInv "Polynomial coefficient";
           input Real b = 119*deltaInv^2 "Polynomial coefficient";
           input Real c = -361*deltaInv^3 "Polynomial coefficient";
           input Real d = 534*deltaInv^4 "Polynomial coefficient";
           input Real e = -380*deltaInv^5 "Polynomial coefficient";
           input Real f = 104*deltaInv^6 "Polynomial coefficient";

           input Real x_der "Abscissa value";
           output Real y_der "Function value";

          algorithm
            y_der :=if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else
              Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                 x=x,
                 x_der=x_der,
                 delta=delta,
                 deltaInv=deltaInv,
                 a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_inverseXRegularized;

          function der_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1)*der_x;
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3) * der_x;
            end if;
           annotation(derivative(order=2, zeroDerivative=n, zeroDerivative=delta)=der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_smoothTransition
            "First order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            output Real y_der "Derivative of function value";

        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
           annotation(smoothOrder=1,
                    derivative(order=2,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
          Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_smoothTransition;

          function der_spliceFunction "Derivative of splice function"
            extends Modelica.Icons.Function;
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
              constant Real asin1 = Modelica.Math.asin(1);
          algorithm
              scaledX1 := x/deltax;
              if scaledX1 <= -0.99999999999 then
                out := dneg;
              elseif scaledX1 >= 0.9999999999 then
                out := dpos;
              else
                scaledX := scaledX1*asin1;
                dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
                out := dpos*y + (1 - y)*dneg;
                out := out + (pos - neg)*dscaledX1*asin1/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;

          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;

          function smoothTransition
            "Twice continuously differentiable transition between the regions"
            extends Modelica.Icons.Function;

            // The function that transitions between the regions is implemented
            // using its own function. This allows Dymola 2016 to inline the function
            // inverseXRegularized.

          input Real x "Abscissa value";
          input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
          input Real deltaInv = 1/delta "Inverse value of delta";

          input Real a = -15*deltaInv "Polynomial coefficient";
          input Real b = 119*deltaInv^2 "Polynomial coefficient";
          input Real c = -361*deltaInv^3 "Polynomial coefficient";
          input Real d = 534*deltaInv^4 "Polynomial coefficient";
          input Real e = -380*deltaInv^5 "Polynomial coefficient";
          input Real f = 104*deltaInv^6 "Polynomial coefficient";
          output Real y "Function value";
        protected
            Real aX "Absolute value of x";

          algorithm
           aX:= abs(x);
           y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
          annotation(smoothOrder=2,
            derivative(order=1,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
              Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.inverseXRegularized\">
Buildings.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
Buildings.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end smoothTransition;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Math.Functions\">Buildings.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://Buildings.Utilities.Math\">
Buildings.Utilities.Math</a>.
</p>
</html>"));
      end Functions;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      package Constants "Library of constants for psychometric functions"
        extends Modelica.Icons.Package;

        constant Modelica.SIunits.Temperature T_ref = 273.15
          "Reference temperature for psychrometric calculations";

        constant Modelica.SIunits.SpecificHeatCapacity cpAir=1006
          "Specific heat capacity of air";

        constant Modelica.SIunits.SpecificHeatCapacity cpSte=1860
          "Specific heat capacity of water vapor";

        constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq = 4184
          "Specific heat capacity of liquid water";

        constant Modelica.SIunits.SpecificEnthalpy h_fg = 2501014.5
          "Enthalpy of evaporation of water at the reference temperature";

        constant Real k_mair = 0.6219647130774989 "Ratio of molar weights";
        annotation (
          Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Added reference temperature.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier)}));
      end Constants;

      block Phi_pTX
        "Block to compute the relative humidity for given pressure, dry bulb temperature and moisture mass fraction"
         extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealInput T(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));
        Modelica.Blocks.Interfaces.RealInput X_w(
          final unit="1",
          min=0) "Water vapor mass fraction per unit mass total air"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));

        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               displayUnit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealOutput phi(
          final unit="1") "Relative humidity"
          annotation (Placement(transformation(extent={{100,-10},{120,10}}),
              iconTransformation(extent={{100,-10},{120,10}})));

      equation
        phi = Buildings.Utilities.Psychrometrics.Functions.phi_pTX(
          p=p,
          T=T,
          X_w=X_w);

        annotation (
        defaultComponentName="phi",
          Documentation(info="<html>
<p>
Block to compute the relative humidity of air for given
pressure, temperature and water vapor mass fraction.
</p>
<p>
Note that the water vapor mass fraction must be in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 13, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                          graphics={
              Polygon(
                points={{-74,88},{-72,74},{-76,74},{-74,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-70,84},{-48,66}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Line(points={{-74,86},{-74,-72}}),
              Line(points={{-74,-46},{-60,-42},{-30,-30},{2,-2},{14,22},{22,54},{26,74}},
                          smooth=Smooth.Bezier),
              Line(points={{74,-72},{-74,-72}}),
              Polygon(
                points={{78,-72},{68,-70},{68,-74},{78,-72}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{76,-80},{86,-96}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{-74,-62},{-12,-46},{28,-16},{52,12}},
                color={255,0,0},
                smooth=Smooth.Bezier),
              Text(
                extent={{34,-10},{56,-28}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="phi")}));
      end Phi_pTX;

      block TDewPoi_pW
        "Model to compute the dew point temperature for given water vapor pressure of moist air"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput p_w(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa")
          "Water vapor partial pressure"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
        Modelica.Blocks.Interfaces.RealOutput T(start=278.15,
                                               final quantity="ThermodynamicTemperature",
                                               final unit="K",
                                               min = 0,
                                               displayUnit="degC")
          "Dew point temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
       p_w = Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi(T=T);
          annotation (
          defaultComponentName="dewPoi",
          Documentation(info="<html>
<p>
Dew point temperature calculation for moist air above freezing temperature.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between
<i>0</i>&deg;C and <i>200</i>&deg;C. It is the correlation from 2005
ASHRAE Handbook, p. 6.2. In an earlier version of this model, the equation from
Peppers has been used, but this equation yielded about <i>15</i> Kelvin lower dew point
temperatures.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 4, 2008 by Michael Wetter:<br/>
Changed from causal to acausal ports, needed, for example, for
<a href=\"modelica://Buildings.Fluid.Examples.MixingVolumeMoistAir\">
Buildings.Fluid.Examples.MixingVolumeMoistAir</a>.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-124,50},{-86,4}},
                lineColor={0,0,255},
                textString="p_w"),
              Text(
                extent={{102,46},{140,0}},
                lineColor={0,0,255},
                textString="TDP"),
              Line(points={{-68,86},{-68,-72}}),
              Line(points={{82,-72},{-66,-72}}),
              Line(points={{-68,-46},{-54,-42},{-24,-30},{8,-2},{20,22},{28,54},{32,
                    74}}),
              Line(
                points={{42,-32},{-28,-32}},
                color={255,0,0},
                thickness=0.5),
              Polygon(
                points={{-28,-32},{-14,-30},{-14,-34},{-28,-32}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{84,-72},{74,-70},{74,-74},{84,-72}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-68,88},{-66,74},{-70,74},{-68,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-64,84},{-42,66}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Text(
                extent={{82,-80},{92,-96}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(points={{68,-44},{-62,-44}}, color={175,175,175}),
              Line(points={{68,-18},{-10,-18}}, color={175,175,175}),
              Line(points={{70,6},{12,6}}, color={175,175,175}),
              Line(points={{68,32},{22,32}}, color={175,175,175})}));
      end TDewPoi_pW;

      block TWetBul_TDryBulPhi
        "Model to compute the wet bulb temperature based on relative humidity"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"
          annotation (choicesAllMatching = true);

        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=Medium.T_default,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));

        Modelica.Blocks.Interfaces.RealInput phi(min=0, max=1)
          "Relative air humidity"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));

        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));

        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=Medium.T_default-2,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

    protected
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.SIunits.MassFraction XiDryBul
          "Water vapor mass fraction at dry bulb state";
        Modelica.SIunits.MassFraction XiSat "Water vapor mass fraction at saturation";
        Modelica.SIunits.MassFraction XiSatRefIn
          "Water vapor mass fraction at saturation, referenced to inlet mass flow rate";

      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100*phi;
          TWetBul      = 273.15 + TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + Modelica.Math.atan(TDryBul_degC + rh_per)
             - Modelica.Math.atan(rh_per-1.676331)
             + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;
          XiSat    = 0;
          XiDryBul = 0;
          XiSatRefIn=0;
        else
          XiSatRefIn=(1-XiDryBul)*XiSat/(1-XiSat);
          XiSat  = Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat = Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p =    p,
            phi =  1);
          XiDryBul =Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            p =    p,
            pSat = Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TDryBul),
            phi =  phi);
          (TWetBul-Buildings.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * Buildings.Utilities.Psychrometrics.Constants.cpAir +
                    XiSatRefIn * Buildings.Utilities.Psychrometrics.Constants.cpSte +
                    (XiDryBul-XiSatRefIn) * Buildings.Utilities.Psychrometrics.Constants.cpWatLiq)
          =
          (TDryBul-Buildings.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * Buildings.Utilities.Psychrometrics.Constants.cpAir +
                    XiDryBul * Buildings.Utilities.Psychrometrics.Constants.cpSte)  +
          (XiDryBul-XiSatRefIn) * Buildings.Utilities.Psychrometrics.Constants.h_fg;

          TDryBul_degC = 0;
          rh_per       = 0;
        end if;

      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-92,100},{-62,56}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-92,14},{-72,-12}},
                lineColor={0,0,127},
                textString="phi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                lineColor={0,0,127},
                textString="TWetBul"),
              Line(points={{78,-74},{-48,-74}}),
              Text(
                extent={{76,-78},{86,-94}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{76,-46},{26,-4}},
                color={255,0,0},
                thickness=0.5),
              Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(points={{-48,84},{-48,-74}}),
              Text(
                extent={{-44,82},{-22,64}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Polygon(
                points={{86,-74},{76,-72},{76,-76},{86,-74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,88},{-46,74},{-50,74},{-48,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
Otherwise a calculation based on an energy balance is used.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a> for a discussion.
The model is validated in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi\">
Buildings.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi</a>.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulPhi;

      block X_pTphi
        "Return steam mass fraction as a function of relative humidity phi and temperature T"
        extends
        Buildings.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;

        package Medium = Buildings.Media.Air "Medium model";
        Modelica.Blocks.Interfaces.RealInput T(final unit="K",
                                                 displayUnit="degC",
                                                 min = 0) "Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput phi(min = 0, max=1)
          "Relative humidity (0...1)"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput X[Medium.nX](each min=0, each max=1)
          "Steam mass fraction"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
        parameter Integer i_w=
         sum({(
           if Modelica.Utilities.Strings.isEqual(
             string1=Medium.substanceNames[i],
             string2="Water",
             caseSensitive=false)
           then i else 0)
           for i in 1:Medium.nX});
        parameter Integer i_nw = if i_w == 1 then 2 else 1 "Index for non-water substance";
        parameter Boolean found = i_w > 0 "Flag, used for error checking";

      initial equation
        assert(Medium.nX==2, "The implementation is only valid if Medium.nX=2.");
        assert(found, "Did not find medium species 'water' in the medium model. Change medium model.");

      equation
        pSat =  Buildings.Media.Air.saturationPressure(T);
        X[i_w] =  Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
           pSat=pSat,
           p=p_in_internal,
           phi=phi);
        //sum(X[:]) = 1; // The formulation with a sum in an equation section leads to a nonlinear equation system
        X[i_nw] =  1 - X[i_w];
        annotation (Documentation(info="<html>
<p>
Block to compute the water vapor concentration based on
pressure, temperature and relative humidity.
</p>
<p>
If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>November 3, 2017 by Filip Jorissen:<br/>
Converted (initial) algorithm section into (initial) equation section.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/847\">#847</a>.
</li>
<li>July 24, 2014 by Michael Wetter:<br/>
Added <code>assert</code> to verify that <code>Medium.nX==2</code>
as the implementation is only valid for such media.
</li>
<li>April 26, 2013 by Michael Wetter:<br/>
Set the medium model to <code>Buildings.Media.Air</code>.
This was required to allow a pedantic model check in Dymola 2014.
</li>
<li>August 21, 2012 by Michael Wetter:<br/>
Added function call to compute water vapor content.
</li>
<li>
February 22, 2010 by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>MassFraction_pTphi</code> to <code>X_pTphi</code>
</li>
<li>
February 4, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-96,16},{-54,-22}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-86,-18},{-36,-100}},
                lineColor={0,0,0},
                textString="phi"),
              Text(
                extent={{26,56},{90,-54}},
                lineColor={0,0,0},
                textString="X_steam")}));
      end X_pTphi;

      model hSat_pTSat
        "Calculate saturation enthalpy given a saturation (dry bulb) temperature"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealInput p(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar") = 101325
          "Pressure of the fluid"
          annotation (Placement(transformation(extent={{-120,30},{-100,50}}),
              iconTransformation(extent={{-120,30},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput TSat(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min = 0.0,
          start = 288.15,
          nominal = 300,
          displayUnit="degC")
          "Saturation temperature of the fluid"
          annotation (Placement(transformation(extent={{-120,-50},{-100,-30}}),
              iconTransformation(extent={{-120,-50},{-100,-30}})));

        Modelica.Blocks.Interfaces.RealOutput hSat(
          final quantity="SpecificEnergy",
          final unit="J/kg")
          "Dew point temperature of air"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

    protected
        constant Integer watIdx = 1 "Index of water";
        constant Integer othIdx = 2 "Index of other species";
        constant Real phiSat(min=0, max=1) = 1 "Saturation relative humidity";
        Modelica.SIunits.AbsolutePressure pSat
          "Saturation pressure of water vapor in air at TSat";
        Real XSat[2]
          "Mass fractions of water and air in moist air at saturation";

      equation
        pSat = Buildings.Utilities.Psychrometrics.Functions.saturationPressure(TSat);
        XSat[watIdx] = Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
          pSat=pSat, p=p, phi=phiSat);
        XSat[othIdx] = 1 - XSat[watIdx];
        hSat = Buildings.Media.Air.specificEnthalpy_pTX(p=p, T=TSat, X=XSat);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          Documentation(revisions="<html>
<ul>
<li>
March 17, 2017, by Michael O'Keefe:<br/>
First implementation. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/622\">
issue 622</a> for more information.
</li>
</ul>
</html>",       info="<html>
<p>
Block to compute the enthalpy of saturated
air given the saturation temperature and fluid pressure.
</p>
</html>"));
      end hSat_pTSat;

      block pW_X "Water vapor pressure for given humidity ratio"
        extends
        Buildings.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;
        Modelica.Blocks.Interfaces.RealInput X_w(min=0, max=0.99999, nominal=0.1)
          "Water concentration at dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}}), iconTransformation(extent={{-120,-10},{-100,10}})));
        Modelica.Blocks.Interfaces.RealOutput p_w(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa",
                                                 min = 0) "Water vapor pressure"
          annotation (Placement(transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,10}})));

        output Modelica.SIunits.MassFraction x_w(min=0, max=1, nominal=0.1, start=0.001)
          "Water mass fraction per mass of dry air";

      equation
        p_w = Buildings.Utilities.Psychrometrics.Functions.pW_X(X_w=X_w, p=p_in_internal);
        x_w = X_w/(1-X_w);
        annotation (
          defaultComponentName="pWat",
          Documentation(info="<html>
<p>
Block to compute the water vapor partial pressure for a given humidity ratio.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>VaporPressure_X</code> to <code>pW_X</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br/>
Converted model to block because <code>RealInput</code> are obsolete in Modelica 3.0.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Text(
                extent={{-88,26},{-60,-26}},
                lineColor={0,0,0},
                textString="X"), Text(
                extent={{46,30},{90,-32}},
                lineColor={0,0,0},
                textString="pW")}));
      end pW_X;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        function X_pSatpphi "Humidity ratio for given water vapor pressure"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
          input Modelica.SIunits.Pressure p "Pressure of the fluid";
          input Real phi(min=0, max=1) "Relative humidity";
          output Modelica.SIunits.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Water vapor concentration per total mass of air";

      protected
          constant Real k = 0.621964713077499 "Ratio of molar masses";
        algorithm
          X_w := phi*k/(k*phi+p/pSat-phi);

          annotation (
            smoothOrder=99,
            Inline=true,
            Documentation(info="<html>
<p>
Function to compute the water vapor concentration based on
saturation pressure, absolute pressure and relative humidity.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 21, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pSatpphi;

        function X_pTphi
          "Absolute humidity for given pressure, dry bulb temperature and relative humidity"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Pressure p "Absolute pressure of the medium";
          input Modelica.SIunits.Temperature T "Dry bulb temperature";
          input Real phi(unit="1") "Relative humidity";
          output Modelica.SIunits.MassFraction X_w
            "Water vapor mass fraction per unit mass total air";

        algorithm
          X_w:=phi/((p/saturationPressure(T)-phi) / Buildings.Utilities.Psychrometrics.Constants.k_mair + phi);
          annotation (
            inverse(phi=phi_pTX(p,T,X_w)),
            smoothOrder=1,
            Documentation(info="<html>
<p>
Absolute humidity of air for given
pressure, temperature and relative humidity.
</p>
<p>
Note that the absolute humidity is in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2019 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pTphi;

        function pW_TDewPoi
          "Function to compute the water vapor partial pressure for a given dew point temperature of moist air"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T(min=100) "Dew point temperature";
          output Modelica.SIunits.Pressure p_w(displayUnit="Pa", min=100)
            "Water vapor partial pressure";
      protected
          constant Real C8=-5.800226E3;
          constant Real C9=1.3914993E0;
          constant Real C10=-4.8640239E-2;
          constant Real C11=4.1764768E-5;
          constant Real C12=-1.4452093E-8;
          constant Real C13=6.5459673E0;

        algorithm
          p_w := Modelica.Math.exp(C8/T + C9 + T*(C10 + T*(C11 + T*C12)) + C13*
            Modelica.Math.log(T));
          annotation (
            Documentation(info="<html>
<p>
Dew point temperature calculation for moist air above freezing temperature.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between
<i>0</i>&deg;C and <i>200</i>&deg;C. It is the correlation from 2005
ASHRAE Handbook, p. 6.2. In an earlier version of this model, the equation from
Peppers has been used, but this equation yielded about <i>15</i> Kelvin lower dew point
temperatures.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 9, 2012 by Michael Wetter:<br/>
Added <code>smoothOrder=99</code> and <code>displayUnit</code> for pressure.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed function from <code>dewPointTemperature</code> to <code>pW_TDewPoi</code>.
</li>
<li>
February 6, 2010 by Michael Wetter:<br/>
Fixed derivative implementation.
</li>
<li>
September 4, 2008 by Michael Wetter:<br/>
Changed from causal to acausal ports, needed, for example, for
<a href=\"modelica://Buildings.Fluid.Examples.MixingVolumeMoistAir\">
Buildings.Fluid.Examples.MixingVolumeMoistAir</a>.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Inline=true,
            smoothOrder=99,
            derivative=BaseClasses.der_pW_TDewPoi);
        end pW_TDewPoi;

        function pW_X "Water vapor pressure for given humidity ratio"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.MassFraction X_w(
            min=0,
            max=0.99999,
            nominal=0.01) "Species concentration at dry bulb temperature";
          input Modelica.SIunits.Pressure p=101325 "Total pressure";
          output Modelica.SIunits.Pressure p_w(displayUnit="Pa") "Water vapor pressure";

      protected
          Modelica.SIunits.MassFraction x_w(nominal=0.01)
            "Water mass fraction per mass of dry air";
        algorithm
          x_w := X_w/(1 - X_w);
          p_w := p*x_w/(0.62198 + x_w);
          annotation (
            Inline=true,
            smoothOrder=99,
            derivative=BaseClasses.der_pW_X,
            Documentation(info="<html>
<p>
Function to compute the water vapor partial pressure for a given humidity ratio.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 9, 2012 by Michael Wetter:<br/>
Added <code>smoothOrder=99</code> and <code>displayUnit</code> for pressure.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>VaporPressure_X</code> to <code>pW_X</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br/>
Converted model to block because <code>RealInput</code> are obsolete in Modelica 3.0.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end pW_X;

        function phi_pTX
          "Relative humidity for given pressure, dry bulb temperature and moisture mass fraction"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Pressure p "Absolute pressure of the medium";
          input Modelica.SIunits.Temperature T "Dry bulb temperature";
          input Modelica.SIunits.MassFraction X_w
            "Water vapor mass fraction per unit mass total air";
          output Real phi(unit="1") "Relative humidity";
        algorithm
          phi :=p/saturationPressure(T)*X_w/(X_w +
            Buildings.Utilities.Psychrometrics.Constants.k_mair*(1-X_w));
          annotation (
            inverse(X_w=X_pTphi(p,T,phi)),
            smoothOrder=1,
            Documentation(info="<html>
<p>
Relative humidity of air for given
pressure, temperature and water vapor mass fraction.
</p>
<p>
Note that the water vapor mass fraction must be in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2019 by Filip Jorissen:<br/>
Added inverse annotation
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1110\">#1110</a>.
</li>
<li>
November 17, 2014 by Michael Wetter:<br/>
Removed test that constrains the saturation pressure to be
lower than <code>p</code>.
I do not see any numerical problems without this test.
</li>
<li>
November 13, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end phi_pTX;

        function saturationPressure
          "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                                  displayUnit="Pa",
                                                  nominal=1000) "Saturation pressure";

        algorithm
          pSat := Buildings.Utilities.Math.Functions.regStep(
                     y1=Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TSat),
                     y2=Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce(TSat),
                     x=TSat-273.16,
                     x_small=1.0);
          annotation(Inline=true,
            smoothOrder=1,
            Documentation(info="<html>
<p>
Saturation pressure of water, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
August 19, 2015 by Michael Wetter:<br/>
Changed <code>smoothOrder</code> from <i>5</i> to <i>1</i> as
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a> is only once
continuously differentiable.
Inlined the function.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressure;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
        algorithm
          pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));

          annotation (
            smoothOrder=99,
            derivative=Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
            Inline=true,
            Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressureLiquid;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
      protected
          Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
          Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
          Real r1=TSat/TTriple "Common subexpression";
          Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[2]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          pSat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_sublimationPressureIce,
            Documentation(info="<html>
<p>
Sublimation pressure of water below the triple point temperature, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>273.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end sublimationPressureIce;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_pW_TDewPoi "Derivative of function pW_TDewPoi"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Temperature T "Dew point temperature";
            input Real dT "Temperature differential";
            output Real dp_w "Differential of water vapor partial pressure";
        protected
            constant Real C8=-5.800226E3;
            constant Real C9=1.3914993E0;
            constant Real C10=-4.8640239E-2;
            constant Real C11=4.1764768E-5;
            constant Real C12=-1.4452093E-8;
            constant Real C13=6.5459673E0;
          algorithm
            dp_w := Modelica.Math.exp(C8/T + C9 + T*(C10 + T*(C11 + T*C12)) + C13*
              Modelica.Math.log(T))*(-C8/T/T + C10 + 2*C11*T + 3*C12*T*T + C13/T)*dT;
            annotation (
              Documentation(info="<html>
<p>
Derivative of dew point temperature calculation for moist air above freezing temperature.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 15, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_pW_TDewPoi;

          function der_pW_X "Derivative of function pW_X"
            extends Modelica.Icons.Function;

            input Modelica.SIunits.MassFraction X_w(
              min=0,
              max=1,
              nominal=0.01) "Species concentration at dry bulb temperature";
            input Modelica.SIunits.Pressure p=101325 "Total pressure";

            input Real dX_w
              "Differential of species concentration at dry bulb temperature";
            input Real dp "Differential of total pressure";

            output Real dp_w "Differential of water vapor pressure";

        protected
            Modelica.SIunits.MassFraction x_w(nominal=0.01)
              "Water mass fraction per mass of dry air";
            Real dX_w_dX "Differential d (x_w) / d X_w";
          algorithm
            x_w := X_w/(1 - X_w);
            dX_w_dX := 1/(1-X_w)^2;
            dp_w := p * 0.62198 / (0.62198 + x_w)^2 * dX_w_dX * dX_w + x_w/(0.62198 + x_w) * dp;

            annotation (
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.pW_X\">
Buildings.Utilities.Psychrometrics.Functions.pW_X</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_pW_X;

          function der_saturationPressureLiquid
            "Derivative of the function saturationPressureLiquid"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Temperature TSat "Saturation temperature";
            input Real dTSat(unit="K/s") "Saturation temperature derivative";
            output Real psat_der(unit="Pa/s") "Differential of saturation pressure";

          algorithm
            psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                      /(TSat - 35.719))*4102.99*dTSat/(TSat - 35.719)^2;

            annotation(Inline=false,
              smoothOrder=98,
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Corrected name of argument to comply with derivative specification.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1393\">#1393</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
          end der_saturationPressureLiquid;

          function der_sublimationPressureIce
            "Derivative of function sublimationPressureIce"
              extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                      nominal=300)
              "Saturation temperature";
              input Real dTSat(unit="K/s") "Sublimation temperature derivative";
              output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
        protected
              Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
              Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
              Real r1=TSat/TTriple "Common subexpression 1";
              Real r1_der=dTSat/TTriple "Derivative of common subexpression 1";
              Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
              Real n[2]={-1.5,-1.25} "Coefficients n[:]";
          algorithm
              psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple*(-(a[1]
                *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
              annotation (
                Inline=false,
                smoothOrder=5,
                Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce\">
Buildings.Utilities.Psychrometrics.Functions.sublimationPressureIce</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Change name of argument <code>dTsat</code> to <code>dTSat</code> for consistency
with
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid\">
Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
          end der_sublimationPressureIce;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions\">Buildings.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for Buildings.Utilities.Psychrometrics"
        extends Modelica.Icons.BasesPackage;

        partial block HumidityRatioVaporPressure
          "Humidity ratio for given water vapor pressure"
          extends Modelica.Blocks.Icons.Block;
          parameter Boolean use_p_in = true "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true);

          parameter Modelica.SIunits.Pressure p = 101325 "Fixed value of pressure"
            annotation (Dialog(enable = not use_p_in));
          Modelica.Blocks.Interfaces.RealInput p_in(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa",
                                                 min = 0) if  use_p_in
            "Atmospheric Pressure"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

      protected
          Modelica.Blocks.Interfaces.RealInput p_in_internal
            "Needed to connect to conditional connector";
        equation
          connect(p_in, p_in_internal);
          if not use_p_in then
            p_in_internal = p;
          end if;
          annotation (
            Documentation(info="<html>
<p>
Partial Block to compute the relation between humidity ratio and water vapor partial pressure.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-96,96},{96,-96}},
                  fillPattern=FillPattern.Sphere,
                  pattern=LinePattern.None,
                  lineColor={255,255,255},
                  fillColor={170,213,255}),
                Text(
                  visible=use_p_in,
                  extent={{-90,108},{-34,16}},
                  lineColor={0,0,0},
                  textString="p_in")}));
        end HumidityRatioVaporPressure;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics\">Buildings.Utilities.Psychrometrics</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</p>
</html>"));
    end Psychrometrics;

    package Time "Package with models for time"
      extends Modelica.Icons.Package;

      block ModelTime "Model time"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealOutput y "Model time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = time;

        annotation (
          defaultComponentName="modTim",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(points={{0,80},{0,60}}, color={160,160,164}),
              Line(points={{80,0},{60,0}}, color={160,160,164}),
              Line(points={{0,-80},{0,-60}}, color={160,160,164}),
              Line(points={{-80,0},{-60,0}}, color={160,160,164}),
              Line(points={{37,70},{26,50}}, color={160,160,164}),
              Line(points={{70,38},{49,26}}, color={160,160,164}),
              Line(points={{71,-37},{52,-27}}, color={160,160,164}),
              Line(points={{39,-70},{29,-51}}, color={160,160,164}),
              Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
              Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
              Line(points={{-71,37},{-54,28}}, color={160,160,164}),
              Line(points={{-38,70},{-28,51}}, color={160,160,164}),
              Line(
                points={{0,0},{-50,50}},
                thickness=0.5),
              Line(
                points={{0,0},{40,0}},
                thickness=0.5)}),
          Documentation(info="<html>
<p>
This component outputs the model time, which starts at the value at which the simulation starts.
For example, if a simulation starts at <i>t=-1</i>, then this block outputs first <i>t=-1</i>,
and its output is advanced at the same rate as the simulation time.
</p>
<p>
The model is used to allow the simulation to start from any time without having to set
the parameters for the clock, as would be necessary for the model
<a href=\"modelica://Modelica.Blocks.Sources.Clock\">Modelica.Blocks.Sources.Clock</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 17, 2020, by Michael Wetter:<br/>
Refactored so that the output connector has a better comment string, because
this comment string is displayed on the weather data bus.
</li>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>Buildings.Utilities.SimulationTime</code>
to
<code>Buildings.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ModelTime;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for time.
</p>
</html>"),
      Icon(graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              thickness=0.5)}));
    end Time;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;

  package Types "Package with type definitions"
    extends Modelica.Icons.TypesPackage;

    package Azimuth "List of possible constant values for surface azimuth"
       extends Modelica.Icons.TypesPackage;

       constant Modelica.SIunits.Angle S = 0
      "Azimuth for an exterior wall whose outer surface faces south";

       constant Modelica.SIunits.Angle W = +Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces west";

       constant Modelica.SIunits.Angle N = Modelica.Constants.pi
      "Azimuth for an exterior wall whose outer surface faces north";

       constant Modelica.SIunits.Angle E = -Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces east";
    annotation(preferredView="info",
    Documentation(info="<html>
<p>
Collection of constant values to define the azimuth of a surface.
For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use
<code>Buildings.Types.Azimuth.S</code>.
</p>
<p>
See also
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">
Buildings.BoundaryConditions.UsersGuide</a>
for explanations of the azimuth.
</p>
</html>",
    revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Azimuth;

    package Tilt "List of possible constant values for surface tilt"
      extends Modelica.Icons.TypesPackage;

      constant Modelica.SIunits.Angle Floor =   Modelica.Constants.pi
      "Tilt for floor";

      constant Modelica.SIunits.Angle Wall =    Modelica.Constants.pi/2
      "Tilt for wall";
    annotation(preferredView="info", Documentation(info="<html>
<p>
Possible constant values to define the tilt of a surface.
For example, for a construction that is a floor, use
<code>Buildings.Types.Tilt.Floor</code>.
</p>
<p>
Note that a ceiling has a tilt of <i>0</i>
, and also the solar collector models
in
<a href=\"Buildings.Fluid.SolarCollectors\">Buildings.Fluid.SolarCollectors</a>
require a tilt of <i>0</i>
if they are facing straight upwards.
This is correct because
the solar irradiation on a ceiling construction is on the other-side surface,
which faces upwards toward the sky. Hence, a construction is considered
a ceiling from the view point of a person standing inside a room.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Tilt;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  end Types;

  package Examples
  "Collection of models that illustrate model use and test models"
    extends Modelica.Icons.ExamplesPackage;

    package VAVReheat
    "Variable air volume flow system with terminal reheat and five thermal zones"
      extends Modelica.Icons.ExamplesPackage;

      package Controls "Package with controller models"
          extends Modelica.Icons.VariantsPackage;

        model SystemHysteresis
          "Block that applies hysteresis and a minimum on timer to a control signal"

          Buildings.Controls.OBC.CDL.Interfaces.RealInput u "Control signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput y "Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}}),
                iconTransformation(extent={{100,-20},{140,20}})));
          Buildings.Controls.OBC.CDL.Interfaces.RealOutput yPum
            "Control signal for pump" annotation (Placement(transformation(extent={{100,
                    -90},{140,-50}}), iconTransformation(extent={{100,-90},{140,-50}})));

          Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr(
            t=0.1,
            h=0.09)
            "Threshold to switch on system"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          Buildings.Controls.OBC.CDL.Logical.Switch swi "Switch for control signal"
            annotation (Placement(transformation(extent={{60,-10},{80,10}})));
          Buildings.Controls.OBC.CDL.Continuous.Sources.Constant con(final k=0)
            "Zero output signal"
            annotation (Placement(transformation(extent={{0,-40},{20,-20}})));

          Buildings.Controls.OBC.CDL.Conversions.BooleanToReal booToRea
            "Switch for pump control signal"
            annotation (Placement(transformation(extent={{60,-80},{80,-60}})));
          Buildings.Controls.OBC.CDL.Logical.TrueFalseHold truFalHol1(
            trueHoldDuration(displayUnit="h") = 14400,
            final falseHoldDuration=0)
                "Keep pump running at least for trueHoldDuration"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
        equation
          connect(greThr.u, u)
            annotation (Line(points={{-62,0},{-120,0}}, color={0,0,127}));
          connect(swi.y, y) annotation (Line(points={{82,0},{98,0},{98,0},{120,0}},
                                                                      color={0,0,127}));
          connect(swi.u1, u) annotation (Line(points={{58,8},{20,8},{20,20},{-80,20},{-80,
                  0},{-120,0}}, color={0,0,127}));
          connect(con.y, swi.u3) annotation (Line(points={{22,-30},{52,-30},{52,-8},{58,
                  -8}}, color={0,0,127}));
          connect(booToRea.y, yPum) annotation (Line(points={{82,-70},{80,-70},{80,-70},
                  {120,-70}}, color={0,0,127}));
          connect(greThr.y, truFalHol1.u) annotation (Line(points={{-38,0},{-22,0}},
                                 color={255,0,255}));
          connect(truFalHol1.y, swi.u2)
            annotation (Line(points={{2,0},{58,0}}, color={255,0,255}));
          connect(truFalHol1.y, booToRea.u) annotation (Line(points={{2,0},{40,0},{40,
                  -70},{58,-70}}, color={255,0,255}));
          annotation (
            defaultComponentName="sysHys",
            Diagram(coordinateSystem(extent={{-100,-100},{100,100}})),
            Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={
                Text(
                  extent={{-48,154},{42,100}},
                  lineColor={0,0,255},
                  textString="%name"),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235},
                    if truFalHol.y then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillColor=DynamicSelect({235,235,235},
                    if truFalHol.y then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-83,7},{-69,-7}},
                  lineColor=DynamicSelect({235,235,235},
                    if truFalHol.u then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillColor=DynamicSelect({235,235,235},
                    if truFalHol.u then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-32,30},{38,-18}},
                  lineColor={0,0,0},
                  textString="y = %y")}),
            Documentation(info="<html>
<p>
Block that ensure that the system runs for a minimum time once it is switched on.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2021, by Michael Wetter:<br/>
First version.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2594\">issue #2594</a>.
</li>
</ul>
</html>"));
        end SystemHysteresis;
      end Controls;

      package BaseClasses
      "Package with base classes for Buildings.Examples.VAVReheat"
      extends Modelica.Icons.BasesPackage;

        model Floor "Model of a floor of the building"
          extends Buildings.Examples.VAVReheat.BaseClasses.PartialFloor(
            final VRooCor=cor.AFlo * hRoo,
            final VRooSou=sou.AFlo * hRoo,
            final VRooNor=nor.AFlo * hRoo,
            final VRooEas=eas.AFlo * hRoo,
            final VRooWes=wes.AFlo * hRoo,
            AFloCor = 2698/hRoo,
            AFloSou = 568.77/hRoo,
            AFloNor = 568.77/hRoo,
            AFloEas = 360.0785/hRoo,
            AFloWes = 360.0785/hRoo);

          parameter HeatTransfer.Types.InteriorConvection intConMod=Buildings.HeatTransfer.Types.InteriorConvection.Temperature
            "Convective heat transfer model for room-facing surfaces of opaque constructions";
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Real winWalRat(
            min=0.01,
            max=0.99) = 0.33 "Window to wall ratio for exterior walls";
          parameter Modelica.SIunits.Length hWin = 1.5 "Height of windows";
          parameter HeatTransfer.Data.Solids.Plywood matFur(x=0.15, nStaRef=5)
            "Material for furniture"
            annotation (Placement(transformation(extent={{140,460},{160,480}})));
          parameter HeatTransfer.Data.Resistances.Carpet matCar "Carpet"
            annotation (Placement(transformation(extent={{180,460},{200,480}})));
          parameter HeatTransfer.Data.Solids.Concrete matCon(
            x=0.1,
            k=1.311,
            c=836,
            nStaRef=5) "Concrete"
            annotation (Placement(transformation(extent={{140,430},{160,450}})));
          parameter HeatTransfer.Data.Solids.Plywood matWoo(
            x=0.01,
            k=0.11,
            d=544,
            nStaRef=1) "Wood for exterior construction"
            annotation (Placement(transformation(extent={{140,400},{160,420}})));
          parameter HeatTransfer.Data.Solids.Generic matIns(
            x=0.087,
            k=0.049,
            c=836.8,
            d=265,
            nStaRef=5) "Steelframe construction with insulation"
            annotation (Placement(transformation(extent={{180,400},{200,420}})));
          parameter HeatTransfer.Data.Solids.GypsumBoard matGyp(
            x=0.0127,
            k=0.16,
            c=830,
            d=784,
            nStaRef=2) "Gypsum board"
            annotation (Placement(transformation(extent={{138,372},{158,392}})));
          parameter HeatTransfer.Data.Solids.GypsumBoard matGyp2(
            x=0.025,
            k=0.16,
            c=830,
            d=784,
            nStaRef=2) "Gypsum board"
            annotation (Placement(transformation(extent={{178,372},{198,392}})));
          parameter HeatTransfer.Data.OpaqueConstructions.Generic conExtWal(final nLay=3,
              material={matWoo,matIns,matGyp}) "Exterior construction"
            annotation (Placement(transformation(extent={{280,460},{300,480}})));
          parameter HeatTransfer.Data.OpaqueConstructions.Generic conIntWal(final nLay=1,
              material={matGyp2}) "Interior wall construction"
            annotation (Placement(transformation(extent={{320,460},{340,480}})));
          parameter HeatTransfer.Data.OpaqueConstructions.Generic conFlo(final nLay=1, material={
                matCon}) "Floor construction (opa_a is carpet)"
            annotation (Placement(transformation(extent={{280,420},{300,440}})));
          parameter HeatTransfer.Data.OpaqueConstructions.Generic conFur(final nLay=1, material={
                matFur}) "Construction for internal mass of furniture"
            annotation (Placement(transformation(extent={{320,420},{340,440}})));
          parameter HeatTransfer.Data.Solids.Plywood matCarTra(
            k=0.11,
            d=544,
            nStaRef=1,
            x=0.215/0.11) "Wood for floor"
            annotation (Placement(transformation(extent={{102,460},{122,480}})));
          parameter HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear glaSys(
            UFra=2,
            shade=Buildings.HeatTransfer.Data.Shades.Gray(),
            haveInteriorShade=false,
            haveExteriorShade=false) "Data record for the glazing system"
            annotation (Placement(transformation(extent={{240,460},{260,480}})));

          constant Modelica.SIunits.Height hRoo=2.74 "Room height";

          parameter Boolean sampleModel = false
            "Set to true to time-sample the model, which can give shorter simulation time if there is already time sampling in the system model"
            annotation (
              Evaluate=true,
              Dialog(tab="Experimental (may be changed in future releases)"));

          Buildings.ThermalZones.Detailed.MixedAir sou(
            redeclare package Medium = Medium,
            lat=lat,
            AFlo=AFloSou,
            hRoo=hRoo,
            nConExt=0,
            nConExtWin=1,
            datConExtWin(
              layers={conExtWal},
              A={49.91*hRoo},
              glaSys={glaSys},
              wWin={winWalRat/hWin*49.91*hRoo},
              each hWin=hWin,
              fFra={0.1},
              til={Buildings.Types.Tilt.Wall},
              azi={Buildings.Types.Azimuth.S}),
            nConPar=2,
            datConPar(
              layers={conFlo,conFur},
              A={AFloSou,414.68},
              til={Buildings.Types.Tilt.Floor,Buildings.Types.Tilt.Wall}),
            nConBou=3,
            datConBou(
              layers={conIntWal,conIntWal,conIntWal},
              A={6.47,40.76,6.47}*hRoo,
              til={Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall}),
            nSurBou=0,
            nPorts=5,
            intConMod=intConMod,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final sampleModel=sampleModel) "South zone"
            annotation (Placement(transformation(extent={{144,-44},{184,-4}})));
          Buildings.ThermalZones.Detailed.MixedAir eas(
            redeclare package Medium = Medium,
            lat=lat,
            AFlo=AFloEas,
            hRoo=hRoo,
            nConExt=0,
            nConExtWin=1,
            datConExtWin(
              layers={conExtWal},
              A={33.27*hRoo},
              glaSys={glaSys},
              wWin={winWalRat/hWin*33.27*hRoo},
              each hWin=hWin,
              fFra={0.1},
              til={Buildings.Types.Tilt.Wall},
              azi={Buildings.Types.Azimuth.E}),
            nConPar=2,
            datConPar(
              layers={conFlo,conFur},
              A={AFloEas,262.52},
              til={Buildings.Types.Tilt.Floor,Buildings.Types.Tilt.Wall}),
            nConBou=1,
            datConBou(
              layers={conIntWal},
              A={24.13}*hRoo,
              til={Buildings.Types.Tilt.Wall}),
            nSurBou=2,
            surBou(
              each A=6.47*hRoo,
              each absIR=0.9,
              each absSol=0.9,
              til={Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall}),
            nPorts=5,
            intConMod=intConMod,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final sampleModel=sampleModel) "East zone"
            annotation (Placement(transformation(extent={{304,56},{344,96}})));
          Buildings.ThermalZones.Detailed.MixedAir nor(
            redeclare package Medium = Medium,
            lat=lat,
            AFlo=AFloNor,
            hRoo=hRoo,
            nConExt=0,
            nConExtWin=1,
            datConExtWin(
              layers={conExtWal},
              A={49.91*hRoo},
              glaSys={glaSys},
              wWin={winWalRat/hWin*49.91*hRoo},
              each hWin=hWin,
              fFra={0.1},
              til={Buildings.Types.Tilt.Wall},
              azi={Buildings.Types.Azimuth.N}),
            nConPar=2,
            datConPar(
              layers={conFlo,conFur},
              A={AFloNor,414.68},
              til={Buildings.Types.Tilt.Floor,Buildings.Types.Tilt.Wall}),
            nConBou=3,
            datConBou(
              layers={conIntWal,conIntWal,conIntWal},
              A={6.47,40.76,6.47}*hRoo,
              til={Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall}),
            nSurBou=0,
            nPorts=5,
            intConMod=intConMod,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final sampleModel=sampleModel) "North zone"
            annotation (Placement(transformation(extent={{144,116},{184,156}})));
          Buildings.ThermalZones.Detailed.MixedAir wes(
            redeclare package Medium = Medium,
            lat=lat,
            AFlo=AFloWes,
            hRoo=hRoo,
            nConExt=0,
            nConExtWin=1,
            datConExtWin(
              layers={conExtWal},
              A={33.27*hRoo},
              glaSys={glaSys},
              wWin={winWalRat/hWin*33.27*hRoo},
              each hWin=hWin,
              fFra={0.1},
              til={Buildings.Types.Tilt.Wall},
              azi={Buildings.Types.Azimuth.W}),
            nConPar=2,
            datConPar(
              layers={conFlo,conFur},
              A={AFloWes,262.52},
              til={Buildings.Types.Tilt.Floor,Buildings.Types.Tilt.Wall}),
            nConBou=1,
            datConBou(
              layers={conIntWal},
              A={24.13}*hRoo,
              til={Buildings.Types.Tilt.Wall}),
            nSurBou=2,
            surBou(
              each A=6.47*hRoo,
              each absIR=0.9,
              each absSol=0.9,
              til={Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall}),
            nPorts=5,
            intConMod=intConMod,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final sampleModel=sampleModel) "West zone"
            annotation (Placement(transformation(extent={{12,36},{52,76}})));
          Buildings.ThermalZones.Detailed.MixedAir cor(
            redeclare package Medium = Medium,
            lat=lat,
            AFlo=AFloCor,
            hRoo=hRoo,
            nConExt=0,
            nConExtWin=0,
            nConPar=2,
            datConPar(
              layers={conFlo,conFur},
              A={AFloCor,1967.01},
              til={Buildings.Types.Tilt.Floor,Buildings.Types.Tilt.Wall}),
            nConBou=0,
            nSurBou=4,
            surBou(
              A={40.76,24.13,40.76,24.13}*hRoo,
              each absIR=0.9,
              each absSol=0.9,
              til={Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall, Buildings.Types.Tilt.Wall}),
            nPorts=11,
            intConMod=intConMod,
            energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
            final sampleModel=sampleModel) "Core zone"
            annotation (Placement(transformation(extent={{144,36},{184,76}})));

          Modelica.Blocks.Math.MatrixGain gai(K=20*[0.4; 0.4; 0.2])
            "Matrix gain to split up heat gain in radiant, convective and latent gain"
            annotation (Placement(transformation(extent={{-100,100},{-80,120}})));
          Modelica.Blocks.Sources.CombiTimeTable intGaiFra(
            table=[0,0.05; 8,0.05; 9,0.9; 12,0.9; 12,0.8; 13,0.8; 13,1; 17,1; 19,0.1;
                24,0.05],
            timeScale=3600,
            extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic)
            "Fraction of internal heat gain"
            annotation (Placement(transformation(extent={{-140,100},{-120,120}})));
          Modelica.Blocks.Math.Gain gaiIntNor[3](each k=kIntNor)
            "Gain for internal heat gain amplification for north zone"
            annotation (Placement(transformation(extent={{-60,134},{-40,154}})));
          Modelica.Blocks.Math.Gain gaiIntSou[3](each k=2 - kIntNor)
            "Gain to change the internal heat gain for south"
            annotation (Placement(transformation(extent={{-60,-38},{-40,-18}})));
          Modelica.Blocks.Sources.Constant uSha(k=0)
            "Control signal for the shading device"
            annotation (Placement(transformation(extent={{-100,170},{-80,190}})));
          Modelica.Blocks.Routing.Replicator replicator(nout=1)
            annotation (Placement(transformation(extent={{-60,170},{-40,190}})));
        equation
          connect(sou.surf_conBou[1], wes.surf_surBou[2]) annotation (Line(
              points={{170,-40.6667},{170,-54},{62,-54},{62,20},{28.2,20},{28.2,42.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(sou.surf_conBou[2], cor.surf_surBou[1]) annotation (Line(
              points={{170,-40},{170,-54},{200,-54},{200,20},{160.2,20},{160.2,41.25}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(sou.surf_conBou[3], eas.surf_surBou[1]) annotation (Line(
              points={{170,-39.3333},{170,-54},{320.2,-54},{320.2,61.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(eas.surf_conBou[1], cor.surf_surBou[2]) annotation (Line(
              points={{330,60},{330,20},{160.2,20},{160.2,41.75}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(eas.surf_surBou[2], nor.surf_conBou[1]) annotation (Line(
              points={{320.2,62.5},{320.2,24},{220,24},{220,100},{170,100},{170,119.333}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(nor.surf_conBou[2], cor.surf_surBou[3]) annotation (Line(
              points={{170,120},{170,100},{200,100},{200,26},{160.2,26},{160.2,42.25}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(nor.surf_conBou[3], wes.surf_surBou[1]) annotation (Line(
              points={{170,120.667},{170,100},{60,100},{60,20},{28.2,20},{28.2,41.5}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(wes.surf_conBou[1], cor.surf_surBou[4]) annotation (Line(
              points={{38,40},{38,30},{160.2,30},{160.2,42.75}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(replicator.y, nor.uSha) annotation (Line(
              points={{-39,180},{130,180},{130,154},{142.4,154}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(replicator.y, wes.uSha) annotation (Line(
              points={{-39,180},{-6,180},{-6,74},{10.4,74}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(replicator.y, eas.uSha) annotation (Line(
              points={{-39,180},{232,180},{232,94},{302.4,94}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(replicator.y, sou.uSha) annotation (Line(
              points={{-39,180},{130,180},{130,-6},{142.4,-6}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(replicator.y, cor.uSha) annotation (Line(
              points={{-39,180},{130,180},{130,74},{142.4,74}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(gai.y, cor.qGai_flow)          annotation (Line(
              points={{-79,110},{120,110},{120,64},{142.4,64}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(gai.y, eas.qGai_flow)          annotation (Line(
              points={{-79,110},{226,110},{226,84},{302.4,84}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(gai.y, wes.qGai_flow)          annotation (Line(
              points={{-79,110},{-14,110},{-14,64},{10.4,64}},
              color={0,0,127},
              pattern=LinePattern.Dash,
              smooth=Smooth.None));
          connect(sou.weaBus, weaBus) annotation (Line(
              points={{181.9,-6.1},{181.9,8},{210,8},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(eas.weaBus, weaBus) annotation (Line(
              points={{341.9,93.9},{341.9,120},{210,120},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(nor.weaBus, weaBus) annotation (Line(
              points={{181.9,153.9},{182,160},{182,168},{210,168},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(wes.weaBus, weaBus) annotation (Line(
              points={{49.9,73.9},{49.9,168},{210,168},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(cor.weaBus, weaBus) annotation (Line(
              points={{181.9,73.9},{181.9,90},{210,90},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(multiplex5_1.y, TRooAir) annotation (Line(
              points={{361,290},{372,290},{372,160},{390,160}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirSou.T, multiplex5_1.u1[1]) annotation (Line(
              points={{310,350},{328,350},{328,300},{338,300}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirEas.T, multiplex5_1.u2[1]) annotation (Line(
              points={{312,320},{324,320},{324,295},{338,295}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirNor.T, multiplex5_1.u3[1]) annotation (Line(
              points={{312,290},{338,290}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirWes.T, multiplex5_1.u4[1]) annotation (Line(
              points={{312,258},{324,258},{324,285},{338,285}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirCor.T, multiplex5_1.u5[1]) annotation (Line(
              points={{314,228},{322,228},{322,228},{332,228},{332,280},{338,280}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(sou.heaPorAir, temAirSou.port) annotation (Line(
              points={{163,-24},{224,-24},{224,100},{264,100},{264,350},{290,350}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(eas.heaPorAir, temAirEas.port) annotation (Line(
              points={{323,76},{286,76},{286,320},{292,320}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(nor.heaPorAir, temAirNor.port) annotation (Line(
              points={{163,136},{164,136},{164,290},{292,290}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(wes.heaPorAir, temAirWes.port) annotation (Line(
              points={{31,56},{70,56},{70,114},{186,114},{186,258},{292,258}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(cor.heaPorAir, temAirCor.port) annotation (Line(
              points={{163,56},{162,56},{162,228},{294,228}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(sou.ports[1], portsSou[1]) annotation (Line(
              points={{149,-37.2},{114,-37.2},{114,-36},{80,-36}},
              color={0,127,255},
              thickness=0.5));
          connect(sou.ports[2], portsSou[2]) annotation (Line(
              points={{149,-35.6},{124,-35.6},{124,-36},{100,-36}},
              color={0,127,255},
              thickness=0.5));
          connect(eas.ports[1], portsEas[1]) annotation (Line(
              points={{309,62.8},{300,62.8},{300,36},{320,36}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(eas.ports[2], portsEas[2]) annotation (Line(
              points={{309,64.4},{298,64.4},{298,34},{320,34},{320,36},{340,36}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(nor.ports[1], portsNor[1]) annotation (Line(
              points={{149,122.8},{114,122.8},{114,124},{80,124}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(nor.ports[2], portsNor[2]) annotation (Line(
              points={{149,124.4},{124,124.4},{124,124},{100,124}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(wes.ports[1], portsWes[1]) annotation (Line(
              points={{17,42.8},{-12,42.8},{-12,44},{-40,44}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(wes.ports[2], portsWes[2]) annotation (Line(
              points={{17,44.4},{-2,44.4},{-2,44},{-20,44}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(cor.ports[1], portsCor[1]) annotation (Line(
              points={{149,42.3636},{114,42.3636},{114,46},{80,46}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(cor.ports[2], portsCor[2]) annotation (Line(
              points={{149,43.0909},{124,43.0909},{124,46},{100,46}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(leaSou.port_b, sou.ports[3]) annotation (Line(
              points={{-22,400},{-2,400},{-2,-72},{134,-72},{134,-34},{149,-34}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(leaEas.port_b, eas.ports[3]) annotation (Line(
              points={{-22,360},{246,360},{246,66},{309,66}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(leaNor.port_b, nor.ports[3]) annotation (Line(
              points={{-20,320},{138,320},{138,126},{149,126}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(leaWes.port_b, wes.ports[3]) annotation (Line(
              points={{-20,280},{4,280},{4,46},{17,46}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeSouCor.port_b1, cor.ports[3]) annotation (Line(
              points={{104,16},{116,16},{116,43.8182},{149,43.8182}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeSouCor.port_a2, cor.ports[4]) annotation (Line(
              points={{104,4},{118,4},{118,44.5455},{149,44.5455}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeSouCor.port_a1, sou.ports[4]) annotation (Line(
              points={{84,16},{74,16},{74,-20},{134,-20},{134,-32.4},{149,-32.4}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeSouCor.port_b2, sou.ports[5]) annotation (Line(
              points={{84,4},{72,4},{72,-22},{132,-22},{132,-30.8},{149,-30.8}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeEasCor.port_b1, eas.ports[4]) annotation (Line(
              points={{270,54},{290,54},{290,67.6},{309,67.6}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeEasCor.port_a2, eas.ports[5]) annotation (Line(
              points={{270,42},{292,42},{292,69.2},{309,69.2}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeEasCor.port_a1, cor.ports[5]) annotation (Line(
              points={{250,54},{190,54},{190,34},{142,34},{142,45.2727},{149,45.2727}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeEasCor.port_b2, cor.ports[6]) annotation (Line(
              points={{250,42},{190,42},{190,34},{142,34},{142,46},{149,46}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeNorCor.port_b1, nor.ports[4]) annotation (Line(
              points={{100,90},{124,90},{124,127.6},{149,127.6}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeNorCor.port_a2, nor.ports[5]) annotation (Line(
              points={{100,78},{126,78},{126,129.2},{149,129.2}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeNorCor.port_a1, cor.ports[7]) annotation (Line(
              points={{80,90},{76,90},{76,60},{142,60},{142,46.7273},{149,46.7273}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(opeNorCor.port_b2, cor.ports[8]) annotation (Line(
              points={{80,78},{76,78},{76,60},{142,60},{142,47.4545},{149,47.4545}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeWesCor.port_b1, cor.ports[9]) annotation (Line(
              points={{40,-4},{54,-4},{54,36},{112,36},{112,48.1818},{149,48.1818}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeWesCor.port_a2, cor.ports[10]) annotation (Line(
              points={{40,-16},{56,-16},{56,34},{114,34},{114,48.9091},{149,48.9091}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeWesCor.port_a1, wes.ports[4]) annotation (Line(
              points={{20,-4},{6,-4},{6,47.6},{17,47.6}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(opeWesCor.port_b2, wes.ports[5]) annotation (Line(
              points={{20,-16},{2,-16},{2,49.2},{17,49.2}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(cor.ports[11], senRelPre.port_a) annotation (Line(
              points={{149,49.6364},{112,49.6364},{112,250},{60,250}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          connect(senRelPre.p_rel, p_rel) annotation (Line(
              points={{50,241},{50,220},{-170,220}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(gaiIntNor.y, nor.qGai_flow) annotation (Line(
              points={{-39,144},{142.4,144}},
              color={0,0,127},
              pattern=LinePattern.Dash));
          connect(gaiIntSou.y, sou.qGai_flow) annotation (Line(
              points={{-39,-28},{68,-28},{68,-16},{142.4,-16}},
              color={0,0,127},
              pattern=LinePattern.Dash));
          connect(gai.y,gaiIntSou. u) annotation (Line(
              points={{-79,110},{-68,110},{-68,-28},{-62,-28}},
              color={0,0,127},
              pattern=LinePattern.Dash));
          connect(gai.y,gaiIntNor. u) annotation (Line(
              points={{-79,110},{-68,110},{-68,144},{-62,144}},
              color={0,0,127},
              pattern=LinePattern.Dash));
          connect(intGaiFra.y,gai. u) annotation (Line(
              points={{-119,110},{-102,110}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(uSha.y,replicator. u) annotation (Line(
              points={{-79,180},{-62,180}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-160,-100},{380,500}},
                initialScale=0.1)),     Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-80,-80},{380,180}}), graphics={
                Rectangle(
                  extent={{-80,-80},{380,180}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,160},{360,-60}},
                  pattern=LinePattern.None,
                  lineColor={117,148,176},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Sphere),
                Rectangle(
                  extent={{0,-80},{294,-60}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{0,-74},{294,-66}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{8,8},{294,100}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{20,88},{280,22}},
                  pattern=LinePattern.None,
                  lineColor={117,148,176},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Sphere),
                Polygon(
                  points={{-56,170},{20,94},{12,88},{-62,162},{-56,170}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{290,16},{366,-60},{358,-66},{284,8},{290,16}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{284,96},{360,168},{368,162},{292,90},{284,96}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-80,120},{-60,-20}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-74,120},{-66,-20}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-64,-56},{18,22},{26,16},{-58,-64},{-64,-56}},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{360,122},{380,-18}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{366,122},{374,-18}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{2,170},{296,178}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{2,160},{296,180}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{2,166},{296,174}},
                  lineColor={95,95,95},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
    <ul>
<li>
April 30, 2021, by Michael Wetter:<br/>
Reformulated replaceable class and introduced floor areas in base class
to avoid access of components that are not in the constraining type.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2471\">issue #2471</a>.
</li>
<li>
January 23, 2020, by Milica Grahovac:<br/>
Updated core zone geometry parameters related to
room heat and mass balance.
</li>
<li>
November 15, 2019, by Milica Grahovac:<br/>
Added extend from a partial floor model.
</li>
<li>
May 1, 2013, by Michael Wetter:<br/>
Declared the parameter record to be a parameter, as declaring its elements
to be parameters does not imply that the whole record has the variability of a parameter.
</li>
</ul>
</html>",         info="<html>
<p>
Model of a floor that consists
of five thermal zones that are representative of one floor of the
new construction medium office building for Chicago, IL,
as described in the set of DOE Commercial Building Benchmarks.
There are four perimeter zones and one core zone.
The envelope thermal properties meet ASHRAE Standard 90.1-2004.
</p>
</html>"));
        end Floor;

        model FreezeStat "Freeze thermostat with timed lockout"

          parameter Real lockoutTime(
            final quantity="Time",
            final unit="s",
            displayUnit="min",
            min=60) = 900
            "Delay time";

          parameter Real TSet(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") = 276.15 "Temperature below which the freeze protection starts";

          Buildings.Controls.OBC.CDL.Interfaces.RealInput u(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC")
            "Connector of Real input signal used as measurement signal"
            annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
          Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput y
            "Connector of Real output signal used as actuator signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          Buildings.Controls.OBC.CDL.Logical.TrueDelay locOut(final delayTime=
                lockoutTime) "If freeze stat triggers, keep it on for specified time"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          Buildings.Controls.OBC.CDL.Logical.Not freStaSig "Signal for freeze stat"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold greThr(
            final t=TSet,
            final h=0) "Greater comparison"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        equation
          connect(locOut.y, freStaSig.u)
            annotation (Line(points={{12,0},{38,0}}, color={255,0,255}));
          connect(freStaSig.y, y)
            annotation (Line(points={{62,0},{120,0}}, color={255,0,255}));
          connect(greThr.y, locOut.u)
            annotation (Line(points={{-38,0},{-12,0}}, color={255,0,255}));
          connect(greThr.u, u)
            annotation (Line(points={{-62,0},{-120,0}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235},
                    if y then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillColor=DynamicSelect({235,235,235},
                    if y then
                      {0,255,0}
                    else
                      {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-160,140},{140,100}},
                  lineColor={0,0,255},
                  textString="%name")}),
        Diagram(
            coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>
Freeze stat that outputs <code>true</code> if freeze protection should be engaged.
</p>
<p>
The freeze stat regulates around a set point. When it triggers freeze protection,
then the freeze protection stays engaged for at least <code>delayTime</code>.
It only becomes disengaged after this time period if the measured temperature is above
the set point.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 23, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FreezeStat;

        partial model PartialFloor "Interface for a model of a floor of a building"

          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
            "Medium model for air" annotation (choicesAllMatching=true);

          parameter Boolean use_windPressure=true
            "Set to true to enable wind pressure";

          parameter Real kIntNor(min=0, max=1) = 1
            "Gain factor to scale internal heat gain in north zone";

          parameter Modelica.SIunits.Volume VRooCor "Room volume corridor";
          parameter Modelica.SIunits.Volume VRooSou "Room volume south";
          parameter Modelica.SIunits.Volume VRooNor "Room volume north";
          parameter Modelica.SIunits.Volume VRooEas "Room volume east";
          parameter Modelica.SIunits.Volume VRooWes "Room volume west";

          parameter Modelica.SIunits.Area AFloCor "Floor area corridor";
          parameter Modelica.SIunits.Area AFloSou "Floor area south";
          parameter Modelica.SIunits.Area AFloNor "Floor area north";
          parameter Modelica.SIunits.Area AFloEas "Floor area east";
          parameter Modelica.SIunits.Area AFloWes "Floor area west";

          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsSou[2](
              redeclare package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{70,-44},{110,-28}}),
                iconTransformation(extent={{78,-32},{118,-16}})));

          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsEas[2](
              redeclare package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{310,28},{350,44}}),
                iconTransformation(extent={{306,48},{346,64}})));

          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsNor[2](
              redeclare package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{70,116},{110,132}}),
                iconTransformation(extent={{78,116},{118,132}})));

          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsWes[2](
              redeclare package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-50,36},{-10,52}}),
                iconTransformation(extent={{-46,48},{-6,64}})));

          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsCor[2](
              redeclare package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{70,38},{110,54}}),
                iconTransformation(extent={{78,48},{118,64}})));

          Modelica.Blocks.Interfaces.RealOutput TRooAir[5](
            each unit="K",
            each displayUnit="degC") "Room air temperatures"
            annotation (Placement(transformation(extent={{380,150},{400,170}}),
                iconTransformation(extent={{380,40},{400,60}})));

          Modelica.Blocks.Interfaces.RealOutput p_rel
            "Relative pressure signal of building static pressure" annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-170,220}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-90,50})));

          BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{200,190},{220,210}}),
                iconTransformation(extent={{200,210},{220,230}})));

          Buildings.Examples.VAVReheat.BaseClasses.RoomLeakage leaSou(
            redeclare package Medium = Medium,
            VRoo=VRooSou,
            s=49.91/33.27,
            azi=Buildings.Types.Azimuth.S,
            final use_windPressure=use_windPressure)
            "Model for air infiltration through the envelope"
            annotation (Placement(transformation(extent={{-58,380},{-22,420}})));
          Buildings.Examples.VAVReheat.BaseClasses.RoomLeakage leaEas(
            redeclare package Medium = Medium,
            VRoo=VRooEas,
            s=33.27/49.91,
            azi=Buildings.Types.Azimuth.E,
            final use_windPressure=use_windPressure)
            "Model for air infiltration through the envelope"
            annotation (Placement(transformation(extent={{-58,340},{-22,380}})));

          Buildings.Examples.VAVReheat.BaseClasses.RoomLeakage leaNor(
            redeclare package Medium = Medium,
            VRoo=VRooNor,
            s=49.91/33.27,
            azi=Buildings.Types.Azimuth.N,
            final use_windPressure=use_windPressure)
            "Model for air infiltration through the envelope"
            annotation (Placement(transformation(extent={{-56,300},{-20,340}})));

          Buildings.Examples.VAVReheat.BaseClasses.RoomLeakage leaWes(
            redeclare package Medium = Medium,
            VRoo=VRooWes,
            s=33.27/49.91,
            azi=Buildings.Types.Azimuth.W,
            final use_windPressure=use_windPressure)
            "Model for air infiltration through the envelope"
            annotation (Placement(transformation(extent={{-56,260},{-20,300}})));

          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirSou
            "Air temperature sensor"
            annotation (Placement(transformation(extent={{290,340},{310,360}})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirEas
            "Air temperature sensor"
            annotation (Placement(transformation(extent={{292,310},{312,330}})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirNor
            "Air temperature sensor"
            annotation (Placement(transformation(extent={{292,280},{312,300}})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirWes
            "Air temperature sensor"
            annotation (Placement(transformation(extent={{292,248},{312,268}})));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirCor
            "Air temperature sensor"
            annotation (Placement(transformation(extent={{294,218},{314,238}})));
          Modelica.Blocks.Routing.Multiplex5 multiplex5_1
            annotation (Placement(transformation(extent={{340,280},{360,300}})));

          Airflow.Multizone.DoorOpen opeSouCor(
            redeclare package Medium = Medium,
            wOpe=10)
            "Opening between perimeter1 and core"
            annotation (Placement(transformation(extent={{84,0},{104,20}})));
          Airflow.Multizone.DoorOpen opeEasCor(
            redeclare package Medium = Medium,
            wOpe=10)
            "Opening between perimeter2 and core"
            annotation (Placement(transformation(extent={{250,38},{270,58}})));
          Airflow.Multizone.DoorOpen opeNorCor(
            redeclare package Medium = Medium,
            wOpe=10)
            "Opening between perimeter3 and core"
            annotation (Placement(transformation(extent={{80,74},{100,94}})));
          Airflow.Multizone.DoorOpen opeWesCor(redeclare package Medium =
                Medium, wOpe=10)
            "Opening between perimeter3 and core"
            annotation (Placement(transformation(extent={{20,-20},{40,0}})));
          Buildings.Fluid.Sensors.RelativePressure senRelPre(redeclare package
            Medium =                                                                    Medium)
            "Building pressure measurement"
            annotation (Placement(transformation(extent={{60,240},{40,260}})));
          Buildings.Fluid.Sources.Outside out(nPorts=1, redeclare package
            Medium =                                                               Medium)
            annotation (Placement(transformation(extent={{-58,240},{-38,260}})));

        equation
          connect(weaBus, leaSou.weaBus) annotation (Line(
              points={{210,200},{-80,200},{-80,400},{-58,400}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaBus, leaEas.weaBus) annotation (Line(
              points={{210,200},{-80,200},{-80,360},{-58,360}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaBus, leaNor.weaBus) annotation (Line(
              points={{210,200},{-80,200},{-80,320},{-56,320}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaBus, leaWes.weaBus) annotation (Line(
              points={{210,200},{-80,200},{-80,280},{-56,280}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(out.weaBus, weaBus) annotation (Line(
              points={{-58,250.2},{-70,250.2},{-70,250},{-80,250},{-80,200},{210,200}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(multiplex5_1.y, TRooAir) annotation (Line(
              points={{361,290},{372,290},{372,160},{390,160}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirSou.T, multiplex5_1.u1[1]) annotation (Line(
              points={{310,350},{328,350},{328,300},{338,300}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirEas.T, multiplex5_1.u2[1]) annotation (Line(
              points={{312,320},{324,320},{324,295},{338,295}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirNor.T, multiplex5_1.u3[1]) annotation (Line(
              points={{312,290},{338,290}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirWes.T, multiplex5_1.u4[1]) annotation (Line(
              points={{312,258},{324,258},{324,285},{338,285}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(temAirCor.T, multiplex5_1.u5[1]) annotation (Line(
              points={{314,228},{322,228},{322,228},{332,228},{332,280},{338,280}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(senRelPre.p_rel, p_rel) annotation (Line(
              points={{50,241},{50,220},{-170,220}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(out.ports[1], senRelPre.port_b) annotation (Line(
              points={{-38,250},{40,250}},
              color={0,127,255},
              smooth=Smooth.None,
              thickness=0.5));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-160,-100},{380,500}},
                initialScale=0.1)),   Icon(coordinateSystem(extent={{-80,-80},{380,160}},
                preserveAspectRatio=true),
                 graphics={Rectangle(
                  extent={{-80,160},{380,-80}},
                  lineColor={95,95,95},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-118,94},{-96,60}},
                  lineColor={0,0,255},
                  textString="dP")}),
            Documentation(info="<html>
<p>
This is a partial model for one floor of the DOE reference office building.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 25, 2021, by Michael Wetter:<br/>
Replaced door model with the new model <a href=\"modelica://Buildings.Airflow.Multizone.DoorOpen\">
Buildings.Airflow.Multizone.DoorOpen</a>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1353\">IBPSA, #1353</a>.
</li>
<li>
November 15, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFloor;

        model RoomLeakage "Room leakage model"
          extends Buildings.BaseClasses.BaseIcon;
          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
            "Medium in the component" annotation (choicesAllMatching=true);
          parameter Modelica.SIunits.Volume VRoo "Room volume";
          parameter Boolean use_windPressure=false
            "Set to true to enable wind pressure"
            annotation(Evaluate=true);
          Buildings.Fluid.FixedResistances.PressureDrop res(
            redeclare package Medium = Medium,
            dp_nominal=50,
            m_flow_nominal=VRoo*1.2/3600) "Resistance model"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(redeclare package Medium
            =   Medium) annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Buildings.Fluid.Sources.Outside_CpLowRise
                                amb(redeclare package Medium = Medium, nPorts=1,
            s=s,
            azi=azi,
            Cp0=if use_windPressure then 0.6 else 0)
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          BoundaryConditions.WeatherData.Bus weaBus "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Buildings.Fluid.Sensors.MassFlowRate senMasFlo1(redeclare package
            Medium =                                                                 Medium,
              allowFlowReversal=true) "Sensor for mass flow rate" annotation (Placement(
                transformation(
                extent={{10,10},{-10,-10}},
                rotation=180,
                origin={-10,0})));
          Modelica.Blocks.Math.Gain ACHInf(k=1/VRoo/1.2*3600, y(unit="1/h"))
            "Air change per hour due to infiltration"
            annotation (Placement(transformation(extent={{12,30},{32,50}})));
          parameter Real s "Side ratio, s=length of this wall/length of adjacent wall";
          parameter Modelica.SIunits.Angle azi "Surface azimuth (South:0, West:pi/2)";

        equation
          connect(res.port_b, port_b) annotation (Line(points={{40,6.10623e-16},{55,
                  6.10623e-16},{55,1.16573e-15},{70,1.16573e-15},{70,5.55112e-16},{100,
                  5.55112e-16}},                                   color={0,127,255}));
          connect(amb.weaBus, weaBus) annotation (Line(
              points={{-60,0.2},{-80,0.2},{-80,5.55112e-16},{-100,5.55112e-16}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(amb.ports[1], senMasFlo1.port_a) annotation (Line(
              points={{-40,6.66134e-16},{-20,6.66134e-16},{-20,7.25006e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(senMasFlo1.port_b, res.port_a) annotation (Line(
              points={{5.55112e-16,-1.72421e-15},{10,-1.72421e-15},{10,6.10623e-16},{20,
                  6.10623e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(senMasFlo1.m_flow, ACHInf.u) annotation (Line(
              points={{-10,11},{-10,40},{10,40}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={
                Ellipse(
                  extent={{-80,40},{0,-40}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,127,255}),
                Rectangle(
                  extent={{20,12},{80,-12}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{20,6},{80,-6}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Line(points={{-100,0},{-80,0}}, color={0,0,255}),
                Line(points={{0,0},{20,0}}, color={0,0,255}),
                Line(points={{80,0},{90,0}}, color={0,0,255})}),
            Documentation(info="<html>
<p>
Room leakage.
</p></html>",         revisions="<html>
<ul>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RoomLeakage;

        model VAVReheatBox "Supply box of a VAV system with a hot water reheat coil"
          extends Modelica.Blocks.Icons.Block;
          replaceable package MediumA = Modelica.Media.Interfaces.PartialMedium
            "Medium model for air" annotation (choicesAllMatching=true);
          replaceable package MediumW = Modelica.Media.Interfaces.PartialMedium
            "Medium model for water" annotation (choicesAllMatching=true);

          parameter Boolean allowFlowReversal=true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
            "Nominal air mass flow rate";
          parameter Real ratVFloHea(start=0.3, min=0, max=1, unit="1")
            "Maximum air flow rate ratio in heating mode";
          parameter Modelica.SIunits.Volume VRoo "Room volume";
          parameter Modelica.SIunits.Temperature THotWatInl_nominal(
            start=55 + 273.15,
            displayUnit="degC")
            "Reheat coil nominal inlet water temperature";
          parameter Modelica.SIunits.Temperature THotWatOut_nominal(
            start=THotWatInl_nominal-10,
            displayUnit="degC")
            "Reheat coil nominal outlet water temperature";
          parameter Modelica.SIunits.Temperature TAirInl_nominal(
            start=12 + 273.15,
            displayUnit="degC")
            "Inlet air nominal temperature";
          parameter Modelica.SIunits.HeatFlowRate QHea_flow_nominal(
            start=m_flow_nominal * ratVFloHea * cpAir * (32 + 273.15 - TAirInl_nominal))
            "Nominal heating heat flow rate";
          final parameter Modelica.SIunits.MassFlowRate mHotWat_flow_nominal=
            QHea_flow_nominal / (cpWatLiq * (THotWatInl_nominal - THotWatOut_nominal))
            "Nominal mass flow rate of hot water to reheat coil";
          Modelica.Fluid.Interfaces.FluidPort_a port_aAir(
            redeclare package Medium=MediumA)
            "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                iconTransformation(extent={{-10,-110},{10,-90}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_bAir(
            redeclare package Medium=MediumA)
            "Fluid connector b (positive design flow direction is from port_a1 to port_b1)"
            annotation (Placement(transformation(extent={{-10,90},{10,110}}),
                iconTransformation(extent={{-10,90},{10,110}})));
          Modelica.Blocks.Interfaces.RealInput yVAV(final unit="1")
            "Signal for VAV damper"
            annotation (
              Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Interfaces.RealOutput y_actual(final unit="1")
          "Actual VAV damper position"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_aHotWat(redeclare package
            Medium =
              MediumW) "Hot water inlet port"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_bHotWat(redeclare package
            Medium =
              MediumW) "Hot water outlet port"
            annotation (Placement(transformation(extent={{-110,-70},{-90,-50}}),
                iconTransformation(extent={{-110,-70},{-90,-50}})));
          Modelica.Blocks.Interfaces.RealOutput TSup(
             final unit = "K",
             displayUnit = "degC")
             "Supply Air Temperature"
            annotation (Placement(transformation(extent={{100,30},{120,50}}),
                iconTransformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput VSup_flow(
            final unit="m3/s")
            "Supply Air Volumetric Flow Rate"
            annotation (Placement(transformation(extent={{100,70},{120,90}}),
                iconTransformation(extent={{100,70},{120,90}})));
          Buildings.Fluid.Actuators.Dampers.PressureIndependent vav(
            redeclare package Medium = MediumA,
            m_flow_nominal=m_flow_nominal,
            dpDamper_nominal=20,
            allowFlowReversal=allowFlowReversal,
            dpFixed_nominal=130)                 "VAV box for room" annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,10})));
          Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU terHea(
            redeclare package Medium1 = MediumW,
            redeclare package Medium2 = MediumA,
            m1_flow_nominal=mHotWat_flow_nominal,
            m2_flow_nominal=m_flow_nominal*ratVFloHea,
            Q_flow_nominal=QHea_flow_nominal,
            configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
            dp1_nominal=0,
            from_dp2=true,
            dp2_nominal=0,
            allowFlowReversal1=false,
            allowFlowReversal2=allowFlowReversal,
            T_a1_nominal=THotWatInl_nominal,
            T_a2_nominal=TAirInl_nominal)
            "Reheat coil"
            annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=270,
                origin={-6,-30})));
          Fluid.Sensors.TemperatureTwoPort senTem(
            redeclare package Medium = MediumA,
            initType=Modelica.Blocks.Types.Init.InitialState,
            m_flow_nominal=m_flow_nominal,
            allowFlowReversal=allowFlowReversal) "Supply Air Temperature Sensor"
            annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=90,
                origin={0,40})));
          Fluid.Sensors.VolumeFlowRate senVolFlo(
            redeclare package Medium = MediumA,
            initType=Modelica.Blocks.Types.Init.InitialState,
            m_flow_nominal=m_flow_nominal,
            allowFlowReversal=allowFlowReversal)
            "Supply Air Volumetric Flow Rate Sensor"
            annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=90,
                origin={0,80})));
          Fluid.Actuators.Valves.TwoWayEqualPercentage val(
            redeclare package Medium = MediumW,
            allowFlowReversal=false,
            m_flow_nominal=mHotWat_flow_nominal,
            from_dp=true,
            dpValve_nominal=3000,
            use_inputFilter=false,
            dpFixed_nominal=3000) "Valve for terminal heater"
            annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
          Modelica.Blocks.Interfaces.RealInput yHea
            "Actuator position for heating valve (0: closed, 1: open)" annotation (
              Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,10},{-100,50}})));
      protected
          constant Modelica.SIunits.SpecificHeatCapacity cpAir=
            Buildings.Utilities.Psychrometrics.Constants.cpAir
            "Air specific heat capacity";
          constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq=
            Buildings.Utilities.Psychrometrics.Constants.cpWatLiq
            "Water specific heat capacity";
        equation
          connect(vav.y, yVAV) annotation (Line(points={{-12,10},{-48,10},{-48,80},{
                  -120,80}},
                        color={0,0,127}));
          connect(vav.y_actual, y_actual)
            annotation (Line(points={{-7,15},{-7,24},{20,24},{20,0},{110,0}},
                                                                  color={0,0,127}));
          connect(port_aAir, terHea.port_a2) annotation (Line(points={{0,-100},{0,-40}},
                                        color={0,127,255}));
          connect(vav.port_a, terHea.port_b2)
            annotation (Line(points={{-4.44089e-16,0},{3.55271e-15,0},{3.55271e-15,-20}},
                                                                   color={0,127,255}));
          connect(port_bHotWat, terHea.port_b1) annotation (Line(points={{-100,-60},{
                  -12,-60},{-12,-40}}, color={0,127,255}));
          connect(vav.port_b, senTem.port_a) annotation (Line(points={{6.66134e-16,20},{
                  0,20},{0,30},{-4.44089e-16,30}}, color={0,127,255}));
          connect(senTem.port_b, senVolFlo.port_a)
            annotation (Line(points={{0,50},{0,70},{-6.66134e-16,70}},
                                                     color={0,127,255}));
          connect(senVolFlo.port_b, port_bAir)
            annotation (Line(points={{4.44089e-16,90},{0,90},{0,100}},
                                                             color={0,127,255}));
          connect(senVolFlo.V_flow, VSup_flow) annotation (Line(points={{11,80},{110,80}},
                                     color={0,0,127}));
          connect(senTem.T, TSup) annotation (Line(points={{11,40},{110,40}},
                        color={0,0,127}));
          connect(port_aHotWat, val.port_a)
            annotation (Line(points={{-100,0},{-70,0}}, color={0,127,255}));
          connect(val.port_b, terHea.port_a1)
            annotation (Line(points={{-50,0},{-12,0},{-12,-20}}, color={0,127,255}));
          connect(yHea, val.y)
            annotation (Line(points={{-120,40},{-60,40},{-60,12}}, color={0,0,127}));
          annotation (Icon(
            graphics={
                Rectangle(
                  extent={{-108.07,-16.1286},{93.93,-20.1286}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255},
                  origin={-18.1286,6.07},
                  rotation=90),
                Rectangle(
                  extent={{-20,-12},{22,-52}},
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175},
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{100.8,-22},{128.8,-44}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192},
                  origin={-32,-76.8},
                  rotation=90),
                Rectangle(
                  extent={{102.2,-11.6667},{130.2,-25.6667}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255},
                  origin={-17.6667,-78.2},
                  rotation=90),
                Polygon(
                  points={{-12,32},{16,48},{16,46},{-12,30},{-12,32}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-20,-20},{14,-20},{14,-22},{-20,-22},{-20,-20}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{-20,-44},{14,-44},{14,-46},{-20,-46},{-20,-44}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{0,-26},{14,-20},{14,-22},{0,-28},{0,-26}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{0,-26},{14,-32},{14,-34},{0,-28},{0,-26}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{0,-38},{14,-44},{14,-46},{0,-40},{0,-38}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Polygon(
                  points={{0,-38},{14,-32},{14,-34},{0,-40},{0,-38}},
                  pattern=LinePattern.None,
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-98,-20},{-18,-24}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={238,46,47},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-100,-42},{-20,-46}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,3},{12,-3}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={238,46,47},
                  fillPattern=FillPattern.Solid,
                  origin={-97,-12},
                  rotation=90),
                Rectangle(
                  extent={{-12,3},{12,-3}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid,
                  origin={-97,-54},
                  rotation=90),
                Line(points={{-100,80},{-38,80},{-38,38},{-10,38}}, color={0,0,127}),
                Polygon(
                  points={{-78,-14},{-78,-30},{-66,-22},{-78,-14}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-54,-14},{-54,-30},{-66,-22},{-54,-14}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,30},{-66,30},{-66,-2},{-66,-20}}, color={0,0,127})}),
                                        Documentation(info="<html>
<p>
Model for a VAV terminal box with a water reheat coil and pressure independent damper.
The pressure independent damper model includes an idealized flow rate controller
and requires a discharge air flow rate set-point (normalized to the nominal value)
as a control signal.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2021, by Michael Wetter:<br/>
Changed model to include the hydraulic configurations of the cooling coil,
heating coil and VAV terminal box.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2594\">issue #2594</a>.
</li>
<li>
February 12, 2021, by Baptiste Ravache:<br/>
First implementation, based on <a href=\"modelica://Buildings.Obsolete.Examples.VAVReheat.BaseClasses.VAVBranch\">
Buildings.Obsolete.Examples.VAVReheat.BaseClasses.VAVBranch</a><br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2059\">#2024</a>.
</li>
</ul>
</html>"));
        end VAVReheatBox;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Examples.VAVReheat\">Buildings.Examples.VAVReheat</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (Documentation(info="<html>
<p>
This package contains variable air volume flow models
for office buildings.
</p>
<h4>Note</h4>
<p>
The models
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter</a>
and
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.Guideline36Winter\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.Guideline36Winter</a>
appear to be quite similar to
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>
and
<a href=\"modelica://Buildings.Examples.VAVReheat.Guideline36\">
Buildings.Examples.VAVReheat.Guideline36</a>,
respectively, because they all have the same HVAC system, control sequences,
and all have five thermal zones.
However, the models in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>
are from the
<i>DOE Commercial Reference Building,
Small Office, new construction, ASHRAE 90.1-2004,
Version 1.3_5.0</i>,
whereas the models in
<a href=\"modelica://Buildings.Examples.VAVReheat\">
Buildings.Examples.VAVReheat</a>
are from the
<i>DOE Commercial Building Benchmark,
Medium Office, new construction, ASHRAE 90.1-2004,
version 1.2_4.0</i>.
Therefore, the dimensions of the thermal zones in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice</a>
are considerably smaller than in
<a href=\"modelica://Buildings.Examples.VAVReheat\">
Buildings.Examples.VAVReheat</a>.
As the sizing is scaled with the volumes of the thermal zones, the model <i>structure</i>
is the same, but the design capacities are different, as is the energy consumption.
</p>
</html>"));
    end VAVReheat;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains a tutorial with step by step instructions
for how to build system models.
This package also contains examples of system models that are
composed of models from a variety of packages of the
<code>Buildings</code> library. The examples illustrate
the scope of the library. Smaller examples that typically only
use models from a few packages can be found in the individual packages.
For example, see
<a href=\"modelica://Buildings.Airflow.Multizone.Examples\">
Buildings.Airflow.Multizone.Examples</a> for examples of
multizone airflow and contaminant transport models, or
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Examples\">
Buildings.Fluid.HeatExchangers.Examples</a> for
examples of heat exchanger models.
</p>
</html>"));
  end Examples;

  package BaseClasses "Package with base classes for the Buildings library"
    extends Modelica.Icons.BasesPackage;

    block BaseIcon "Base icon"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Text(
              extent={{-46,158},{52,110}},
              lineColor={0,0,255},
              textString="%name")}),
    Documentation(
    info="<html>
<p>
Basic class that provides a label with the component name above the icon.
</p>
</html>",
    revisions="<html>
<ul>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end BaseIcon;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings\">Buildings</a>.
</p>
</html>"));
  end BaseClasses;
annotation (
preferredView="info",
version="9.0.0",
versionDate="2021-06-08",
dateModified="2021-06-08",
uses(Modelica(version="3.2.3")),
conversion(
  from(version={"8.0.0"},
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_8_to_9.0.0.mos")),
preferredView="info",
Documentation(info="<html>
<p>
The <code>Buildings</code> library is a free library
for modeling building energy and control systems.
Many models are based on models from the package
<code>Modelica.Fluid</code> and use
the same ports to ensure compatibility with the Modelica Standard
Library.
</p>
<p>
The figure below shows a section of the schematic view of the model
<a href=\"modelica://Buildings.Examples.HydronicHeating\">
Buildings.Examples.HydronicHeating</a>.
In the lower part of the figure, there is a dynamic model of a boiler, a pump and a stratified energy storage tank. Based on the temperatures of the storage tank, a finite state machine switches the boiler and its pump on and off.
The heat distribution is done using a hydronic heating system with a three way valve and a pump with variable revolutions. The upper right hand corner shows a room model that is connected to a radiator whose flow is controlled by a thermostatic valve.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/UsersGuide/HydronicHeating.png\" border=\"1\"/>
</p>
<p>
The web page for this library is
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica</a>,
and the development page is
<a href=\"https://github.com/lbl-srg/modelica-buildings\">https://github.com/lbl-srg/modelica-buildings</a>.
Contributions to further advance the library are welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"));
end Buildings;

package Modelica "Modelica Standard Library - Version 3.2.3"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      import Modelica.SIunits;
      extends Modelica.Icons.InterfacesPackage;

      connector RealInput = input Real "'input Real' as connector" annotation (
        defaultComponentName="u",
        Icon(graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})},
          coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{-10.0,60.0},{-10.0,85.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

      connector RealOutput = output Real "'output Real' as connector" annotation (
        defaultComponentName="y",
        Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})}),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{30.0,60.0},{30.0,110.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

      connector BooleanInput = input Boolean "'input Boolean' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

      connector BooleanOutput = output Boolean "'output Boolean' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

      connector IntegerInput = input Integer "'input Integer' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>"));

      connector IntegerOutput = output Integer "'output Integer' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>"));

      partial block SO "Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

      end SO;

      partial block MO "Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        parameter Integer nout(min=1) = 1 "Number of outputs";
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal vector.
</p>
</html>"));

      end MO;

      partial block SISO "Single Input Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
      end SISO;

      partial block SI2SO
        "2 Single Input / 1 Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u1 "Connector of Real input signal 1" annotation (Placement(
              transformation(extent={{-140,40},{-100,80}})));
        RealInput u2 "Connector of Real input signal 2" annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"));

      end SI2SO;

      partial block SIMO "Single Input Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer nout=1 "Number of outputs";
        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p> Block has one continuous Real input signal and a
    vector of continuous Real output signals.</p>

</html>"));
      end SIMO;

      partial block MISO "Multiple Input Single Output continuous control block"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer nin=1 "Number of inputs";
        RealInput u[nin] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a vector of continuous Real input signals and
one continuous Real output signal.
</p>
</html>"));
      end MISO;

      partial block MIMO "Multiple Input Multiple Output continuous control block"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer nin=1 "Number of inputs";
        parameter Integer nout=1 "Number of outputs";
        RealInput u[nin] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a continuous Real input and a continuous Real output signal vector.
The signal sizes of the input and output vector may be different.
</p>
</html>"));
      end MIMO;

      partial block IntegerSO "Single Integer Output continuous control block"
        extends Modelica.Blocks.Icons.IntegerBlock;

        IntegerOutput y "Connector of Integer output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Integer output signal.
</p>
</html>"));
      end IntegerSO;

      partial block PartialConversionBlock
        "Partial block defining the interface for conversion blocks"

        RealInput u "Connector of Real input signal to be converted" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y
          "Connector of Real output signal containing input signal u in another unit"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            Line(
              points={{-90.0,0.0},{30.0,0.0}},
              color={191,0,0}),
            Polygon(
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid,
              points={{90.0,0.0},{30.0,20.0},{30.0,-20.0},{90.0,0.0}}),
            Text(
              lineColor={0,0,255},
              extent={{-150,110},{150,150}},
              textString="%name")}), Documentation(info="<html>
<p>
This block defines the interface of a conversion block that
converts from one unit into another one.
</p>

</html>"));

      end PartialConversionBlock;
      annotation (Documentation(info="<html>
<p>
This package contains interface definitions for
<strong>continuous</strong> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</html>",     revisions="<html>
<ul>
<li><em>Oct. 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Added several new interfaces.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Interfaces;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.SIunits;
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      encapsulated package UnitConversions
      "Conversion blocks to convert between SI and non-SI unit signals"
        import Modelica;
        import SI = Modelica.SIunits;
        import NonSI = Modelica.SIunits.Conversions.NonSIunits;
        extends Modelica.Icons.Package;

        block From_degC "Convert from degCelsius to Kelvin"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="degC"),
              y(unit="K"));
        equation
          y = SI.Conversions.from_degC(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="degC"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="K")}), Documentation(info="<html>
<p>
This block converts the input signal from degCelsius to Kelvin and returns
the result as output signal.
</p>
</html>"));
        end From_degC;

        block From_deg "Convert from degree to radian"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="deg"),
              y(unit="rad"));
        equation
          y = SI.Conversions.from_deg(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="deg"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="rad")}), Documentation(info="<html>
<p>
This block converts the input signal from degree to radian and returns
the result as output signal.
</p>
</html>"));
        end From_deg;
        annotation (Documentation(info="<html>
<p>
This package consists of blocks that convert an input signal
with a specific unit to an output signal in another unit
(e.g., conversion of an angle signal from \"deg\" to \"rad\").
</p>

</html>"));
      end UnitConversions;

      block Gain "Output the product of a gain value with the input signal"

        parameter Real k(start=1, unit="1")
          "Gain value multiplied with input signal";
    public
        Interfaces.RealInput u "Input signal connector" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Output signal connector" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

      equation
        y = k*u;
        annotation (
          Documentation(info="<html>
<p>
This block computes output <em>y</em> as
<em>product</em> of gain <em>k</em> with the
input <em>u</em>:
</p>
<pre>
    y = k * u;
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                lineColor={0,0,255})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-76,38},{0,-34}},
                  textString="k",
                  lineColor={0,0,255})}));
      end Gain;

      block MatrixGain
        "Output the product of a gain matrix with the input signal vector"

        parameter Real K[:, :]=[1, 0; 0, 1]
          "Gain matrix which is multiplied with the input";
        extends Interfaces.MIMO(final nin=size(K, 2), final nout=size(K, 1));
      equation
        y = K*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output vector <strong>y</strong> as <em>product</em> of the
gain matrix <strong>K</strong> with the input signal vector <strong>u</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>K</strong> * <strong>u</strong>;
</pre>
<p>
Example:
</p>
<pre>
   parameter: <strong>K</strong> = [0.12 2; 3 1.5]

   results in the following equations:

     | y[1] |     | 0.12  2.00 |   | u[1] |
     |      |  =  |            | * |      |
     | y[2] |     | 3.00  1.50 |   | u[2] |
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-90,-60},{90,60}},
                lineColor={160,160,164},
                textString="*K")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-90,-60},{90,60}},
                  lineColor={160,160,164},
                  textString="*K")}));
      end MatrixGain;

      block Sum "Output the sum of the elements of the input vector"
        extends Interfaces.MISO;
        parameter Real k[nin]=ones(nin) "Optional: sum coefficients";
      equation
        y = k*u;
        annotation (
          defaultComponentName="sum1",
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>sum</em> of the elements of the input signal vector
<strong>u</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>u</strong>[1] + <strong>u</strong>[2] + ...;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   nin = 3;

  results in the following equations:

     y = u[1] + u[2] + u[3];
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Line(
                points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(
                  points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}));
      end Sum;

      block Feedback "Output difference between commanded and feedback input"

        Interfaces.RealInput u1 annotation (Placement(transformation(extent={{-100,
                  -20},{-60,20}})));
        Interfaces.RealInput u2 annotation (Placement(transformation(
              origin={0,-80},
              extent={{-20,-20},{20,20}},
              rotation=90)));
        Interfaces.RealOutput y annotation (Placement(transformation(extent={{80,-10},
                  {100,10}})));

      equation
        y = u1 - u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>difference</em> of the
commanded input <strong>u1</strong> and the feedback
input <strong>u2</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>u1</strong> - <strong>u2</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   n = 2

  results in the following equations:

     y = u1 - u2
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                lineColor={0,0,127},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                extent={{-20,-20},{20,20}}),
              Line(points={{-60,0},{-20,0}}, color={0,0,127}),
              Line(points={{20,0},{80,0}}, color={0,0,127}),
              Line(points={{0,-20},{0,-60}}, color={0,0,127}),
              Text(extent={{-14,-94},{82,0}}, textString="-"),
              Text(
                lineColor={0,0,255},
                extent={{-150,44},{150,94}},
                textString="%name")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),Line(points={{-60,0},{-20,0}}, color={0,0,255}),
                Line(points={{20,0},{80,0}}, color={0,0,255}),Line(points={{0,
                -20},{0,-60}}, color={0,0,255}),Text(
                  extent={{-12,10},{84,-84}},
                  textString="-")}));
      end Feedback;

      block Add "Output the sum of the two inputs"
        extends Interfaces.SI2SO;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";

      equation
        y = k1*u1 + k2*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
two input signals <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    <strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3

  results in the following equations:

     y = 2 * u1 - 3 * u2
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(extent={{-38,-34},{38,34}}, textString="+"),
              Text(extent={{-100,52},{5,92}}, textString="%k1"),
              Text(extent={{-100,-92},{5,-52}}, textString="%k2")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{50,0},{100,0}},
                color={0,0,255}),Line(points={{-100,60},{-74,24},{-44,24}}, color={
                0,0,127}),Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
                Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),Line(
                points={{50,0},{100,0}}, color={0,0,127}),Text(
                  extent={{-36,38},{40,-30}},
                  textString="+"),Text(
                  extent={{-100,52},{5,92}},
                  textString="k1"),Text(
                  extent={{-100,-52},{5,-92}},
                  textString="k2")}));
      end Add;

      block Product "Output product of the two inputs"
        extends Interfaces.SI2SO;

      equation
        y = u1*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes the output <strong>y</strong>
as <em>product</em> of the two inputs <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    y = u1 * u2;
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Line(points={{-30,0},{30,0}}),
              Line(points={{-15,25.99},{15,-25.99}}),
              Line(points={{-15,-25.99},{15,25.99}}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{-100,60},{-40,60},{-30,
                40}}, color={0,0,255}),Line(points={{-100,-60},{-40,-60},{-30,-40}},
                color={0,0,255}),Line(points={{50,0},{100,0}}, color={0,0,255}),
                Line(points={{-30,0},{30,0}}),Line(points={{-15,
                25.99},{15,-25.99}}),Line(points={{-15,-25.99},{15,
                25.99}}),Ellipse(extent={{-50,50},{50,-50}},
                lineColor={0,0,255})}));
      end Product;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>,
such as summation and multiplication, and basic <strong>mathematical
functions</strong>, such as <strong>sqrt</strong> and <strong>sin</strong>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added WrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><em>August 7, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"),     Icon(graphics={Line(
              points={{-80,-2},{-68.7,32.2},{-61.5,51.1},{-55.1,64.4},{-49.4,72.6},
                  {-43.8,77.1},{-38.2,77.8},{-32.6,74.6},{-26.9,67.7},{-21.3,57.4},
                  {-14.9,42.1},{-6.83,19.2},{10.1,-32.8},{17.3,-52.2},{23.7,-66.2},
                  {29.3,-75.1},{35,-80.4},{40.6,-82},{46.2,-79.6},{51.9,-73.5},{
                  57.5,-63.9},{63.9,-49.2},{72,-26.8},{80,-2}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Math;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      block Replicator "Signal replicator"
        extends Modelica.Blocks.Interfaces.SIMO;
      equation
        y = fill(u, nout);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{0,0},{100,10}}, color={0,0,127}),
              Line(points={{0,0},{100,-10}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This block replicates the input signal to an array of <code>nout</code> identical output signals.
</p>
</html>"));
      end Replicator;

    block Extractor
        "Extract scalar signal out of signal vector dependent on IntegerRealInput index"

      extends Modelica.Blocks.Interfaces.MISO;

      parameter Boolean allowOutOfRange=false "Index may be out of range";
      parameter Real outOfRangeValue=1e10 "Output signal if index is out of range";

      Modelica.Blocks.Interfaces.IntegerInput index annotation (Placement(
              transformation(
              origin={0,-120},
              extent={{-20,-20},{20,20}},
              rotation=90)));
    protected
      Real k[nin];
    equation

      when {initial(),change(index)} then

        for i in 1:nin loop
          k[i] = if index == i then 1 else 0;

        end for;

      end when;

      y = if not allowOutOfRange or index > 0 and index <= nin then
                  k*u else outOfRangeValue;
      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-80,50},{-40,-50}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                    -84.4104,1.9079}},
                lineColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,127}),
              Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
              Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
              Ellipse(
                extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
              Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                    0,0,127}),
              Polygon(
                points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-39,42},{-39,38},{-35,40},{-39,42}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                    {-38.8728,-38.0295}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                    14.8801}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-30,50},{30,-50}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{100,0},{0,0}}, color={0,0,127}),
              Line(points={{0,2},{0,-104}}, color={255,128,0}),
              Line(points={{-35,40},{-20,40}}, color={0,0,127}),
              Line(points={{-35,13},{-20,13}}, color={0,0,127}),
              Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
              Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
              Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                    127}),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={255,128,0},
                fillColor={255,128,0},
                fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This block extracts a scalar output signal out the
vector of input signals dependent on the Integer
value of the additional u index:</p>
<pre>    y = u [ index ] ;
</pre>
<p>where index is an additional Integer input signal.</p>
</html>"));
    end Extractor;

      block Multiplex4 "Multiplexer block for four input connectors"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer n1=1 "Dimension of input signal connector 1";
        parameter Integer n2=1 "Dimension of input signal connector 2";
        parameter Integer n3=1 "Dimension of input signal connector 3";
        parameter Integer n4=1 "Dimension of input signal connector 4";
        Modelica.Blocks.Interfaces.RealInput u1[n1]
          "Connector of Real input signals 1" annotation (Placement(transformation(
                extent={{-140,70},{-100,110}})));
        Modelica.Blocks.Interfaces.RealInput u2[n2]
          "Connector of Real input signals 2" annotation (Placement(transformation(
                extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput u3[n3]
          "Connector of Real input signals 3" annotation (Placement(transformation(
                extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealInput u4[n4]
          "Connector of Real input signals 4" annotation (Placement(transformation(
                extent={{-140,-110},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4]
          "Connector of Real output signals" annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      equation
        [y] = [u1; u2; u3; u4];
        annotation (
          Documentation(info="<html>
<p>
The output connector is the <strong>concatenation</strong> of the four input connectors.
Note, that the dimensions of the input connector signals have to be
explicitly defined via parameters n1, n2, n3 and n4.
</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Line(points={{-100,90},{-60,90},{-3,4}}, color={0,0,127}),
              Line(points={{-100,30},{-60,30},{0,0}}, color={0,0,127}),
              Line(points={{-100,-30},{-60,-30},{0,0}}, color={0,0,127}),
              Line(points={{-100,-90},{-60,-90},{-5,-6}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,90},{-60,90},{0,0}}, color={0,0,127}),
              Line(points={{-100,-90},{-60,-90},{0,0}}, color={0,0,127}),
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{-100,30},{-60,30},{0,0}}, color={0,0,127}),
              Line(points={{-100,-30},{-59,-30},{0,0}}, color={0,0,127})}));
      end Multiplex4;

      block Multiplex5 "Multiplexer block for five input connectors"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer n1=1 "Dimension of input signal connector 1";
        parameter Integer n2=1 "Dimension of input signal connector 2";
        parameter Integer n3=1 "Dimension of input signal connector 3";
        parameter Integer n4=1 "Dimension of input signal connector 4";
        parameter Integer n5=1 "Dimension of input signal connector 5";
        Modelica.Blocks.Interfaces.RealInput u1[n1]
          "Connector of Real input signals 1" annotation (Placement(transformation(
                extent={{-140,80},{-100,120}})));
        Modelica.Blocks.Interfaces.RealInput u2[n2]
          "Connector of Real input signals 2" annotation (Placement(transformation(
                extent={{-140,30},{-100,70}})));
        Modelica.Blocks.Interfaces.RealInput u3[n3]
          "Connector of Real input signals 3" annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput u4[n4]
          "Connector of Real input signals 4" annotation (Placement(transformation(
                extent={{-140,-70},{-100,-30}})));
        Modelica.Blocks.Interfaces.RealInput u5[n5]
          "Connector of Real input signals 5" annotation (Placement(transformation(
                extent={{-140,-120},{-100,-80}})));
        Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4 + n5]
          "Connector of Real output signals" annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      equation
        [y] = [u1; u2; u3; u4; u5];
        annotation (
          Documentation(info="<html>
<p>
The output connector is the <strong>concatenation</strong> of the five input connectors.
Note, that the dimensions of the input connector signals have to be
explicitly defined via parameters n1, n2, n3, n4 and n5.
</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Line(points={{-100,100},{-60,100},{0,0}}, color={0,0,127}),
              Line(points={{-100,50},{-60,50},{-4,0}}, color={0,0,127}),
              Line(points={{-100,0},{-7,0}}, color={0,0,127}),
              Line(points={{-100,-50},{-60,-50},{-4,0}}, color={0,0,127}),
              Line(points={{-100,-100},{-60,-100},{0,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,100},{-60,100},{0,0}}, color={0,0,127}),
              Line(points={{-100,-100},{-60,-100},{0,0}}, color={0,0,127}),
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{-100,50},{-60,50},{-4,0}}, color={0,0,127}),
              Line(points={{-100,0},{-7,0}}, color={0,0,127}),
              Line(points={{-100,-50},{-60,-50},{-4,0}}, color={0,0,127})}));
      end Multiplex5;

      block DeMultiplex5 "DeMultiplexer block for five output connectors"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer n1=1 "Dimension of output signal connector 1";
        parameter Integer n2=1 "Dimension of output signal connector 2";
        parameter Integer n3=1 "Dimension of output signal connector 3";
        parameter Integer n4=1 "Dimension of output signal connector 4";
        parameter Integer n5=1 "Dimension of output signal connector 5";
        Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3 + n4 + n5]
          "Connector of Real input signals" annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput y1[n1]
          "Connector of Real output signals 1" annotation (Placement(transformation(
                extent={{100,70},{120,90}})));
        Modelica.Blocks.Interfaces.RealOutput y2[n2]
          "Connector of Real output signals 2" annotation (Placement(transformation(
                extent={{100,30},{120,50}})));
        Modelica.Blocks.Interfaces.RealOutput y3[n3]
          "Connector of Real output signals 3" annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealOutput y4[n4]
          "Connector of Real output signals 4" annotation (Placement(transformation(
                extent={{100,-50},{120,-30}})));
        Modelica.Blocks.Interfaces.RealOutput y5[n5]
          "Connector of Real output signals 5" annotation (Placement(transformation(
                extent={{100,-90},{120,-70}})));

      equation
        [u] = [y1; y2; y3; y4; y5];
        annotation (
          Documentation(info="<html>
<p>
The input connector is <strong>split</strong> into five output connectors.
Note, that the dimensions of the output connector signals have to be
explicitly defined via parameters n1, n2, n3, n4 and n5.</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,80},{60,80},{0,0}}, color={0,0,127}),
              Line(points={{100,40},{60,40},{8,4}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{100,-40},{60,-40},{8,-4}}, color={0,0,127}),
              Line(points={{100,-80},{60,-80},{0,0}}, color={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{100,80},{60,80},{0,0}}, color={0,0,127}),
              Line(points={{100,-80},{60,-80},{0,0}},  color={0,0,127}),
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{100,40},{60,40},{8,4}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{100,-40},{60,-40},{8,-4}}, color={0,0,127})}));
      end DeMultiplex5;

      model RealPassThrough "Pass a Real signal through without modification"
        extends Modelica.Blocks.Interfaces.SISO;
      equation
        y = u;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={0,0,127})}),
                          Documentation(info="<html>
<p>
Passes a Real signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.
</p>
</html>"));
      end RealPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),     Icon(graphics={
            Line(points={{-90,0},{4,0}}, color={95,95,95}),
            Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
            Line(points={{-8,0},{93,0}}, color={95,95,95}),
            Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real, Integer and Boolean signals"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block Constant "Generate constant signal of type Real"
        parameter Real k(start=1) "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png"));
        extends Interfaces.SO;

      equation
        y = k;
        annotation (
          defaultComponentName="const",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{-80,90},{-86,68},{-74,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(
                points={{-80,0},{80,0}},
                color={0,0,255},
                thickness=0.5),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-64},{68,-76},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-83,92},{-30,74}},
                textString="y"),
              Text(
                extent={{70,-80},{94,-100}},
                textString="time"),
              Text(
                extent={{-101,8},{-81,-12}},
                textString="k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\"
     alt=\"Constant.png\">
</p>
</html>"));
      end Constant;

      block CombiTimeTable
        "Table look-up with respect to time and linear/periodic extrapolation methods (data from matrix/file)"
        import Modelica.Blocks.Tables.Internal;
        extends Modelica.Blocks.Interfaces.MO(final nout=max([size(columns, 1); size(offset, 1)]));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation",
          groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time timeScale(
          min=Modelica.Constants.eps)=1 "Time scale of first table column"
          annotation (Dialog(group="Table data interpretation"), Evaluate=true);
        parameter Real offset[:]={0} "Offsets of output signals"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time startTime=0
          "Output = offset for time < startTime"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time shiftTime=startTime
          "Shift time of first table column"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.TimeEvents timeEvents=Modelica.Blocks.Types.TimeEvents.Always
          "Time event handling of table interpolation"
          annotation (Dialog(group="Table data interpretation", enable=smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if time is outside the table definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Modelica.SIunits.Time t_min=t_minScaled*timeScale
          "Minimum abscissa value defined in table";
        final parameter Modelica.SIunits.Time t_max=t_maxScaled*timeScale
          "Maximum abscissa value defined in table";
        final parameter Real t_minScaled=Internal.getTimeTableTmin(tableID)
          "Minimum (scaled) abscissa value defined in table";
        final parameter Real t_maxScaled=Internal.getTimeTableTmax(tableID)
          "Maximum (scaled) abscissa value defined in table";
    protected
        final parameter Real p_offset[nout]=(if size(offset, 1) == 1 then ones(nout)*offset[1] else offset)
          "Offsets of output signals";
        parameter Modelica.Blocks.Types.ExternalCombiTimeTable tableID=
            Modelica.Blocks.Types.ExternalCombiTimeTable(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              startTime/timeScale,
              columns,
              smoothness,
              extrapolation,
              shiftTime/timeScale,
              if smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments then timeEvents elseif smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then Modelica.Blocks.Types.TimeEvents.Always else Modelica.Blocks.Types.TimeEvents.NoTimeEvents,
              if tableOnFile then verboseRead else false) "External table object";
        discrete Modelica.SIunits.Time nextTimeEvent(start=0, fixed=true)
          "Next time event instant";
        discrete Real nextTimeEventScaled(start=0, fixed=true)
          "Next scaled time event instant";
        Real timeScaled "Scaled time";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTimeTableData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(time >= t_min), "
Extrapolation warning: Time (="     + String(time) + ") must be greater or equal
than the minimum abscissa value t_min (="     + String(t_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(time <= t_max), "
Extrapolation warning: Time (="     + String(time) + ") must be less or equal
than the maximum abscissa value t_max (="     + String(t_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        timeScaled = time/timeScale;
        when {time >= pre(nextTimeEvent), initial()} then
          nextTimeEventScaled = Internal.getNextTimeEvent(tableID, timeScaled);
          nextTimeEvent = if nextTimeEventScaled < Modelica.Constants.inf then nextTimeEventScaled*timeScale else Modelica.Constants.inf;
        end when;
        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = p_offset[i] + Internal.getTimeTableValueNoDer(tableID, i, timeScaled, nextTimeEventScaled, pre(nextTimeEventScaled));
          end for;
        else
          for i in 1:nout loop
            y[i] = p_offset[i] + Internal.getTimeTableValue(tableID, i, timeScaled, nextTimeEventScaled, pre(nextTimeEventScaled));
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
This block generates an output signal y[:] by <strong>constant</strong>,
<strong>linear</strong> or <strong>cubic Hermite spline interpolation</strong>
in a table. The time points and function values are stored in a matrix
<strong>table[i,j]</strong>, where the first column table[:,1] contains the
time points and the other columns contain the data to be interpolated.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png\"
     alt=\"CombiTimeTable.png\">
</p>

<p>
Via parameter <strong>columns</strong> it can be defined which columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output is computed
by interpolation of column 2 and the second output is computed
by interpolation of column 4 of the table matrix.
The table interpolation has the following properties:
</p>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>The time points need to be <strong>strictly increasing</strong> for cubic Hermite
    spline interpolation, otherwise <strong>monotonically increasing</strong>.</li>
<li><strong>Discontinuities</strong> are allowed for (constant or) linear interpolation,
    by providing the same time point twice in the table.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, no interpolation is performed and
    the table values of this row are just returned.</li>
<li>Via parameters <strong>shiftTime</strong> and <strong>offset</strong> the curve defined
    by the table can be shifted both in time and in the ordinate value.
    The time instants stored in the table are therefore <strong>relative</strong>
    to <strong>shiftTime</strong>.</li>
<li>If time &lt; startTime, no interpolation is performed and the offset
    is used as ordinate value for all outputs.</li>
<li>The table is implemented in a numerically sound way by
    generating <strong>time events</strong> at interval boundaries, in case of
    interpolation by linear segments.
    This generates continuously differentiable values for the integrator.
    Via parameter <strong>timeEvents</strong> it is defined how the time events are generated:
<pre>
  timeEvents = 1: Always generate time events at interval boundaries
             = 2: Generate time events at discontinuities (defined by duplicated sample points)
             = 3: No time events at interval boundaries
</pre>
    For interpolation by constant segments time events are always generated at interval boundaries.
    For smooth interpolation by cubic Hermite splines no time events are generated at interval boundaries.</li>
<li>Via parameter <strong>timeScale</strong> the first column of the table array can
    be scaled, e.g., if the table array is given in hours (instead of seconds)
    <strong>timeScale</strong> shall be set to 3600.</li>
<li>For special applications it is sometimes needed to know the minimum
    and maximum time instant defined in the table as a parameter. For this
    reason parameters <strong>t_min</strong>/<strong>t_minScaled</strong> and
    <strong>t_max</strong>/<strong>t_maxScaled</strong> are provided and can be
    accessed from the outside of the table object. Whereas <strong>t_min</strong> and
    <strong>t_max</strong> define the scaled abscissa values (using parameter
    <strong>timeScale</strong>) in SIunits.Time, <strong>t_minScaled</strong> and
    <strong>t_maxScaled</strong> define the unitless original abscissa values of
    the table.</li>
</ul>
<p>
Example:
</p>
<pre>
   table = [0, 0;
            1, 0;
            1, 1;
            2, 4;
            3, 9;
            4, 16];
   extrapolation = 2 (default), timeEvents = 2
If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
    e.g., time = 1.5, the output y =  2.5,
    e.g., time = 2.0, the output y =  4.0,
    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).
</pre>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(6,2)   # comment line
  0   0
  1   0
  1   1
  2   4
  3   9
  4  16
double tab2(6,2)   # another comment line
  0   0
  2   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>",     revisions="<html>
<p><strong>Release Notes:</strong></p>
<ul>
<li><em>April 09, 2013</em>
       by Thomas Beutlich:<br>
       Implemented as external object.</li>
<li><em>March 31, 2001</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Used CombiTableTime as a basis and added the
       arguments <strong>extrapolation, columns, startTime</strong>.
       This allows periodic function definitions.</li>
</ul>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
          Line(points={{-80.0,68.0},{-80.0,-80.0}},
            color={192,192,192}),
          Line(points={{-90.0,-70.0},{82.0,-70.0}},
            color={192,192,192}),
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{90.0,-70.0},{68.0,-62.0},{68.0,-78.0},{90.0,-70.0}}),
          Rectangle(lineColor={255,255,255},
            fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-48.0,-50.0},{2.0,70.0}}),
          Line(points={{-48.0,-50.0},{-48.0,70.0},{52.0,70.0},{52.0,-50.0},{-48.0,-50.0},{-48.0,-20.0},{52.0,-20.0},{52.0,10.0},{-48.0,10.0},{-48.0,40.0},{52.0,40.0},{52.0,70.0},{2.0,70.0},{2.0,-51.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,90},{20,-30}},
                lineColor={255,255,255},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-20,-30},{-20,90},{80,90},{80,-30},{-20,-30},{-20,0},{
                    80,0},{80,30},{-20,30},{-20,60},{80,60},{80,90},{20,90},{20,-30}}),
              Text(
                extent={{-71,-42},{-32,-54}},
                textString="offset"),
              Polygon(
                points={{-31,-30},{-33,-40},{-28,-40},{-31,-30}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-31,-70},{-34,-60},{-29,-60},{-31,-70},{-31,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-31,-31},{-31,-70}}, color={95,95,95}),
              Line(points={{-20,-30},{-20,-70}}, color={95,95,95}),
              Text(
                extent={{-42,-74},{6,-84}},
                textString="startTime"),
              Line(points={{-20,-30},{-80,-30}}, color={95,95,95}),
              Text(
                extent={{-73,93},{-44,74}},
                textString="y"),
              Text(
                extent={{66,-81},{92,-92}},
                textString="time"),
              Text(
                extent={{-19,83},{20,68}},
                textString="time"),
              Text(
                extent={{21,82},{50,68}},
                textString="y[1]"),
              Line(points={{50,90},{50,-30}}),
              Line(points={{80,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{34,-30},{71,-42}},
                textString="columns",
                lineColor={0,0,255}),
              Text(
                extent={{51,82},{80,68}},
                textString="y[2]")}));
      end CombiTimeTable;

      block IntegerConstant "Generate constant signal of type Integer"
        parameter Integer k(start=1) "Constant output value";
        extends Interfaces.IntegerSO;

      equation
        y = k;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-80,90},{-86,68},{-74,68},{-80,90}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),Line(points={{-80,68},{-80,-80}},
                color={95,95,95}),Line(
                  points={{-80,0},{80,0}},
                  color={0,0,255},
                  thickness=0.5),Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-81,92},{-38,74}},
                  textString="y"),Text(
                  extent={{66,-82},{94,-94}},
                  textString="time"),Text(
                  extent={{-101,8},{-81,-12}},
                  textString="k")}),
          Documentation(info="<html>
<p>
The Integer output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/IntegerConstant.png\"
     alt=\"IntegerConstant.png\">
</p>
</html>"));
      end IntegerConstant;
      annotation (Documentation(info="<html>
<p>
This package contains <strong>source</strong> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>offset</strong></td>
      <td>Value which is added to the signal</td>
  </tr>
  <tr><td><strong>startTime</strong></td>
      <td>Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <strong>offset</strong> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><em>Nov. 8, 1999</em>
       by <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><em>Oct. 31, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><em>June 29, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Tables
    "Library of blocks to interpolate in one and two-dimensional tables"
      extends Modelica.Icons.Package;

      block CombiTable1Ds
        "Table look-up in one dimension (matrix/file) with one input and n outputs"
        extends Modelica.Blocks.Interfaces.SIMO(final nout=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTable1DData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(u >= u_min), "
Extrapolation warning: The value u (="     + String(u) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(u <= u_max), "
Extrapolation warning: The value u (="     + String(u) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u);
          end for;
        else
          for i in 1:nout loop
            y[i] = Internal.getTable1DValue(tableID, i, u);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output interpolates
via column 2 and the second output interpolates via column 4 of the
table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="Univariate constant, linear or cubic Hermite spline table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-52,56},{-34,44}},
                textString="u",
                lineColor={0,0,255}),
              Text(
                extent={{-22,54},{2,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{4,54},{28,42}},
                textString="y[2]",
                lineColor={0,0,255}),
              Text(
                extent={{0,-40},{32,-54}},
                textString="columns",
                lineColor={0,0,255})}));
      end CombiTable1Ds;

      package Internal
      "Internal external object definitions for table functions that should not be directly utilized by the user"
        extends Modelica.Icons.InternalPackage;

        function readTimeTableData "Read table data from text or MATLAB MAT-file"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Boolean forceRead = false
            "= true: Force reading of table data; = false: Only read, if not yet read.";
          output Real readSuccess "Table read success";
          input Boolean verboseRead = true
            "= true: Print info message; = false: No info message";
          external"C" readSuccess = ModelicaStandardTables_CombiTimeTable_read(tableID, forceRead, verboseRead)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation(__ModelicaAssociation_Impure=true);
        end readTimeTableData;

        function getTimeTableValue
          "Interpolate 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative(
              noDerivative=nextTimeEvent,
              noDerivative=pre_nextTimeEvent) = getDerTimeTableValue);
        end getTimeTableValue;

        function getTimeTableValueNoDer
          "Interpolate 1-dim. table where first column is time (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableValueNoDer;

        function getDerTimeTableValue
          "Derivative of interpolated 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          input Real der_timeIn;
          output Real der_y;
          external"C" der_y = ModelicaStandardTables_CombiTimeTable_getDerValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent, der_timeIn)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTimeTableValue;

        function getTimeTableTmin
          "Return minimum abscissa value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          output Real timeMin "Minimum abscissa value in table";
          external"C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableTmin;

        function getTimeTableTmax
          "Return maximum abscissa value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          output Real timeMax "Maximum abscissa value in table";
          external"C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableTmax;

        function readTable1DData "Read table data from text or MATLAB MAT-file"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Boolean forceRead = false
            "= true: Force reading of table data; = false: Only read, if not yet read.";
          input Boolean verboseRead = true
            "= true: Print info message; = false: No info message";
          output Real readSuccess "Table read success";
          external"C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation(__ModelicaAssociation_Impure=true);
        end readTable1DData;

        function getNextTimeEvent
          "Return next time event value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Real timeIn;
          output Real nextTimeEvent "Next time event in table";
          external"C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getNextTimeEvent;

        function getTable1DValue "Interpolate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative = getDerTable1DValue);
        end getTable1DValue;

        function getTable1DValueNoDer
          "Interpolate 1-dim. table defined by matrix (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DValueNoDer;

        function getDerTable1DValue
          "Derivative of interpolated 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          input Real der_u;
          output Real der_y;
          external"C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTable1DValue;

        function getTable1DAbscissaUmin
          "Return minimum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMin "Minimum abscissa value in table";
          external"C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmin;

        function getTable1DAbscissaUmax
          "Return maximum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMax "Maximum abscissa value in table";
          external"C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmax;
      end Internal;
      annotation (Documentation(info="<html>
<p>This package contains blocks for one- and two-dimensional interpolation in tables.</p>
<h4>Special interest topic: Statically stored tables for real-time simulation targets</h4>
<p>Especially for use on real-time platform targets (e.g., HIL-simulators) with <strong>no file system</strong>, it is possible to statically
store tables using a function &quot;usertab&quot; in a file conventionally named &quot;usertab.c&quot;. This can be more efficient than providing the tables as Modelica parameter arrays.</p>
<p>This is achieved by providing the tables in a specific structure as C-code and compiling that C-code together with the rest of the simulation model into a binary
that can be executed on the target platform. The &quot;Resources/Data/Tables/&quot; subdirectory of the MSL installation directory contains the files
<a href=\"modelica://Modelica/Resources/Data/Tables/usertab.c\">&quot;usertab.c&quot;</a> and <a href=\"modelica://Modelica/Resources/Data/Tables/usertab.h\">&quot;usertab.h&quot;</a>
that can be used as a template for own developments. While &quot;usertab.c&quot; would be typically used unmodified, the
&quot;usertab.h&quot; needs to adapted for the own needs.</p>
<p>In order to work it is necessary that the compiler pulls in the &quot;usertab.c&quot; file. Different Modelica tools might provide different mechanisms to do so.
Please consult the respective documentation/support for your Modelica tool.</p>
<p>A possible (though a bit &quot;hackish&quot;) Modelica standard conformant approach is to pull in the required files by utilizing a &quot;dummy&quot;-function that uses the Modelica external function
interface to pull in the required &quot;usertab.c&quot;. An example how this can be done is given below.</p>
<pre>
model Test25_usertab \"Test utilizing the usertab.c interface\"
  extends Modelica.Icons.Example;
public
  Modelica.Blocks.Sources.RealExpression realExpression(y=getUsertab(t_new.y))
    annotation (Placement(transformation(extent={{-40,-34},{-10,-14}})));
  Modelica.Blocks.Tables.CombiTable1D t_new(tableOnFile=true, tableName=\"TestTable_1D_a\")
    annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
  Modelica.Blocks.Sources.Clock clock
    annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
protected
  encapsulated function getUsertab
    input Real dummy_u[:];
    output Real dummy_y;
    external \"C\" dummy_y=  mydummyfunc(dummy_u);
    annotation(IncludeDirectory=\"modelica://Modelica/Resources/Data/Tables\",
           Include = \"#include \"usertab.c\"
double mydummyfunc(double* dummy_in) {
   return 0;
}
\");
  end getUsertab;
equation
  connect(clock.y,t_new. u[1]) annotation (Line(
      points={{-59,10},{-42,10}}, color={0,0,127}));
  annotation (experiment(StartTime=0, StopTime=5), uses(Modelica(version=\"3.2.2\")));
end Test25_usertab;
</pre>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-76,-26},{80,-76}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,24},{80,-26}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,74},{80,24}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-28,74},{-28,-76}},
              color={95,95,95}),
            Line(
              points={{24,74},{24,-76}},
              color={95,95,95})}));
    end Tables;

    package Types
    "Library of constants, external objects and types with choices, especially to build menus"
      extends Modelica.Icons.TypesPackage;

      type Smoothness = enumeration(
        LinearSegments   "Table points are linearly interpolated",
        ContinuousDerivative
            "Table points are interpolated (by Akima splines) such that the first derivative is continuous",
        ConstantSegments
            "Table points are not interpolated, but the value from the previous abscissa point is returned",
        MonotoneContinuousDerivative1
            "Table points are interpolated (by Fritsch-Butland splines) such that the monotonicity is preserved and the first derivative is continuous",
        MonotoneContinuousDerivative2
            "Table points are interpolated (by Steffen splines) such that the monotonicity is preserved and the first derivative is continuous")
        "Enumeration defining the smoothness of table interpolation";

        type Extrapolation = enumeration(
        HoldLastPoint
            "Hold the first/last table point outside of the table scope",
        LastTwoPoints
            "Extrapolate by using the derivative at the first/last table points outside of the table scope",
        Periodic   "Repeat the table scope periodically",
        NoExtrapolation   "Extrapolation triggers an error")
        "Enumeration defining the extrapolation of table interpolation";

        type TimeEvents = enumeration(
        Always   "Always generate time events at interval boundaries",
        AtDiscontinuities   "Generate time events at discontinuities (defined by duplicated sample points)",
        NoTimeEvents   "No time events at interval boundaries")
        "Enumeration defining the time event handling of time table interpolation";

        type Init = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)")
        "Enumeration defining initialization of a block" annotation (Evaluate=true,
        Documentation(info="<html>
  <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
  </dl>
</html>"));

      class ExternalCombiTimeTable
        "External object of 1-dim. table where first column is time"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Modelica.SIunits.Time startTime;
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation;
          input Modelica.SIunits.Time shiftTime=0.0;
          input Modelica.Blocks.Types.TimeEvents timeEvents=Modelica.Blocks.Types.TimeEvents.Always;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTimeTable externalCombiTimeTable;
        external"C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                startTime,
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                shiftTime,
                timeEvents,
                verboseRead) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input ExternalCombiTimeTable externalCombiTimeTable;
        external"C" ModelicaStandardTables_CombiTimeTable_close(
            externalCombiTimeTable) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTimeTable;

      class ExternalCombiTable1D
        "External object of 1-dim. table defined by matrix"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTable1D externalCombiTable1D;
        external"C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                verboseRead) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input ExternalCombiTable1D externalCombiTable1D;
        external"C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTable1D;
      annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong>, <strong>constants</strong> and <strong>external objects</strong> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
    end Types;

    package Icons "Icons for Blocks"
        extends Modelica.Icons.IconsPackage;

        partial block Block "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end Block;

    partial block IntegerBlock "Basic graphical layout of Integer block"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Integer block (no declarations, no equations).
</p>
</html>"));
    end IntegerBlock;
    end Icons;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a><br></dd>
</dl>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 23, 2004</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapted all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New subpackage Examples, additional components.
       </li>
<li><em>June 20, 2000</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<pre>
   replaceable type SignalType = Real
</pre>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<pre>
   Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
</pre>
      </li>
<li><em>Sept. 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package StateGraph
  "Library of hierarchical state machine components to model discrete event and reactive systems"
  extends Modelica.Icons.Package;

  package Interfaces "Connectors and partial models"
    extends Modelica.Icons.InterfacesPackage;

    connector Step_in "Input port of a step"
      output Boolean occupied "true, if step is active" annotation (HideResult=true);
      input Boolean set "true, if transition fires and step is activated" annotation (HideResult=true);
      annotation (
     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                fillPattern=FillPattern.Solid)}),
     Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                textString="%name")}));
    end Step_in;

    connector Step_out "Output port of a step"
      output Boolean available "true, if step is active" annotation (HideResult=true);

      input Boolean reset "true, if transition fires and step is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
                                Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,50},{0,-50}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-100,100},{186,58}},
                textString="%name")}));
    end Step_out;

    connector Transition_in "Input port of a transition"
      input Boolean available
          "true, if step connected to the transition input is active"
        annotation (HideResult=true);
      output Boolean reset
          "true, if transition fires and the step connected to the transition input is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                fillPattern=FillPattern.Solid)}),
                                              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                textString="%name")}));
    end Transition_in;

    connector Transition_out "Output port of a transition"
      input Boolean occupied
          "true, if step connected to the transition output is active"
        annotation (HideResult=true);
      output Boolean set
          "true, if transition fires and step connected to the transition output becomes active"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Text(
                extent={{-100,100},{146,60}},
                textString="%name"), Rectangle(
                extent={{-100,50},{0,-50}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
    end Transition_out;

    connector CompositeStepStatePort_in
        "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are inputs)"

      input Boolean suspend
          "= true, if suspend transition of CompositeStep fires";
      input Boolean resume "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
          "Dummy variable in order that connector fulfills restriction of connector"
                                                                                  annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
    end CompositeStepStatePort_in;

    connector CompositeStepStatePort_out
        "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are outputs)"

      output Boolean suspend
          "= true, if suspend transition of CompositeStep fires";
      output Boolean resume "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
          "Dummy variable in order that connector fulfills restriction of connector"
                                                                                   annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
    end CompositeStepStatePort_out;

    partial block PartialStep
        "Partial step with one input and one output transition port"

      parameter Integer nIn(min=0) = 1 "Number of input connections";
      parameter Integer nOut(min=0) = 1 "Number of output connections";

      /* localActive is introduced since component 'Step' has Boolean variable 'active'
     and component 'StepWithSignal' has connector instance 'active' defined
     and both components inherit from PartialStep
  */
      output Boolean localActive
          "= true if step is active, otherwise the step is not active"
        annotation (HideResult=true);
      Interfaces.Step_in inPort[nIn] "Vector of step input connectors"
        annotation (Placement(transformation(extent={{-120,10},{-100,-10}})));
      Interfaces.Step_out outPort[nOut] "Vector of step output connectors"
        annotation (Placement(transformation(extent={{100,5},{110,-5}})));
  protected
      outer Interfaces.CompositeStepState stateGraphRoot;
      model OuterStatePort
        CompositeStepStatePort_in subgraphStatePort;
      end OuterStatePort;
      OuterStatePort outerStatePort;

      Boolean newActive "Value of active in the next iteration"
        annotation (HideResult=true);
      Boolean oldActive "Value of active when CompositeStep was aborted";
    initial equation
      pre(newActive) = pre(localActive);
      pre(oldActive) = pre(localActive);
    equation
      connect(outerStatePort.subgraphStatePort, stateGraphRoot.subgraphStatePort);

      // Check that connections to the connector are correct
      for i in 1:nIn loop

      assert(cardinality(inPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      for i in 1:nOut loop

      assert(cardinality(outPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      // set active state
      localActive = pre(newActive);
      newActive = if outerStatePort.subgraphStatePort.resume then
                       oldActive else
                       ( StateGraph.Temporary.anyTrue(inPort.set) or
                            localActive
                         and not StateGraph.Temporary.anyTrue(outPort.reset))
                       and not outerStatePort.subgraphStatePort.suspend;

      // Remember state for suspend action
      when outerStatePort.subgraphStatePort.suspend then
        oldActive = localActive;
      end when;

      // Report state to CompositeStep
      outerStatePort.subgraphStatePort.activeSteps = if localActive then 1.0 else 0.0;

      // Report state to input and output transitions
      for i in 1:nIn loop
        inPort[i].occupied = if i == 1 then localActive else
                                            inPort[i-1].occupied or
                                            inPort[i-1].set;
      end for;

      for i in 1:nOut loop
         outPort[i].available = if i == 1 then localActive else
                                               outPort[i-1].available and not
                                               outPort[i-1].reset;
      end for;

      // Default setting, if an inPort or an outPort is not connected
      for i in 1:nIn loop
        if cardinality(inPort[i]) == 0 then
          inPort[i].set = false;
        end if;
      end for;

      for i in 1:nOut loop
        if cardinality(outPort[i]) == 0 then
          outPort[i].reset = false;
        end if;
      end for;
    end PartialStep;

    partial block PartialTransition
        "Partial transition with input and output connections"
      input Boolean localCondition "= true, if transition may fire"
        annotation (HideResult=true);
      parameter Boolean enableTimer=false "= true, if timer is enabled"
        annotation (Evaluate=true, Dialog(group="Timer"));
      parameter Modelica.SIunits.Time waitTime(min=0) = 0
          "Wait time before transition fires"
        annotation (Dialog(group="Timer", enable=enableTimer));
      output Modelica.SIunits.Time t
          "= actual waiting time (transition will fire when t > waitTime)";
      output Boolean enableFire "= true, if all firing conditions are true";
      output Boolean fire "= true, if transition fires" annotation (HideResult=true);

      StateGraph.Interfaces.Transition_in inPort
          "Vector of transition input connectors"
        annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
      StateGraph.Interfaces.Transition_out outPort
          "Vector of transition output connectors"
        annotation (Placement(transformation(extent={{10,-5},{20,5}})));
  protected
      Modelica.SIunits.Time t_start
          "Time instant at which the transition would fire, if waitTime would be zero";
      Real t_dummy;
    initial equation
      if enableTimer then
         pre(t_start) = time;
      end if;
      pre(enableFire) = false;
    equation
      assert(cardinality(inPort) == 1,
        "Connector inPort is not connected to exactly one other connector");
      assert(cardinality(outPort) == 1,
        "Connector outPort is not connected to exactly one other connector");

      // Handling of Timer
      if enableTimer then
        when enableFire then
          t_start = time;
        end when;
        t_dummy = time - t_start;
        t = if enableFire then t_dummy else 0;
        fire = enableFire and time >= t_start + waitTime;
      else
        t_start = 0;
        t_dummy = 0;
        t = 0;
        fire = enableFire;
      end if;

      // Determine fire setting and report it to the connected step
      enableFire = localCondition and inPort.available and not outPort.occupied;
      inPort.reset = fire;
      outPort.set = fire;
    end PartialTransition;

    model CompositeStepState
        "Communication channel between CompositeSteps and steps in the CompositeStep"

      output Boolean suspend = false;
      output Boolean resume =  false;
      CompositeStepStatePort_out subgraphStatePort;

    /*
    missingInnerMessage="No \"stateGraphRoot\" component is defined on highest level
of the StateGraph. A stateGraphRoot component is automatically introduced.
In order to get rid of this message, drag StateGraph.StateGraphRoot into the
top level your model.");
*/
    equation
      suspend = subgraphStatePort.suspend;
      resume  = subgraphStatePort.resume;
      subgraphStatePort.activeStepsDummy = 0;
      annotation (
        defaultComponentName="stateGraphRoot",
        defaultComponentPrefixes="inner",
        missingInnerMessage="A \"stateGraphRoot\" component was automatically introduced.");
    end CompositeStepState;
  end Interfaces;

  block InitialStep "Initial step (= step that is active when simulation starts)"

    output Boolean active
        "= true if step is active, otherwise the step is not active";

    extends Interfaces.PartialStep;

  initial equation
    active = true;
  equation
    active = localActive;
    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,
                  0} else {255,255,255}),
              fillPattern=FillPattern.Solid),
            Rectangle(extent={{-80,80},{80,-80}})}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}}), Rectangle(extent={{-80,80},{80,-80}})}));
  end InitialStep;

  block StepWithSignal
      "Ordinary step (= step that is not active when simulation starts). Connector 'active' is true when the step is active"

    extends Interfaces.PartialStep;

    Modelica.Blocks.Interfaces.BooleanOutput active
      annotation (Placement(transformation(
            origin={0,-110},
            extent={{-10,-10},{10,10}},
            rotation=270)));
  initial equation
    active = false;
  equation
    active = localActive;
    annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}})}),
         Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,
                  0} else {255,255,255}),
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-92,-74},{94,-92}},
              textString="active")}));
  end StepWithSignal;

  block TransitionWithSignal
      "Transition where the fire condition is set by a Boolean input signal"

    Modelica.Blocks.Interfaces.BooleanInput condition
      annotation (Placement(transformation(
            origin={0,-120},
            extent={{-20,-20},{20,20}},
            rotation=90)));

    extends Interfaces.PartialTransition(final localCondition=condition);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{20,20},{200,45}},
              lineColor=DynamicSelect({0,0,0}, if enableTimer < 0.5 then {255,255,
                  255} else {0,0,0}),
              textString="%waitTime"),
            Rectangle(
              extent={{-10,100},{10,-100}},
              fillColor=DynamicSelect({0,0,0}, if enableFire > 0.5 then {0,255,0} else
                        {0,0,0}),
              fillPattern=FillPattern.Solid),
            Line(points={{-30,0},{-10,0}}),
            Text(
              extent={{200,110},{-200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{7,-81},{-7,-95}},
              lineColor=DynamicSelect({0,0,0}, if condition > 0.5 then {0,255,0} else
                        {0,0,0}),
              fillColor=DynamicSelect({0,0,0}, if condition > 0.5 then {0,255,0} else
                        {0,0,0}),
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Line(points={{-31,0},{-11,0}}),
              Rectangle(
              extent={{-10,100},{10,-100}},
              fillPattern=FillPattern.Solid)}));
  end TransitionWithSignal;

  model StateGraphRoot
      "Root of a StateGraph (has to be present on the highest level of a StateGraph)"

    extends StateGraph.Interfaces.CompositeStepState;
    output Integer activeSteps "Number of active steps within the stategraph";

  equation
    activeSteps = -integer(subgraphStatePort.activeSteps);
    annotation (
      defaultComponentName="stateGraphRoot",
      defaultComponentPrefixes="inner",
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}}),
            Text(
              extent={{-92,78},{96,34}},
              textString="root"),
            Rectangle(extent={{-82,-6},{-44,-40}}),
            Line(points={{0,10},{0,-60}}),
            Rectangle(extent={{48,-6},{86,-40}}),
            Polygon(
              points={{-12,-16},{0,-22},{-12,-28},{-12,-16}},
              fillPattern=FillPattern.Solid),
            Line(points={{-44,-22},{-12,-22}}),
            Polygon(
              points={{36,-16},{48,-22},{36,-28},{36,-16}},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-22},{36,-22}})}),
      Documentation(info="<html>
<p>
On the highest level of a StateGraph, an instance of StateGraphRoot
has to be present.
</p>
<p>
The StateGraphRoot object is needed, since all Step objects have
an \"outer\" reference to communicate with the \"nearest\" CompositeStep
(which inherits from PartialCompositeStep), especially to abort
a CompositeStep via the \"suspend\" port. Even if no \"CompositeStep\" is present,
on highest level a corresponding \"inner\" definition is needed
and is provided by the StateGraphRoot object.
</p>
</html>"));
  end StateGraphRoot;

  package Temporary
    "Components that will be provided by other libraries in the future"
    extends Modelica.Icons.Package;
    extends Modelica.Icons.ObsoleteModel;

    function anyTrue
        "Returns true, if at least on element of the Boolean input vector is true"

      extends Modelica.Icons.Function;
      extends Modelica.Icons.ObsoleteModel;
      input Boolean b[:];
      output Boolean result;
    algorithm
      result := false;
      for i in 1:size(b,1) loop
         result := result or b[i];
      end for;
    annotation (
      obsolete = "Obsolete function - use Modelica.Math.BooleanVectors.anyTrue instead",
      Documentation(info="<html></html>"));
    end anyTrue;
    annotation (obsolete = "Obsolete package due to experimental design",
    Documentation(info="<html>
<p>
This library is just temporarily present. The components of
this library will be present in the future in the Modelica
standard library (with the new block connectors) and in the
<a href=\"modelica://Modelica.Blocks.Interaction\">Interaction</a> library .
</p>
</html>"));
  end Temporary;
  annotation (
    Documentation(info="<html>
<p>
Note, there is a much improved version of this library called
\"Modelica_StateGraph2\". If this library is not yet distributed with your
Modelica tool, you can download it from
<a href=\"https://github.com/modelica/Modelica_StateGraph2\">https://github.com/modelica/Modelica_StateGraph2</a>.
In the
<a href=\"modelica://Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2\">Users Guide</a>
a detailed comparison is given. It is highly recommended to use Modelica_StateGraph2 instead
of Modelica.StateGraph.
</p>

<p>
Library <strong>StateGraph</strong> is a <strong>free</strong> Modelica package providing
components to model <strong>discrete event</strong> and <strong>reactive</strong>
systems in a convenient
way. It is based on the JGrafchart method and
takes advantage of Modelica features for
the \"action\" language. JGrafchart is a further development of
Grafcet to include elements of StateCharts that are not present
in Grafcet/Sequential Function Charts. Therefore, the StateGraph
library has a similar modeling power as StateCharts but avoids
some deficiencies of StateCharts.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.StateGraph.UsersGuide\">StateGraph.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.StateGraph.Examples\">StateGraph.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
A typical model generated with this library is shown
in the next figure where on the left hand side a two-tank
system with a tank controller and on the right hand side the
top-level part of the tank controller as a StateGraph is shown:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/StateGraph/Examples/ControlledTanks1_small.png\">

<img src=\"modelica://Modelica/Resources/Images/StateGraph/Examples/ControlledTanks2_small.png\">
</p>

<p>
The unique feature of the StateGraph library with respect to JGrafcharts,
Grafcet, Sequential Function Charts, and StateCharts, is Modelica's
\"single assignment rule\" that requires that every variable is defined
by exactly one equation. This leads to a different \"action\" definition
as in these formalisms. The advantage is that the translator can either
determine a useful evaluation sequence by equation sorting or
reports an error if this is not possible, e.g., because a model
would lead to a non-determinism or to a dead-lock. As a side effect,
this leads also to simpler and more easier to understand models and
global variables are no longer needed (whereas in JGrafcharts,
Grafcet, Sequential Function Charts and StateCharts global variables
are nearly always needed).
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"),   Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={-70.0,-0.0},
          fillColor={255,255,255},
          extent={{-20.0,-20.0},{20.0,20.0}}),
        Rectangle(
          origin={70.0,-0.0},
          fillColor={255,255,255},
          extent={{-20.0,-20.0},{20.0,20.0}}),
        Line(points={{0.0,50.0},{0.0,-50.0}}),
        Polygon(
          origin={-16.6667,0.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-3.3333,10.0},{16.667,0.0},{-3.3333,-10.0}}),
        Line(origin={-35.0,0.0}, points={{15.0,0.0},{-15.0,0.0}}),
        Polygon(
          origin={33.3333,0.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-3.3333,10.0},{16.667,0.0},{-3.3333,-10.0}}),
        Line(origin={15.0,-0.0},  points={{15.0,0.0},{-15.0,-0.0}})}));
  end StateGraph;

  package Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description"
    extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

    package Vessels "Devices for storing fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        connector VesselFluidPorts_b
          "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
          extends Interfaces.FluidPort;
          annotation (defaultComponentName="ports_b",
                      Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Text(extent={{-75,130},{75,100}}, textString="%name"),
                Rectangle(
                  extent={{-25,100},{25,-100}}),
                Ellipse(
                  extent={{-22,100},{-10,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,-69},{-12,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,100},{6,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,100},{22,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-69},{4,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{12,-69},{20,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
               Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Rectangle(
                  extent={{-50,200},{50,-200}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-44,200},{-20,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-12,200},{12,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,200},{44,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-39,-118.5},{-25,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-7,-118.5},{7,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{25,-117.5},{39,114}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end VesselFluidPorts_b;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Vessels;

    package Interfaces
    "Interfaces for steady state and unsteady, mixed-phase, multi-substance, incompressible and compressible flow"
      extends Modelica.Icons.InterfacesPackage;

      connector FluidPort
        "Interface for quasi one-dimensional fluid flow in a piping network (incompressible or compressible, one or more phases, one or more substances)"

        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
          "Medium model" annotation (choicesAllMatching=true);

        flow Medium.MassFlowRate m_flow
          "Mass flow rate from the connection point into the component";
        Medium.AbsolutePressure p "Thermodynamic pressure in the connection point";
        stream Medium.SpecificEnthalpy h_outflow
          "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        stream Medium.MassFraction Xi_outflow[Medium.nXi]
          "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        stream Medium.ExtraProperty C_outflow[Medium.nC]
          "Properties c_i/m close to the connection point if m_flow < 0";
      end FluidPort;

      connector FluidPort_a "Generic fluid connector at design inlet"
        extends FluidPort;
        annotation (defaultComponentName="port_a",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Text(extent={{-150,110},{150,50}},
                  textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_a;

      connector FluidPort_b "Generic fluid connector at design outlet"
        extends FluidPort;
        annotation (defaultComponentName="port_b",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(extent={{-150,110},{150,50}}, textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_b;

      connector FluidPorts_b
        "Fluid connector with outlined, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,-50},{15,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,15},{15,-15}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,50},{15,80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,100},{30,160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-100},{30,-160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_b;
      annotation (Documentation(info="<html>

</html>",     revisions="<html>
<ul>
<li><em>June 9th, 2008</em>
       by Michael Sielemann: Introduced stream keyword after decision at 57th Design Meeting (Lund).</li>
<li><em>May 30, 2007</em>
       by Christoph Richter: moved everything back to its original position in Modelica.Fluid.</li>
<li><em>Apr. 20, 2007</em>
       by Christoph Richter: moved parts of the original package from Modelica.Fluid
       to the development branch of Modelica 2.2.2.</li>
<li><em>Nov. 2, 2005</em>
       by Francesco Casella: restructured after 45th Design Meeting.</li>
<li><em>Nov. 20-21, 2002</em>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.
<li><em>Nov. 11, 2002</em>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><em>Nov. 6, 2002</em>
       by Hilding Elmqvist: first version.</li>
<li><em>Aug. 11, 2002</em>
       by Martin Otter: Improved according to discussion with Hilding
       Elmqvist and Hubertus Tummescheit.<br>
       The PortVicinity model is manually
       expanded in the base models.<br>
       The Volume used for components is renamed
       PartialComponentVolume.<br>
       A new volume model \"Fluid.Components.PortVolume\"
       introduced that has the medium properties of the port to which it is
       connected.<br>
       Fluid.Interfaces.PartialTwoPortTransport is a component
       for elementary two port transport elements, whereas PartialTwoPort
       is a component for a container component.</li>
</ul>
</html>"));
    end Interfaces;

    package Types "Common types for fluid models"
      extends Modelica.Icons.TypesPackage;

      type Dynamics = enumeration(
        DynamicFreeInitial
            "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial   "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
            "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",
        SteadyState   "SteadyState -- Steady state balance, Initial guess value")
        "Enumeration to define definition of balance equations"
      annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>Dynamics.</strong></th><th><strong>Meaning</strong></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Mass balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> <strong>der</strong>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Energy balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(T)=0 or <strong>der</strong>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Momentum balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <strong>true</strong>.
</p>

</html>"));

      type PortFlowDirection = enumeration(
        Entering   "Fluid flow is only entering",
        Leaving   "Fluid flow is only leaving",
        Bidirectional   "No restrictions on fluid flow (flow reversal possible)")
        "Enumeration to define whether flow reversal is allowed" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>PortFlowDirection.</strong></th>
    <th><strong>Meaning</strong></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));
      annotation (preferredView="info",
                  Documentation(info="<html>

</html>"));
    end Types;

    package Utilities
    "Utility models to construct fluid components (should not be used directly)"
      extends Modelica.Icons.UtilitiesPackage;

      function checkBoundary "Check whether boundary definition is correct"
        extends Modelica.Icons.Function;
        input String mediumName;
        input String substanceNames[:] "Names of substances";
        input Boolean singleState;
        input Boolean define_p;
        input Real X_boundary[:];
        input String modelName = "??? boundary ???";
    protected
        Integer nX = size(X_boundary,1);
        String X_str;
      algorithm
        assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""     + modelName + "\":
The selected medium \""     + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

        for i in 1:nX loop
          assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
      + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary("   + String(i) + ") = " + String(
            X_boundary[i]) + "
is negative. It must be positive.
");     end for;

        if nX > 0 and abs(sum(X_boundary) - 1.0) > 1e-10 then
           X_str :="";
           for i in 1:nX loop
              X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
              i]) + " \"" + substanceNames[i] + "\"\n";
           end for;
           Modelica.Utilities.Streams.error(
              "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
              "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
              + X_str);
        end if;
      end checkBoundary;

      function regStep
        "Approximation of a general step, such that the characteristic is continuous and differentiable"
        extends Modelica.Icons.Function;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > 0";
        input Real y2 "Ordinate value for x < 0";
        input Real x_small(min=0) = 1e-5
          "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
        output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := smooth(1, if x >  x_small then y1 else
                       if x < -x_small then y2 else
                       if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
        annotation(Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",       info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
      end regStep;

      function cubicHermite "Evaluate a cubic Hermite spline"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";
        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;
          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite;
      annotation (Documentation(info="<html>

</html>"));
    end Utilities;
  annotation (Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            fillPattern=FillPattern.Solid)}), preferredView="info",
    Documentation(info="<html>
<p>
Library <strong>Modelica.Fluid</strong> is a <strong>free</strong> Modelica package providing components for
<strong>1-dimensional thermo-fluid flow</strong> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica.Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/HeatingSystem.png\" border=\"1\"
     alt=\"HeatingSystem.png\">
</p>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide\">Modelica.Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide.ReleaseNotes\">Modelica.Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Fluid.Examples\">Modelica.Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 2002-2019, Modelica Association and contributors
</p>
</html>"));
  end Fluid;

  package Media "Library of media property models"
  extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

  package Interfaces "Interfaces for media models"
    extends Modelica.Icons.InterfacesPackage;

    partial package PartialMedium
      "Partial medium properties (base package of all media packages)"
      extends Modelica.Media.Interfaces.Types;
      extends Modelica.Icons.MaterialPropertiesPackage;

      // Constants to be set in Medium
      constant Modelica.Media.Interfaces.Choices.IndependentVariables
        ThermoStates "Enumeration type for independent variables";
      constant String mediumName="unusablePartialMedium" "Name of the medium";
      constant String substanceNames[:]={mediumName}
        "Names of the mixture substances. Set substanceNames={mediumName} if only one substance.";
      constant String extraPropertiesNames[:]=fill("", 0)
        "Names of the additional (extra) transported properties. Set extraPropertiesNames=fill(\"\",0) if unused";
      constant Boolean singleState
        "= true, if u and d are not a function of pressure";
      constant Boolean reducedX=true
        "= true if medium contains the equation sum(X) = 1.0; set reducedX=true if only one substance (see docu for details)";
      constant Boolean fixedX=false
        "= true if medium contains the equation X = reference_X";
      constant AbsolutePressure reference_p=101325
        "Reference pressure of Medium: default 1 atmosphere";
      constant Temperature reference_T=298.15
        "Reference temperature of Medium: default 25 deg Celsius";
      constant MassFraction reference_X[nX]=fill(1/nX, nX)
        "Default mass fractions of medium";
      constant AbsolutePressure p_default=101325
        "Default value for pressure of medium (for initialization)";
      constant Temperature T_default=Modelica.SIunits.Conversions.from_degC(20)
        "Default value for temperature of medium (for initialization)";
      constant SpecificEnthalpy h_default=specificEnthalpy_pTX(
              p_default,
              T_default,
              X_default)
        "Default value for specific enthalpy of medium (for initialization)";
      constant MassFraction X_default[nX]=reference_X
        "Default value for mass fractions of medium (for initialization)";
      constant ExtraProperty C_default[nC]=fill(0, nC)
        "Default value for trace substances of medium (for initialization)";

      final constant Integer nS=size(substanceNames, 1) "Number of substances";
      constant Integer nX=nS "Number of mass fractions";
      constant Integer nXi=if fixedX then 0 else if reducedX then nS - 1 else nS
        "Number of structurally independent mass fractions (see docu for details)";

      final constant Integer nC=size(extraPropertiesNames, 1)
        "Number of extra (outside of standard mass-balance) transported properties";
      constant Real C_nominal[nC](min=fill(Modelica.Constants.eps, nC)) = 1.0e-6*
        ones(nC) "Default for the nominal values for the extra properties";
      replaceable record FluidConstants =
          Modelica.Media.Interfaces.Types.Basic.FluidConstants
        "Critical, triple, molecular and other standard data of fluid";

      replaceable record ThermodynamicState
        "Minimal variable set that is available as input argument to every medium function"
        extends Modelica.Icons.Record;
      end ThermodynamicState;

      replaceable partial model BaseProperties
        "Base properties (p, d, T, h, u, R, MM and, if applicable, X and Xi) of a medium"
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi(start=reference_X[1:nXi])
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Density d "Density of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        SpecificInternalEnergy u "Specific internal energy of medium";
        SpecificHeatCapacity R "Gas constant (of mixture if applicable)";
        MolarMass MM "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        SI.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        SI.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input SI.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input SI.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input SI.MassFraction
          "Mass fraction as input signal connector";

      equation
        if standardOrderComponents then
          Xi = X[1:nXi];

          if fixedX then
            X = reference_X;
          end if;
          if reducedX and not fixedX then
            X[nX] = 1 - sum(Xi);
          end if;
          for i in 1:nX loop
            assert(X[i] >= -1.e-5 and X[i] <= 1 + 1.e-5, "Mass fraction X[" +
              String(i) + "] = " + String(X[i]) + "of substance " +
              substanceNames[i] + "\nof medium " + mediumName +
              " is not in the range 0..1");
          end for;

        end if;

        assert(p >= 0.0, "Pressure (= " + String(p) + " Pa) of medium \"" +
          mediumName + "\" is negative\n(Temperature = " + String(T) + " K)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}), Text(
                extent={{-152,164},{152,102}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
Model <strong>BaseProperties</strong> is a model within package <strong>PartialMedium</strong>
and contains the <strong>declarations</strong> of the minimum number of
variables that every medium model is supposed to support.
A specific medium inherits from model <strong>BaseProperties</strong> and provides
the equations for the basic properties.</p>
<p>
The BaseProperties model contains the following <strong>7+nXi variables</strong>
(nXi is the number of independent mass fractions defined in package
PartialMedium):
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>
In order to implement an actual medium model, one can extend from this
base model and add <strong>5 equations</strong> that provide relations among
these variables. Equations will also have to be added in order to
set all the variables within the ThermodynamicState record state.</p>
<p>
If standardOrderComponents=true, the full composition vector X[nX]
is determined by the equations contained in this base class, depending
on the independent mass fraction vector Xi[nXi].</p>
<p>Additional <strong>2 + nXi</strong> equations will have to be provided
when using the BaseProperties model, in order to fully specify the
thermodynamic conditions. The input connector qualifier applied to
p, h, and nXi indirectly declares the number of missing equations,
permitting advanced equation balance checking by Modelica tools.
Please note that this doesn't mean that the additional equations
should be connection equations, nor that exactly those variables
should be supplied, in order to complete the model.
For further information, see the Modelica.Media User's guide, and
Section 4.7 (Balanced Models) of the Modelica 3.0 specification.</p>
</html>"));
      end BaseProperties;

      replaceable partial function setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_pTX;

      replaceable partial function setState_phX
        "Return thermodynamic state as function of p, h and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_phX;

      replaceable partial function setState_psX
        "Return thermodynamic state as function of p, s and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_psX;

      replaceable partial function setState_dTX
        "Return thermodynamic state as function of d, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_dTX;

      replaceable partial function setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        extends Modelica.Icons.Function;
        input Real x "m_flow or dp";
        input ThermodynamicState state_a "Thermodynamic state if x > 0";
        input ThermodynamicState state_b "Thermodynamic state if x < 0";
        input Real x_small(min=0)
          "Smooth transition in the region -x_small < x < x_small";
        output ThermodynamicState state
          "Smooth thermodynamic state for all x (continuous and differentiable)";
        annotation (Documentation(info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    state = <strong>if</strong> x &gt; 0 <strong>then</strong> state_a <strong>else</strong> state_b;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   state := <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> state_a <strong>else</strong>
                      <strong>if</strong> x &lt; -x_small <strong>then</strong> state_b <strong>else</strong> f(state_a, state_b));
</pre>

<p>
This is performed by applying function <strong>Media.Common.smoothStep</strong>(..)
on every element of the thermodynamic state record.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(state.X) = 1, provided sum(state_a.X) = sum(state_b.X) = 1.
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise state.X is either state_a.X or state_b.X):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>

</html>"));
      end setSmoothState;

      replaceable partial function dynamicViscosity "Return dynamic viscosity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DynamicViscosity eta "Dynamic viscosity";
      end dynamicViscosity;

      replaceable partial function thermalConductivity
        "Return thermal conductivity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output ThermalConductivity lambda "Thermal conductivity";
      end thermalConductivity;

      replaceable function prandtlNumber "Return the Prandtl number"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output PrandtlNumber Pr "Prandtl number";
      algorithm
        Pr := dynamicViscosity(state)*specificHeatCapacityCp(state)/
          thermalConductivity(state);
      end prandtlNumber;

      replaceable partial function pressure "Return pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output AbsolutePressure p "Pressure";
      end pressure;

      replaceable partial function temperature "Return temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Temperature T "Temperature";
      end temperature;

      replaceable partial function density "Return density"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density d "Density";
      end density;

      replaceable partial function specificEnthalpy "Return specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnthalpy h "Specific enthalpy";
      end specificEnthalpy;

      replaceable partial function specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy u "Specific internal energy";
      end specificInternalEnergy;

      replaceable partial function specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEntropy s "Specific entropy";
      end specificEntropy;

      replaceable partial function specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy g "Specific Gibbs energy";
      end specificGibbsEnergy;

      replaceable partial function specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy f "Specific Helmholtz energy";
      end specificHelmholtzEnergy;

      replaceable partial function specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
      end specificHeatCapacityCp;

      function heatCapacity_cp = specificHeatCapacityCp
        "Alias for deprecated name";

      replaceable partial function specificHeatCapacityCv
        "Return specific heat capacity at constant volume"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cv
          "Specific heat capacity at constant volume";
      end specificHeatCapacityCv;

      function heatCapacity_cv = specificHeatCapacityCv
        "Alias for deprecated name";

      replaceable partial function isentropicExponent
        "Return isentropic exponent"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsentropicExponent gamma "Isentropic exponent";
      end isentropicExponent;

      replaceable partial function isentropicEnthalpy
        "Return isentropic enthalpy"
        extends Modelica.Icons.Function;
        input AbsolutePressure p_downstream "Downstream pressure";
        input ThermodynamicState refState "Reference state for entropy";
        output SpecificEnthalpy h_is "Isentropic enthalpy";
        annotation (Documentation(info="<html>
<p>
This function computes an isentropic state transformation:
</p>
<ol>
<li> A medium is in a particular state, refState.</li>
<li> The enthalpy at another state (h_is) shall be computed
     under the assumption that the state transformation from refState to h_is
     is performed with a change of specific entropy ds = 0 and the pressure of state h_is
     is p_downstream and the composition X upstream and downstream is assumed to be the same.</li>
</ol>

</html>"));
      end isentropicEnthalpy;

      replaceable partial function velocityOfSound "Return velocity of sound"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output VelocityOfSound a "Velocity of sound";
      end velocityOfSound;

      replaceable partial function isobaricExpansionCoefficient
        "Return overall the isobaric expansion coefficient beta"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsobaricExpansionCoefficient beta "Isobaric expansion coefficient";
        annotation (Documentation(info="<html>
<pre>
beta is defined as  1/v * der(v,T), with v = 1/d, at constant pressure p.
</pre>
</html>"));
      end isobaricExpansionCoefficient;

      function beta = isobaricExpansionCoefficient
        "Alias for isobaricExpansionCoefficient for user convenience";

      replaceable partial function isothermalCompressibility
        "Return overall the isothermal compressibility factor"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SI.IsothermalCompressibility kappa "Isothermal compressibility";
        annotation (Documentation(info="<html>
<pre>

kappa is defined as - 1/v * der(v,p), with v = 1/d at constant temperature T.

</pre>
</html>"));
      end isothermalCompressibility;

      function kappa = isothermalCompressibility
        "Alias of isothermalCompressibility for user convenience";

      // explicit derivative functions for finite element models
      replaceable partial function density_derp_h
        "Return density derivative w.r.t. pressure at const specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddph "Density derivative w.r.t. pressure";
      end density_derp_h;

      replaceable partial function density_derh_p
        "Return density derivative w.r.t. specific enthalpy at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByEnthalpy ddhp
          "Density derivative w.r.t. specific enthalpy";
      end density_derh_p;

      replaceable partial function density_derp_T
        "Return density derivative w.r.t. pressure at const temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddpT "Density derivative w.r.t. pressure";
      end density_derp_T;

      replaceable partial function density_derT_p
        "Return density derivative w.r.t. temperature at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByTemperature ddTp
          "Density derivative w.r.t. temperature";
      end density_derT_p;

      replaceable partial function density_derX
        "Return density derivative w.r.t. mass fraction"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density[nX] dddX "Derivative of density w.r.t. mass fraction";
      end density_derX;

      replaceable partial function molarMass
        "Return the molar mass of the medium"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output MolarMass MM "Mixture molar mass";
      end molarMass;

      replaceable function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_pTX(
                p,
                T,
                X));
        annotation (inverse(T=temperature_phX(
                      p,
                      h,
                      X)));
      end specificEnthalpy_pTX;

      replaceable function specificEntropy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEntropy s "Specific entropy";
      algorithm
        s := specificEntropy(setState_pTX(
                p,
                T,
                X));

        annotation (inverse(T=temperature_psX(
                      p,
                      s,
                      X)));
      end specificEntropy_pTX;

      replaceable function density_pTX "Return density from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                X));
      end density_pTX;

      replaceable function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_phX(
                p,
                h,
                X));
      end temperature_phX;

      replaceable function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      replaceable function temperature_psX
        "Return temperature from p,s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_psX(
                p,
                s,
                X));
        annotation (inverse(s=specificEntropy_pTX(
                      p,
                      T,
                      X)));
      end temperature_psX;

      replaceable function density_psX "Return density from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_psX(
                p,
                s,
                X));
      end density_psX;

      replaceable function specificEnthalpy_psX
        "Return specific enthalpy from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_psX(
                p,
                s,
                X));
      end specificEnthalpy_psX;

      type MassFlowRate = SI.MassFlowRate (
          quantity="MassFlowRate." + mediumName,
          min=-1.0e5,
          max=1.e5) "Type for mass flow rate with medium specific attributes";

      // Only for backwards compatibility to version 3.2 (
      // (do not use these definitions in new models, but use Modelica.Media.Interfaces.Choices instead)
      package Choices = Modelica.Media.Interfaces.Choices annotation (obsolete=
            "Use Modelica.Media.Interfaces.Choices");

      annotation (Documentation(info="<html>
<p>
<strong>PartialMedium</strong> is a package and contains all <strong>declarations</strong> for
a medium. This means that constants, models, and functions
are defined that every medium is supposed to support
(some of them are optional). A medium package
inherits from <strong>PartialMedium</strong> and provides the
equations for the medium. The details of this package
are described in
<a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.
</p>
</html>",   revisions="<html>

</html>"));
    end PartialMedium;

    partial package PartialPureSubstance
      "Base class for pure substances of one chemical substance"
      extends PartialMedium(final reducedX=true, final fixedX=true);

      replaceable function setState_pT "Return thermodynamic state from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_pTX(
                p,
                T,
                fill(0, 0));
      end setState_pT;

      replaceable function setState_ph "Return thermodynamic state from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_phX(
                p,
                h,
                fill(0, 0));
      end setState_ph;

      replaceable function setState_ps "Return thermodynamic state from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_psX(
                p,
                s,
                fill(0, 0));
      end setState_ps;

      replaceable function setState_dT "Return thermodynamic state from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_dTX(
                d,
                T,
                fill(0, 0));
      end setState_dT;

      replaceable function density_ph "Return density from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Density d "Density";
      algorithm
        d := density_phX(
                p,
                h,
                fill(0, 0));
      end density_ph;

      replaceable function temperature_ph "Return temperature from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_phX(
                p,
                h,
                fill(0, 0));
      end temperature_ph;

      replaceable function pressure_dT "Return pressure from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output AbsolutePressure p "Pressure";
      algorithm
        p := pressure(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end pressure_dT;

      replaceable function specificEnthalpy_dT
        "Return specific enthalpy from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end specificEnthalpy_dT;

      replaceable function specificEnthalpy_ps
        "Return specific enthalpy from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_psX(
                p,
                s,
                fill(0, 0));
      end specificEnthalpy_ps;

      replaceable function temperature_ps "Return temperature from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_psX(
                p,
                s,
                fill(0, 0));
      end temperature_ps;

      replaceable function density_ps "Return density from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Density d "Density";
      algorithm
        d := density_psX(
                p,
                s,
                fill(0, 0));
      end density_ps;

      replaceable function specificEnthalpy_pT
        "Return specific enthalpy from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_pTX(
                p,
                T,
                fill(0, 0));
      end specificEnthalpy_pT;

      replaceable function density_pT "Return density from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                fill(0, 0)));
      end density_pT;

      redeclare replaceable partial model extends BaseProperties(final
          standardOrderComponents=true)
      end BaseProperties;
    end PartialPureSubstance;

    partial package PartialMixtureMedium
      "Base class for pure substances of several chemical substances"
      extends PartialMedium(redeclare replaceable record FluidConstants =
            Modelica.Media.Interfaces.Types.IdealGas.FluidConstants);

      redeclare replaceable record extends ThermodynamicState
        "Thermodynamic state variables"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
      end ThermodynamicState;

      constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

      replaceable function gasConstant
        "Return the gas constant of the mixture (also for liquids)"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        output SI.SpecificHeatCapacity R "Mixture gas constant";
      end gasConstant;

      function moleToMassFractions "Return mass fractions X from mole fractions"
        extends Modelica.Icons.Function;
        input SI.MoleFraction moleFractions[:] "Mole fractions of mixture";
        input MolarMass[:] MMX "Molar masses of components";
        output SI.MassFraction X[size(moleFractions, 1)]
          "Mass fractions of gas mixture";
    protected
        MolarMass Mmix=moleFractions*MMX "Molar mass of mixture";
      algorithm
        for i in 1:size(moleFractions, 1) loop
          X[i] := moleFractions[i]*MMX[i]/Mmix;
        end for;
        annotation (smoothOrder=5);
      end moleToMassFractions;

      function massToMoleFractions "Return mole fractions from mass fractions X"
        extends Modelica.Icons.Function;
        input SI.MassFraction X[:] "Mass fractions of mixture";
        input SI.MolarMass[:] MMX "Molar masses of components";
        output SI.MoleFraction moleFractions[size(X, 1)]
          "Mole fractions of gas mixture";
    protected
        Real invMMX[size(X, 1)] "Inverses of molar weights";
        SI.MolarMass Mmix "Molar mass of mixture";
      algorithm
        for i in 1:size(X, 1) loop
          invMMX[i] := 1/MMX[i];
        end for;
        Mmix := 1/(X*invMMX);
        for i in 1:size(X, 1) loop
          moleFractions[i] := Mmix*X[i]/MMX[i];
        end for;
        annotation (smoothOrder=5);
      end massToMoleFractions;

    end PartialMixtureMedium;

    partial package PartialCondensingGases
      "Base class for mixtures of condensing and non-condensing gases"
      extends PartialMixtureMedium(ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pTX);

      replaceable partial function saturationPressure
        "Return saturation pressure of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature Tsat "Saturation temperature";
        output AbsolutePressure psat "Saturation pressure";
      end saturationPressure;

      replaceable partial function enthalpyOfVaporization
        "Return vaporization enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy r0 "Vaporization enthalpy";
      end enthalpyOfVaporization;

      replaceable partial function enthalpyOfLiquid
        "Return liquid enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Liquid enthalpy";
      end enthalpyOfLiquid;

      replaceable partial function enthalpyOfGas
        "Return enthalpy of non-condensing gas mixture"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        input MassFraction[:] X "Vector of mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfGas;

      replaceable partial function enthalpyOfCondensingGas
        "Return enthalpy of condensing gas (most often steam)"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfCondensingGas;

      replaceable partial function enthalpyOfNonCondensingGas
        "Return enthalpy of the non-condensing species"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfNonCondensingGas;
    end PartialCondensingGases;

    partial package PartialSimpleMedium
      "Medium model with linear dependency of u, h from temperature. All other quantities, especially density, are constant."

      extends Interfaces.PartialPureSubstance(final ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
          final singleState=true);

      constant SpecificHeatCapacity cp_const
        "Constant specific heat capacity at constant pressure";
      constant SpecificHeatCapacity cv_const
        "Constant specific heat capacity at constant volume";
      constant Density d_const "Constant density";
      constant DynamicViscosity eta_const "Constant dynamic viscosity";
      constant ThermalConductivity lambda_const "Constant thermal conductivity";
      constant VelocityOfSound a_const "Constant velocity of sound";
      constant Temperature T_min "Minimum temperature valid for medium model";
      constant Temperature T_max "Maximum temperature valid for medium model";
      constant Temperature T0=reference_T "Zero enthalpy temperature";
      constant MolarMass MM_const "Molar mass";

      constant FluidConstants[nS] fluidConstants "Fluid constants";

      redeclare record extends ThermodynamicState "Thermodynamic state"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
      end ThermodynamicState;

      redeclare replaceable model extends BaseProperties(T(stateSelect=if
              preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
              StateSelect.default)) "Base properties"
      equation
        assert(T >= T_min and T <= T_max, "
Temperature T (= "   + String(T) + " K) is not
in the allowed range ("   + String(T_min) + " K <= T <= " + String(T_max) + " K)
required from medium model \""   + mediumName + "\".
");

        // h = cp_const*(T-T0);
        h = specificEnthalpy_pTX(
                p,
                T,
                X);
        u = cv_const*(T - T0);
        d = d_const;
        R = 0;
        MM = MM_const;
        state.T = T;
        state.p = p;
        annotation (Documentation(info="<html>
<p>
This is the most simple incompressible medium model, where
specific enthalpy h and specific internal energy u are only
a function of temperature T and all other provided medium
quantities are assumed to be constant.
Note that the (small) influence of the pressure term p/d is neglected.
</p>
</html>"));
      end BaseProperties;

      redeclare function setState_pTX
        "Return thermodynamic state from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T);
      end setState_pTX;

      redeclare function setState_phX
        "Return thermodynamic state from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T0 + h/cp_const);
      end setState_phX;

      redeclare replaceable function setState_psX
        "Return thermodynamic state from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=Modelica.Math.exp(s/cp_const +
          Modelica.Math.log(reference_T)))
          "Here the incompressible limit is used, with cp as heat capacity";
      end setState_psX;

      redeclare function setState_dTX
        "Return thermodynamic state from d, T, and X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        assert(false,
          "Pressure can not be computed from temperature and density for an incompressible fluid!");
      end setState_dTX;

      redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
      algorithm
        state := ThermodynamicState(p=Media.Common.smoothStep(
                x,
                state_a.p,
                state_b.p,
                x_small), T=Media.Common.smoothStep(
                x,
                state_a.T,
                state_b.T,
                x_small));
      end setSmoothState;

      redeclare function extends dynamicViscosity "Return dynamic viscosity"

      algorithm
        eta := eta_const;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Return thermal conductivity"

      algorithm
        lambda := lambda_const;
      end thermalConductivity;

      redeclare function extends pressure "Return pressure"

      algorithm
        p := state.p;
      end pressure;

      redeclare function extends temperature "Return temperature"

      algorithm
        T := state.T;
      end temperature;

      redeclare function extends density "Return density"

      algorithm
        d := d_const;
      end density;

      redeclare function extends specificEnthalpy "Return specific enthalpy"

      algorithm
        h := cp_const*(state.T - T0);
      end specificEnthalpy;

      redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"

      algorithm
        cp := cp_const;
      end specificHeatCapacityCp;

      redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume"

      algorithm
        cv := cv_const;
      end specificHeatCapacityCv;

      redeclare function extends isentropicExponent "Return isentropic exponent"

      algorithm
        gamma := cp_const/cv_const;
      end isentropicExponent;

      redeclare function extends velocityOfSound "Return velocity of sound"

      algorithm
        a := a_const;
      end velocityOfSound;

      redeclare function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[nX] "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := cp_const*(T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific enthalpy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificEnthalpy_pTX;

      redeclare function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := T0 + h/cp_const;
      end temperature_phX;

      redeclare function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      redeclare function extends specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        //  u := cv_const*(state.T - T0) - reference_p/d_const;
        u := cv_const*(state.T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific internal energy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificInternalEnergy;

      redeclare function extends specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
      algorithm
        s := cv_const*Modelica.Math.log(state.T/T0);
      end specificEntropy;

      redeclare function extends specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := specificEnthalpy(state) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := specificInternalEnergy(state) - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
      algorithm
        h_is := cp_const*(temperature(refState) - T0);
      end isentropicEnthalpy;

      redeclare function extends isobaricExpansionCoefficient
        "Returns overall the isobaric expansion coefficient beta"
      algorithm
        beta := 0.0;
      end isobaricExpansionCoefficient;

      redeclare function extends isothermalCompressibility
        "Returns overall the isothermal compressibility factor"
      algorithm
        kappa := 0;
      end isothermalCompressibility;

      redeclare function extends density_derp_T
        "Returns the partial derivative of density with respect to pressure at constant temperature"
      algorithm
        ddpT := 0;
      end density_derp_T;

      redeclare function extends density_derT_p
        "Returns the partial derivative of density with respect to temperature at constant pressure"
      algorithm
        ddTp := 0;
      end density_derT_p;

      redeclare function extends density_derX
        "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
      algorithm
        dddX := fill(0, nX);
      end density_derX;

      redeclare function extends molarMass "Return the molar mass of the medium"
      algorithm
        MM := MM_const;
      end molarMass;
    end PartialSimpleMedium;

    package Choices "Types, constants to define menu choices"
      extends Modelica.Icons.Package;

      type IndependentVariables = enumeration(
        T   "Temperature",
        pT   "Pressure, Temperature",
        ph   "Pressure, Specific Enthalpy",
        phX   "Pressure, Specific Enthalpy, Mass Fraction",
        pTX   "Pressure, Temperature, Mass Fractions",
        dTX   "Density, Temperature, Mass Fractions")
        "Enumeration defining the independent variables of a medium";
      annotation (Documentation(info="<html>
<p>
Enumerations and data types for all types of fluids
</p>

<p>
Note: Reference enthalpy might have to be extended with enthalpy of formation.
</p>
</html>"));
    end Choices;

    package Types "Types to be used in fluid models"
      extends Modelica.Icons.Package;

      type AbsolutePressure = SI.AbsolutePressure (
          min=0,
          max=1.e8,
          nominal=1.e5,
          start=1.e5)
        "Type for absolute pressure with medium specific attributes";

      type Density = SI.Density (
          min=0,
          max=1.e5,
          nominal=1,
          start=1) "Type for density with medium specific attributes";

      type DynamicViscosity = SI.DynamicViscosity (
          min=0,
          max=1.e8,
          nominal=1.e-3,
          start=1.e-3)
        "Type for dynamic viscosity with medium specific attributes";

      type EnthalpyFlowRate = SI.EnthalpyFlowRate (
          nominal=1000.0,
          min=-1.0e8,
          max=1.e8) "Type for enthalpy flow rate with medium specific attributes";

      type MassFraction = Real (
          quantity="MassFraction",
          final unit="kg/kg",
          min=0,
          max=1,
          nominal=0.1) "Type for mass fraction with medium specific attributes";

      type MolarMass = SI.MolarMass (
          min=0.001,
          max=0.25,
          nominal=0.032) "Type for molar mass with medium specific attributes";

      type MolarVolume = SI.MolarVolume (
          min=1e-6,
          max=1.0e6,
          nominal=1.0) "Type for molar volume with medium specific attributes";

      type IsentropicExponent = SI.RatioOfSpecificHeatCapacities (
          min=1,
          max=500000,
          nominal=1.2,
          start=1.2)
        "Type for isentropic exponent with medium specific attributes";

      type SpecificEnergy = SI.SpecificEnergy (
          min=-1.0e8,
          max=1.e8,
          nominal=1.e6)
        "Type for specific energy with medium specific attributes";

      type SpecificInternalEnergy = SpecificEnergy
        "Type for specific internal energy with medium specific attributes";

      type SpecificEnthalpy = SI.SpecificEnthalpy (
          min=-1.0e10,
          max=1.e10,
          nominal=1.e6)
        "Type for specific enthalpy with medium specific attributes";

      type SpecificEntropy = SI.SpecificEntropy (
          min=-1.e7,
          max=1.e7,
          nominal=1.e3)
        "Type for specific entropy with medium specific attributes";

      type SpecificHeatCapacity = SI.SpecificHeatCapacity (
          min=0,
          max=1.e7,
          nominal=1.e3,
          start=1.e3)
        "Type for specific heat capacity with medium specific attributes";

      type Temperature = SI.Temperature (
          min=1,
          max=1.e4,
          nominal=300,
          start=288.15) "Type for temperature with medium specific attributes";

      type ThermalConductivity = SI.ThermalConductivity (
          min=0,
          max=500,
          nominal=1,
          start=1)
        "Type for thermal conductivity with medium specific attributes";

      type PrandtlNumber = SI.PrandtlNumber (
          min=1e-3,
          max=1e5,
          nominal=1.0) "Type for Prandtl number with medium specific attributes";

      type VelocityOfSound = SI.Velocity (
          min=0,
          max=1.e5,
          nominal=1000,
          start=1000)
        "Type for velocity of sound with medium specific attributes";

      type ExtraProperty = Real (min=0.0, start=1.0)
        "Type for unspecified, mass-specific property transported by flow";

      type ExtraPropertyFlowRate = Real (unit="kg/s")
        "Type for flow rate of unspecified, mass-specific property";

      type IsobaricExpansionCoefficient = Real (
          min=0,
          max=1.0e8,
          unit="1/K")
        "Type for isobaric expansion coefficient with medium specific attributes";

      type DipoleMoment = Real (
          min=0.0,
          max=2.0,
          unit="debye",
          quantity="ElectricDipoleMoment")
        "Type for dipole moment with medium specific attributes";

      type DerDensityByPressure = SI.DerDensityByPressure
        "Type for partial derivative of density with respect to pressure with medium specific attributes";

      type DerDensityByEnthalpy = SI.DerDensityByEnthalpy
        "Type for partial derivative of density with respect to enthalpy with medium specific attributes";

      type DerDensityByTemperature = SI.DerDensityByTemperature
        "Type for partial derivative of density with respect to temperature with medium specific attributes";

      package Basic
      "The most basic version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants
          "Critical, triple, molecular and other standard data of fluid"
          extends Modelica.Icons.Record;
          String iupacName
            "Complete IUPAC name (or common name, if non-existent)";
          String casRegistryNumber
            "Chemical abstracts sequencing number (if it exists)";
          String chemicalFormula
            "Chemical formula, (brutto, nomenclature according to Hill";
          String structureFormula "Chemical structure formula";
          MolarMass molarMass "Molar mass";
        end FluidConstants;
      end Basic;

      package IdealGas
      "The ideal gas version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants "Extended fluid constants"
          extends Modelica.Media.Interfaces.Types.Basic.FluidConstants;
          Temperature criticalTemperature "Critical temperature";
          AbsolutePressure criticalPressure "Critical pressure";
          MolarVolume criticalMolarVolume "Critical molar Volume";
          Real acentricFactor "Pitzer acentric factor";
          //   Temperature triplePointTemperature "Triple point temperature";
          //   AbsolutePressure triplePointPressure "Triple point pressure";
          Temperature meltingPoint "Melting point at 101325 Pa";
          Temperature normalBoilingPoint "Normal boiling point (at 101325 Pa)";
          DipoleMoment dipoleMoment
            "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
          Boolean hasIdealGasHeatCapacity=false
            "True if ideal gas heat capacity is available";
          Boolean hasCriticalData=false "True if critical data are known";
          Boolean hasDipoleMoment=false "True if a dipole moment known";
          Boolean hasFundamentalEquation=false "True if a fundamental equation";
          Boolean hasLiquidHeatCapacity=false
            "True if liquid heat capacity is available";
          Boolean hasSolidHeatCapacity=false
            "True if solid heat capacity is available";
          Boolean hasAccurateViscosityData=false
            "True if accurate data for a viscosity function is available";
          Boolean hasAccurateConductivityData=false
            "True if accurate data for thermal conductivity is available";
          Boolean hasVapourPressureCurve=false
            "True if vapour pressure data, e.g., Antoine coefficients are known";
          Boolean hasAcentricFactor=false
            "True if Pitzer acentric factor is known";
          SpecificEnthalpy HCRIT0=0.0
            "Critical specific enthalpy of the fundamental equation";
          SpecificEntropy SCRIT0=0.0
            "Critical specific entropy of the fundamental equation";
          SpecificEnthalpy deltah=0.0
            "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
          SpecificEntropy deltas=0.0
            "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
        end FluidConstants;
      end IdealGas;
    end Types;
    annotation (Documentation(info="<html>
<p>
This package provides basic interfaces definitions of media models for different
kind of media.
</p>
</html>"));
  end Interfaces;

  package Common
    "Data structures and fundamental functions for fluid properties"
    extends Modelica.Icons.Package;

    function smoothStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica.Icons.Function;
      input Real x "Abscissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small > 0 required";
      output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x > x_small then y1 else if x < -x_small then y2 else if
        abs(x_small) > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2 - y1)/4 + (y1
         + y2)/2 else (y1 + y2)/2);

      annotation (
        Inline=true,
        smoothOrder=1,
        Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",   info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(X) = 1, provided sum(X_a) = sum(X_b) = 1
(and y1=X_a[i], y2=X_b[i]).
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise X is either X_a or X_b):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>
</html>"));
    end smoothStep;

    package OneNonLinearEquation
      "Determine solution of a non-linear algebraic equation in one unknown without derivatives in a reliable and efficient way"
      extends Modelica.Icons.Package;

      replaceable record f_nonlinear_Data
        "Data specific for function f_nonlinear"
        extends Modelica.Icons.Record;
      end f_nonlinear_Data;

      replaceable partial function f_nonlinear
        "Nonlinear algebraic equation in one unknown: y = f_nonlinear(x,p,X)"
        extends Modelica.Icons.Function;
        input Real x "Independent variable of function";
        input Real p=0.0 "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (her always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for the function";
        output Real y "= f_nonlinear(x)";
        // annotation(derivative(zeroDerivative=y)); // this must hold for all replaced functions
      end f_nonlinear;

      replaceable function solve
        "Solve f_nonlinear(x_zero)=y_zero; f_nonlinear(x_min) - y_zero and f_nonlinear(x_max)-y_zero must have different sign"
        import Modelica.Utilities.Streams.error;
        extends Modelica.Icons.Function;
        input Real y_zero
          "Determine x_zero, such that f_nonlinear(x_zero) = y_zero";
        input Real x_min "Minimum value of x";
        input Real x_max "Maximum value of x";
        input Real pressure=0.0
          "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (here always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for function f_nonlinear";
        input Real x_tol=100*Modelica.Constants.eps
          "Relative tolerance of the result";
        output Real x_zero "f_nonlinear(x_zero) = y_zero";
    protected
        constant Real eps=Modelica.Constants.eps "Machine epsilon";
        constant Real x_eps=1e-10
          "Slight modification of x_min, x_max, since x_min, x_max are usually exactly at the borders T_min/h_min and then small numeric noise may make the interval invalid";
        Real x_min2=x_min - x_eps;
        Real x_max2=x_max + x_eps;
        Real a=x_min2 "Current best minimum interval value";
        Real b=x_max2 "Current best maximum interval value";
        Real c "Intermediate point a <= c <= b";
        Real d;
        Real e "b - a";
        Real m;
        Real s;
        Real p;
        Real q;
        Real r;
        Real tol;
        Real fa "= f_nonlinear(a) - y_zero";
        Real fb "= f_nonlinear(b) - y_zero";
        Real fc;
        Boolean found=false;
      algorithm
        // Check that f(x_min) and f(x_max) have different sign
        fa := f_nonlinear(
                x_min2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fb := f_nonlinear(
                x_max2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fc := fb;
        if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
          error(
            "The arguments x_min and x_max to OneNonLinearEquation.solve(..)\n"
             + "do not bracket the root of the single non-linear equation:\n" +
            "  x_min  = " + String(x_min2) + "\n" + "  x_max  = " + String(x_max2)
             + "\n" + "  y_zero = " + String(y_zero) + "\n" +
            "  fa = f(x_min) - y_zero = " + String(fa) + "\n" +
            "  fb = f(x_max) - y_zero = " + String(fb) + "\n" +
            "fa and fb must have opposite sign which is not the case");
        end if;

        // Initialize variables
        c := a;
        fc := fa;
        e := b - a;
        d := e;

        // Search loop
        while not found loop
          if abs(fc) < abs(fb) then
            a := b;
            b := c;
            c := a;
            fa := fb;
            fb := fc;
            fc := fa;
          end if;

          tol := 2*eps*abs(b) + x_tol;
          m := (c - b)/2;

          if abs(m) <= tol or fb == 0.0 then
            // root found (interval is small enough)
            found := true;
            x_zero := b;
          else
            // Determine if a bisection is needed
            if abs(e) < tol or abs(fa) <= abs(fb) then
              e := m;
              d := e;
            else
              s := fb/fa;
              if a == c then
                // linear interpolation
                p := 2*m*s;
                q := 1 - s;
              else
                // inverse quadratic interpolation
                q := fa/fc;
                r := fb/fc;
                p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                q := (q - 1)*(r - 1)*(s - 1);
              end if;

              if p > 0 then
                q := -q;
              else
                p := -p;
              end if;

              s := e;
              e := d;
              if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                // interpolation successful
                d := p/q;
              else
                // use bi-section
                e := m;
                d := e;
              end if;
            end if;

            // Best guess value is defined as "a"
            a := b;
            fa := fb;
            b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
            fb := f_nonlinear(
                    b,
                    pressure,
                    X,
                    f_nonlinear_data) - y_zero;

            if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
              // initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;
            end if;
          end if;
        end while;
      end solve;

      annotation (Documentation(info="<html>
<p>
This function should currently only be used in Modelica.Media,
since it might be replaced in the future by another strategy,
where the tool is responsible for the solution of the non-linear
equation.
</p>

<p>
This library determines the solution of one non-linear algebraic equation \"y=f(x)\"
in one unknown \"x\" in a reliable way. As input, the desired value y of the
non-linear function has to be given, as well as an interval x_min, x_max that
contains the solution, i.e., \"f(x_min) - y\" and \"f(x_max) - y\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

<p>
Due to current limitations of the
Modelica language (not possible to pass a function reference to a function),
the construction to use this solver on a user-defined function is a bit
complicated (this method is from Hans Olsson, Dassault Syst&egrave;mes AB). A user has to
provide a package in the following way:
</p>

<pre>
  <strong>package</strong> MyNonLinearSolver
    <strong>extends</strong> OneNonLinearEquation;

    <strong>redeclare record extends</strong> Data
      // Define data to be passed to user function
      ...
    <strong>end</strong> Data;

    <strong>redeclare function extends</strong> f_nonlinear
    <strong>algorithm</strong>
       // Compute the non-linear equation: y = f(x, Data)
    <strong>end</strong> f_nonlinear;

    // Dummy definition that has to be present for current Dymola
    <strong>redeclare function extends</strong> solve
    <strong>end</strong> solve;
  <strong>end</strong> MyNonLinearSolver;

  x_zero = MyNonLinearSolver.solve(y_zero, x_min, x_max, data=data);
</pre>
</html>"));
    end OneNonLinearEquation;
    annotation (Documentation(info="<html><h4>Package description</h4>
      <p>Package Modelica.Media.Common provides records and functions shared by many of the property sub-packages.
      High accuracy fluid property models share a lot of common structure, even if the actual models are different.
      Common data structures and computations shared by these property models are collected in this library.
   </p>

</html>",   revisions="<html>
      <ul>
      <li>First implemented: <em>July, 2000</em>
      by Hubertus Tummescheit
      for the ThermoFluid Library with help from Jonas Eborn and Falko Jens Wagner
      </li>
      <li>Code reorganization, enhanced documentation, additional functions: <em>December, 2002</em>
      by Hubertus Tummescheit and move to Modelica
                            properties library.</li>
      <li>Inclusion into Modelica.Media: September 2003</li>
      </ul>

      <address>Author: Hubertus Tummescheit,<br>
      Lund University<br>
      Department of Automatic Control<br>
      Box 118, 22100 Lund, Sweden<br>
      email: hubertus@control.lth.se
      </address>
</html>"));
  end Common;

    package IdealGases
    "Data and models of ideal gases (single, fixed and dynamic mixtures) from NASA source"
      extends Modelica.Icons.VariantsPackage;

      package Common "Common packages and data for the ideal gas models"
      extends Modelica.Icons.Package;

      record DataRecord
        "Coefficient data record for properties of ideal gases based on NASA source"
        extends Modelica.Icons.Record;
        String name "Name of ideal gas";
        SI.MolarMass MM "Molar mass";
        SI.SpecificEnthalpy Hf "Enthalpy of formation at 298.15K";
        SI.SpecificEnthalpy H0 "H0(298.15K) - H0(0K)";
        SI.Temperature Tlimit "Temperature limit between low and high data sets";
        Real alow[7] "Low temperature coefficients a";
        Real blow[2] "Low temperature constants b";
        Real ahigh[7] "High temperature coefficients a";
        Real bhigh[2] "High temperature constants b";
        SI.SpecificHeatCapacity R "Gas constant";
        annotation (Documentation(info="<html>
<p>
This data record contains the coefficients for the
ideal gas equations according to:
</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>
The equations have the following structure:
</p>
<img src=\"modelica://Modelica/Resources/Images/Media/IdealGases/singleEquations.png\">
<p>
The polynomials for h(T) and s0(T) are derived via integration from the one for cp(T)  and contain the integration constants b1, b2 that define the reference specific enthalpy and entropy. For entropy differences the reference pressure p0 is arbitrary, but not for absolute entropies. It is chosen as 1 standard atmosphere (101325 Pa).
</p>
<p>
For most gases, the region of validity is from 200 K to 6000 K.
The equations are split into two regions that are separated
by Tlimit (usually 1000 K). In both regions the gas is described
by the data above. The two branches are continuous and in most
gases also differentiable at Tlimit.
</p>
</html>"));
      end DataRecord;

        package FluidData "Critical data, dipole moments and related data"
          extends Modelica.Icons.Package;
          import Modelica.Media.Interfaces.PartialMixtureMedium;
          import Modelica.Media.IdealGases.Common.SingleGasesData;

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants N2(
                               chemicalFormula =        "N2",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7727-37-9",
                               meltingPoint =            63.15,
                               normalBoilingPoint =      77.35,
                               criticalTemperature =    126.20,
                               criticalPressure =        33.98e5,
                               criticalMolarVolume =     90.10e-6,
                               acentricFactor =           0.037,
                               dipoleMoment =             0.0,
                               molarMass =              SingleGasesData.N2.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants H2O(
                               chemicalFormula =        "H2O",
                               iupacName =              "oxidane",
                               structureFormula =       "H2O",
                               casRegistryNumber =      "7732-18-5",
                               meltingPoint =           273.15,
                               normalBoilingPoint =     373.124,
                               criticalTemperature =    647.096,
                               criticalPressure =       220.64e5,
                               criticalMolarVolume =     55.95e-6,
                               acentricFactor =           0.344,
                               dipoleMoment =             1.8,
                               molarMass =              SingleGasesData.H2O.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);
          annotation (Documentation(info="<html>
<p>
This package contains FluidConstants data records for the following 37 gases
(see also the description in
<a href=\"modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>):
</p>
<pre>
Argon             Methane          Methanol       Carbon Monoxide  Carbon Dioxide
Acetylene         Ethylene         Ethanol        Ethane           Propylene
Propane           1-Propanol       1-Butene       N-Butane         1-Pentene
N-Pentane         Benzene          1-Hexene       N-Hexane         1-Heptane
N-Heptane         Ethylbenzene     N-Octane       Chlorine         Fluorine
Hydrogen          Steam            Helium         Ammonia          Nitric Oxide
Nitrogen Dioxide  Nitrogen         Nitrous        Oxide            Neon Oxygen
Sulfur Dioxide    Sulfur Trioxide
</pre>

</html>"));
        end FluidData;

        package SingleGasesData
        "Ideal gas data based on the NASA Glenn coefficients"
          extends Modelica.Icons.Package;

          constant IdealGases.Common.DataRecord Air(
            name="Air",
            MM=0.0289651159,
            Hf=-4333.833858403446,
            H0=298609.6803431054,
            Tlimit=1000,
            alow={10099.5016,-196.827561,5.00915511,-0.00576101373,1.06685993e-005,-7.94029797e-009,
                2.18523191e-012},
            blow={-176.796731,-3.921504225},
            ahigh={241521.443,-1257.8746,5.14455867,-0.000213854179,7.06522784e-008,-1.07148349e-011,
                6.57780015e-016},
            bhigh={6462.26319,-8.147411905},
            R=287.0512249529787);

          constant IdealGases.Common.DataRecord CO2(
            name="CO2",
            MM=0.0440095,
            Hf=-8941478.544405185,
            H0=212805.6215135368,
            Tlimit=1000,
            alow={49436.5054,-626.411601,5.30172524,0.002503813816,-2.127308728e-007,-7.68998878e-010,
                2.849677801e-013},
            blow={-45281.9846,-7.04827944},
            ahigh={117696.2419,-1788.791477,8.29152319,-9.22315678e-005,4.86367688e-009,
                -1.891053312e-012,6.330036589999999e-016},
            bhigh={-39083.5059,-26.52669281},
            R=188.9244822140674);

          constant IdealGases.Common.DataRecord H2O(
            name="H2O",
            MM=0.01801528,
            Hf=-13423382.81725291,
            H0=549760.6476280135,
            Tlimit=1000,
            alow={-39479.6083,575.573102,0.931782653,0.00722271286,-7.34255737e-006,
                4.95504349e-009,-1.336933246e-012},
            blow={-33039.7431,17.24205775},
            ahigh={1034972.096,-2412.698562,4.64611078,0.002291998307,-6.836830479999999e-007,
                9.426468930000001e-011,-4.82238053e-015},
            bhigh={-13842.86509,-7.97814851},
            R=461.5233290850878);

          constant IdealGases.Common.DataRecord N2(
            name="N2",
            MM=0.0280134,
            Hf=0,
            H0=309498.4543111511,
            Tlimit=1000,
            alow={22103.71497,-381.846182,6.08273836,-0.00853091441,1.384646189e-005,-9.62579362e-009,
                2.519705809e-012},
            blow={710.846086,-10.76003744},
            ahigh={587712.406,-2239.249073,6.06694922,-0.00061396855,1.491806679e-007,-1.923105485e-011,
                1.061954386e-015},
            bhigh={12832.10415,-15.86640027},
            R=296.8033869505308);
          annotation (Documentation(info="<html>
<p>This package contains ideal gas models for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>

<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre>
</html>"));
        end SingleGasesData;
      annotation (Documentation(info="<html>

</html>"));
      end Common;
    annotation (Documentation(info="<html>
<p>This package contains data for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>Medium models for some of these gases are available in package
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a>
and some examples for mixtures are available in package <a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a>
</p>
<h4>Using and Adapting Medium Models</h4>
<p>
The data records allow computing the ideal gas specific enthalpy, specific entropy and heat capacity of the substances listed below. From them, even the Gibbs energy and equilibrium constants for reactions can be computed. Critical data that is needed for computing the viscosity and thermal conductivity is not included. In order to add mixtures or single substance medium packages that are
subtypes of
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">Interfaces.PartialMedium</a>
(i.e., can be utilized at all places where PartialMedium is defined),
a few additional steps have to be performed:
</p>
<ol>
<li>
All single gas media need to define a constant instance of record
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">IdealGases.Common.SingleGasNasa.FluidConstants</a>.
For 37 ideal gases such records are provided in package
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">IdealGases.Common.FluidData</a>.
For the other gases, such a record instance has to be provided by the user, e.g., by getting
the data from a commercial or public data base. A public source of the needed data is for example the <a href=\"http://webbook.nist.gov/chemistry/\"> NIST Chemistry WebBook</a></li>

<li>When the data is available, and a user has an instance of a
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">FluidConstants</a> record filled with data, a medium package has to be written. Note that only the dipole moment, the acentric factor and critical data are necessary for the viscosity and thermal conductivity functions.</li>
<li><ul>
<li>For single components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a> has to be created, pointing both to a data record for cp and to a user-defined fluidConstants record.</li>
<li>For mixtures of several components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a> has to be created, building an array of data records for cp and an array of (partly) user-defined fluidConstants records.</li>
</ul></li>
</ol>
<p>Note that many properties can computed for the full set of 1241 gases listed below, but due to the missing viscosity and thermal conductivity functions, no fully Modelica.Media-compliant media can be defined.</p>
<p>
Data records for heat capacity, specific enthalpy and specific entropy exist for the following substances and ions:
</p>
<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></html>"));
    end IdealGases;

    package Incompressible
    "Medium model for T-dependent properties, defined by tables or polynomials"
      extends Modelica.Icons.VariantsPackage;
      import Modelica.Constants;
      import Modelica.Math;

      package Common "Common data structures"
        extends Modelica.Icons.Package;

        record BaseProps_Tpoly "Fluid state record"
          extends Modelica.Icons.Record;
          SI.Temperature T "Temperature";
          SI.Pressure p "Pressure";
          //    SI.Density d "Density";
        end BaseProps_Tpoly;
      end Common;

      package TableBased "Incompressible medium properties based on tables"
        import Poly = Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        extends Modelica.Media.Interfaces.PartialMedium(
           ThermoStates = if enthalpyOfT then Modelica.Media.Interfaces.Choices.IndependentVariables.T
                                                                             else Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
           final reducedX=true,
           final fixedX = true,
           mediumName="tableMedium",
           redeclare record ThermodynamicState=Common.BaseProps_Tpoly,
           singleState=true,
           reference_p = 1.013e5,
           Temperature(min = T_min, max = T_max));

        constant Boolean enthalpyOfT=true
          "True if enthalpy is approximated as a function of T only, (p-dependence neglected)";

        constant Boolean densityOfT = size(tableDensity,1) > 1
          "True if density is a function of temperature";

        constant Modelica.SIunits.Temperature T_min
          "Minimum temperature valid for medium model";

        constant Modelica.SIunits.Temperature T_max
          "Maximum temperature valid for medium model";

        constant Temperature T0=273.15 "Reference Temperature";

        constant SpecificEnthalpy h0=0 "Reference enthalpy at T0, reference_p";

        constant SpecificEntropy s0=0 "Reference entropy at T0, reference_p";

        constant MolarMass MM_const=0.1 "Molar mass";

        constant Integer npol=2 "Degree of polynomial used for fitting";

        constant Integer npolDensity=npol
          "Degree of polynomial used for fitting rho(T)";

        constant Integer npolHeatCapacity=npol
          "Degree of polynomial used for fitting Cp(T)";

        constant Integer npolViscosity=npol
          "Degree of polynomial used for fitting eta(T)";

        constant Integer npolConductivity=npol
          "Degree of polynomial used for fitting lambda(T)";

        constant Integer neta=size(tableViscosity,1)
          "Number of data points for viscosity";

        constant Real[:,2] tableDensity "Table for rho(T)";

        constant Real[:,2] tableHeatCapacity "Table for Cp(T)";

        constant Real[:,2] tableViscosity "Table for eta(T)";

        constant Real[:,2] tableConductivity "Table for lambda(T)";

        constant Boolean TinK "True if T[K],Kelvin used for table temperatures";

        constant Boolean hasDensity = not (size(tableDensity,1)==0)
          "True if table tableDensity is present";

        constant Boolean hasHeatCapacity = not (size(tableHeatCapacity,1)==0)
          "True if table tableHeatCapacity is present";

        constant Boolean hasViscosity = not (size(tableViscosity,1)==0)
          "True if table tableViscosity is present";

        final constant Real invTK[neta] = if size(tableViscosity,1) > 0 then
            (if TinK then 1 ./ tableViscosity[:,1] else 1 ./ Cv.from_degC(tableViscosity[:,1])) else fill(0,neta);

        final constant Real poly_rho[:] = if hasDensity then
                                             Poly.fitting(tableDensity[:,1],tableDensity[:,2],npolDensity) else
                                               zeros(npolDensity+1);

        final constant Real poly_Cp[:] = if hasHeatCapacity then
                                             Poly.fitting(tableHeatCapacity[:,1],tableHeatCapacity[:,2],npolHeatCapacity) else
                                               zeros(npolHeatCapacity+1);

        final constant Real poly_eta[:] = if hasViscosity then
                                             Poly.fitting(invTK, Math.log(tableViscosity[:,2]),npolViscosity) else
                                               zeros(npolViscosity+1);

        final constant Real poly_lam[:] = if size(tableConductivity,1)>0 then
                                             Poly.fitting(tableConductivity[:,1],tableConductivity[:,2],npolConductivity) else
                                               zeros(npolConductivity+1);

        redeclare model extends BaseProperties(
          final standardOrderComponents=true,
          p_bar=Cv.to_bar(p),
          T_degC(start = T_start-273.15)=Cv.to_degC(T),
          T(start = T_start,
            stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of T dependent medium"
        //  redeclare parameter SpecificHeatCapacity R=Modelica.Constants.R,

          SI.SpecificHeatCapacity cp "Specific heat capacity";
          parameter SI.Temperature T_start = 298.15 "Initial temperature";
        equation
          assert(hasDensity,"Medium " + mediumName +
                            " can not be used without assigning tableDensity.");
          assert(T >= T_min and T <= T_max, "Temperature T (= " + String(T) +
                 " K) is not in the allowed range (" + String(T_min) +
                 " K <= T <= " + String(T_max) + " K) required from medium model \""
                 + mediumName + "\".");
          R = Modelica.Constants.R/MM_const;
          cp = Poly.evaluate(poly_Cp,if TinK then T else T_degC);
          h = if enthalpyOfT then h_T(T) else  h_pT(p,T,densityOfT);
          u = h - (if singleState then  reference_p/d else state.p/d);
          d = Poly.evaluate(poly_rho,if TinK then T else T_degC);
          state.T = T;
          state.p = p;
          MM = MM_const;
          annotation(Documentation(info="<html>
<p>
Note that the inner energy neglects the pressure dependence, which is only
true for an incompressible medium with d = constant. The neglected term is
p-reference_p)/rho*(T/rho)*(partial rho /partial T). This is very small for
liquids due to proportionality to 1/d^2, but can be problematic for gases that are
modeled incompressible.
</p>
<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>
<p>
Enthalpy is never a function of T only (h = h(T) + (p-reference_p)/d), but the
error is also small and non-linear systems can be avoided. In particular,
non-linear systems are small and local as opposed to large and over all volumes.
</p>

<p>
Entropy is calculated as
</p>
<pre>
  s = s0 + integral(Cp(T)/T,dt)
</pre>
<p>
which is only exactly true for a fluid with constant density d=d0.
</p>
</html>"));
        end BaseProperties;

        redeclare function extends setState_pTX
          "Returns state record, given pressure and temperature"
        algorithm
          state := ThermodynamicState(p=p,T=T);
          annotation(smoothOrder=3);
        end setState_pTX;

        redeclare function extends setState_dTX
          "Returns state record, given pressure and temperature"
        algorithm
          assert(false, "For incompressible media with d(T) only, state can not be set from density and temperature");
        end setState_dTX;

        redeclare function extends setState_phX
          "Returns state record, given pressure and specific enthalpy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ph(p,h));
          annotation(Inline=true,smoothOrder=3);
        end setState_phX;

        redeclare function extends setState_psX
          "Returns state record, given pressure and specific entropy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ps(p,s));
          annotation(Inline=true,smoothOrder=3);
        end setState_psX;

            redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state :=ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                         T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
              annotation(Inline=true,smoothOrder=3);
            end setSmoothState;

        redeclare function extends specificHeatCapacityCv
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cv := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends specificHeatCapacityCp
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cp := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends dynamicViscosity
          "Return dynamic viscosity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableViscosity,1)>0,"DynamicViscosity, eta, is not defined for medium "
                                                 + mediumName + ".");
          eta := Math.exp(Poly.evaluate(poly_eta, 1/state.T));
         annotation(smoothOrder=2);
        end dynamicViscosity;

        redeclare function extends thermalConductivity
          "Return thermal conductivity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableConductivity,1)>0,"ThermalConductivity, lambda, is not defined for medium "
                                                 + mediumName + ".");
          lambda := Poly.evaluate(poly_lam,if TinK then state.T else Cv.to_degC(state.T));
         annotation(smoothOrder=2);
        end thermalConductivity;

        function s_T "Compute specific entropy"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          output SpecificEntropy s "Specific entropy";
        algorithm
          s := s0 + (if TinK then
            Poly.integralValue(poly_Cp[1:npol],T, T0) else
            Poly.integralValue(poly_Cp[1:npol],Cv.to_degC(T),Cv.to_degC(T0)))
            + Modelica.Math.log(T/T0)*
            Poly.evaluate(poly_Cp,if TinK then 0 else Modelica.Constants.T_zero);
         annotation(Inline=true,smoothOrder=2);
        end s_T;

        redeclare function extends specificEntropy
          "Return specific entropy as a function of the thermodynamic state record"

      protected
          Integer npol=size(poly_Cp,1)-1;
        algorithm
          assert(hasHeatCapacity,"Specific Entropy, s(T), is not defined for medium "
                                                 + mediumName + ".");
          s := s_T(state.T);
         annotation(smoothOrder=2);
        end specificEntropy;

        function h_T "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0));
         annotation(derivative=h_T_der);
        end h_T;

        function h_T_der "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          input Real dT "Temperature derivative";
          output Real dh "Derivative of Specific enthalpy at T";
        algorithm
          dh :=Poly.evaluate(poly_Cp, if TinK then T else Cv.to_degC(T))*dT;
         annotation(smoothOrder=1);
        end h_T_der;

        function h_pT "Compute specific enthalpy from pressure and temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input Boolean densityOfT = false
            "Include or neglect density derivative dependence of enthalpy" annotation(Evaluate);
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0)) + (p - reference_p)/Poly.evaluate(poly_rho, if TinK then
                  T else Cv.to_degC(T))
            *(if densityOfT then (1 + T/Poly.evaluate(poly_rho, if TinK then T else Cv.to_degC(T))
          *Poly.derivativeValue(poly_rho,if TinK then T else Cv.to_degC(T))) else 1.0);
         annotation(smoothOrder=2);
        end h_pT;

        redeclare function extends temperature
          "Return temperature as a function of the thermodynamic state record"
        algorithm
         T := state.T;
         annotation(Inline=true,smoothOrder=2);
        end temperature;

        redeclare function extends pressure
          "Return pressure as a function of the thermodynamic state record"
        algorithm
         p := state.p;
         annotation(Inline=true,smoothOrder=2);
        end pressure;

        redeclare function extends density
          "Return density as a function of the thermodynamic state record"
        algorithm
          d := Poly.evaluate(poly_rho,if TinK then state.T else Cv.to_degC(state.T));
         annotation(Inline=true,smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy
          "Return specific enthalpy as a function of the thermodynamic state record"
        algorithm
          h := if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T);
         annotation(Inline=true,smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy as a function of the thermodynamic state record"
        algorithm
          u := (if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T)) - (if singleState then  reference_p else state.p)/density(state);
         annotation(Inline=true,smoothOrder=2);
        end specificInternalEnergy;

        function T_ph "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := if singleState then h_T(x) else h_pT(p,x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(h, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
          annotation(Inline=false, LateInline=true, inverse(h=h_pT(p,T)));
        end T_ph;

        function T_ps "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;

          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := s_T(x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(s, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
        end T_ps;

        package Polynomials_Temp
        "Temporary Functions operating on polynomials (including polynomial fitting); only to be used in Modelica.Media.Incompressible.TableBased"
          extends Modelica.Icons.Package;

          function evaluate "Evaluate polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of polynomial at u";
          algorithm
            y := p[1];
            for j in 2:size(p, 1) loop
              y := p[j] + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=evaluate_der);
          end evaluate;

          function derivativeValue
            "Value of derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              y := p[j]*(n - j) + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=derivativeValue_der);
          end derivativeValue;

          function secondDerivativeValue
            "Value of 2nd derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of 2nd derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1)*(n - 2);
            for j in 2:size(p, 1)-2 loop
              y := p[j]*(n - j)*(n - j - 1) + u*y;
            end for;
          end secondDerivativeValue;

          function integralValue "Integral of polynomial p(u) from u_low to u_high"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            output Real integral=0.0
              "Integral of polynomial p from u_low to u_high";
        protected
            Integer n=size(p, 1) "Degree of integrated polynomial";
            Real y_low=0 "Value at lower integrand";
          algorithm
            for j in 1:n loop
              integral := u_high*(p[j]/(n - j + 1) + integral);
              y_low := u_low*(p[j]/(n - j + 1) + y_low);
            end for;
            integral := integral - y_low;
            annotation(derivative(zeroDerivative=p)=integralValue_der);
          end integralValue;

          function fitting
            "Computes the coefficients of a polynomial that fits a set of data points in a least-squares sense"
            extends Modelica.Icons.Function;
            input Real u[:] "Abscissa data values";
            input Real y[size(u, 1)] "Ordinate data values";
            input Integer n(min=1)
              "Order of desired polynomial that fits the data points (u,y)";
            output Real p[n + 1]
              "Polynomial coefficients of polynomial that fits the date points";
        protected
            Real V[size(u, 1), n + 1] "Vandermonde matrix";
          algorithm
            // Construct Vandermonde matrix
            V[:, n + 1] := ones(size(u, 1));
            for j in n:-1:1 loop
              V[:, j] := {u[i] * V[i, j + 1] for i in 1:size(u,1)};
            end for;

            // Solve least squares problem
            p :=Modelica.Math.Matrices.leastSquares(V, y);
            annotation (Documentation(info="<html>
<p>
Polynomials.fitting(u,y,n) computes the coefficients of a polynomial
p(u) of degree \"n\" that fits the data \"p(u[i]) - y[i]\"
in a least squares sense. The polynomial is
returned as a vector p[n+1] that has the following definition:
</p>
<pre>
  p(u) = p[1]*u^n + p[2]*u^(n-1) + ... + p[n]*u + p[n+1];
</pre>
</html>"));
          end fitting;

          function evaluate_der
            "Evaluate derivative of polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              dy := p[j]*(n - j) + u*dy;
            end for;
            dy := dy*du;
          end evaluate_der;

          function integralValue_der
            "Time derivative of integral of polynomial p(u) from u_low to u_high, assuming only u_high as time-dependent (Leibniz rule)"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            input Real du_high "High integrand value";
            input Real du_low=0 "Low integrand value, default 0";
            output Real dintegral=0.0
              "Integral of polynomial p from u_low to u_high";
          algorithm
            dintegral := evaluate(p,u_high)*du_high;
          end integralValue_der;

          function derivativeValue_der
            "Time derivative of derivative of polynomial"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy
              "Time-derivative of derivative of polynomial w.r.t. input variable at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := secondDerivativeValue(p,u)*du;
          end derivativeValue_der;
          annotation (Documentation(info="<html>
<p>
This package contains functions to operate on polynomials,
in particular to determine the derivative and the integral
of a polynomial and to use a polynomial to fit a given set
of data points.
</p>

<p>
Copyright &copy; 2004-2019, Modelica Association and contributors
</p>
</html>",         revisions="<html>
<ul>
<li><em>Oct. 22, 2004</em> by Martin Otter (DLR):<br>
       Renamed functions to not have abbreviations.<br>
       Based fitting on LAPACK<br>
       New function to return the polynomial of an indefinite integral</li>
<li><em>Sept. 3, 2004</em> by Jonas Eborn (Scynamics):<br>
       polyderval, polyintval added</li>
<li><em>March 1, 2004</em> by Martin Otter (DLR):<br>
       first version implemented</li>
</ul>
</html>"));
        end Polynomials_Temp;
      annotation(Documentation(info="<html>
<p>
This is the base package for medium models of incompressible fluids based on
tables. The minimal data to provide for a useful medium description is tables
of density and heat capacity as functions of temperature.
</p>

<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>

<h4>Using the package TableBased</h4>
<p>
To implement a new medium model, create a package that <strong>extends</strong> TableBased
and provides one or more of the constant tables:
</p>

<pre>
tableDensity        = [T, d];
tableHeatCapacity   = [T, Cp];
tableConductivity   = [T, lam];
tableViscosity      = [T, eta];
tableVaporPressure  = [T, pVap];
</pre>

<p>
The table data is used to fit constant polynomials of order <strong>npol</strong>, the
temperature data points do not need to be same for different properties. Properties
like enthalpy, inner energy and entropy are calculated consistently from integrals
and derivatives of d(T) and Cp(T). The minimal
data for a useful medium model is thus density and heat capacity. Transport
properties and vapor pressure are optional, if the data tables are empty the corresponding
function calls can not be used.
</p>
</html>"));
      end TableBased;
      annotation (
        Documentation(info="<html>
<h4>Incompressible media package</h4>
<p>
This package provides a structure and examples of how to create simple
medium models of incompressible fluids, meaning fluids with very little
pressure influence on density. The medium properties is typically described
in terms of tables, functions or polynomial coefficients.
</p>
<h4>Definitions</h4>
<p>
The common meaning of <em>incompressible</em> is that properties like density
and enthalpy are independent of pressure. Thus properties are conveniently
described as functions of temperature, e.g., as polynomials density(T) and cp(T).
However, enthalpy can not be independent of pressure since h = u - p/d. For liquids
it is anyway
common to neglect this dependence since for constant density the neglected term
is (p - p0)/d, which in comparison with cp is very small for most liquids. For
water, the equivalent change of temperature to increasing pressure 1 bar is
0.025 Kelvin.
</p>
<p>
Two Boolean flags are used to choose how enthalpy and inner energy is calculated:
</p>
<ul>
<li><strong>enthalpyOfT</strong>=true, means assuming that enthalpy is only a function
of temperature, neglecting the pressure dependent term.</li>
<li><strong>singleState</strong>=true, means also neglect the pressure influence on inner
energy, which makes all medium properties pure functions of temperature.</li>
</ul>
<p>
The default setting for both these flags is true, which enables the simulation tool
to choose temperature as the only medium state and avoids non-linear equation
systems, see the section about
<a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition.StaticStateSelection\">Static
state selection</a> in the Modelica.Media User's Guide.
</p>

<h4>Contents</h4>
<p>
Currently, the package contains the following parts:
</p>
<ol>
<li> <a href=\"modelica://Modelica.Media.Incompressible.TableBased\">
      Table based medium models</a></li>
<li> <a href=\"modelica://Modelica.Media.Incompressible.Examples\">
      Example medium models</a></li>
</ol>

<p>
A few examples are given in the Examples package. The model
<a href=\"modelica://Modelica.Media.Incompressible.Examples.Glycol47\">
Examples.Glycol47</a> shows how the medium models can be used. For more
realistic examples of how to implement volume models with medium properties
look in the <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Medium
usage section</a> of the User's Guide.
</p>

</html>"));
    end Incompressible;

    package Water "Medium models for water"
    extends Modelica.Icons.VariantsPackage;
    import Modelica.Media.Water.ConstantPropertyLiquidWater.simpleWaterConstants;

    package ConstantPropertyLiquidWater
      "Water: Simple liquid water medium (incompressible, constant data)"

      //   redeclare record extends FluidConstants
      //   end FluidConstants;

      constant Modelica.Media.Interfaces.Types.Basic.FluidConstants[1]
        simpleWaterConstants(
        each chemicalFormula="H2O",
        each structureFormula="H2O",
        each casRegistryNumber="7732-18-5",
        each iupacName="oxidane",
        each molarMass=0.018015268);

      extends Interfaces.PartialSimpleMedium(
        mediumName="SimpleLiquidWater",
        cp_const=4184,
        cv_const=4184,
        d_const=995.586,
        eta_const=1.e-3,
        lambda_const=0.598,
        a_const=1484,
        T_min=Cv.from_degC(-1),
        T_max=Cv.from_degC(130),
        T0=273.15,
        MM_const=0.018015268,
        fluidConstants=simpleWaterConstants);

      annotation (Documentation(info="<html>

</html>"));
    end ConstantPropertyLiquidWater;
    annotation (Documentation(info="<html>
<p>This package contains different medium models for water:</p>
<ul>
<li><strong>ConstantPropertyLiquidWater</strong><br>
    Simple liquid water medium (incompressible, constant data).</li>
<li><strong>IdealSteam</strong><br>
    Steam water medium as ideal gas from Media.IdealGases.SingleGases.H2O</li>
<li><strong>WaterIF97 derived models</strong><br>
    High precision water model according to the IAPWS/IF97 standard
    (liquid, steam, two phase region). Models with different independent
    variables are provided as well as models valid only
    for particular regions. The <strong>WaterIF97_ph</strong> model is valid
    in all regions and is the recommended one to use.</li>
</ul>
<h4>Overview of WaterIF97 derived water models</h4>
<p>
The WaterIF97 models calculate medium properties
for water in the <strong>liquid</strong>, <strong>gas</strong> and <strong>two phase</strong> regions
according to the IAPWS/IF97 standard, i.e., the accepted industrial standard
and best compromise between accuracy and computation time.
It has been part of the ThermoFluid Modelica library and been extended,
reorganized and documented to become part of the Modelica Standard library.</p>
<p>An important feature that distinguishes this implementation of the IF97 steam property standard
is that this implementation has been explicitly designed to work well in dynamic simulations. Computational
performance has been of high importance. This means that there often exist several ways to get the same result
from different functions if one of the functions is called often but can be optimized for that purpose.
</p>
<p>Three variable pairs can be the independent variables of the model:
</p>
<ol>
<li>Pressure <strong>p</strong> and specific enthalpy <strong>h</strong> are
    the most natural choice for general applications.
    This is the recommended choice for most general purpose
    applications, in particular for power plants.</li>
<li>Pressure <strong>p</strong> and temperature <strong>T</strong> are the most natural
    choice for applications where water is always in the same phase,
    both for liquid water and steam.</li>
<li>Density <strong>d</strong> and temperature <strong>T</strong> are explicit
    variables of the Helmholtz function in the near-critical
    region and can be the best choice for applications with
    super-critical or near-critical states.</li>
</ol>
<p>
The following quantities are always computed in Medium.BaseProperties:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>pressure</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
</table>
<p>
In some cases additional medium properties are needed.
A component that needs these optional properties has to call
one of the following functions:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.dynamicViscosity(medium.state)</td>
      <td>Pa.s</td>
      <td>dynamic viscosity</td></tr>
  <tr><td>Medium.thermalConductivity(medium.state)</td>
      <td>W/(m.K)</td>
      <td>thermal conductivity</td></tr>
  <tr><td>Medium.prandtlNumber(medium.state)</td>
      <td>1</td>
      <td>Prandtl number</td></tr>
  <tr><td>Medium.specificEntropy(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific entropy</td></tr>
  <tr><td>Medium.heatCapacity_cp(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant pressure</td></tr>
  <tr><td>Medium.heatCapacity_cv(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant density</td></tr>
  <tr><td>Medium.isentropicExponent(medium.state)</td>
      <td>1</td>
      <td>isentropic exponent</td></tr>
  <tr><td>Medium.isentropicEnthalpy(pressure, medium.state)</td>
      <td>J/kg</td>
      <td>isentropic enthalpy</td></tr>
  <tr><td>Medium.velocityOfSound(medium.state)</td>
      <td>m/s</td>
      <td>velocity of sound</td></tr>
  <tr><td>Medium.isobaricExpansionCoefficient(medium.state)</td>
      <td>1/K</td>
      <td>isobaric expansion coefficient</td></tr>
  <tr><td>Medium.isothermalCompressibility(medium.state)</td>
      <td>1/Pa</td>
      <td>isothermal compressibility</td></tr>
  <tr><td>Medium.density_derp_h(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant enthalpy</td></tr>
  <tr><td>Medium.density_derh_p(medium.state)</td>
      <td>kg2/(m3.J)</td>
      <td>derivative of density by enthalpy at constant pressure</td></tr>
  <tr><td>Medium.density_derp_T(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant temperature</td></tr>
  <tr><td>Medium.density_derT_p(medium.state)</td>
      <td>kg/(m3.K)</td>
      <td>derivative of density by temperature at constant pressure</td></tr>
  <tr><td>Medium.density_derX(medium.state)</td>
      <td>kg/m3</td>
      <td>derivative of density by mass fraction</td></tr>
  <tr><td>Medium.molarMass(medium.state)</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>More details are given in
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.OptionalProperties\">
Modelica.Media.UsersGuide.MediumUsage.OptionalProperties</a>.

Many additional optional functions are defined to compute properties of
saturated media, either liquid (bubble point) or vapour (dew point).
The argument to such functions is a SaturationProperties record, which can be
set starting from either the saturation pressure or the saturation temperature.
With reference to a model defining a pressure p, a temperature T, and a
SaturationProperties record sat, the following functions are provided:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.saturationPressure(T)</td>
      <td>Pa</td>
      <td>Saturation pressure at temperature T</td></tr>
  <tr><td>Medium.saturationTemperature(p)</td>
      <td>K</td>
      <td>Saturation temperature at pressure p</td></tr>
  <tr><td>Medium.saturationTemperature_derp(p)</td>
      <td>K/Pa</td>
      <td>Derivative of saturation temperature with respect to pressure</td></tr>
  <tr><td>Medium.bubbleEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at bubble point</td></tr>
  <tr><td>Medium.dewEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at dew point</td></tr>
  <tr><td>Medium.bubbleEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at bubble point</td></tr>
  <tr><td>Medium.dewEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at dew point</td></tr>
  <tr><td>Medium.bubbleDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at bubble point</td></tr>
  <tr><td>Medium.dewDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at dew point</td></tr>
  <tr><td>Medium.dBubbleDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at dew point with respect to pressure</td></tr>
  <tr><td>Medium.dBubbleEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at dew point with respect to pressure</td></tr>
  <tr><td>Medium.surfaceTension(sat)</td>
      <td>N/m</td>
      <td>Surface tension between liquid and vapour phase</td></tr>
</table>
<p>Details on usage and some examples are given in:
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.TwoPhase\">
Modelica.Media.UsersGuide.MediumUsage.TwoPhase</a>.
</p>
<p>Many further properties can be computed. Using the well-known Bridgman's Tables,
all first partial derivatives of the standard thermodynamic variables can be computed easily.
</p>
<p>
The documentation of the IAPWS/IF97 steam properties can be freely
distributed with computer implementations and are included here
(in directory Modelica/Resources/Documentation/Media/Water/IF97documentation):
</p>
<ul>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/IF97.pdf\">IF97.pdf</a> The standards document for the main part of the IF97.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/Back3.pdf\">Back3.pdf</a> The backwards equations for region 3.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/crits.pdf\">crits.pdf</a> The critical point data.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/meltsub.pdf\">meltsub.pdf</a> The melting- and sublimation line formulation (not implemented)</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/surf.pdf\">surf.pdf</a> The surface tension standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/thcond.pdf\">thcond.pdf</a> The thermal conductivity standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/visc.pdf\">visc.pdf</a> The viscosity standard definition</li>
</ul>
</html>"));
    end Water;
  annotation (preferredView="info",Documentation(info="<html>
<p>
This library contains <a href=\"modelica://Modelica.Media.Interfaces\">interface</a>
definitions for media and the following <strong>property</strong> models for
single and multiple substance fluids with one and multiple phases:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.IdealGases\">Ideal gases:</a><br>
     1241 high precision gas models based on the
     NASA Glenn coefficients, plus ideal gas mixture models based
     on the same data.</li>
<li> <a href=\"modelica://Modelica.Media.Water\">Water models:</a><br>
     ConstantPropertyLiquidWater, WaterIF97 (high precision
     water model according to the IAPWS/IF97 standard)</li>
<li> <a href=\"modelica://Modelica.Media.Air\">Air models:</a><br>
     SimpleAir, DryAirNasa, ReferenceAir, MoistAir, ReferenceMoistAir.</li>
<li> <a href=\"modelica://Modelica.Media.Incompressible\">
     Incompressible media:</a><br>
     TableBased incompressible fluid models (properties are defined by tables rho(T),
     HeatCapacity_cp(T), etc.)</li>
<li> <a href=\"modelica://Modelica.Media.CompressibleLiquids\">
     Compressible liquids:</a><br>
     Simple liquid models with linear compressibility</li>
<li> <a href=\"modelica://Modelica.Media.R134a\">Refrigerant Tetrafluoroethane (R134a)</a>.</li>
</ul>
<p>
The following parts are useful, when newly starting with this library:</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Modelica.Media.UsersGuide.MediumUsage</a>
     describes how to use a medium model in a component model.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition\">
     Modelica.Media.UsersGuide.MediumDefinition</a>
     describes how a new fluid medium model has to be implemented.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.ReleaseNotes\">Modelica.Media.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Media.Examples\">Modelica.Media.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>February 01, 2017</em> by Thomas Beutlich:<br/>
    Fixed data errors of the NASA Glenn coefficients in some ideal gases (CH2, CH3, CH3OOH, C2CL2, C2CL4, C2CL6, C2HCL, C2HCL3, CH2CO_ketene, O_CH_2O, HO_CO_2OH, CH2BrminusCOOH, C2H3CL, CH2CLminusCOOH, HO2, HO2minus, OD, ODminus), see <a href=\"https://github.com/modelica/ModelicaStandardLibrary/issues/1922\">#1922</a></li>
<li><em>May 16, 2013</em> by Stefan Wischhusen (XRG Simulation):<br/>
    Added new media models Air.ReferenceMoistAir, Air.ReferenceAir, R134a.</li>
<li><em>May 25, 2011</em> by Francesco Casella:<br/>Added min/max attributes to Water, TableBased, MixtureGasNasa, SimpleAir and MoistAir local types.</li>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added individual settings for polynomial fittings of properties.</li>
</ul>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      extends Modelica.Icons.Package;

      package Components "Lumped thermal components"
      extends Modelica.Icons.Package;

        model HeatCapacitor "Lumped thermal element storing heat"
          parameter Modelica.SIunits.HeatCapacity C
            "Heat capacity of element (= cp*m)";
          Modelica.SIunits.Temperature T(start=293.15, displayUnit="degC")
            "Temperature of element";
          Modelica.SIunits.TemperatureSlope der_T(start=0)
            "Time derivative of temperature (= der(T))";
          Interfaces.HeatPort_a port annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        equation
          T = port.T;
          der_T = der(T);
          C*der(T) = port.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,110},{150,70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-69,7},{71,-24}},
                  textString="%C")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,-1},{6,-12}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{11,13},{50,-25}},
                  textString="T"),
                Line(points={{0,-12},{0,-96}}, color={255,0,0})}),
            Documentation(info="<html>
<p>
This is a generic model for the heat capacity of a material.
No specific geometry is assumed beyond a total volume with
uniform temperature for the entire volume.
Furthermore, it is assumed that the heat capacity
is constant (independent of temperature).
</p>
<p>
The temperature T [Kelvin] of this component is a <strong>state</strong>.
A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
is used as start value for initialization.
This usually means that at start of integration the temperature of this
component is 25 degrees Celsius. You may, of course, define a different
temperature as start value for initialization. Alternatively, it is possible
to set parameter <strong>steadyStateStart</strong> to <strong>true</strong>. In this case
the additional equation '<strong>der</strong>(T) = 0' is used during
initialization, i.e., the temperature T is computed in such a way that
the component starts in <strong>steady state</strong>. This is useful in cases,
where one would like to start simulation in a suitable operating
point without being forced to integrate for a long time to arrive
at this point.
</p>
<p>
Note, that parameter <strong>steadyStateStart</strong> is not available in
the parameter menu of the simulation window, because its value
is utilized during translation to generate quite different
equations depending on its setting. Therefore, the value of this
parameter can only be changed before translating the model.
</p>
<p>
This component may be used for complicated geometries where
the heat capacity C is determined my measurements. If the component
consists mainly of one type of material, the <strong>mass m</strong> of the
component may be measured or calculated and multiplied with the
<strong>specific heat capacity cp</strong> of the component material to
compute C:
</p>
<pre>
   C = cp*m.
   Typical values for cp at 20 degC in J/(kg.K):
      aluminium   896
      concrete    840
      copper      383
      iron        452
      silver      235
      steel       420 ... 500 (V2A)
      wood       2500
</pre>
</html>"));
        end HeatCapacitor;

        model ThermalConductor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalConductance G
            "Constant thermal conductance of material";

        equation
          Q_flow = G*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  textString="G=%G")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-100,-20},{100,-40}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-100,40},{100,20}},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalResistor\">ThermalResistor</a>.
It may be used for complicated geometries where
the thermal conductance G (= inverse of thermal resistance)
is determined by measurements and is assumed to be constant
over the range of operations. If the component consists mainly of
one type of material and a regular geometry, it may be calculated,
e.g., with one of the following equations:
</p>
<ul>
<li><p>
    Conductance for a <strong>box</strong> geometry under the assumption
    that heat flows along the box length:</p>
    <pre>
    G = k*A/L
    k: Thermal conductivity (material constant)
    A: Area of box
    L: Length of box
    </pre>
    </li>
<li><p>
    Conductance for a <strong>cylindrical</strong> geometry under the assumption
    that heat flows from the inside to the outside radius
    of the cylinder:</p>
    <pre>
    G = 2*pi*k*L/log(r_out/r_in)
    pi   : Modelica.Constants.pi
    k    : Thermal conductivity (material constant)
    L    : Length of cylinder
    log  : Modelica.Math.log;
    r_out: Outer radius of cylinder
    r_in : Inner radius of cylinder
    </pre>
    </li>
</ul>
<pre>
    Typical values for k at 20 degC in W/(m.K):
      aluminium   220
      concrete      1
      copper      384
      iron         74
      silver      407
      steel        45 .. 15 (V2A)
      wood         0.1 ... 0.2
</pre>
</html>"));
        end ThermalConductor;

        model Convection
          "Lumped thermal element for heat convection (Q_flow = Gc*dT)"
          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = Gc*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Gc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor\">ConvectiveResistor</a>.
It may be used for complicated solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <em>calculated</em> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<strong>Machines cooled by air</strong> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><strong>Laminar</strong> flow with constant velocity of a fluid along a
<strong>flat plate</strong> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re &lt; 5e5 and 0.6 &lt; Pr &lt; 50
</pre>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-40,40},{80,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end Convection;

        model ThermalCollector "Collects m heat flows"
          parameter Integer m(min=1)=3 "Number of collected heat flows";
          Interfaces.HeatPort_a port_a[m]
            annotation (Placement(transformation(extent={{-10,110},{10,90}})));
          Interfaces.HeatPort_b port_b
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        equation
          port_b.Q_flow + sum(port_a.Q_flow) = 0;
          port_a.T = fill(port_b.T, m);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,-30},{150,-70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,80},{150,50}},
                  textString="m=%m"),
                Line(
                  points={{0,90},{0,40}},
                  color={181,0,0}),
                Rectangle(
                  extent={{-60,40},{60,30}},
                  lineColor={181,0,0},
                  fillColor={181,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,30},{0,-30},{0,-90}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{-20,30}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{20,30}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{60,30}},
                  color={181,0,0})}),
            Documentation(info="<html>
<p>
This is a model to collect the heat flows from <em>m</em> heatports to one single heatport.
</p>
</html>"));
        end ThermalCollector;
        annotation (Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Rectangle(
            origin = {12,40},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Backward,
            extent = {{-100,-100},{-70,18}}),
          Line(
            origin = {12,40},
            points = {{-44,16},{-44,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,16},{-4,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,18},{30,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,18},{66,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{76,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{56,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{40,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{20,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{6,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{-14,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-34,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-54,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-70,-60},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-70},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-50},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-30},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-10},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{-70,-20},{66,-20}},
            color = {191,0,0})}), Documentation(
              info="<html>

</html>"));
      end Components;

      package Sensors "Thermal sensors"
        extends Modelica.Icons.SensorsPackage;

        model TemperatureSensor "Absolute temperature sensor in Kelvin"

          Modelica.Blocks.Interfaces.RealOutput T(unit="K")
            "Absolute temperature as output signal"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Interfaces.HeatPort_a port annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
        equation
          T = port.T;
          port.Q_flow = 0;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-94,0},{-14,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                      12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{102,-28},{60,-78}},
                  textString="K")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-90,0},{-12,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},
                      {12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{126,-20},{26,-120}},
                  textString="K"),
                Text(
                  extent={{-150,130},{150,90}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This is an ideal absolute temperature sensor which returns
the temperature of the connected port in Kelvin as an output
signal.  The sensor itself has no thermal interaction with
whatever it is connected to.  Furthermore, no
thermocouple-like lags are associated with this
sensor model.
</p>
</html>"));
        end TemperatureSensor;

        model HeatFlowSensor "Heat flow rate sensor"
          extends Modelica.Icons.RotationalSensor;
          Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
            "Heat flow from port_a to port_b as output signal" annotation (Placement(
                transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Interfaces.HeatPort_a port_a annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b port_b annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          port_a.T = port_b.T;
          port_a.Q_flow + port_b.Q_flow = 0;
          Q_flow = port_a.Q_flow;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-70,0},{-95,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Line(points={{94,0},{69,0}}, color={191,0,0})}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{5,-86},{116,-110}},
                  textString="Q_flow"),
                Line(points={{-70,0},{-90,0}}, color={191,0,0}),
                Line(points={{69,0},{90,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Text(
                  extent={{-150,125},{150,85}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model is capable of monitoring the heat flow rate flowing through
this component. The sensed value of heat flow rate is the amount that
passes through this sensor while keeping the temperature drop across the
sensor zero.  This is an ideal model so it does not absorb any energy
and it has no direct effect on the thermal response of a system it is included in.
The output signal is positive, if the heat flows from port_a to port_b.
</p>
</html>"));
        end HeatFlowSensor;
        annotation (Documentation(info="<html>

</html>"));
      end Sensors;

      package Sources "Thermal sources"
      extends Modelica.Icons.SourcesPackage;

        model PrescribedTemperature
          "Variable temperature boundary condition in Kelvin"

          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput T(unit="K") annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}})));
        equation
          port.T = T;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{50,-20},{50,20},{90,0},{50,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <strong>T</strong>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{52,-20},{52,20},{90,0},{52,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedTemperature;

        model PrescribedHeatFlow "Prescribed heat flow boundary condition"
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature";
          parameter Modelica.SIunits.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
                annotation (Placement(transformation(
                origin={-100,0},
                extent={{20,-20},{-20,20}},
                rotation=180)));
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(
                  points={{-60,-20},{40,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{40,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-60,-20},{68,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{68,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{60,0},{60,40},{90,20},{60,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,-40},{60,0},{90,-20},{60,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedHeatFlow;
        annotation (Documentation(info="<html>

</html>"));
      end Sources;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          Modelica.SIunits.Temperature T "Port temperature";
          flow Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
          "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  lineColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        connector HeatPort_b
          "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_b",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-100,120},{120,60}},
                  lineColor={191,0,0},
                  textString="%name")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end HeatPort_b;

        partial model Element1D
          "Partial heat transfer element with two HeatPort connectors that does not store energy"

          Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate from port_a -> port_b";
          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
      public
          HeatPort_a port_a annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          HeatPort_b port_b annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          port_a.Q_flow = Q_flow;
          port_b.Q_flow = -Q_flow;
          annotation (Documentation(info="<html>
<p>
This partial model contains the basic connectors and variables to
allow heat transfer models to be created that <strong>do not store energy</strong>,
This model defines and includes equations for the temperature
drop across the element, <strong>dT</strong>, and the heat flow rate
through the element from port_a to port_b, <strong>Q_flow</strong>.
</p>
<p>
By extending this model, it is possible to write simple
constitutive equations for many types of heat transfer components.
</p>
</html>"));
        end Element1D;
        annotation (Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Polygon(
            origin = {13.758,27.517},
            lineColor = {128,128,128},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
        Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {160,160,164},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
          Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
          Line(
            origin = {13.758,27.517},
            points = {{-41,-17},{-9,-17}},
            color = {191,0,0},
            thickness = 0.5),
          Line(
            origin = {13.758,27.517},
            points = {{-17,-40},{15,-40}},
            color = {191,0,0},
            thickness = 0.5),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}),
                                Documentation(info="<html>
<p>
This package contains components to model <strong>1-dimensional heat transfer</strong>
with lumped elements. This allows especially to model heat transfer in
machines provided the parameters of the lumped elements, such as
the heat capacity of a part, can be determined by measurements
(due to the complex geometries and many materials used in machines,
calculating the lumped element parameters from some basic analytic
formulas is usually not possible).
</p>
<p>
Example models how to use this library are given in subpackage <strong>Examples</strong>.<br>
For a first simple example, see <strong>Examples.TwoMasses</strong> where two masses
with different initial temperatures are getting in contact to each
other and arriving after some time at a common temperature.<br>
<strong>Examples.ControlledTemperature</strong> shows how to hold a temperature
within desired limits by switching on and off an electric resistor.<br>
A more realistic example is provided in <strong>Examples.Motor</strong> where the
heating of an electrical motor is modelled, see the following screen shot
of this example:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Thermal/HeatTransfer/driveWithHeatTransfer.png\" alt=\"driveWithHeatTransfer\">
</p>

<p>
The <strong>filled</strong> and <strong>non-filled red squares</strong> at the left and
right side of a component represent <strong>thermal ports</strong> (connector HeatPort).
Drawing a line between such squares means that they are thermally connected.
The variables of a HeatPort connector are the temperature <strong>T</strong> at the port
and the heat flow rate <strong>Q_flow</strong> flowing into the component (if Q_flow is positive,
the heat flows into the element, otherwise it flows out of the element):
</p>
<pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
   Modelica.SIunits.HeatFlowRate Q_flow  \"flow rate at the port in Watt\";
</pre>
<p>
Note, that all temperatures of this package, including initial conditions,
are given in Kelvin. For convenience, in subpackages <strong>HeatTransfer.Celsius</strong>,
 <strong>HeatTransfer.Fahrenheit</strong> and <strong>HeatTransfer.Rankine</strong> components are provided such that source and
sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
respectively. Additionally, in package <strong>SIunits.Conversions</strong> conversion
functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
provided. These functions may be used in the following way:
</p>
<pre>  <strong>import</strong> SI=Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
</pre>

<p>
There are several other components available, such as AxialConduction (discretized PDE in
axial direction), which have been temporarily removed from this library. The reason is that
these components reference material properties, such as thermal conductivity, and currently
the Modelica design group is discussing a general scheme to describe material properties.
</p>
<p>
For technical details in the design of this library, see the following reference:<br>
<strong>Michael Tiller (2001)</strong>: <a href=\"http://www.amazon.de\">
Introduction to Physical Modeling with Modelica</a>.
Kluwer Academic Publishers Boston.
</p>
<p>
<strong>Acknowledgements:</strong><br>
Several helpful remarks from the following persons are acknowledged:
John Batteh, Ford Motors, Dearborn, U.S.A;
<a href=\"https://www.haumer.at/\">Anton Haumer</a>, Technical Consulting &amp; Electrical Engineering, Germany;
Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
Hans Olsson, Dassault Syst&egrave;mes AB, Sweden;
Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
</p>
<dl>
  <dt><strong>Main Authors:</strong></dt>
  <dd>
  <p>
  <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
  Technical Consulting &amp; Electrical Engineering<br>
  D-93049 Regensburg, Germany<br>
  email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
</p>
  </dd>
</dl>
<p>
Copyright &copy; 2001-2019, Modelica Association and contributors
</p>
</html>",     revisions="<html>
<ul>
<li><em>July 15, 2002</em>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Nikolaus Sch&uuml;rmann:<br>
       Implemented.
</li>
<li><em>June 13, 2005</em>
       by <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       components moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
    annotation (
     Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Line(
      origin={-47.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={-50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={2.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={0.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={52.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}})}),
      Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

  package Vectors "Library of functions operating on vectors"
    extends Modelica.Icons.Package;

    function toString "Convert a real vector in to a string representation"
      extends Modelica.Icons.Function;
      import Modelica.Utilities.Strings;

      input Real v[:] "Real vector";
      input String name="" "Independent variable name used for printing";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      output String s="";
  protected
      String blanks=Strings.repeat(significantDigits);
      String space=Strings.repeat(8);
      Integer r=size(v, 1);

    algorithm
      if r == 0 then
        s := if name == "" then "[]" else name + " = []";
      else
        s := if name == "" then "\n" else "\n" + name + " = \n";
        for i in 1:r loop
          s := s + space;

          if v[i] >= 0 then
            s := s + " ";
          end if;
          s := s + String(v[i], significantDigits=significantDigits) +
            Strings.repeat(significantDigits + 8 - Strings.length(String(abs(v[i]))));

          s := s + "\n";
        end for;

      end if;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>toString</strong>(v);
Vectors.<strong>toString</strong>(v,name=\"\",significantDigits=6);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>toString</strong>(v)</code>\" returns the string representation of vector <strong>v</strong>.
With the optional arguments \"name\" and \"significantDigits\" a name and the number of the digits are defined.
The default values of \"name\" and \"significantDigits\" are \"\" and 6 respectively. If name==\"\" (empty string) then the prefix \"&lt;name&gt; =\" is left out at the output-string.
</p>
<h4>Example</h4>
<blockquote><pre>
  v = {2.12, -4.34, -2.56, -1.67};
  <strong>toString</strong>(v);
                         // = \"
                         //           2.12
                         //          -4.34
                         //          -2.56
                         //          -1.67\"
  <strong>toString</strong>(v,\"vv\",1);
                         // = \"vv =
                         //           2
                         //          -4
                         //          -3
                         //          -2\"
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.toString\">Matrices.toString</a>,
</p>
</html>",   revisions="<html>

</html>"));
    end toString;

    function norm "Return the p-norm of a vector"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector";
      input Real p(min=1) = 2
        "Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)";
      output Real result=0.0 "p-norm of vector v";
  protected
      Real eps = 10*Modelica.Constants.eps;
    algorithm
     if size(v,1) > 0 then
      if p >= 2-eps and p <= 2+eps then
        result := sqrt(v*v);
      elseif p >= Modelica.Constants.inf then
        result := max(abs(v));
      elseif p >= 1-eps and p <= 1+eps then
        result := sum(abs(v));
      elseif p >= 1 then
        result := (sum(abs(v[i])^p for i in 1:size(v, 1)))^(1/p);
      else
        assert(false, "Optional argument \"p\" (= " + String(p) + ") of function \"norm\" >= 1 required");
      end if;
     end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>norm</strong>(v);
Vectors.<strong>norm</strong>(v,p=2);   // 1 &le; p &le; &#8734;
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>norm</strong>(v)</code>\" returns the
<strong>Euclidean norm</strong> \"<code>sqrt(v*v)</code>\" of vector v.
With the optional
second argument \"p\", any other p-norm can be computed:
</p>
<center>
<img src=\"modelica://Modelica/Resources/Images/Math/Vectors/vectorNorm.png\" alt=\"function Vectors.norm\">
</center>
<p>
Besides the Euclidean norm (p=2), also the 1-norm and the
infinity-norm are sometimes used:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>1-norm</strong></td>
      <td>= sum(abs(v))</td>
      <td><strong>norm</strong>(v,1)</td>
  </tr>
  <tr><td><strong>2-norm</strong></td>
      <td>= sqrt(v*v)</td>
      <td><strong>norm</strong>(v) or <strong>norm</strong>(v,2)</td>
  </tr>
  <tr><td><strong>infinity-norm</strong></td>
      <td>= max(abs(v))</td>
      <td><strong>norm</strong>(v,Modelica.Constants.<strong>inf</strong>)</td>
  </tr>
</table>
<p>
Note, for any vector norm the following inequality holds:
</p>
<blockquote><pre>
<strong>norm</strong>(v1+v2,p) &le; <strong>norm</strong>(v1,p) + <strong>norm</strong>(v2,p)
</pre></blockquote>
<h4>Example</h4>
<blockquote><pre>
  v = {2, -4, -2, -1};
  <strong>norm</strong>(v,1);    // = 9
  <strong>norm</strong>(v,2);    // = 5
  <strong>norm</strong>(v);      // = 5
  <strong>norm</strong>(v,10.5); // = 4.00052597412635
  <strong>norm</strong>(v,Modelica.Constants.inf);  // = 4
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.norm\">Matrices.norm</a>
</p>
</html>"));
    end norm;

    function sort "Sort elements of vector in ascending or descending order"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector to be sorted";
      input Boolean ascending=true
        "= true if ascending order, otherwise descending order";
      output Real sorted_v[size(v, 1)]=v "Sorted vector";
      output Integer indices[size(v, 1)]=1:size(v, 1) "sorted_v = v[indices]";

      /* shellsort algorithm; should be improved later */
  protected
      Integer gap;
      Integer i;
      Integer j;
      Real wv;
      Integer wi;
      Integer nv=size(v, 1);
      Boolean swap;
    algorithm
      gap := div(nv, 2);

      while gap > 0 loop
        i := gap;
        while i < nv loop
          j := i - gap;
          if j >= 0 then
            if ascending then
              swap := sorted_v[j + 1] > sorted_v[j + gap + 1];
            else
              swap := sorted_v[j + 1] < sorted_v[j + gap + 1];
            end if;
          else
            swap := false;
          end if;

          while swap loop
            wv := sorted_v[j + 1];
            wi := indices[j + 1];
            sorted_v[j + 1] := sorted_v[j + gap + 1];
            sorted_v[j + gap + 1] := wv;
            indices[j + 1] := indices[j + gap + 1];
            indices[j + gap + 1] := wi;
            j := j - gap;
            if j >= 0 then
              if ascending then
                swap := sorted_v[j + 1] > sorted_v[j + gap + 1];
              else
                swap := sorted_v[j + 1] < sorted_v[j + gap + 1];
              end if;
            else
              swap := false;
            end if;
          end while;
          i := i + 1;
        end while;
        gap := div(gap, 2);
      end while;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_v = Vectors.<strong>sort</strong>(v);
(sorted_v, indices) = Vectors.<strong>sort</strong>(v, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>sort</strong>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument \"ascending\" is <strong>false</strong>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>
<h4>Example</h4>
<blockquote><pre>
  (v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
       -> v2 = {-1, 2, 3, 6, 8}
          i2 = {1, 5, 3, 4, 2}
</pre></blockquote>
</html>"));
    end sort;
    annotation (preferredView="info", Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on vectors:
</p>

<ul>
<li> <a href=\"modelica://Modelica.Math.Vectors.toString\">toString</a>(v)
     - returns the string representation of vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.isEqual\">isEqual</a>(v1, v2)
     - returns true if vectors v1 and v2 have the same size and the same elements.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.norm\">norm</a>(v,p)
     - returns the p-norm of vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.length\">length</a>(v)
     - returns the length of vector v (= norm(v,2), but inlined and therefore usable in
       symbolic manipulations)</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.normalize\">normalize</a>(v)
     - returns vector in direction of v with length = 1 and prevents
       zero-division for zero vector.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.reverse\">reverse</a>(v)
     - reverses the vector elements of v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.sort\">sort</a>(v)
     - sorts the elements of vector v in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.find\">find</a>(e, v)
     - returns the index of the first occurrence of scalar e in vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.interpolate\">interpolate</a>(x, y, xi)
     - returns the interpolated value in (x,y) that corresponds to xi.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.relNodePositions\">relNodePositions</a>(nNodes)
     - returns a vector of relative node positions (0..1).</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices\">Matrices</a>
</html>"),
      Icon(graphics={Rectangle(
            extent={{-16,66},{14,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid), Rectangle(
            extent={{-16,-14},{14,-62}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Vectors;

    package BooleanVectors "Library of functions operating on Boolean vectors"
     extends Modelica.Icons.Package;

    function allTrue
        "Returns true, if all elements of the Boolean input vector are true ('and')"
      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if all elements of b are true";
    algorithm
      result := size(b,1) > 0;
      for i in 1:size(b,1) loop
         result := result and b[i];
      end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>allTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if all elements of the Boolean input vector b are <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {true, true, true};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = allTrue(b1);  // r1 = true
  r2 = allTrue(b2);  // r2 = false
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>

</html>"));
    end allTrue;

    function anyTrue
        "Returns true, if at least on element of the Boolean input vector is true ('or')"

      extends Modelica.Icons.Function;
      input Boolean b[:];
      output Boolean result;
    algorithm
      result := false;
      for i in 1:size(b,1) loop
         result := result or b[i];
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>anyTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if at least one elements of the input Boolean vector b is <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {false, false, false};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = anyTrue(b1);  // r1 = false
  r2 = anyTrue(b2);  // r2 = true
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.allTrue\">allTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>
</html>"));
    end anyTrue;

    function countTrue "Returns the number of true entries in a Boolean vector"

      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Integer n "Number of true entries";
    algorithm
      n := sum(if b[i] then 1 else 0 for i in 1:size(b, 1));

        annotation (Inline=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>countTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the number of <strong>true</strong> entries in a Boolean vector b.
</p>

<h4>Example</h4>
<p><code>countTrue({false, true, false, true})</code> returns 2.</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.allTrue\">allTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>
</html>"));
    end countTrue;

    function index "Returns the indices of the true entries of a Boolean vector"
      extends Modelica.Icons.Function;

      input Boolean b[:] "Boolean vector";
      output Integer indices[countTrue(b)] "Indices of the true entries";

    protected
      Integer count;

    algorithm
        count := 1;
        for i in 1:size(b, 1) loop
          if b[i] then
            indices[count] := i;
            count := count + 1;
          end if;
        end for;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>index</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns an integer vector that contains indices to the
<strong>true</strong> entries in a Boolean vector b.  The number of entries in
the integer vector is the number of <strong>true</strong> entries in b.
</p>

<h4>Example</h4>
<code>index({false, true, false, true})</code> returns <code>{2,4}</code>.

  <h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.allTrue\">allTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>
</html>"));
    end index;
      annotation (Documentation(info="<html>
<p>
This library provides functions operating on vectors that have
a Boolean vector as input argument.
</p>
</html>"),     Icon(graphics={Rectangle(
              extent={{-16,62},{14,14}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-16,-18},{14,-66}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}));
    end BooleanVectors;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function leastSquares
      "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
        "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A, 1), size(A, 2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsy_vec(
              A,
              b,
              rcond);
        x := xx[1:size(A, 2)];
        assert(info == 0,
          "Solving an overdetermined or underdetermined linear system\n" +
          "of equations with function \"Matrices.leastSquares\" failed.");
      else
        x := fill(0.0, size(A, 2));
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>leastSquares</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*x - b |
</pre>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     x = P * Z' [ inv(T11)*Q1'*b ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.Package;

      function dgelsy_vec
        "Computes the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A, 1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(size(A, 1), size(A, 2))]=cat(
                  1,
                  b,
                  zeros(max(nrow, ncol) - nrow))
          "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nrhs=1;
        Integer nx=max(nrow, ncol);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + 1);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + 1)];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                x,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy_vec;
      annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;
    annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><strong>Basic Information</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><strong>Linear Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><strong>Matrix Factorizations</strong></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><strong>Matrix Properties</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><strong>Matrix Exponentials</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><strong>Matrix Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccati equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccati equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><strong>Matrix Manipulation</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</html>"),   Icon(graphics={
          Rectangle(
            extent={{-60,66},{-30,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,66},{58,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,-18},{-30,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,-18},{58,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Matrices;

    package Nonlinear "Library of functions operating on nonlinear equations"
      extends Modelica.Icons.Package;

      package Interfaces "Interfaces for functions"
        extends Modelica.Icons.InterfacesPackage;

      encapsulated partial function partialScalarFunction
          "Interface for a function with one input and one output Real signal"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real u "Independent variable";
        output Real y "Dependent variable y=f(u)";
          annotation (Documentation(info="<html>
<p>
This partial function defines the interface of a function with
one input and one output Real signal. The scalar functions
of <a href=\"modelica://Modelica.Math.Nonlinear\">Modelica.Math.Nonlinear</a>
are derived from this base type by inheritance.
This allows to use these functions directly as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>

</html>"));
      end partialScalarFunction;
        annotation (Documentation(info="<html>
<p>
Interface definitions of functions. The main purpose is to use functions
derived from these interface definitions as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>
</html>"));
      end Interfaces;

      function solveOneNonlinearEquation
        "Solve f(u) = 0 in a very reliable and efficient way (f(u_min) and f(u_max) must have different signs)"
        extends Modelica.Icons.Function;
        import Modelica.Utilities.Streams.error;

        input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction f
          "Function y = f(u); u is computed so that y=0";
        input Real u_min "Lower bound of search interval";
        input Real u_max "Upper bound of search interval";
        input Real tolerance=100*Modelica.Constants.eps
          "Relative tolerance of solution u";
        output Real u "Value of independent variable u so that f(u) = 0";

    protected
        constant Real eps=Modelica.Constants.eps "machine epsilon";
        Real a=u_min "Current best minimum interval value";
        Real b=u_max "Current best maximum interval value";
        Real c "Intermediate point a <= c <= b";
        Real d;
        Real e "b - a";
        Real m;
        Real s;
        Real p;
        Real q;
        Real r;
        Real tol;
        Real fa "= f(a)";
        Real fb "= f(b)";
        Real fc;
        Boolean found=false;
      algorithm
        // Check that f(u_min) and f(u_max) have different sign
        fa := f(u_min);
        fb := f(u_max);
        fc := fb;
        if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
          error(
            "The arguments u_min and u_max provided in the function call\n"+
            "    solveOneNonlinearEquation(f,u_min,u_max)\n" +
            "do not bracket the root of the single non-linear equation 0=f(u):\n" +
            "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
             + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
            "  fb = f(u_max) = " + String(fb) + "\n" +
            "fa and fb must have opposite sign which is not the case");
        end if;

        // Initialize variables
        c := a;
        fc := fa;
        e := b - a;
        d := e;

        // Search loop
        while not found loop
          if abs(fc) < abs(fb) then
            a := b;
            b := c;
            c := a;
            fa := fb;
            fb := fc;
            fc := fa;
          end if;

          tol := 2*eps*abs(b) + tolerance;
          m := (c - b)/2;

          if abs(m) <= tol or fb == 0.0 then
            // root found (interval is small enough)
            found := true;
            u := b;
          else
            // Determine if a bisection is needed
            if abs(e) < tol or abs(fa) <= abs(fb) then
              e := m;
              d := e;
            else
              s := fb/fa;
              if a == c then
                // linear interpolation
                p := 2*m*s;
                q := 1 - s;
              else
                // inverse quadratic interpolation
                q := fa/fc;
                r := fb/fc;
                p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                q := (q - 1)*(r - 1)*(s - 1);
              end if;

              if p > 0 then
                q := -q;
              else
                p := -p;
              end if;

              s := e;
              e := d;
              if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                // interpolation successful
                d := p/q;
              else
                // use bi-section
                e := m;
                d := e;
              end if;
            end if;

            // Best guess value is defined as "a"
            a := b;
            fa := fb;
            b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
            fb := f(b);

            if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
              // initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;
            end if;
          end if;
        end while;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>solveOneNonlinearEquation</strong>(function f(), u_min, u_max);
<strong>solveOneNonlinearEquation</strong>(function f(), u_min, u_max, tolerance=100*Modelica.Constants.eps);
</pre></blockquote>

<h4>Description</h4>

<p>
This function determines the solution of <strong>one non-linear algebraic equation</strong> \"y=f(u)\"
in <strong>one unknown</strong> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. The function computes a smaller interval
in which a sign change is present using the relative tolerance
\"tolerance\" that can be given as 4th input argument.
</p>

<p>
The interval reduction is performed using
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<blockquote>
<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.<br>
     Download: <a href=\"http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf\">http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf</a><br>
     Errata and new print: <a href=\"http://wwwmaths.anu.edu.au/~brent/pub/pub011.html\">http://wwwmaths.anu.edu.au/~brent/pub/pub011.html</a>
</dd>
</dl>
</blockquote>

<h4>Example</h4>

<p>
See the examples in <a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Modelica.Math.Nonlinear.Examples</a>.
</p>
</html>"));
      end solveOneNonlinearEquation;
      annotation (Documentation(info="<html>
<p>
This package contains functions to perform tasks such as numerically integrating
a function, or solving a nonlinear algebraic equation system.
The common feature of the functions in this package is
that the nonlinear characteristics are passed as user definable
functions.
</p>

<p>
For details about how to define and to use functions as input arguments
to functions, see
<a href=\"modelica://ModelicaReference.Classes.'function'\">ModelicaReference.Classes.'function'</a>
or the Modelica Language  Specification, Chapter 12.4.2.
</p>

</html>",     revisions="<html>
<ul>
<li><em>July 2010 </em> by Martin Otter (DLR-RM):<br>
    Included in MSL3.2, adapted, and documentation improved</li>

<li><em>March 2010 </em> by Andreas Pfeiffer (DLR-RM):<br>
    Adapted the quadrature function from Gerhard Schillhuber and
    the solution of one non-linear equation in one unknown from
    Modelica.Media.Common.OneNonLinearEquation so that
    function objects are used.</li>

<li><em>June 2002 </em> by Gerhard Schillhuber (master thesis at DLR-RM):<br>
       Adaptive quadrature to compute the curve length of a Spline.</li>
</ul>
</html>"),     Icon(graphics={Polygon(points={{-44,-52},{-44,-26},{-17.1,
                  44.4},{-11.4,52.6},{-5.8,57.1},{-0.2,57.8},{5.4,54.6},{11.1,47.7},
                  {16.7,37.4},{23.1,22.1},{31.17,-0.8},{48,-52},{-44,-52}},
              lineColor={135,135,135},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}));
    end Nonlinear;

  package Icons "Icons for Math"
    extends Modelica.Icons.IconsPackage;

    partial function AxisLeft
      "Basic icon for mathematical function with y-axis on left side"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                100,100}}), graphics={Line(points={{-80,80},{-88,80}}, color={95,95,95}),
              Line(points={{-80,-80},{-88,-80}}, color={95,95,95}),Line(
              points={{-80,-90},{-80,84}}, color={95,95,95}),Text(
                  extent={{-75,104},{-55,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{-80,98},{-86,82},{-74,82},{-80,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisLeft;

    partial function AxisCenter
      "Basic icon for mathematical function with y-axis in the center"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(graphics={Line(points={{0,80},{-8,80}}, color={95,95,95}),Line(
              points={{0,-80},{-8,-80}}, color={95,95,95}),Line(points={{0,-90},{
              0,84}}, color={95,95,95}),Text(
                  extent={{5,104},{25,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{0,98},{-6,82},{6,82},{0,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisCenter;
  end Icons;

  function sin "Sine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.SIunits.Angle u;
    output Real y;

  external "builtin" y = sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}),
          Text(
            extent={{12,84},{84,36}},
            lineColor={192,192,192},
            textString="sin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
              {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,
              44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},
              {35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,
              -47.2},{72,-24.8},{80,0}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-6},{102,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,80},{-28,80}},
              color={175,175,175}),Line(
              points={{-80,-80},{50,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"));
  end sin;

  function cos "Cosine"
    extends Modelica.Math.Icons.AxisLeft;
    input SI.Angle u;
    output Real y;

  external "builtin" y = cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}),
          Text(
            extent={{-36,82},{36,34}},
            lineColor={192,192,192},
            textString="cos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-103,72},{-83,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
              {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
              {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{
              24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
              73.4},{75.2,78.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{78,-6},{98,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,-80},{18,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"));
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends Modelica.Math.Icons.AxisCenter;
    input SI.Angle u;
    output Real y;

  external "builtin" y = tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}),
          Text(
            extent={{-90,72},{-18,24}},
            lineColor={192,192,192},
            textString="tan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-37,-72},{-17,-88}},
              textString="-5.8",
              lineColor={0,0,255}),Text(
              extent={{-33,86},{-13,70}},
              textString=" 5.8",
              lineColor={0,0,255}),Text(
              extent={{68,-13},{88,-33}},
              textString="1.4",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
              {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
              {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
              47.4},{76,56.1},{77.6,63.8},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,22},{102,2}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,88},{80,-16}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"));
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}),
          Text(
            extent={{-88,78},{-16,30}},
            lineColor={192,192,192},
            textString="asin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-40,-72},{-15,-88}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{-38,88},{-13,72}},
              textString=" pi/2",
              lineColor={0,0,255}),Text(
              extent={{68,-9},{88,-29}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{-90,21},{-70,1}},
              textString="-1",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
              -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
              52.7},{75.2,62.2},{77.6,67.5},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,24},{102,4}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,86},{80,-10}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"));
  end asin;

  function acos "Inverse cosine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = acos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
          Polygon(
            points={{90,-80},{68,-72},{68,-88},{90,-80}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,
                49.8},{-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}}),
          Text(
            extent={{-86,-14},{-14,-62}},
            lineColor={192,192,192},
            textString="acos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80},{84,-80}}, color={95,95,95}),
            Polygon(
              points={{98,-80},{82,-74},{82,-86},{98,-80}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,49.8},
              {-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},{
              75.2,-62.2},{77.6,-67.5},{80,-80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-30,88},{-5,72}},
              textString=" pi",
              lineColor={0,0,255}),Text(
              extent={{-94,-57},{-74,-77}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{60,-81},{80,-101}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{82,-56},{102,-76}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175}),Line(
              points={{80,82},{80,-86}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = acos(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/acos.png\">
</p>
</html>"));
  end acos;

  function atan "Inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = atan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
                {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},
                {9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,
                73.6},{69.5,78.6},{80,80}}),
          Text(
            extent={{-86,68},{-14,20}},
            lineColor={192,192,192},
            textString="atan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
              {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},{
              9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},
              {65,77},{80,78}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-34,87},{-14,74}},
              textString="pi/2",
              lineColor={0,0,255}),Text(
              extent={{-32,-71},{-12,-91}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{84,-4},{104,-24}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan.png\">
</p>
</html>"));
  end atan;

  function cosh "Hyperbolic cosine"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = cosh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-86.083},{68,-86.083}}, color={192,192,192}),
          Polygon(
            points={{90,-86.083},{68,-78.083},{68,-94.083},{90,-86.083}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,
                1.29},{-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,
                -64.3},{-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{
                23.7,-75.2},{34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{
                59.1,-27.5},{63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{
                77.6,61.1},{80,80}}),
          Text(
            extent={{4,66},{66,20}},
            lineColor={192,192,192},
            textString="cosh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-84.083},{84,-84.083}}, color=
             {95,95,95}),Polygon(
              points={{98,-84.083},{82,-78.083},{82,-90.083},{98,-84.083}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,1.29},
              {-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,-64.3},
              {-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{23.7,-75.2},
              {34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{59.1,-27.5},{
              63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="27",
              lineColor={0,0,255}),Text(
              extent={{64,-83},{84,-103}},
              textString="4",
              lineColor={0,0,255}),Text(
              extent={{-94,-63},{-74,-83}},
              textString="-4",
              lineColor={0,0,255}),Text(
              extent={{80,-60},{100,-80}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-90}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cosh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cosh.png\">
</p>
</html>"));
  end cosh;

  function tanh "Hyperbolic tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = tanh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-47.8,-78.7},{-35.8,-75.7},{-27.7,-70.6},{-22.1,
                -64.2},{-17.3,-55.9},{-12.5,-44.3},{-7.64,-29.2},{-1.21,-4.82},{
                6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},
                {45.4,78.4},{72,79.9},{80,80}}),
          Text(
            extent={{-88,72},{-16,24}},
            lineColor={192,192,192},
            textString="tanh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80.5},{-47.8,-79.2},{-35.8,-76.2},{-27.7,-71.1},{-22.1,
              -64.7},{-17.3,-56.4},{-12.5,-44.8},{-7.64,-29.7},{-1.21,-5.32},{
              6.83,25.8},{11.7,41.5},{16.5,53.7},{21.3,62.6},{26.9,69.4},{34.2,
              74.5},{45.4,77.9},{72,79.4},{80,79.5}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-29,72},{-9,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{3,-72},{23,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-2},{102,-22}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tanh.png\">
</p>
</html>"));
  end tanh;

  function exp "Exponential, base e"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
          Text(
            extent={{-86,50},{-14,2}},
            lineColor={192,192,192},
            textString="exp")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80.3976},{84,-80.3976}},
            color={95,95,95}),Polygon(
              points={{98,-80.3976},{82,-74.3976},{82,-86.3976},{98,-80.3976}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},{
              34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{67.1,
              18.6},{72,38.2},{76,57.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-92,-81},{-72,-101}},
              textString="-3",
              lineColor={0,0,255}),Text(
              extent={{66,-81},{86,-101}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{2,-69},{22,-89}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{78,-54},{98,-74}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-84}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"));
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u;
    output Real y;

  external "builtin" y = log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-6,-24},{66,-72}},
            lineColor={192,192,192},
            textString="log")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-78,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
              {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},{-45,
              38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{60,-3},{80,-23}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-78,-7},{-58,-27}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{84,26},{104,6}},
              lineColor={95,95,95},
              textString="u"),Text(
              extent={{-100,9},{-80,-11}},
              textString="0",
              lineColor={0,0,255}),Line(
              points={{-80,80},{84,80}},
              color={175,175,175}),Line(
              points={{82,82},{82,-6}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"));
  end log;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
            {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
              {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
              -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
              -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
              {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
              0,0,0}, smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<h4>Main Authors</h4>
<p><a href=\"http://www.robotic.dlr.de/Martin.Otter/\"><strong>Martin Otter</strong></a>
and <strong>Marcus Baur</strong><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a>
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added wrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Function tempInterpol2 added.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>

</html>"));
  end Math;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.UtilitiesPackage;

    package Files "Functions to work with files and directories"
      extends Modelica.Icons.FunctionsPackage;

    function fullPathName "Get full path name of file or directory name"
      extends Modelica.Icons.Function;
      input String name "Absolute or relative file or directory name";
      output String fullName "Full path of 'name'";
    external "C" fullName = ModelicaInternal_fullPathName(name) annotation(Library="ModelicaExternalC");

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fullName = Files.<strong>fullPathName</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the full path name of a file or directory \"name\".
</p>
</html>"));
    end fullPathName;

      function loadResource
        "Return the absolute path name of a URI or local file name"
         extends
        Modelica.Utilities.Internal.PartialModelicaServices.ExternalReferences.PartialLoadResource;
         extends ModelicaServices.ExternalReferences.loadResource;
        annotation (
          Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = Files.<strong>loadResource</strong>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Files.<strong>loadResource</strong>(uri)</code>\" returns the
<strong>absolute path name</strong> of the file that is either defined by an URI or by a local
path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific. However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\\\data\\\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
      end loadResource;
        annotation (
    Documentation(info="<html>
<p>
This package contains functions to work with files and directories.
As a general convention of this package, '/' is used as directory
separator both for input and output arguments of all functions.
For example:
</p>
<pre>
   exist(\"Modelica/Mechanics/Rotational.mo\");
</pre>
<p>
The functions provide the mapping to the directory separator of the
underlying operating system. Note, that on Windows system the usage
of '\\' as directory separator would be inconvenient, because this
character is also the escape character in Modelica and C Strings.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.list\">list</a>(name)</td>
      <td> List content of file or of directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName, replace=false)</td>
      <td> Generate a copy of a file or of a directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName, replace=false)</td>
      <td> Move a file or a directory to another place.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.remove\">remove</a>(name)</td>
      <td> Remove file or directory (ignore call, if it does not exist).</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.removeFile\">removeFile</a>(name)</td>
      <td> Remove file (ignore call, if it does not exist)</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.createDirectory\">createDirectory</a>(name)</td>
      <td> Create directory (if directory already exists, ignore call).</td>
  </tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Files.exist\">exist</a>(name)</td>
      <td> Inquire whether file or directory exists.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.assertNew\">assertNew</a>(name,message)</td>
      <td> Trigger an assert, if a file or directory exists.</td>
  </tr>
  <tr><td>fullName = <a href=\"modelica://Modelica.Utilities.Files.fullPathName\">fullPathName</a>(name)</td>
      <td> Get full path name of file or directory name.</td>
  </tr>
  <tr><td>(directory, name, extension) = <a href=\"modelica://Modelica.Utilities.Files.splitPathName\">splitPathName</a>(name)</td>
      <td> Split path name in directory, file name kernel, file name extension.</td>
  </tr>
  <tr><td>fileName = <a href=\"modelica://Modelica.Utilities.Files.temporaryFileName\">temporaryFileName</a>()</td>
      <td> Return arbitrary name of a file that does not exist<br>
           and is in a directory where access rights allow to<br>
           write to this file (useful for temporary output of files).</td>
  </tr>
  <tr><td>fileReference = <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>(uri)</td>
      <td>Return the absolute path name of a URI or local file name.</td>
  </tr>
</table>
</html>"));
    end Files;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.FunctionsPackage;

      function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
          "File where to print (empty string is the terminal)"
                     annotation(Dialog(saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName) annotation(Library="ModelicaExternalC");

        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>print</strong>(string);
Streams.<strong>print</strong>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>print</strong>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <strong>Streams.close</strong>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.print(\"x = \" + String(x));
  Streams.print(\"y = \" + String(y));
  Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end print;

      function readLine "Read a line of text from a file and return it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
          "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) annotation(Library="ModelicaExternalC");
        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<strong>readLine</strong>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readLine</strong>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      function error "Print error message and cancel all actions - in case of an unrecoverable error"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>error</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
In case of an unrecoverable error (i.e., if the solver is unable to recover from the error),
print the string \"string\" as error message and cancel all actions.
This function is semantically equivalent with the built-in function <strong>assert</strong> if called with the (default) <strong>AssertionLevel.error</strong>.
Line breaks are characterized by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.'assert()'\">ModelicaReference.Operators.'assert()'</a>
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end error;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Streams</strong> contains functions to input and output strings
to a message window or on files, as well as reading matrices from file
and writing matrices to file. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<blockquote><p>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</p></blockquote>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td>stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td>(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td>Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td>lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td>Returns the number of lines in a file.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>(fileName, matrixName)</td>
      <td> Read dimensions of a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>(fileName, matrixName, nrow, ncol)</td>
      <td> Read a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>(fileName, matrixName, matrix, append, format)</td>
      <td> Write Real matrix to a MATLAB MAT file. </td></tr>
</table>
<p>
Use functions <strong>scanXXX</strong> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>(...).
Example:
</p>
<pre>
  <strong>if</strong> x &lt; 0 <strong>or</strong> x &gt; 1 <strong>then</strong>
     Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
  <strong>end if</strong>;
</pre>
</html>"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.FunctionsPackage;

      function length "Return length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>length</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      function substring "Return a substring defined by start and end index"

        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
          "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
          "String containing substring string[startIndex:endIndex]";
      external "C" result=ModelicaStrings_substring(string,startIndex,endIndex) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>substring</strong>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
  string1 := \"This is line 111\";
  string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      function repeat "Repeat a string n times"
        extends Modelica.Icons.Function;
        input Integer n(min=0) = 1 "Number of occurrences";
        input String string=" " "String that is repeated";
        output String repeatedString "String containing n concatenated strings";
      algorithm
        repeatedString :="";
        for i in 1:n loop
           repeatedString := repeatedString + string;
        end for;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>repeat</strong>(n);
string2 = Strings.<strong>repeat</strong>(n, string=\" \");
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns a string consisting of n blanks.
</p>
<p>
The second form returns a string consisting of n substrings
defined by the optional argument \"string\".
</p>
</html>"));
      end repeat;

      function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<strong>compare</strong>(string1, string2);
result = Strings.<strong>compare</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<pre>
  result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
         = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
         = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEqual</strong>(string1, string2);
Strings.<strong>isEqual</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function isEmpty
        "Return true if a string is empty (has only white space characters)"
        extends Modelica.Icons.Function;
        input String string;
        output Boolean result "True, if string is empty";
    protected
        Integer nextIndex;
        Integer len;
      algorithm
        nextIndex := Strings.Advanced.skipWhiteSpace(string);
        len := Strings.length(string);
        if len < 1 or nextIndex > len then
          result := true;
        else
          result := false;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEmpty</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true if the string has no characters or if the string consists
only of white space characters. Otherwise, false is returned.
</p>

<h4>Example</h4>
<blockquote><pre>
  isEmpty(\"\");       // returns true
  isEmpty(\"   \");    // returns true
  isEmpty(\"  abc\");  // returns false
  isEmpty(\"a\");      // returns false
</pre></blockquote>
</html>"));
      end isEmpty;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
         output Integer index
          "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>find</strong>(string, searchString);
index = Strings.<strong>find</strong>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end find;

      function replace
        "Replace non-overlapping occurrences of a string from left to right"
        extends Modelica.Icons.Function;
        input String string "String to be modified";
        input String searchString
          "Replace non-overlapping occurrences of 'searchString' in 'string' with 'replaceString'";
        input String replaceString
          "String that replaces 'searchString' in 'string'";
        input Integer startIndex=1 "Start search at index startIndex";
        input Boolean replaceAll=true
          "if false, replace only the first occurrence, otherwise all occurrences";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored when searching for searchString";
        output String result "Resultant string of replacement operation";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer i = startIndex;
        Integer i_found;
      algorithm
        result := if startIndex == 1 then "" else substring(string,1,startIndex-1);
        while i > 0 loop
           i_found := find(string, searchString, i, caseSensitive);
           if i_found > 0 then
              result := if i_found == 1 then
                           replaceString else
                           result + (if i_found-1<i then "" else substring(string, i, i_found-1)) + replaceString;
              i := i_found + lenSearchString;
              if i > lenString then
                 i := 0;
              elseif not replaceAll then
                 result := result + substring(string, i, lenString);
                 i := 0;
              end if;
           elseif lenString<i then
              i := 0;
           else
              result := result + substring(string, i, lenString);
              i := 0;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>replace</strong>(string, searchString, replaceString);
Strings.<strong>replace</strong>(string, searchString, replaceString,
                startIndex=1, replaceAll=true, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Search in \"string\" for \"searchString\" and replace the found
substring by \"replaceString\".
</p>
<ul>
<li> The search starts at the first character of \"string\",
     or at character position \"startIndex\",
     if this optional argument is provided.</li>
<li> If the optional argument \"replaceAll\" is <strong>true</strong> (default),
     all occurrences of \"searchString\" are replaced.
     If the argument is <strong>false</strong>, only the first occurrence
     is replaced.</li>
<li> The search for \"searchString\" distinguishes upper and lower
     case letters. If the optional argument \"caseSensitive\" is
     <strong>false</strong>,
     the search ignores whether letters are upper
     or lower case.</li>
</ul>
<p>
The function returns the \"string\" with the
performed replacements.
</p>
</html>"));
      end replace;

      package Advanced "Advanced scanning functions"
        extends Modelica.Icons.FunctionsPackage;

        function scanReal "Scan a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <strong>scanReal</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<pre>
    real     ::= [sign] unsigned [fraction] [exponent]
    sign     ::= '+' | '-'
    unsigned ::= digit [unsigned]
    fraction ::= '.' [unsigned]
    exponent ::= ('e' | 'E') [sign] unsigned
    digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanReal;

        function skipWhiteSpace "Scan white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
          external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipWhiteSpace</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\" and
skips white space. The function returns nextIndex = index of character
of the first non white space character.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipWhiteSpace;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings.Advanced</strong> contains basic scanning
functions. These functions should be <strong>not called</strong> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<pre>
  (nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
  (nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
  (nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
  (nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).</li>
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\".</li>
</ul>
</html>"));
      end Advanced;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings</strong> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <strong>default</strong> options.
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td>len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td>Returns length of string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td>Returns a substring defined by start and end index</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td>Repeat a blank or a string n times.</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td>Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td>identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td>Determine whether two strings are identical</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td>Count the number of occurrences of a string</td></tr>
  <tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td>Find first occurrence of a string in another string</td></tr>
<tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td>Find last occurrence of a string in another string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td>Replace one or all occurrences of a string</td></tr>
  <tr><td>stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td>Sort vector of strings in alphabetic order</td></tr>
  <tr><td>hash = <a href=\"modelica://Modelica.Utilities.Strings.hashString\">hashString</a>(string)</td>
      <td>Create a hash value of a string</td></tr>
  <tr><td>(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td>Scan for a Real constant</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td>Scan for an Integer constant</td></tr>
  <tr><td>(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td>Scan for a Boolean constant</td></tr>
  <tr><td>(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td>Scan for a String constant</td></tr>
  <tr><td>(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td>Scan for an identifier</td></tr>
  <tr><td>(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td>Scan for delimiters</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td>Check that remaining part of string consists solely of<br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td> Print a \"syntax error message\" as well as a string and the<br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <strong>caseSensitive</strong> with default <strong>true</strong>.
If <strong>false</strong>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</html>"));
    end Strings;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.TypesPackage;

      type Compare = enumeration(
        Less   "String 1 is lexicographically less than string 2",
        Equal   "String 1 is identical to string 2",
        Greater   "String 1 is lexicographically greater than string 2")
        "Enumeration defining comparison of two strings";
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;

    package Internal
    "Internal components that a user should usually not directly utilize"
      extends Modelica.Icons.InternalPackage;

    partial package PartialModelicaServices
      "Interfaces of components requiring a tool specific implementation"
        extends Modelica.Icons.InternalPackage;

      package ExternalReferences "Functions to access external resources"
        extends Modelica.Icons.InternalPackage;

        partial function PartialLoadResource
            "Interface for tool specific function to return the absolute path name of a URI or local file name"
          extends Modelica.Icons.Function;
          input String uri "URI or local file name";
          output String fileReference "Absolute path name of file";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices. The interface is documented at
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Internal.FileSystem.loadResource</a>.
</p>

</html>"));
        end PartialLoadResource;
      end ExternalReferences;
        annotation (Documentation(info="<html>

<p>
This package contains interfaces of a set of functions and models used in the
Modelica Standard Library that requires a <strong>tool specific implementation</strong>.
There is an associated package called <strong>ModelicaServices</strong>. A tool vendor
should provide a proper implementation of this library for the corresponding
tool. The default implementation is \"do nothing\".
In the Modelica Standard Library, the models and functions of ModelicaServices
are used.
</p>
</html>"));
    end PartialModelicaServices;
    end Internal;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <strong>functions</strong> that are
especially suited for <strong>scripting</strong>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    import SI = Modelica.SIunits;
    import NonSI = Modelica.SIunits.Conversions.NonSIunits;
    extends Modelica.Icons.Package;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=ModelicaServices.Machine.eps
      "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=ModelicaServices.Machine.small
      "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=ModelicaServices.Machine.inf
      "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Acceleration g_n=9.80665
      "Standard acceleration of gravity on earth";

    final constant Real R(final unit="J/(mol.K)") = 8.3144598
      "Molar gas constant (previous value: 8.314472)";

    final constant Real sigma(final unit="W/(m2.K4)") = 5.670367e-8
      "Stefan-Boltzmann constant (previous value: 5.670400e-8)";

    final constant NonSI.Temperature_degC T_zero=-273.15
      "Absolute zero temperature";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source:
</p>

<dl>
<dt>Peter J. Mohr, David B. Newell, and Barry N. Taylor:</dt>
<dd><strong>CODATA Recommended Values of the Fundamental Physical Constants: 2014</strong>.
<a href= \"http://dx.doi.org/10.5281/zenodo.22826\">http://dx.doi.org/10.5281/zenodo.22826</a>, 2015. See also <a href=
\"http://physics.nist.gov/cuu/Constants/index.html\">http://physics.nist.gov/cuu/Constants/index.html</a></dd>
</dl>

<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>Nov 4, 2015</em>
       by Thomas Beutlich:<br>
       Constants updated according to 2014 CODATA values.</li>
<li><em>Nov 8, 2004</em>
       by Christian Schweiger:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><em>Dec 9, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><em>Sep 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><em>Nov 15, 1997</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Polygon(
          origin={-9.2597,25.6673},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={-19.9923,-8.3993},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={23.753,-11.5422},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
          smooth=Smooth.Bezier)}));
  end Constants;

  package Icons "Library of icons"
    extends Icons.Package;

    partial package ExamplesPackage
    "Icon for packages containing runnable examples"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(
              origin={8.0,14.0},
              lineColor={78,138,73},
              fillColor={78,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial model Example "Icon for runnable examples"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor = {75,138,73},
                    fillColor={255,255,255},
                    fillPattern = FillPattern.Solid,
                    extent = {{-100,-100},{100,100}}),
            Polygon(lineColor = {0,0,255},
                    fillColor = {75,138,73},
                    pattern = LinePattern.None,
                    fillPattern = FillPattern.Solid,
                    points = {{-36,60},{64,0},{-36,-60},{-36,60}})}), Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
    end Example;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              extent={{-30.0,-30.0},{30.0,30.0}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package VariantsPackage "Icon for package containing variants"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                {100,100}}), graphics={
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains several variants of one component.</p>
</html>"));
    end VariantsPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={20.0,0.0},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
            Polygon(fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={23.3333,0.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
            Rectangle(
              fillColor = {128,128,128},
              pattern = LinePattern.None,
              fillPattern = FillPattern.Solid,
              extent = {{-70,-4.5},{0,4.5}})}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package SensorsPackage "Icon for packages containing sensors"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(origin={0.0,-30.0},
              fillColor={255,255,255},
              extent={{-90.0,-90.0},{90.0,90.0}},
              startAngle=20.0,
              endAngle=160.0),
            Ellipse(origin={0.0,-30.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-20.0,-20.0},{20.0,20.0}}),
            Line(origin={0.0,-30.0},
              points={{0.0,60.0},{0.0,90.0}}),
            Ellipse(origin={-0.0,-30.0},
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-10.0,-10.0},{10.0,10.0}}),
            Polygon(
              origin={-0.0,-30.0},
              rotation=-35.0,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-7.0,0.0},{-3.0,85.0},{0.0,90.0},{3.0,85.0},{7.0,0.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package containing sensors.</p>
</html>"));
    end SensorsPackage;

    partial package UtilitiesPackage "Icon for utility packages"
      extends Modelica.Icons.Package;
       annotation (Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}),
      Documentation(info="<html>
<p>This icon indicates a package containing utility classes.</p>
</html>"));
    end UtilitiesPackage;

    partial package TypesPackage
    "Icon for packages containing type definitions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-12.167,-23},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                  {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                  -30},{4.167,20},{12.167,65}},
              smooth=Smooth.Bezier), Polygon(
              origin={2.7403,1.6673},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
              smooth=Smooth.Bezier)}));
    end TypesPackage;

    partial package FunctionsPackage "Icon for packages containing functions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
              Text(
                lineColor={128,128,128},
                extent={{-90,-90},{90,90}},
                textString="f")}));
    end FunctionsPackage;

    partial package IconsPackage "Icon for packages containing icons"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}));
    end IconsPackage;

    partial package InternalPackage
    "Icon for an internal package (indicating that the package should not be directly utilized by user)"
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            lineColor={215,215,215},
            fillColor={255,255,255},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25),
          Rectangle(
            lineColor={215,215,215},
            extent={{-100,-100},{100,100}},
            radius=25),
          Ellipse(
            extent={{-80,80},{80,-80}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid),
          Ellipse(
            extent={{-55,55},{55,-55}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,14},{60,-14}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid,
            rotation=45)}),
      Documentation(info="<html>

<p>
This icon shall be used for a package that contains internal classes not to be
directly utilized by a user.
</p>
</html>"));
    end InternalPackage;

    partial package MaterialPropertiesPackage
    "Icon for package containing property classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-60.0,-60.0},{60.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains properties</p>
</html>"));
    end MaterialPropertiesPackage;

    partial class RotationalSensor "Icon representing a round measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-70.0},{70.0,70.0}}),
            Line(points={{0.0,70.0},{0.0,40.0}}),
            Line(points={{22.9,32.8},{40.2,57.3}}),
            Line(points={{-22.9,32.8},{-40.2,57.3}}),
            Line(points={{37.6,13.7},{65.8,23.9}}),
            Line(points={{-37.6,13.7},{-65.8,23.9}}),
            Ellipse(
              lineColor={64,64,64},
              fillColor={255,255,255},
              extent={{-12.0,-12.0},{12.0,12.0}}),
            Polygon(
              rotation=-17.5,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-5.0,0.0},{-2.0,60.0},{0.0,65.0},{2.0,60.0},{5.0,0.0}}),
            Ellipse(
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-7.0,-7.0},{7.0,7.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>rotational sensor</strong> model.
</p>
</html>"));
    end RotationalSensor;

    partial class TranslationalSensor
      "Icon representing a linear measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-60.0},{70.0,20.0}}),
            Polygon(
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{0.0,-40.0},{-10.0,-16.0},{10.0,-16.0},{0.0,-40.0}}),
            Line(points={{0.0,0.0},{0.0,-16.0}}),
            Line(points={{-70.0,0.0},{0.0,0.0}}),
            Line(points={{-50.0,-40.0},{-50.0,-60.0}}),
            Line(points={{-30.0,-40.0},{-30.0,-60.0}}),
            Line(points={{-10.0,-40.0},{-10.0,-60.0}}),
            Line(points={{10.0,-40.0},{10.0,-60.0}}),
            Line(points={{30.0,-40.0},{30.0,-60.0}}),
            Line(points={{50.0,-40.0},{50.0,-60.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>translational sensor</strong> model.
</p></html>"));
    end TranslationalSensor;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,105},{150,145}},
              textString="%name"),
            Ellipse(
              lineColor = {108,88,49},
              fillColor = {255,215,136},
              fillPattern = FillPattern.Solid,
              extent = {{-100,-100},{100,100}}),
            Text(
              lineColor={108,88,49},
              extent={{-90.0,-90.0},{90.0,90.0}},
              textString="f")}),
    Documentation(info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,60},{150,100}},
              textString="%name"),
            Rectangle(
              origin={0.0,-25.0},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-75.0},{100.0,75.0}},
              radius=25.0),
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-50.0},
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-25.0},
              points={{0.0,75.0},{0.0,-75.0}},
              color={64,64,64})}), Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    expandable connector SignalBus "Icon for signal bus"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}, initialScale=0.2), graphics={
              Rectangle(
                lineColor={255,204,51},
                lineThickness=0.5,
                extent={{-20.0,-2.0},{20.0,2.0}}),
              Polygon(
                fillColor={255,215,136},
                fillPattern=FillPattern.Solid,
                points={{-80.0,50.0},{80.0,50.0},{100.0,30.0},{80.0,-40.0},{60.0,-50.0},{-60.0,-50.0},{-80.0,-40.0},{-100.0,30.0}},
                smooth=Smooth.Bezier),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-65.0,15.0},{-55.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-5.0,15.0},{5.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{55.0,15.0},{65.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-35.0,-25.0},{-25.0,-15.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{25.0,-25.0},{35.0,-15.0}})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,-20},{-50,15}},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid,
              smooth=Smooth.Bezier),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              textString="%name")}),
        Documentation(info="<html>
This icon is designed for a <strong>signal bus</strong> connector.
</html>"));
    end SignalBus;

    partial class ObsoleteModel
      "Icon for classes that are obsolete and will be removed in later versions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-102,102},{102,-102}},
              lineColor={255,0,0},
              pattern=LinePattern.Dash,
              lineThickness=0.5)}), Documentation(info="<html>
<p>
This partial class is intended to provide a <u>default icon
for an obsolete model</u> that will be removed from the
corresponding library in a future release.
</p>
</html>"));
    end ObsoleteModel;
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}), Documentation(info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer.</p>

<h4>Main Authors:</h4>

<dl>
<dt><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dt>
    <dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd>
    <dd>Oberpfaffenhofen</dd>
    <dd>Postfach 1116</dd>
    <dd>D-82230 Wessling</dd>
    <dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
<dt>Christian Kral</dt>

    <dd>  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
</dd>
    <dd>1060 Vienna, Austria</dd>
    <dd>email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a></dd>
<dt>Johan Andreasson</dt>
    <dd><a href=\"http://www.modelon.se/\">Modelon AB</a></dd>
    <dd>Ideon Science Park</dd>
    <dd>22370 Lund, Sweden</dd>
    <dd>email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Icons;

  package SIunits
  "Library of type and unit definitions based on SI units according to ISO 31-1992"
    extends Modelica.Icons.Package;

    package Icons "Icons for SIunits"
      extends Modelica.Icons.IconsPackage;

      partial function Conversion "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                lineColor={0,0,255})}));
      end Conversion;
    end Icons;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      package NonSIunits "Type definitions of non SI units"
        extends Modelica.Icons.Package;

        type Temperature_degC = Real (final quantity="ThermodynamicTemperature",
              final unit="degC")
          "Absolute temperature in degree Celsius (for relative temperature use SIunits.TemperatureDifference)" annotation(absoluteValue=true);

        type Angle_deg = Real (final quantity="Angle", final unit="deg")
          "Angle in degree";

        type AngularVelocity_rpm = Real (final quantity="AngularVelocity", final unit=
                   "rev/min")
          "Angular velocity in revolutions per minute. Alias unit names that are outside of the SI system: rpm, r/min, rev/min";

        type Pressure_bar = Real (final quantity="Pressure", final unit="bar")
          "Absolute pressure in bar";
        annotation (Documentation(info="<html>
<p>
This package provides predefined types, such as <strong>Angle_deg</strong> (angle in
degree), <strong>AngularVelocity_rpm</strong> (angular velocity in revolutions per
minute) or <strong>Temperature_degF</strong> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package Modelica.SIunits. For more information on units, see also
the book of Francois Cardarelli <strong>Scientific Unit Conversion - A
Practical Guide to Metrication</strong> (Springer 1997).</p>
<p>Some units, such as <strong>Temperature_degC/Temp_C</strong> are both defined in
Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
definitions have been placed erroneously in Modelica.SIunits although they
are not SIunits. For backward compatibility, these type definitions are
still kept in Modelica.SIunits.</p>
</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={
        Text(
          origin={15.0,51.8518},
          extent={{-105.0,-86.8518},{75.0,-16.8518}},
          textString="[km/h]")}));
      end NonSIunits;

      function to_degC "Convert from Kelvin to degCelsius"
        extends Modelica.SIunits.Icons.Conversion;
        input Temperature Kelvin "Kelvin value";
        output NonSIunits.Temperature_degC Celsius "Celsius value";
      algorithm
        Celsius := Kelvin + Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="K"), Text(
                extent={{100,-20},{20,-100}},
                textString="degC")}));
      end to_degC;

      function from_degC "Convert from degCelsius to Kelvin"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Temperature_degC Celsius "Celsius value";
        output Temperature Kelvin "Kelvin value";
      algorithm
        Kelvin := Celsius - Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="degC"), Text(
                extent={{100,-20},{20,-100}},
                textString="K")}));
      end from_degC;

      function from_deg "Convert from degree to radian"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Angle_deg degree "degree value";
        output Angle radian "radian value";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                textString="rad")}));
      end from_deg;

      function to_bar "Convert from Pascal to bar"
        extends Modelica.SIunits.Icons.Conversion;
        input Pressure Pa "Pascal value";
        output NonSIunits.Pressure_bar bar "bar value";
      algorithm
        bar := Pa/1e5;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-12,100},{-100,56}},
                textString="Pa"), Text(
                extent={{98,-52},{-4,-100}},
                textString="bar")}));
      end to_bar;
      annotation (Documentation(info="<html>
<p>This package provides conversion functions from the non SI Units
defined in package Modelica.SIunits.Conversions.NonSIunits to the
corresponding SI Units defined in package Modelica.SIunits and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<pre>
  <strong>import</strong> SI = Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
  <strong>parameter</strong> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
  <strong>parameter</strong> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                      // to radian per seconds
</pre>

</html>"));
    end Conversions;

    type Angle = Real (
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg");

    type Length = Real (final quantity="Length", final unit="m");

    type Height = Length(min=0);

    type Area = Real (final quantity="Area", final unit="m2");

    type Volume = Real (final quantity="Volume", final unit="m3");

    type Time = Real (final quantity="Time", final unit="s");

    type Velocity = Real (final quantity="Velocity", final unit="m/s");

    type Acceleration = Real (final quantity="Acceleration", final unit="m/s2");

    type Frequency = Real (final quantity="Frequency", final unit="Hz");

    type Mass = Real (
        quantity="Mass",
        final unit="kg",
        min=0);

    type Density = Real (
        final quantity="Density",
        final unit="kg/m3",
        displayUnit="g/cm3",
        min=0.0);

    type Pressure = Real (
        final quantity="Pressure",
        final unit="Pa",
        displayUnit="bar");

    type AbsolutePressure = Pressure (min=0.0, nominal = 1e5);

    type PressureDifference = Pressure;

    type DynamicViscosity = Real (
        final quantity="DynamicViscosity",
        final unit="Pa.s",
        min=0);

    type Energy = Real (final quantity="Energy", final unit="J");

    type Power = Real (final quantity="Power", final unit="W");

    type EnthalpyFlowRate = Real (final quantity="EnthalpyFlowRate", final unit=
            "W");

    type Efficiency = Real (
        final quantity="Efficiency",
        final unit="1",
        min=0);

    type MassFlowRate = Real (quantity="MassFlowRate", final unit="kg/s");

    type VolumeFlowRate = Real (final quantity="VolumeFlowRate", final unit=
            "m3/s");

    type ThermodynamicTemperature = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K",
        min = 0.0,
        start = 288.15,
        nominal = 300,
        displayUnit="degC")
      "Absolute temperature (use type TemperatureDifference for relative temperatures)" annotation(absoluteValue=true);

    type Temperature = ThermodynamicTemperature;

    type TemperatureDifference = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K") annotation(absoluteValue=false);

    type TemperatureSlope = Real (final quantity="TemperatureSlope",
        final unit="K/s");

    type LinearTemperatureCoefficient = Real(final quantity = "LinearTemperatureCoefficient", final unit="1/K");

    type Compressibility = Real (final quantity="Compressibility", final unit=
            "1/Pa");

    type IsothermalCompressibility = Compressibility;

    type HeatFlowRate = Real (final quantity="Power", final unit="W");

    type HeatFlux = Real (final quantity="HeatFlux", final unit="W/m2");

    type ThermalConductivity = Real (final quantity="ThermalConductivity", final unit=
               "W/(m.K)");

    type CoefficientOfHeatTransfer = Real (final quantity=
            "CoefficientOfHeatTransfer", final unit="W/(m2.K)");

    type ThermalResistance = Real (final quantity="ThermalResistance", final unit=
           "K/W");

    type ThermalConductance = Real (final quantity="ThermalConductance", final unit=
               "W/K");

    type HeatCapacity = Real (final quantity="HeatCapacity", final unit="J/K");

    type SpecificHeatCapacity = Real (final quantity="SpecificHeatCapacity",
          final unit="J/(kg.K)");

    type RatioOfSpecificHeatCapacities = Real (final quantity=
            "RatioOfSpecificHeatCapacities", final unit="1");

    type SpecificEntropy = Real (final quantity="SpecificEntropy",
                                 final unit="J/(kg.K)");

    type SpecificEnergy = Real (final quantity="SpecificEnergy",
                                final unit="J/kg");

    type SpecificInternalEnergy = SpecificEnergy;

    type SpecificEnthalpy = SpecificEnergy;

    type DerDensityByEnthalpy = Real (final unit="kg.s2/m5");

    type DerDensityByPressure = Real (final unit="s2/m2");

    type DerDensityByTemperature = Real (final unit="kg/(m3.K)");

    type RadiantPower = Real (final quantity="Power", final unit="W");

    type Irradiance = Real (final quantity="Irradiance", final unit="W/m2");

    type Emissivity = Real (final quantity="Emissivity", final unit="1");

    type ReflectionCoefficient = Real (final quantity="ReflectionCoefficient",
          final unit="1");

    type TransmissionCoefficient = Real (final quantity="TransmissionCoefficient",
            final unit="1");

    type MolarMass = Real (final quantity="MolarMass", final unit="kg/mol",min=0);

    type MolarVolume = Real (final quantity="MolarVolume", final unit="m3/mol", min=0);

    type MassFraction = Real (final quantity="MassFraction", final unit="1",
                              min=0, max=1);

    type MoleFraction = Real (final quantity="MoleFraction", final unit="1",
                              min = 0, max = 1);

    type PrandtlNumber = Real (final quantity="PrandtlNumber", final unit="1");
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
              -100},{100,100}}), graphics={
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-80,-40},{-80,-40},{-55,50},{-52.5,62.5},{-65,60},{-65,65},{-35,77.5},{-32.5,60},{-50,0},{-50,0},{-30,15},{-20,27.5},{-32.5,27.5},{-32.5,27.5},{-32.5,32.5},{-32.5,32.5},{2.5,32.5},{2.5,32.5},{2.5,27.5},{2.5,27.5},{-7.5,27.5},{-30,7.5},{-30,7.5},{-25,-25},{-17.5,-28.75},{-10,-25},{-5,-26.25},{-5,-32.5},{-16.25,-41.25},{-31.25,-43.75},{-40,-33.75},{-45,-5},{-45,-5},{-52.5,-10},{-52.5,-10},{-60,-40},{-60,-40}},
          smooth = Smooth.Bezier),
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{87.5,30},{62.5,30},{62.5,30},{55,33.75},{36.25,35},{16.25,25},{7.5,6.25},{11.25,-7.5},{22.5,-12.5},{22.5,-12.5},{6.25,-22.5},{6.25,-35},{16.25,-38.75},{16.25,-38.75},{21.25,-41.25},{21.25,-41.25},{45,-48.75},{47.5,-61.25},{32.5,-70},{12.5,-65},{7.5,-51.25},{21.25,-41.25},{21.25,-41.25},{16.25,-38.75},{16.25,-38.75},{6.25,-41.25},{-6.25,-50},{-3.75,-68.75},{30,-76.25},{65,-62.5},{63.75,-35},{27.5,-26.25},{22.5,-20},{27.5,-15},{27.5,-15},{30,-7.5},{30,-7.5},{27.5,-2.5},{28.75,11.25},{36.25,27.5},{47.5,30},{53.75,22.5},{51.25,8.75},{45,-6.25},{35,-11.25},{30,-7.5},{30,-7.5},{27.5,-15},{27.5,-15},{43.75,-16.25},{65,-6.25},{72.5,10},{70,20},{70,20},{80,20}},
          smooth = Smooth.Bezier)}), Documentation(info="<html>
<p>This package provides predefined types, such as <em>Mass</em>,
<em>Angle</em>, <em>Time</em>, based on the international standard
on units, e.g.,
</p>

<pre>   <strong>type</strong> Angle = Real(<strong>final</strong> quantity = \"Angle\",
                     <strong>final</strong> unit     = \"rad\",
                     displayUnit    = \"deg\");
</pre>

<p>
Some of the types are derived SI units that are utilized in package Modelica
(such as ComplexCurrent, which is a complex number where both the real and imaginary
part have the SI unit Ampere).
</p>

<p>
Furthermore, conversion functions from non SI-units to SI-units and vice versa
are provided in subpackage
<a href=\"modelica://Modelica.SIunits.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica standard library
with package SIunits, have a look at:
<a href=\"modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added molar units for energy and enthalpy.</li>
<li><em>Jan. 27, 2010</em> by Christian Kral:<br/>Added complex units.</li>
<li><em>Dec. 14, 2005</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Add User&#39;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><em>October 21, 2002</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Christian Schweiger:<br/>Added new package <strong>Conversions</strong>. Corrected typo <em>Wavelenght</em>.</li>
<li><em>June 6, 2000</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Introduced the following new types<br/>type Temperature = ThermodynamicTemperature;<br/>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br/>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br/>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><em>Oct. 27, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><em>Sept. 18, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><em>Aug 12, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><em>June 29, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><em>April 8, 1998</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br/>Complete ISO 31 chapters realized.</li>
<li><em>Nov. 15, 1997</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Hubertus Tummescheit:<br/>Some chapters realized.</li>
</ul>
</html>"));
  end SIunits;
annotation (
preferredView="info",
version="3.2.3",
versionBuild=2,
versionDate="2019-01-23",
dateModified = "2019-03-20 12:00:00Z",
revisionId="8f65f621a 2019-03-20 09:22:19 +0100",
uses(Complex(version="3.2.3"), ModelicaServices(version="3.2.3")),
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="3.2",
 noneFromVersion="3.1",
 noneFromVersion="3.0.1",
 noneFromVersion="3.0",
 from(version="2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos")),
Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
  Polygon(
    origin={-6.9888,20.048},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    points={{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
    smooth=Smooth.Bezier),
  Ellipse(
    origin={40.8208,-37.7602},
    fillColor={161,0,4},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    extent={{-17.8562,-17.8563},{17.8563,17.8562}})}),
Documentation(info="<html>
<p>
Package <strong>Modelica&reg;</strong> is a <strong>standardized</strong> and <strong>free</strong> package
that is developed together with the Modelica&reg; language from the
Modelica Association, see
<a href=\"https://www.Modelica.org\">https://www.Modelica.org</a>.
It is also called <strong>Modelica Standard Library</strong>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <strong>Examples</strong> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li><strong>1288</strong> component models and blocks,</li>
<li><strong>404</strong> example models, and</li>
<li><strong>1227</strong> functions</li>
</ul>
<p>
that are directly usable (= number of public, non-partial, non-internal and non-obsolete classes). It is fully compliant
to <a href=\"https://www.modelica.org/documents/ModelicaSpec32Revision2.pdf\">Modelica Specification Version 3.2 Revision 2</a>
and it has been tested with Modelica tools from different vendors.
</p>

<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 1998-2019, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>.
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica;

package SystemModel "System models for case study"
  extends Modelica.Icons.Package;

  package VAV "Package with VAV model"

    model System
      "Variable air volume flow system with terminal reheat and five thermal zones controlled using an ASHRAE G36 controller"
      extends SystemModel.VAV.BaseClasses.Guideline36(
        redeclare replaceable Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.BaseClasses.Floor flo
        constrainedby
        Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.BaseClasses.Floor,
        ACHCor=4,
        ACHSou=4,
        ACHEas=6,
        ACHNor=4,
        ACHWes=6);
      annotation (
        __Dymola_Commands(
          file="modelica://Buildings/Resources/Scripts/Dymola/ThermalZones/EnergyPlus/Examples/SmallOffice/Guideline36Winter.mos" "Simulate and plot"),
        experiment(
          StartTime=432000,
          StopTime=864000,
          Tolerance=1e-07),
        Icon(
          coordinateSystem(
            extent={{-400,-400},{1380,680}},
            preserveAspectRatio=true)),
        Diagram(
          coordinateSystem(
            preserveAspectRatio=false,
            extent={{-400,-400},{1380,680}})),
        Documentation(
          info="<html>
<p>
This model consist of an HVAC system, a building envelope model and a model
for air flow through building leakage and through open doors.
</p>
<p>
The HVAC system is a variable air volume (VAV) flow system with economizer
and a heating and cooling coil in the air handler unit. There is also a
reheat coil and an air damper in each of the five zone inlet branches.
</p>
<p>
See the model
<a href=\"modelica://Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop\">
Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop</a>
for a description of the HVAC system and the building envelope.
</p>
<p>
The control is based on ASHRAE Guideline 36, and implemented
using the sequences from the library
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1\">
Buildings.Controls.OBC.ASHRAE.G36_PR1</a> for
multi-zone VAV systems with economizer. The schematic diagram of the HVAC and control
sequence is shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Examples/VAVReheat/vavControlSchematics.png\" border=\"1\"/>
</p>
<p>
A similar model but with a different control sequence can be found in
<a href=\"modelica://Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter\">
Buildings.ThermalZones.EnergyPlus.Examples.SmallOffice.ASHRAE2006Winter</a>..
Note that this model, because of the frequent time sampling,
has longer computing time than
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>.
The reason is that the time integrator cannot make large steps
because it needs to set a time step each time the control samples
its input.
</p>
</html>", revisions="<html>
<ul>
<li>
November 25, 2019, by Milica Grahovac:<br/>
Impementation of <a href=\"modelica://Buildings.Examples.VAVReheat.Guideline36\">
Buildings.Examples.VAVReheat.Guideline36</a> model with an EnergyPlus thermal zone instance.
</li>
</ul>
</html>"));
    end System;

    package BaseClasses

      model Guideline36
        "Variable air volume flow system with terminal reheat and five thermal zones"
        extends Modelica.Icons.Example;
        extends VAV.BaseClasses.PartialOpenLoop(
          redeclare replaceable Buildings.Examples.VAVReheat.BaseClasses.Floor flo(
            final lat=lat,
            final sampleModel=sampleModel),
          amb(nPorts=3),
          damOut(
            dpDamper_nominal=10,
            dpFixed_nominal=10),
          freSta(lockoutTime=3600));

        parameter Modelica.SIunits.VolumeFlowRate VPriSysMax_flow=m_flow_nominal/1.2
          "Maximum expected system primary airflow rate at design stage";
        parameter Modelica.SIunits.VolumeFlowRate minZonPriFlo[numZon]={
          conVAVCor.VDisSetMin_flow, conVAVSou.VDisSetMin_flow,
          conVAVEas.VDisSetMin_flow, conVAVNor.VDisSetMin_flow,
          conVAVWes.VDisSetMin_flow}
          "Minimum expected zone primary flow rate";
        parameter Modelica.SIunits.Time samplePeriod=120
          "Sample period of component, set to the same value as the trim and respond that process yPreSetReq";
        parameter Modelica.SIunits.PressureDifference dpDisRetMax=40
          "Maximum return fan discharge static pressure setpoint";

        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller conVAVCor(
          V_flow_nominal=mCor_flow_nominal/1.2,
          AFlo=AFloCor,
          final samplePeriod=samplePeriod,
          VDisSetMin_flow=max(1.5*VCorOA_flow_nominal, 0.15*mCor_flow_nominal/1.2),
          VDisHeaSetMax_flow=ratVFloHea*mCor_flow_nominal/1.2)
          "Controller for terminal unit corridor"
          annotation (Placement(transformation(extent={{530,84},{550,104}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller conVAVSou(
          V_flow_nominal=mSou_flow_nominal/1.2,
          AFlo=AFloSou,
          final samplePeriod=samplePeriod,
          VDisSetMin_flow=max(1.5*VSouOA_flow_nominal, 0.15*mSou_flow_nominal/1.2),
          VDisHeaSetMax_flow=ratVFloHea*mSou_flow_nominal/1.2)
          "Controller for terminal unit south"
          annotation (Placement(transformation(extent={{702,84},{722,104}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller conVAVEas(
          V_flow_nominal=mEas_flow_nominal/1.2,
          AFlo=AFloEas,
          final samplePeriod=samplePeriod,
          VDisSetMin_flow=max(1.5*VEasOA_flow_nominal, 0.15*mEas_flow_nominal/1.2),
          VDisHeaSetMax_flow=ratVFloHea*mEas_flow_nominal/1.2)
          "Controller for terminal unit east"
          annotation (Placement(transformation(extent={{880,84},{900,104}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller conVAVNor(
          V_flow_nominal=mNor_flow_nominal/1.2,
          AFlo=AFloNor,
          final samplePeriod=samplePeriod,
          VDisSetMin_flow=max(1.5*VNorOA_flow_nominal, 0.15*mNor_flow_nominal/1.2),
          VDisHeaSetMax_flow=ratVFloHea*mNor_flow_nominal/1.2)
          "Controller for terminal unit north"
          annotation (Placement(transformation(extent={{1038,84},{1058,104}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller conVAVWes(
          V_flow_nominal=mWes_flow_nominal/1.2,
          AFlo=AFloWes,
          final samplePeriod=samplePeriod,
          VDisSetMin_flow=max(1.5*VWesOA_flow_nominal, 0.15*mWes_flow_nominal/1.2),
          VDisHeaSetMax_flow=ratVFloHea*mWes_flow_nominal/1.2)
          "Controller for terminal unit west"
          annotation (Placement(transformation(extent={{1240,84},{1260,104}})));
        Modelica.Blocks.Routing.Multiplex5 TDis "Discharge air temperatures"
          annotation (Placement(transformation(extent={{220,360},{240,380}})));
        Modelica.Blocks.Routing.Multiplex5 VDis_flow
          "Air flow rate at the terminal boxes"
          annotation (Placement(transformation(extent={{220,320},{240,340}})));
        Buildings.Controls.OBC.CDL.Integers.MultiSum TZonResReq(nin=5)
          "Number of zone temperature requests"
          annotation (Placement(transformation(extent={{300,360},{320,380}})));
        Buildings.Controls.OBC.CDL.Integers.MultiSum PZonResReq(nin=5)
          "Number of zone pressure requests"
          annotation (Placement(transformation(extent={{300,320},{320,340}})));
        Buildings.Controls.OBC.CDL.Logical.Switch swiFreSta "Switch for freeze stat"
          annotation (Placement(transformation(extent={{-40,-150},{-20,-130}})));
        Buildings.Controls.OBC.CDL.Continuous.Sources.Constant yFreHeaCoi(final k=1)
          "Flow rate signal for heating coil when freeze stat is on"
          annotation (Placement(transformation(extent={{-100,-142},{-80,-122}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Controller conAHU(
          kMinOut=0.03,
          final pMaxSet=410,
          final yFanMin=yFanMin,
          final VPriSysMax_flow=VPriSysMax_flow,
          final peaSysPop=divP*sum({ratP_A*AFlo[i] for i in 1:numZon}))
          "AHU controller"
          annotation (Placement(transformation(extent={{340,512},{420,640}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone
          zonOutAirSet[numZon](
          final AFlo=AFlo,
          final have_occSen=fill(false, numZon),
          final have_winSen=fill(false, numZon),
          final desZonPop={ratP_A*AFlo[i] for i in 1:numZon},
          final minZonPriFlo=minZonPriFlo)
          "Zone level calculation of the minimum outdoor airflow setpoint"
          annotation (Placement(transformation(extent={{220,580},{240,600}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone
          zonToSys(final numZon=numZon) "Sum up zone calculation output"
          annotation (Placement(transformation(extent={{280,570},{300,590}})));
        Buildings.Controls.OBC.CDL.Routing.RealScalarReplicator reaRep1(final nout=numZon)
          "Replicate design uncorrected minimum outdoor airflow setpoint"
          annotation (Placement(transformation(extent={{460,580},{480,600}})));
        Buildings.Controls.OBC.CDL.Routing.BooleanScalarReplicator booRep1(final nout=numZon)
          "Replicate signal whether the outdoor airflow is required"
          annotation (Placement(transformation(extent={{460,550},{480,570}})));

        Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus zonSta[numZon]
          "Check zone temperature status"
          annotation (Placement(transformation(extent={{-220,268},{-200,296}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.GroupStatus zonGroSta(
          final numZon=numZon) "Check zone group status according to the zones status"
          annotation (Placement(transformation(extent={{-160,260},{-140,300}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode
          opeModSel(final numZon=numZon)
          annotation (Placement(transformation(extent={{-100,284},{-80,316}})));
        Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures
          TZonSet[numZon](
          final have_occSen=fill(false, numZon),
          final have_winSen=fill(false, numZon))  "Zone setpoint"
          annotation (Placement(transformation(extent={{-100,180},{-80,208}})));
        Buildings.Controls.OBC.CDL.Continuous.Sources.Constant warCooTim[numZon](
          final k=fill(1800, numZon)) "Warm up and cool down time"
          annotation (Placement(transformation(extent={{-300,370},{-280,390}})));
        Buildings.Controls.OBC.CDL.Logical.Sources.Constant falSta[numZon](
          final k=fill(false, numZon))
          "All windows are closed, no zone has override switch"
          annotation (Placement(transformation(extent={{-300,330},{-280,350}})));
        Buildings.Controls.OBC.CDL.Routing.RealScalarReplicator reaRep(nout=numZon)
          "Assume all zones have same occupancy schedule"
          annotation (Placement(transformation(extent={{-200,-190},{-180,-170}})));
        Buildings.Controls.OBC.CDL.Routing.BooleanScalarReplicator booRep(nout=numZon)
          "Assume all zones have same occupancy schedule"
          annotation (Placement(transformation(extent={{-200,-150},{-180,-130}})));
        Buildings.Controls.OBC.CDL.Integers.Sources.Constant demLimLev[numZon](
          final  k=fill(0, numZon)) "Demand limit level, assumes to be 0"
          annotation (Placement(transformation(extent={{-300,230},{-280,250}})));
        Buildings.Controls.OBC.CDL.Routing.IntegerScalarReplicator intRep(
          final nout=numZon)
          "All zones in same operation mode"
          annotation (Placement(transformation(extent={{-140,220},{-120,240}})));

        Buildings.Examples.VAVReheat.Controls.SystemHysteresis sysHysHea
          "Hysteresis and delay to switch heating on and off"
          annotation (Placement(transformation(extent={{20,-150},{40,-130}})));
        Buildings.Examples.VAVReheat.Controls.SystemHysteresis sysHysCoo
          "Hysteresis and delay to switch cooling on and off"
          annotation (Placement(transformation(extent={{20,-250},{40,-230}})));
      equation
        connect(conVAVCor.TZon, TRooAir.y5[1]) annotation (Line(
            points={{528,94},{520,94},{520,275},{480,275}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        connect(conVAVSou.TZon, TRooAir.y1[1]) annotation (Line(
            points={{700,94},{656,94},{656,40},{680,40},{680,275},{496,275}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        connect(TRooAir.y2[1], conVAVEas.TZon) annotation (Line(
            points={{492,275},{868,275},{868,94},{878,94}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        connect(TRooAir.y3[1], conVAVNor.TZon) annotation (Line(
            points={{488,275},{1028,275},{1028,94},{1036,94}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        connect(TRooAir.y4[1], conVAVWes.TZon) annotation (Line(
            points={{484,275},{1220,275},{1220,94},{1238,94}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        connect(conVAVCor.TDis, cor.TSup) annotation (Line(points={{528,88},{466,88},{
                466,74},{620,74},{620,50},{612,50}},  color={0,0,127}));
        connect(sou.TSup, conVAVSou.TDis) annotation (Line(points={{792,48},{800,48},{
                800,72},{684,72},{684,88},{700,88}},
                                    color={0,0,127}));
        connect(eas.TSup, conVAVEas.TDis) annotation (Line(points={{972,48},{980,48},{
                980,74},{870,74},{870,88},{878,88}},
                                    color={0,0,127}));
        connect(nor.TSup, conVAVNor.TDis) annotation (Line(points={{1132,48},{1140,48},
                {1140,74},{1032,74},{1032,88},{1036,88}},
                                          color={0,0,127}));
        connect(wes.TSup, conVAVWes.TDis) annotation (Line(points={{1332,48},{1340,48},
                {1340,74},{1228,74},{1228,88},{1238,88}},
                                          color={0,0,127}));
        connect(conVAVCor.yZonTemResReq, TZonResReq.u[1]) annotation (Line(points={{552,90},
                {554,90},{554,220},{280,220},{280,375.6},{298,375.6}},         color=
                {255,127,0}));
        connect(conVAVSou.yZonTemResReq, TZonResReq.u[2]) annotation (Line(points={{724,90},
                {726,90},{726,220},{280,220},{280,372.8},{298,372.8}},         color=
                {255,127,0}));
        connect(conVAVEas.yZonTemResReq, TZonResReq.u[3]) annotation (Line(points={{902,90},
                {904,90},{904,220},{280,220},{280,370},{298,370}},         color={255,
                127,0}));
        connect(conVAVNor.yZonTemResReq, TZonResReq.u[4]) annotation (Line(points={{1060,90},
                {1064,90},{1064,220},{280,220},{280,367.2},{298,367.2}},
              color={255,127,0}));
        connect(conVAVWes.yZonTemResReq, TZonResReq.u[5]) annotation (Line(points={{1262,90},
                {1266,90},{1266,220},{280,220},{280,364.4},{298,364.4}},
              color={255,127,0}));
        connect(conVAVCor.yZonPreResReq, PZonResReq.u[1]) annotation (Line(points={{552,86},
                {558,86},{558,214},{288,214},{288,335.6},{298,335.6}},         color=
                {255,127,0}));
        connect(conVAVSou.yZonPreResReq, PZonResReq.u[2]) annotation (Line(points={{724,86},
                {728,86},{728,214},{288,214},{288,332.8},{298,332.8}},         color=
                {255,127,0}));
        connect(conVAVEas.yZonPreResReq, PZonResReq.u[3]) annotation (Line(points={{902,86},
                {906,86},{906,214},{288,214},{288,330},{298,330}},         color={255,
                127,0}));
        connect(conVAVNor.yZonPreResReq, PZonResReq.u[4]) annotation (Line(points={{1060,86},
                {1066,86},{1066,214},{288,214},{288,327.2},{298,327.2}},
              color={255,127,0}));
        connect(conVAVWes.yZonPreResReq, PZonResReq.u[5]) annotation (Line(points={{1262,86},
                {1268,86},{1268,214},{288,214},{288,324.4},{298,324.4}},
              color={255,127,0}));
        connect(cor.VSup_flow, VDis_flow.u1[1]) annotation (Line(points={{612,58},{620,
                58},{620,74},{472,74},{472,206},{180,206},{180,340},{218,340}},
                                                                         color={0,0,
                127}));
        connect(sou.VSup_flow, VDis_flow.u2[1]) annotation (Line(points={{792,56},{800,
                56},{800,72},{744,72},{744,216},{182,216},{182,335},{218,335}},
                                                                         color={0,0,
                127}));
        connect(eas.VSup_flow, VDis_flow.u3[1]) annotation (Line(points={{972,56},{980,
                56},{980,74},{914,74},{914,206},{180,206},{180,330},{218,330}},
                                                                         color={0,0,
                127}));
        connect(nor.VSup_flow, VDis_flow.u4[1]) annotation (Line(points={{1132,56},{1140,
                56},{1140,74},{1082,74},{1082,206},{180,206},{180,325},{218,325}},
                                                                           color={0,0,
                127}));
        connect(wes.VSup_flow, VDis_flow.u5[1]) annotation (Line(points={{1332,56},{1340,
                56},{1340,74},{1286,74},{1286,204},{164,204},{164,320},{218,320}},
                                                                           color={0,0,
                127}));
        connect(cor.TSup, TDis.u1[1]) annotation (Line(points={{612,50},{620,50},{620,
                74},{466,74},{466,230},{176,230},{176,380},{218,380}},
                                                         color={0,0,127}));
        connect(sou.TSup, TDis.u2[1]) annotation (Line(points={{792,48},{800,48},{800,
                72},{688,72},{688,210},{176,210},{176,375},{218,375}},     color={0,0,
                127}));
        connect(eas.TSup, TDis.u3[1]) annotation (Line(points={{972,48},{980,48},{980,
                74},{872,74},{872,210},{176,210},{176,370},{218,370}},
                                                         color={0,0,127}));
        connect(nor.TSup, TDis.u4[1]) annotation (Line(points={{1132,48},{1140,48},{1140,
                74},{1032,74},{1032,210},{176,210},{176,365},{218,365}},
                                                          color={0,0,127}));
        connect(wes.TSup, TDis.u5[1]) annotation (Line(points={{1332,48},{1340,48},{1340,
                74},{1228,74},{1228,210},{176,210},{176,360},{218,360}},
                                                          color={0,0,127}));
        connect(conVAVCor.VDis_flow, cor.VSup_flow) annotation (Line(points={{528,92},
                {522,92},{522,74},{620,74},{620,58},{612,58}},
                                               color={0,0,127}));
        connect(sou.VSup_flow, conVAVSou.VDis_flow) annotation (Line(points={{792,56},
                {800,56},{800,72},{690,72},{690,92},{700,92}},
                                                   color={0,0,127}));
        connect(eas.VSup_flow, conVAVEas.VDis_flow) annotation (Line(points={{972,56},
                {980,56},{980,74},{874,74},{874,92},{878,92}},
                                                   color={0,0,127}));
        connect(nor.VSup_flow, conVAVNor.VDis_flow) annotation (Line(points={{1132,56},
                {1140,56},{1140,74},{1034,74},{1034,92},{1036,92}},
                                                      color={0,0,127}));
        connect(wes.VSup_flow, conVAVWes.VDis_flow) annotation (Line(points={{1332,56},
                {1340,56},{1340,74},{1230,74},{1230,92},{1238,92}},
                                                      color={0,0,127}));
        connect(TSup.T, conVAVCor.TSupAHU) annotation (Line(points={{340,-29},{340,-20},
                {462,-20},{462,86},{528,86}}, color={0,0,127}));
        connect(TSup.T, conVAVSou.TSupAHU) annotation (Line(points={{340,-29},{340,-20},
                {624,-20},{624,86},{700,86}}, color={0,0,127}));
        connect(TSup.T, conVAVEas.TSupAHU) annotation (Line(points={{340,-29},{340,-20},
                {806,-20},{806,86},{878,86}}, color={0,0,127}));
        connect(TSup.T, conVAVNor.TSupAHU) annotation (Line(points={{340,-29},{340,-20},
                {986,-20},{986,86},{1036,86}},   color={0,0,127}));
        connect(TSup.T, conVAVWes.TSupAHU) annotation (Line(points={{340,-29},{340,-20},
                {1168,-20},{1168,86},{1238,86}}, color={0,0,127}));
        connect(yFreHeaCoi.y, swiFreSta.u1) annotation (Line(points={{-78,-132},{-42,
                -132}},               color={0,0,127}));
        connect(zonToSys.ySumDesZonPop, conAHU.sumDesZonPop) annotation (Line(points={{302,589},
              {308,589},{308,609.778},{336,609.778}},             color={0,0,127}));
        connect(zonToSys.VSumDesPopBreZon_flow, conAHU.VSumDesPopBreZon_flow)
          annotation (Line(points={{302,586},{310,586},{310,604.444},{336,
              604.444}},
              color={0,0,127}));
        connect(zonToSys.VSumDesAreBreZon_flow, conAHU.VSumDesAreBreZon_flow)
          annotation (Line(points={{302,583},{312,583},{312,599.111},{336,
              599.111}},
              color={0,0,127}));
        connect(zonToSys.yDesSysVenEff, conAHU.uDesSysVenEff) annotation (Line(points={{302,580},
              {314,580},{314,593.778},{336,593.778}},             color={0,0,127}));
        connect(zonToSys.VSumUncOutAir_flow, conAHU.VSumUncOutAir_flow) annotation (
            Line(points={{302,577},{316,577},{316,588.444},{336,588.444}}, color={0,0,
                127}));
        connect(zonToSys.VSumSysPriAir_flow, conAHU.VSumSysPriAir_flow) annotation (
            Line(points={{302,571},{318,571},{318,583.111},{336,583.111}}, color={0,0,
                127}));
        connect(zonToSys.uOutAirFra_max, conAHU.uOutAirFra_max) annotation (Line(
              points={{302,574},{320,574},{320,577.778},{336,577.778}}, color={0,0,127}));
        connect(zonOutAirSet.yDesZonPeaOcc, zonToSys.uDesZonPeaOcc) annotation (Line(
              points={{242,599},{270,599},{270,588},{278,588}},     color={0,0,127}));
        connect(zonOutAirSet.VDesPopBreZon_flow, zonToSys.VDesPopBreZon_flow)
          annotation (Line(points={{242,596},{268,596},{268,586},{278,586}},
                                                           color={0,0,127}));
        connect(zonOutAirSet.VDesAreBreZon_flow, zonToSys.VDesAreBreZon_flow)
          annotation (Line(points={{242,593},{266,593},{266,584},{278,584}},
              color={0,0,127}));
        connect(zonOutAirSet.yDesPriOutAirFra, zonToSys.uDesPriOutAirFra) annotation (
           Line(points={{242,590},{264,590},{264,578},{278,578}},     color={0,0,127}));
        connect(zonOutAirSet.VUncOutAir_flow, zonToSys.VUncOutAir_flow) annotation (
            Line(points={{242,587},{262,587},{262,576},{278,576}},     color={0,0,127}));
        connect(zonOutAirSet.yPriOutAirFra, zonToSys.uPriOutAirFra)
          annotation (Line(points={{242,584},{260,584},{260,574},{278,574}},
                                                           color={0,0,127}));
        connect(zonOutAirSet.VPriAir_flow, zonToSys.VPriAir_flow) annotation (Line(
              points={{242,581},{258,581},{258,572},{278,572}},     color={0,0,127}));
        connect(conAHU.yAveOutAirFraPlu, zonToSys.yAveOutAirFraPlu) annotation (Line(
              points={{424,586.667},{440,586.667},{440,468},{270,468},{270,582},
              {278,582}},
              color={0,0,127}));
        connect(conAHU.VDesUncOutAir_flow, reaRep1.u) annotation (Line(points={{424,
              597.333},{440,597.333},{440,590},{458,590}},
                                                    color={0,0,127}));
        connect(reaRep1.y, zonOutAirSet.VUncOut_flow_nominal) annotation (Line(points={{482,590},
                {490,590},{490,464},{210,464},{210,581},{218,581}},          color={0,
                0,127}));
        connect(conAHU.yReqOutAir, booRep1.u) annotation (Line(points={{424,
              565.333},{444,565.333},{444,560},{458,560}},
                                                   color={255,0,255}));
        connect(booRep1.y, zonOutAirSet.uReqOutAir) annotation (Line(points={{482,560},
                {496,560},{496,460},{206,460},{206,593},{218,593}}, color={255,0,255}));
        connect(flo.TRooAir, zonOutAirSet.TZon) annotation (Line(points={{1107.13,
              506},{1164,506},{1164,660},{210,660},{210,590},{218,590}},  color={0,0,127}));
        connect(TDis.y, zonOutAirSet.TDis) annotation (Line(points={{241,370},{252,
                370},{252,414},{200,414},{200,587},{218,587}},
                                                          color={0,0,127}));
        connect(VDis_flow.y, zonOutAirSet.VDis_flow) annotation (Line(points={{241,330},
                {260,330},{260,420},{194,420},{194,584},{218,584}}, color={0,0,127}));
        connect(TZonResReq.y, conAHU.uZonTemResReq) annotation (Line(points={{322,370},
              {330,370},{330,526.222},{336,526.222}},   color={255,127,0}));
        connect(PZonResReq.y, conAHU.uZonPreResReq) annotation (Line(points={{322,330},
              {326,330},{326,520.889},{336,520.889}},   color={255,127,0}));
        connect(TOut.y, conAHU.TOut) annotation (Line(points={{-279,180},{-260,
              180},{-260,625.778},{336,625.778}},
                                         color={0,0,127}));
        connect(dpDisSupFan.p_rel, conAHU.ducStaPre) annotation (Line(points={{311,0},
              {160,0},{160,620.444},{336,620.444}},   color={0,0,127}));
        connect(TSup.T, conAHU.TSup) annotation (Line(points={{340,-29},{340,
              -20},{152,-20},{152,567.111},{336,567.111}},
                                                   color={0,0,127}));
        connect(TRet.T, conAHU.TOutCut) annotation (Line(points={{100,151},{100,
              561.778},{336,561.778}},
                                color={0,0,127}));
        connect(VOut1.V_flow, conAHU.VOut_flow) annotation (Line(points={{-80,-29},
              {-80,-20},{-60,-20},{-60,546},{138,546},{138,545.778},{336,
              545.778}},                     color={0,0,127}));
        connect(TMix.T, conAHU.TMix) annotation (Line(points={{40,-29},{40,
              538.667},{336,538.667}},
                           color={0,0,127}));
        connect(conAHU.yOutDamPos, damOut.y) annotation (Line(points={{424,
              522.667},{448,522.667},{448,36},{-40,36},{-40,-28}},
                                                       color={0,0,127}));
        connect(conAHU.yRetDamPos, damRet.y) annotation (Line(points={{424,
              533.333},{442,533.333},{442,40},{-20,40},{-20,-10},{-12,-10}},
                                                           color={0,0,127}));
        connect(conAHU.ySupFanSpe, fanSup.y) annotation (Line(points={{424,
              618.667},{432,618.667},{432,-14},{310,-14},{310,-28}},
                                                         color={0,0,127}));
        connect(cor.y_actual,conVAVCor.yDam_actual)  annotation (Line(points={{612,42},
                {620,42},{620,74},{518,74},{518,90},{528,90}}, color={0,0,127}));
        connect(sou.y_actual,conVAVSou.yDam_actual)  annotation (Line(points={{792,40},
                {800,40},{800,72},{684,72},{684,90},{700,90}}, color={0,0,127}));
        connect(eas.y_actual,conVAVEas.yDam_actual)  annotation (Line(points={{972,40},
                {980,40},{980,74},{864,74},{864,90},{878,90}}, color={0,0,127}));
        connect(nor.y_actual,conVAVNor.yDam_actual)  annotation (Line(points={{1132,40},
                {1140,40},{1140,74},{1024,74},{1024,90},{1036,90}},     color={0,0,
                127}));
        connect(wes.y_actual,conVAVWes.yDam_actual)  annotation (Line(points={{1332,40},
                {1340,40},{1340,74},{1224,74},{1224,90},{1238,90}},     color={0,0,
                127}));
        connect(warCooTim.y, zonSta.cooDowTim) annotation (Line(points={{-278,380},{-240,
                380},{-240,290},{-222,290}}, color={0,0,127}));
        connect(warCooTim.y, zonSta.warUpTim) annotation (Line(points={{-278,380},{-240,
                380},{-240,286},{-222,286}}, color={0,0,127}));
        connect(flo.TRooAir, zonSta.TZon) annotation (Line(points={{1107.13,506},
              {1164,506},{1164,660},{-250,660},{-250,274},{-222,274}},       color={0,
                0,127}));
        connect(zonSta.yCooTim, zonGroSta.uCooTim) annotation (Line(points={{-198,295},
                {-176,295},{-176,291},{-162,291}}, color={0,0,127}));
        connect(zonSta.yWarTim, zonGroSta.uWarTim) annotation (Line(points={{-198,293},
                {-178,293},{-178,289},{-162,289}}, color={0,0,127}));
        connect(zonSta.yOccHeaHig, zonGroSta.uOccHeaHig) annotation (Line(points={{-198,
                288},{-180,288},{-180,285},{-162,285}}, color={255,0,255}));
        connect(zonSta.yHigOccCoo, zonGroSta.uHigOccCoo)
          annotation (Line(points={{-198,283},{-162,283}}, color={255,0,255}));
        connect(zonSta.THeaSetOff, zonGroSta.THeaSetOff) annotation (Line(points={{-198,
                280},{-182,280},{-182,277},{-162,277}}, color={0,0,127}));
        connect(zonSta.yUnoHeaHig, zonGroSta.uUnoHeaHig) annotation (Line(points={{-198,
                278},{-188,278},{-188,279},{-162,279}}, color={255,0,255}));
        connect(zonSta.yEndSetBac, zonGroSta.uEndSetBac) annotation (Line(points={{-198,
                276},{-188,276},{-188,275},{-162,275}}, color={255,0,255}));
        connect(zonSta.TCooSetOff, zonGroSta.TCooSetOff) annotation (Line(points={{-198,
                273},{-190,273},{-190,269},{-162,269}}, color={0,0,127}));
        connect(zonSta.yHigUnoCoo, zonGroSta.uHigUnoCoo)
          annotation (Line(points={{-198,271},{-162,271}}, color={255,0,255}));
        connect(zonSta.yEndSetUp, zonGroSta.uEndSetUp) annotation (Line(points={{-198,
                269},{-192,269},{-192,267},{-162,267}}, color={255,0,255}));
        connect(flo.TRooAir, zonGroSta.TZon) annotation (Line(points={{1107.13,
              506},{1164,506},{1164,660},{-250,660},{-250,263},{-162,263}},
              color={0,0,127}));
        connect(falSta.y, zonGroSta.uWin) annotation (Line(points={{-278,340},{-172,
                340},{-172,261},{-162,261}}, color={255,0,255}));
        connect(occSch.tNexOcc, reaRep.u) annotation (Line(points={{-297,-204},{-236,
                -204},{-236,-180},{-202,-180}}, color={0,0,127}));
        connect(reaRep.y, zonGroSta.tNexOcc) annotation (Line(points={{-178,-180},{-164,
                -180},{-164,295},{-162,295}}, color={0,0,127}));
        connect(occSch.occupied, booRep.u) annotation (Line(points={{-297,-216},{-220,
                -216},{-220,-140},{-202,-140}}, color={255,0,255}));
        connect(booRep.y, zonGroSta.uOcc) annotation (Line(points={{-178,-140},{-166,
                -140},{-166,297},{-162,297}}, color={255,0,255}));
        connect(falSta.y, zonGroSta.zonOcc) annotation (Line(points={{-278,340},{-172,
                340},{-172,299},{-162,299}}, color={255,0,255}));
        connect(zonGroSta.uGroOcc, opeModSel.uOcc) annotation (Line(points={{-138,299},
                {-136,299},{-136,314},{-102,314}}, color={255,0,255}));
        connect(zonGroSta.nexOcc, opeModSel.tNexOcc) annotation (Line(points={{-138,
                297},{-134,297},{-134,312},{-102,312}}, color={0,0,127}));
        connect(zonGroSta.yCooTim, opeModSel.maxCooDowTim) annotation (Line(points={{
                -138,293},{-132,293},{-132,310},{-102,310}}, color={0,0,127}));
        connect(zonGroSta.yWarTim, opeModSel.maxWarUpTim) annotation (Line(points={{-138,
                291},{-128,291},{-128,306},{-102,306}}, color={0,0,127}));
        connect(zonGroSta.yOccHeaHig, opeModSel.uOccHeaHig) annotation (Line(points={
                {-138,287},{-126,287},{-126,304},{-102,304}}, color={255,0,255}));
        connect(zonGroSta.yHigOccCoo, opeModSel.uHigOccCoo) annotation (Line(points={
                {-138,285},{-130,285},{-130,308},{-102,308}}, color={255,0,255}));
        connect(zonGroSta.yColZon, opeModSel.totColZon) annotation (Line(points={{-138,
                282},{-122,282},{-122,300},{-102,300}}, color={255,127,0}));
        connect(zonGroSta.ySetBac, opeModSel.uSetBac) annotation (Line(points={{-138,280},
                {-120,280},{-120,298},{-102,298}},      color={255,0,255}));
        connect(zonGroSta.yEndSetBac, opeModSel.uEndSetBac) annotation (Line(points={{-138,
                278},{-118,278},{-118,296},{-102,296}},       color={255,0,255}));
        connect(zonGroSta.TZonMax, opeModSel.TZonMax) annotation (Line(points={{-138,267},
                {-116,267},{-116,294},{-102,294}},      color={0,0,127}));
        connect(zonGroSta.TZonMin, opeModSel.TZonMin) annotation (Line(points={{-138,265},
                {-114,265},{-114,292},{-102,292}},      color={0,0,127}));
        connect(zonGroSta.yHotZon, opeModSel.totHotZon) annotation (Line(points={{-138,
                275},{-112,275},{-112,290},{-102,290}}, color={255,127,0}));
        connect(zonGroSta.ySetUp, opeModSel.uSetUp) annotation (Line(points={{-138,273},
                {-110,273},{-110,288},{-102,288}},      color={255,0,255}));
        connect(zonGroSta.yEndSetUp, opeModSel.uEndSetUp) annotation (Line(points={{-138,
                271},{-108,271},{-108,286},{-102,286}}, color={255,0,255}));
        connect(zonSta.THeaSetOn, TZonSet.TZonHeaSetOcc) annotation (Line(points={{
                -198,290},{-186,290},{-186,198},{-102,198}}, color={0,0,127}));
        connect(zonSta.THeaSetOff, TZonSet.TZonHeaSetUno) annotation (Line(points={{
                -198,280},{-182,280},{-182,196},{-102,196}}, color={0,0,127}));
        connect(zonSta.TCooSetOn, TZonSet.TZonCooSetOcc) annotation (Line(points={{
                -198,285},{-184,285},{-184,203},{-102,203}}, color={0,0,127}));
        connect(zonSta.TCooSetOff, TZonSet.TZonCooSetUno) annotation (Line(points={{
                -198,273},{-190,273},{-190,201},{-102,201}}, color={0,0,127}));
        connect(demLimLev.y, TZonSet.uCooDemLimLev) annotation (Line(points={{-278,
                240},{-220,240},{-220,188},{-102,188}}, color={255,127,0}));
        connect(demLimLev.y, TZonSet.uHeaDemLimLev) annotation (Line(points={{-278,
                240},{-220,240},{-220,186},{-102,186}}, color={255,127,0}));
        connect(opeModSel.yOpeMod, conVAVCor.uOpeMod) annotation (Line(points={{-78,300},
                {-16,300},{-16,76},{506,76},{506,84},{528,84}},      color={255,127,0}));
        connect(opeModSel.yOpeMod, conVAVSou.uOpeMod) annotation (Line(points={{-78,300},
                {-18,300},{-18,76},{676,76},{676,84},{700,84}},      color={255,127,0}));
        connect(opeModSel.yOpeMod, conVAVEas.uOpeMod) annotation (Line(points={{-78,300},
                {-18,300},{-18,76},{860,76},{860,84},{878,84}},      color={255,127,0}));
        connect(opeModSel.yOpeMod, conVAVNor.uOpeMod) annotation (Line(points={{-78,300},
                {-18,300},{-18,76},{1020,76},{1020,84},{1036,84}},      color={255,
                127,0}));
        connect(opeModSel.yOpeMod, conVAVWes.uOpeMod) annotation (Line(points={{-78,300},
                {-18,300},{-18,76},{1216,76},{1216,84},{1238,84}},      color={255,
                127,0}));
        connect(opeModSel.yOpeMod, conAHU.uOpeMod) annotation (Line(points={{-78,300},
              {-18,300},{-18,531.556},{336,531.556}},   color={255,127,0}));
        connect(TZonSet[1].TZonHeaSet, conAHU.TZonHeaSet) annotation (Line(points={{-78,194},
              {-36,194},{-36,636.444},{336,636.444}},            color={0,0,127}));
        connect(TZonSet[1].TZonCooSet, conAHU.TZonCooSet) annotation (Line(points={{-78,202},
              {-26,202},{-26,631.111},{336,631.111}},            color={0,0,127}));
        connect(TZonSet[1].TZonHeaSet, conVAVCor.TZonHeaSet) annotation (Line(points={{-78,194},
                {482,194},{482,104},{528,104}},          color={0,0,127}));
        connect(TZonSet[2].TZonHeaSet, conVAVSou.TZonHeaSet) annotation (Line(points={{-78,194},
                {672,194},{672,104},{700,104}},          color={0,0,127}));
        connect(TZonSet[3].TZonHeaSet, conVAVEas.TZonHeaSet) annotation (Line(points={{-78,194},
                {852,194},{852,104},{878,104}},          color={0,0,127}));
        connect(TZonSet[4].TZonHeaSet, conVAVNor.TZonHeaSet) annotation (Line(points={{-78,194},
                {1016,194},{1016,104},{1036,104}},          color={0,0,127}));
        connect(TZonSet[5].TZonHeaSet, conVAVWes.TZonHeaSet) annotation (Line(points={{-78,194},
                {1186,194},{1186,104},{1238,104}},          color={0,0,127}));
        connect(TZonSet[1].TZonCooSet, conVAVCor.TZonCooSet) annotation (Line(points={{-78,202},
                {476,202},{476,102},{528,102}},          color={0,0,127}));
        connect(TZonSet[2].TZonCooSet, conVAVSou.TZonCooSet) annotation (Line(points={{-78,202},
                {666,202},{666,102},{700,102}},          color={0,0,127}));
        connect(TZonSet[3].TZonCooSet, conVAVEas.TZonCooSet) annotation (Line(points={{-78,202},
                {844,202},{844,102},{878,102}},          color={0,0,127}));
        connect(TZonSet[4].TZonCooSet, conVAVNor.TZonCooSet) annotation (Line(points={{-78,202},
                {1010,202},{1010,102},{1036,102}},          color={0,0,127}));
        connect(TZonSet[5].TZonCooSet, conVAVWes.TZonCooSet) annotation (Line(points={{-78,202},
                {1180,202},{1180,102},{1238,102}},          color={0,0,127}));
        connect(opeModSel.yOpeMod, intRep.u) annotation (Line(points={{-78,300},{-18,
                300},{-18,250},{-160,250},{-160,230},{-142,230}}, color={255,127,0}));
        connect(intRep.y, TZonSet.uOpeMod) annotation (Line(points={{-118,230},{-110,
                230},{-110,207},{-102,207}}, color={255,127,0}));
        connect(zonGroSta.yOpeWin, opeModSel.uOpeWin) annotation (Line(points={{-138,261},
                {-124,261},{-124,302},{-102,302}}, color={255,127,0}));
        connect(amb.ports[3], TRet.port_b) annotation (Line(points={{-114,-45},{-100,
                -45},{-100,140},{90,140}}, color={0,127,255}));
        connect(cor.yVAV, conVAVCor.yDam) annotation (Line(points={{566,58},{560,58},
                {560,100},{552,100}}, color={0,0,127}));
        connect(cor.yHea, conVAVCor.yVal) annotation (Line(points={{566,48},{556,48},
                {556,95},{552,95}}, color={0,0,127}));
        connect(conVAVSou.yDam, sou.yVAV) annotation (Line(points={{724,100},{738,100},
                {738,56},{746,56}}, color={0,0,127}));
        connect(conVAVSou.yVal, sou.yHea) annotation (Line(points={{724,95},{736,95},
                {736,46},{746,46}}, color={0,0,127}));
        connect(conVAVEas.yDam, eas.yVAV) annotation (Line(points={{902,100},{918,100},
                {918,56},{926,56}}, color={0,0,127}));
        connect(conVAVEas.yVal, eas.yHea) annotation (Line(points={{902,95},{912,95},
                {912,46},{926,46}}, color={0,0,127}));
        connect(conVAVNor.yDam, nor.yVAV) annotation (Line(points={{1060,100},{1076,
                100},{1076,56},{1086,56}}, color={0,0,127}));
        connect(conVAVNor.yVal, nor.yHea) annotation (Line(points={{1060,95},{1072,95},
                {1072,46},{1086,46}}, color={0,0,127}));
        connect(conVAVWes.yDam, wes.yVAV) annotation (Line(points={{1262,100},{1276,
                100},{1276,56},{1286,56}}, color={0,0,127}));
        connect(conVAVWes.yVal, wes.yHea) annotation (Line(points={{1262,95},{1272,95},
                {1272,46},{1286,46},{1286,46}}, color={0,0,127}));
        connect(freSta.y, swiFreSta.u2) annotation (Line(points={{-118,-90},{-64,-90},
                {-64,-140},{-42,-140}}, color={255,0,255}));
        connect(swiFreSta.y, sysHysHea.u)
          annotation (Line(points={{-18,-140},{18,-140}}, color={0,0,127}));
        connect(sysHysHea.y, valHeaCoi.y) annotation (Line(points={{42,-140},{160,
                -140},{160,-170},{152,-170}}, color={0,0,127}));
        connect(sysHysHea.yPum, pumHeaCoi.y) annotation (Line(points={{42,-147},{158,
                -147},{158,-120},{152,-120}}, color={0,0,127}));
        connect(sysHysCoo.y, valCooCoi.y) annotation (Line(points={{42,-240},{160,
                -240},{160,-210},{166,-210},{166,-210},{168,-210}}, color={0,0,127}));
        connect(sysHysCoo.yPum, pumCooCoi.y) annotation (Line(points={{42,-247},{240,
                -247},{240,-120},{192,-120},{192,-120}}, color={0,0,127}));
        connect(conAHU.yHea, swiFreSta.u3) annotation (Line(points={{424,
              554.667},{456,554.667},{456,-300},{-60,-300},{-60,-148},{-42,-148}},
                                                                           color={0,0,
                127}));
        connect(conAHU.yCoo, sysHysCoo.u) annotation (Line(points={{424,544},{424,546},
                {452,546},{452,-296},{0,-296},{0,-240},{18,-240}}, color={0,0,127}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-380,-320},{1400,
                  680}})),
          Documentation(info="<html>
<p>
This model consist of an HVAC system, a building envelope model and a model
for air flow through building leakage and through open doors.
</p>
<p>
The HVAC system is a variable air volume (VAV) flow system with economizer
and a heating and cooling coil in the air handler unit. There is also a
reheat coil and an air damper in each of the five zone inlet branches.
</p>
<p>
See the model
<a href=\"modelica://Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop\">
Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop</a>
for a description of the HVAC system and the building envelope.
</p>
<p>
The control is based on ASHRAE Guideline 36, and implemented
using the sequences from the library
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1\">
Buildings.Controls.OBC.ASHRAE.G36_PR1</a> for
multi-zone VAV systems with economizer. The schematic diagram of the HVAC and control
sequence is shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Examples/VAVReheat/vavControlSchematics.png\" border=\"1\"/>
</p>
<p>
A similar model but with a different control sequence can be found in
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>.
Note that this model, because of the frequent time sampling,
has longer computing time than
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>.
The reason is that the time integrator cannot make large steps
because it needs to set a time step each time the control samples
its input.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2021, by Michael Wetter:<br/>
Changed model to include the hydraulic configurations of the cooling coil,
heating coil and VAV terminal box.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2594\">issue #2594</a>.
</li>
<li>
April 30, 2021, by Michael Wetter:<br/>
Reformulated replaceable class and introduced floor areas in base class
to avoid access of components that are not in the constraining type.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2471\">issue #2471</a>.
</li>
<li>
April 16, 2021, by Michael Wetter:<br/>
Refactored model to implement the economizer dampers directly in
<code>Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop</code> rather than through the
model of a mixing box. Since the version of the Guideline 36 model has no exhaust air damper,
this leads to simpler equations.
<br/> This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2454\">issue #2454</a>.
</li>
<li>
March 15, 2021, by David Blum:<br/>
Change component name <code>yOutDam</code> to <code>yExhDam</code>
and update documentation graphic to include relief damper.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2399\">#2399</a>.
</li>
<li>
July 10, 2020, by Antoine Gautier:<br/>
Changed design and control parameters for outdoor air flow.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2019\">#2019</a>
</li>
<li>
June 15, 2020, by Jianjun Hu:<br/>
Upgraded sequence of specifying operating mode according to G36 official release.
</li>
<li>
April 20, 2020, by Jianjun Hu:<br/>
Exported actual VAV damper position as the measured input data for terminal controller.<br/>
This is
for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1873\">issue #1873</a>
</li>
<li>
March 20, 2020, by Jianjun Hu:<br/>
Replaced the AHU controller with reimplemented one. The new controller separates the
zone level calculation from the system level calculation and does not include
vector-valued calculations.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1829\">#1829</a>.
</li>
<li>
March 09, 2020, by Jianjun Hu:<br/>
Replaced the block that calculates operation mode and zone temperature setpoint,
with the new one that does not include vector-valued calculations.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1709\">#1709</a>.
</li>
<li>
May 19, 2016, by Michael Wetter:<br/>
Changed chilled water supply temperature to <i>6&deg;C</i>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/509\">#509</a>.
</li>
<li>
April 26, 2016, by Michael Wetter:<br/>
Changed controller for freeze protection as the old implementation closed
the outdoor air damper during summer.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/511\">#511</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Set default temperature for medium to avoid conflicting
start values for alias variables of the temperature
of the building and the ambient air.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
</ul>
</html>"),__Dymola_Commands(file=
                "modelica://Buildings/Resources/Scripts/Dymola/Examples/VAVReheat/Guideline36.mos"
              "Simulate and plot"),
          experiment(StopTime=172800, Tolerance=1e-06),
          Icon(coordinateSystem(extent={{-100,-100},{100,100}})));
      end Guideline36;

      partial model PartialOpenLoop
        "Partial model of variable air volume flow system with terminal reheat and five thermal zones"

        replaceable package MediumA = Buildings.Media.Air "Medium model for air";
        replaceable package MediumW = Buildings.Media.Water "Medium model for water";

        constant Integer numZon=5 "Total number of served VAV boxes";

        parameter Modelica.SIunits.Volume VRooCor=flo.VRooCor
          "Room volume corridor";
        parameter Modelica.SIunits.Volume VRooSou=flo.VRooSou
          "Room volume south";
        parameter Modelica.SIunits.Volume VRooNor=flo.VRooNor
          "Room volume north";
        parameter Modelica.SIunits.Volume VRooEas=flo.VRooEas
          "Room volume east";
        parameter Modelica.SIunits.Volume VRooWes=flo.VRooWes
          "Room volume west";

        parameter Modelica.SIunits.Area AFloCor=flo.AFloCor "Floor area corridor";
        parameter Modelica.SIunits.Area AFloSou=flo.AFloSou "Floor area south";
        parameter Modelica.SIunits.Area AFloNor=flo.AFloNor "Floor area north";
        parameter Modelica.SIunits.Area AFloEas=flo.AFloEas "Floor area east";
        parameter Modelica.SIunits.Area AFloWes=flo.AFloWes "Floor area west";

        parameter Modelica.SIunits.Area AFlo[numZon]={flo.AFloCor,flo.AFloSou,flo.AFloEas,
            flo.AFloNor,flo.AFloWes} "Floor area of each zone";
        final parameter Modelica.SIunits.Area ATot=sum(AFlo) "Total floor area";

        constant Real conv=1.2/3600 "Conversion factor for nominal mass flow rate";

        parameter Real ACHCor(final unit="1/h")=6
          "Design air change per hour core";
        parameter Real ACHSou(final unit="1/h")=6
          "Design air change per hour south";
        parameter Real ACHEas(final unit="1/h")=9
          "Design air change per hour east";
        parameter Real ACHNor(final unit="1/h")=6
          "Design air change per hour north";
        parameter Real ACHWes(final unit="1/h")=7
          "Design air change per hour west";

        parameter Modelica.SIunits.MassFlowRate mCor_flow_nominal=ACHCor*VRooCor*conv
          "Design mass flow rate core";
        parameter Modelica.SIunits.MassFlowRate mSou_flow_nominal=ACHSou*VRooSou*conv
          "Design mass flow rate south";
        parameter Modelica.SIunits.MassFlowRate mEas_flow_nominal=ACHEas*VRooEas*conv
          "Design mass flow rate east";
        parameter Modelica.SIunits.MassFlowRate mNor_flow_nominal=ACHNor*VRooNor*conv
          "Design mass flow rate north";
        parameter Modelica.SIunits.MassFlowRate mWes_flow_nominal=ACHWes*VRooWes*conv
          "Design mass flow rate west";

        parameter Modelica.SIunits.MassFlowRate m_flow_nominal=0.7*(mCor_flow_nominal
             + mSou_flow_nominal + mEas_flow_nominal + mNor_flow_nominal +
            mWes_flow_nominal) "Nominal mass flow rate";

        parameter Modelica.SIunits.MassFlowRate mHeaWat_flow_nominal=m_flow_nominal*1000*
            (10 - (-20))/4200/10 "Nominal water mass flow rate for heating coil in AHU";
        parameter Modelica.SIunits.MassFlowRate mCooWat_flow_nominal=m_flow_nominal*1000*
            15/4200/10 "Nominal water mass flow rate for cooling coil";

        parameter Real ratVFloHea(final unit="1") = 0.3
          "VAV box maximum air flow rate ratio in heating mode";

        parameter Modelica.SIunits.Angle lat=41.98*3.14159/180 "Latitude";

        parameter Real ratOAFlo_A(final unit="m3/(s.m2)") = 0.3e-3
          "Outdoor airflow rate required per unit area";
        parameter Real ratOAFlo_P = 2.5e-3
          "Outdoor airflow rate required per person";
        parameter Real ratP_A = 5e-2
          "Occupant density";
        parameter Real effZ(final unit="1") = 0.8
          "Zone air distribution effectiveness (limiting value)";
        parameter Real divP(final unit="1") = 0.7
          "Occupant diversity ratio";
        parameter Modelica.SIunits.VolumeFlowRate VCorOA_flow_nominal=
          (ratOAFlo_P * ratP_A + ratOAFlo_A) * AFloCor / effZ
          "Zone outdoor air flow rate";
        parameter Modelica.SIunits.VolumeFlowRate VSouOA_flow_nominal=
          (ratOAFlo_P * ratP_A + ratOAFlo_A) * AFloSou / effZ
          "Zone outdoor air flow rate";
        parameter Modelica.SIunits.VolumeFlowRate VEasOA_flow_nominal=
          (ratOAFlo_P * ratP_A + ratOAFlo_A) * AFloEas / effZ
          "Zone outdoor air flow rate";
        parameter Modelica.SIunits.VolumeFlowRate VNorOA_flow_nominal=
          (ratOAFlo_P * ratP_A + ratOAFlo_A) * AFloNor / effZ
          "Zone outdoor air flow rate";
        parameter Modelica.SIunits.VolumeFlowRate VWesOA_flow_nominal=
          (ratOAFlo_P * ratP_A + ratOAFlo_A) * AFloWes / effZ
          "Zone outdoor air flow rate";
        parameter Modelica.SIunits.VolumeFlowRate Vou_flow_nominal=
          (divP * ratOAFlo_P * ratP_A + ratOAFlo_A) * sum(
            {AFloCor, AFloSou, AFloNor, AFloEas, AFloWes})
          "System uncorrected outdoor air flow rate";
        parameter Real effVen(final unit="1") = if divP < 0.6 then
          0.88 * divP + 0.22 else 0.75
          "System ventilation efficiency";
        parameter Modelica.SIunits.VolumeFlowRate Vot_flow_nominal=
          Vou_flow_nominal / effVen
          "System design outdoor air flow rate";

        parameter Modelica.SIunits.Temperature THeaOn=293.15
          "Heating setpoint during on";
        parameter Modelica.SIunits.Temperature THeaOff=285.15
          "Heating setpoint during off";
        parameter Modelica.SIunits.Temperature TCooOn=297.15
          "Cooling setpoint during on";
        parameter Modelica.SIunits.Temperature TCooOff=303.15
          "Cooling setpoint during off";
        parameter Modelica.SIunits.PressureDifference dpBuiStaSet(min=0) = 12
          "Building static pressure";
        parameter Real yFanMin = 0.1 "Minimum fan speed";

        parameter Modelica.SIunits.Temperature THotWatInl_nominal(
          displayUnit="degC")=55 + 273.15
          "Reheat coil nominal inlet water temperature";

        parameter Boolean allowFlowReversal=true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation (Evaluate=true);

        parameter Boolean use_windPressure=true "Set to true to enable wind pressure";

        parameter Boolean sampleModel=true
          "Set to true to time-sample the model, which can give shorter simulation time if there is already time sampling in the system model"
          annotation (Evaluate=true, Dialog(tab=
          "Experimental (may be changed in future releases)"));

        Buildings.Fluid.Sources.Outside amb(redeclare package Medium = MediumA,
            nPorts=2) "Ambient conditions"
          annotation (Placement(transformation(extent={{-136,-56},{-114,-34}})));

        replaceable Buildings.Examples.VAVReheat.BaseClasses.PartialFloor flo
          constrainedby Buildings.Examples.VAVReheat.BaseClasses.PartialFloor(
            redeclare final package Medium = MediumA,
            final use_windPressure=use_windPressure)
          "Model of a floor of the building that is served by this VAV system"
          annotation (Placement(transformation(extent={{772,396},{1100,616}})), choicesAllMatching=true);

        Buildings.Fluid.HeatExchangers.DryCoilEffectivenessNTU heaCoi(
          redeclare package Medium1 = MediumW,
          redeclare package Medium2 = MediumA,
          m1_flow_nominal=mHeaWat_flow_nominal,
          m2_flow_nominal=m_flow_nominal,
          show_T=true,
          configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
          Q_flow_nominal=m_flow_nominal*1006*(16.7 - 4),
          dp1_nominal=3000,
          dp2_nominal=200 + 200 + 100 + 40,
          allowFlowReversal1=false,
          allowFlowReversal2=allowFlowReversal,
          T_a1_nominal=THotWatInl_nominal,
          T_a2_nominal=277.15)
          "Heating coil"
          annotation (Placement(transformation(extent={{118,-36},{98,-56}})));

        Buildings.Fluid.HeatExchangers.WetCoilEffectivenessNTU cooCoi(
          show_T=true,
          UA_nominal=3*m_flow_nominal*1000*15/
              Buildings.Fluid.HeatExchangers.BaseClasses.lmtd(
              T_a1=26.2,
              T_b1=12.8,
              T_a2=6,
              T_b2=16),
          redeclare package Medium1 = MediumW,
          redeclare package Medium2 = MediumA,
          m1_flow_nominal=mCooWat_flow_nominal,
          m2_flow_nominal=m_flow_nominal,
          dp2_nominal=0,
          dp1_nominal=3000,
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          allowFlowReversal1=false,
          allowFlowReversal2=allowFlowReversal) "Cooling coil"
          annotation (Placement(transformation(extent={{210,-36},{190,-56}})));
        Buildings.Fluid.FixedResistances.PressureDrop dpRetDuc(
          m_flow_nominal=m_flow_nominal,
          redeclare package Medium = MediumA,
          allowFlowReversal=allowFlowReversal,
          dp_nominal=40) "Pressure drop for return duct"
          annotation (Placement(transformation(extent={{400,130},{380,150}})));
        Buildings.Fluid.Movers.SpeedControlled_y fanSup(
          redeclare package Medium = MediumA,
          per(pressure(V_flow={0,m_flow_nominal/1.2*2}, dp=2*{780 + 10 + dpBuiStaSet,
                  0})),
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial) "Supply air fan"
          annotation (Placement(transformation(extent={{300,-50},{320,-30}})));

        Buildings.Fluid.Sensors.VolumeFlowRate senSupFlo(redeclare package
          Medium =
              MediumA, m_flow_nominal=m_flow_nominal)
          "Sensor for supply fan flow rate"
          annotation (Placement(transformation(extent={{400,-50},{420,-30}})));

        Buildings.Fluid.Sensors.VolumeFlowRate senRetFlo(redeclare package
          Medium =
              MediumA, m_flow_nominal=m_flow_nominal)
          "Sensor for return fan flow rate"
          annotation (Placement(transformation(extent={{360,130},{340,150}})));

        Modelica.Blocks.Routing.RealPassThrough TOut(y(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC",
            min=0))
          annotation (Placement(transformation(extent={{-300,170},{-280,190}})));
        Buildings.Fluid.Sensors.TemperatureTwoPort TSup(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          allowFlowReversal=allowFlowReversal)
          annotation (Placement(transformation(extent={{330,-50},{350,-30}})));
        Buildings.Fluid.Sensors.RelativePressure dpDisSupFan(redeclare package
          Medium =
              MediumA) "Supply fan static discharge pressure" annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={320,0})));
        Buildings.Controls.SetPoints.OccupancySchedule occSch(occupancy=3600*{6,19})
          "Occupancy schedule"
          annotation (Placement(transformation(extent={{-318,-220},{-298,-200}})));
        Buildings.Utilities.Math.Min min(nin=5) "Computes lowest room temperature"
          annotation (Placement(transformation(extent={{1200,440},{1220,460}})));
        Buildings.Utilities.Math.Average ave(nin=5)
          "Compute average of room temperatures"
          annotation (Placement(transformation(extent={{1200,410},{1220,430}})));
        Buildings.Fluid.Sensors.TemperatureTwoPort TRet(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          allowFlowReversal=allowFlowReversal) "Return air temperature sensor"
          annotation (Placement(transformation(extent={{110,130},{90,150}})));
        Buildings.Fluid.Sensors.TemperatureTwoPort TMix(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          allowFlowReversal=allowFlowReversal) "Mixed air temperature sensor"
          annotation (Placement(transformation(extent={{30,-50},{50,-30}})));
        Buildings.Fluid.Sensors.VolumeFlowRate VOut1(redeclare package Medium
          =   MediumA, m_flow_nominal=m_flow_nominal) "Outside air volume flow rate"
          annotation (Placement(transformation(extent={{-90,-50},{-70,-30}})));

        Buildings.Examples.VAVReheat.BaseClasses.VAVReheatBox cor(
          redeclare package MediumA = MediumA,
          redeclare package MediumW = MediumW,
          m_flow_nominal=mCor_flow_nominal,
          VRoo=VRooCor,
          allowFlowReversal=allowFlowReversal,
          ratVFloHea=ratVFloHea,
          THotWatInl_nominal=THotWatInl_nominal,
          THotWatOut_nominal=THotWatInl_nominal-10,
          TAirInl_nominal=12+273.15,
          QHea_flow_nominal=mCor_flow_nominal*ratVFloHea*cpAir*(32-12))
          "Zone for core of buildings (azimuth will be neglected)"
          annotation (Placement(transformation(extent={{570,22},{610,62}})));
        Buildings.Examples.VAVReheat.BaseClasses.VAVReheatBox sou(
          redeclare package MediumA = MediumA,
          redeclare package MediumW = MediumW,
          m_flow_nominal=mSou_flow_nominal,
          VRoo=VRooSou,
          allowFlowReversal=allowFlowReversal,
          ratVFloHea=ratVFloHea,
          THotWatInl_nominal=THotWatInl_nominal,
          THotWatOut_nominal=THotWatInl_nominal-10,
          TAirInl_nominal=12+273.15,
          QHea_flow_nominal=mSou_flow_nominal*ratVFloHea*cpAir*(32-12))
          "South-facing thermal zone"
          annotation (Placement(transformation(extent={{750,20},{790,60}})));
        Buildings.Examples.VAVReheat.BaseClasses.VAVReheatBox eas(
          redeclare package MediumA = MediumA,
          redeclare package MediumW = MediumW,
          m_flow_nominal=mEas_flow_nominal,
          VRoo=VRooEas,
          allowFlowReversal=allowFlowReversal,
          ratVFloHea=ratVFloHea,
          THotWatInl_nominal=THotWatInl_nominal,
          THotWatOut_nominal=THotWatInl_nominal-10,
          TAirInl_nominal=12+273.15,
          QHea_flow_nominal=mEas_flow_nominal*ratVFloHea*cpAir*(32-12))
          "East-facing thermal zone"
          annotation (Placement(transformation(extent={{930,20},{970,60}})));
        Buildings.Examples.VAVReheat.BaseClasses.VAVReheatBox nor(
          redeclare package MediumA = MediumA,
          redeclare package MediumW = MediumW,
          m_flow_nominal=mNor_flow_nominal,
          VRoo=VRooNor,
          allowFlowReversal=allowFlowReversal,
          ratVFloHea=ratVFloHea,
          THotWatInl_nominal=THotWatInl_nominal,
          THotWatOut_nominal=THotWatInl_nominal-10,
          TAirInl_nominal=12+273.15,
          QHea_flow_nominal=mNor_flow_nominal*ratVFloHea*cpAir*(32-12))
          "North-facing thermal zone"
          annotation (Placement(transformation(extent={{1090,20},{1130,60}})));
        Buildings.Examples.VAVReheat.BaseClasses.VAVReheatBox wes(
          redeclare package MediumA = MediumA,
          redeclare package MediumW = MediumW,
          m_flow_nominal=mWes_flow_nominal,
          VRoo=VRooWes,
          allowFlowReversal=allowFlowReversal,
          ratVFloHea=ratVFloHea,
          THotWatInl_nominal=THotWatInl_nominal,
          THotWatOut_nominal=THotWatInl_nominal-10,
          TAirInl_nominal=12+273.15,
          QHea_flow_nominal=mWes_flow_nominal*ratVFloHea*cpAir*(32-12))
          "West-facing thermal zone"
          annotation (Placement(transformation(extent={{1290,20},{1330,60}})));
        Buildings.Fluid.FixedResistances.Junction splRetRoo1(
          redeclare package Medium = MediumA,
          m_flow_nominal={m_flow_nominal,m_flow_nominal - mCor_flow_nominal,
              mCor_flow_nominal},
          from_dp=false,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering)
          "Splitter for room return"
          annotation (Placement(transformation(extent={{630,10},{650,-10}})));
        Buildings.Fluid.FixedResistances.Junction splRetSou(
          redeclare package Medium = MediumA,
          m_flow_nominal={mSou_flow_nominal + mEas_flow_nominal + mNor_flow_nominal
               + mWes_flow_nominal,mEas_flow_nominal + mNor_flow_nominal +
              mWes_flow_nominal,mSou_flow_nominal},
          from_dp=false,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering)
          "Splitter for room return"
          annotation (Placement(transformation(extent={{812,10},{832,-10}})));
        Buildings.Fluid.FixedResistances.Junction splRetEas(
          redeclare package Medium = MediumA,
          m_flow_nominal={mEas_flow_nominal + mNor_flow_nominal + mWes_flow_nominal,
              mNor_flow_nominal + mWes_flow_nominal,mEas_flow_nominal},
          from_dp=false,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering)
          "Splitter for room return"
          annotation (Placement(transformation(extent={{992,10},{1012,-10}})));
        Buildings.Fluid.FixedResistances.Junction splRetNor(
          redeclare package Medium = MediumA,
          m_flow_nominal={mNor_flow_nominal + mWes_flow_nominal,mWes_flow_nominal,
              mNor_flow_nominal},
          from_dp=false,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering)
          "Splitter for room return"
          annotation (Placement(transformation(extent={{1142,10},{1162,-10}})));
        Buildings.Fluid.FixedResistances.Junction splSupRoo1(
          redeclare package Medium = MediumA,
          m_flow_nominal={m_flow_nominal,m_flow_nominal - mCor_flow_nominal,
              mCor_flow_nominal},
          from_dp=true,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving)
          "Splitter for room supply"
          annotation (Placement(transformation(extent={{580,-30},{600,-50}})));
        Buildings.Fluid.FixedResistances.Junction splSupSou(
          redeclare package Medium = MediumA,
          m_flow_nominal={mSou_flow_nominal + mEas_flow_nominal + mNor_flow_nominal
               + mWes_flow_nominal,mEas_flow_nominal + mNor_flow_nominal +
              mWes_flow_nominal,mSou_flow_nominal},
          from_dp=true,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving)
          "Splitter for room supply"
          annotation (Placement(transformation(extent={{760,-30},{780,-50}})));
        Buildings.Fluid.FixedResistances.Junction splSupEas(
          redeclare package Medium = MediumA,
          m_flow_nominal={mEas_flow_nominal + mNor_flow_nominal + mWes_flow_nominal,
              mNor_flow_nominal + mWes_flow_nominal,mEas_flow_nominal},
          from_dp=true,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving)
          "Splitter for room supply"
          annotation (Placement(transformation(extent={{940,-30},{960,-50}})));
        Buildings.Fluid.FixedResistances.Junction splSupNor(
          redeclare package Medium = MediumA,
          m_flow_nominal={mNor_flow_nominal + mWes_flow_nominal,mWes_flow_nominal,
              mNor_flow_nominal},
          from_dp=true,
          linearized=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving)
          "Splitter for room supply"
          annotation (Placement(transformation(extent={{1100,-30},{1120,-50}})));
        Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather Data Bus"
          annotation (Placement(transformation(extent={{-330,170},{-310,190}}),
              iconTransformation(extent={{-360,170},{-340,190}})));

        Modelica.Blocks.Routing.DeMultiplex5 TRooAir(u(each unit="K", each
              displayUnit="degC")) "Demultiplex for room air temperature"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=270,
              origin={488,286})));

        Results res(
          final A=ATot,
          PFan=fanSup.P + 0,
          PPum=pumHeaCoi.P + pumCooCoi.P,
          PHea=heaCoi.Q2_flow + cor.terHea.Q2_flow + nor.terHea.Q2_flow + wes.terHea.Q2_flow + eas.terHea.Q2_flow + sou.terHea.Q2_flow,
          PCooSen=cooCoi.QSen2_flow,
          PCooLat=cooCoi.QLat2_flow) "Results of the simulation";

        /*fanRet*/

        Buildings.Examples.VAVReheat.BaseClasses.FreezeStat freSta
          "Freeze stat for heating coil"
          annotation (Placement(transformation(extent={{-140,-100},{-120,-80}})));

        Buildings.Fluid.Actuators.Dampers.Exponential damRet(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          from_dp=false,
          riseTime=15,
          dpDamper_nominal=5,
          dpFixed_nominal=5) "Return air damper" annotation (Placement(transformation(
              origin={0,-10},
              extent={{10,-10},{-10,10}},
              rotation=90)));
        Buildings.Fluid.Actuators.Dampers.Exponential damOut(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          from_dp=false,
          riseTime=15,
          dpDamper_nominal=5,
          dpFixed_nominal=5) "Outdoor air damper"
          annotation (Placement(transformation(extent={{-50,-50},{-30,-30}})));
        Buildings.Fluid.FixedResistances.Junction splCooSup(
          redeclare package Medium = MediumW,
          m_flow_nominal=mCooWat_flow_nominal*{1,1,1},
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving) "Flow splitter"
          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={220,-166})));
        Buildings.Fluid.Actuators.Valves.ThreeWayEqualPercentageLinear valHeaCoi(
          redeclare package Medium = MediumW,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          m_flow_nominal=mHeaWat_flow_nominal,
          dpValve_nominal=3000) "Valve for heating coil in AHU" annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={140,-170})));
        Buildings.Fluid.Actuators.Valves.TwoWayEqualPercentage valCooCoi(
          redeclare package Medium = MediumW,
          m_flow_nominal=mCooWat_flow_nominal,
          dpValve_nominal=6000,
          dpFixed_nominal=0) "Valve for cooling coil" annotation (Placement(
              transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={180,-210})));
        Buildings.Fluid.FixedResistances.Junction splHeaRet(
          redeclare package Medium = MediumW,
          m_flow_nominal=mHeaWat_flow_nominal*{1,1,1},
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving) "Flow splitter"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={80,-170})));
        Buildings.Fluid.FixedResistances.Junction splCooRet(
          redeclare package Medium = MediumW,
          m_flow_nominal=mCooWat_flow_nominal*{1,1,1},
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_nominal(each displayUnit="Pa") = {0,0,0},
          portFlowDirection_1=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=if allowFlowReversal then Modelica.Fluid.Types.PortFlowDirection.Bidirectional
               else Modelica.Fluid.Types.PortFlowDirection.Leaving) "Flow splitter"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={180,-166})));
        Buildings.Fluid.Movers.SpeedControlled_y pumCooCoi(
          redeclare package Medium = MediumW,
          per(pressure(V_flow={0,mCooWat_flow_nominal/1000*2}, dp=2*{3000,0})),
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial) "Supply air fan"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={180,-120})));
        Buildings.Fluid.Movers.SpeedControlled_y pumHeaCoi(
          redeclare package Medium = MediumW,
          per(pressure(V_flow={0,mHeaWat_flow_nominal/1000*2}, dp=2*{6000,0})),
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial)
          "Pump for heating coil" annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={140,-120})));

        Modelica.Fluid.Interfaces.FluidPort_a portHeaCoiSup(redeclare package
          Medium =
              MediumW) "Heating coil loop supply"
          annotation (Placement(transformation(extent={{130,-410},{150,-390}}),
              iconTransformation(extent={{92,-412},{112,-392}})));
        Modelica.Fluid.Interfaces.FluidPort_b portHeaCoiRet(redeclare package
          Medium =
              MediumW) "Heating coil loop return" annotation (Placement(
              transformation(extent={{50,-410},{70,-390}}), iconTransformation(extent={{12,-412},
                  {32,-392}})));
        Modelica.Fluid.Interfaces.FluidPort_a portHeaTerSup(redeclare package
          Medium =
              MediumW) "Terminal heat loop supply"
          annotation (Placement(transformation(extent={{450,-410},{470,-390}}),
              iconTransformation(extent={{410,-410},{430,-390}})));
        Modelica.Fluid.Interfaces.FluidPort_b portHeaTerRet(redeclare package
          Medium =
              MediumW) "Terminal heat loop return" annotation (Placement(
              transformation(extent={{370,-410},{390,-390}}),
                                                            iconTransformation(extent={{332,
                  -412},{352,-392}})));

        Modelica.Fluid.Interfaces.FluidPort_a portCooCoiSup(redeclare package
          Medium =
              MediumW) "Cooling coil loop supply"
          annotation (Placement(transformation(extent={{250,-410},{270,-390}}),
              iconTransformation(extent={{230,-410},{250,-390}})));
        Modelica.Fluid.Interfaces.FluidPort_b portCooCoiRet(redeclare package
          Medium =
              MediumW)
          "Coolin coil loop return"
          annotation (Placement(transformation(extent={{170,-410},{190,-390}})));

    protected
        constant Modelica.SIunits.SpecificHeatCapacity cpAir=
          Buildings.Utilities.Psychrometrics.Constants.cpAir
          "Air specific heat capacity";
        constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq=
          Buildings.Utilities.Psychrometrics.Constants.cpWatLiq
          "Water specific heat capacity";
        model Results "Model to store the results of the simulation"
          parameter Modelica.SIunits.Area A "Floor area";
          input Modelica.SIunits.Power PFan "Fan energy";
          input Modelica.SIunits.Power PPum "Pump energy";
          input Modelica.SIunits.Power PHea "Heating energy";
          input Modelica.SIunits.Power PCooSen "Sensible cooling energy";
          input Modelica.SIunits.Power PCooLat "Latent cooling energy";

          Real EFan(
            unit="J/m2",
            start=0,
            nominal=1E5,
            fixed=true) "Fan energy";
          Real EPum(
            unit="J/m2",
            start=0,
            nominal=1E5,
            fixed=true) "Pump energy";
          Real EHea(
            unit="J/m2",
            start=0,
            nominal=1E5,
            fixed=true) "Heating energy";
          Real ECooSen(
            unit="J/m2",
            start=0,
            nominal=1E5,
            fixed=true) "Sensible cooling energy";
          Real ECooLat(
            unit="J/m2",
            start=0,
            nominal=1E5,
            fixed=true) "Latent cooling energy";
          Real ECoo(unit="J/m2") "Total cooling energy";
        equation

          A*der(EFan) = PFan;
          A*der(EPum) = PPum;
          A*der(EHea) = PHea;
          A*der(ECooSen) = PCooSen;
          A*der(ECooLat) = PCooLat;
          ECoo = ECooSen + ECooLat;

        end Results;
      equation
        connect(fanSup.port_b, dpDisSupFan.port_a) annotation (Line(
            points={{320,-40},{320,-10}},
            color={0,0,0},
            smooth=Smooth.None,
            pattern=LinePattern.Dot));
        connect(TSup.port_a, fanSup.port_b) annotation (Line(
            points={{330,-40},{320,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(amb.ports[1], VOut1.port_a) annotation (Line(
            points={{-114,-42.8},{-94,-42.8},{-94,-40},{-90,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splRetRoo1.port_1, dpRetDuc.port_a) annotation (Line(
            points={{630,0},{430,0},{430,140},{400,140}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splRetNor.port_1, splRetEas.port_2) annotation (Line(
            points={{1142,0},{1110,0},{1110,0},{1078,0},{1078,0},{1012,0}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splRetEas.port_1, splRetSou.port_2) annotation (Line(
            points={{992,0},{952,0},{952,0},{912,0},{912,0},{832,0}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splRetSou.port_1, splRetRoo1.port_2) annotation (Line(
            points={{812,0},{650,0}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupRoo1.port_3, cor.port_aAir) annotation (Line(
            points={{590,-30},{590,-4},{590,22},{590,22}},
            color={0,127,255},
            thickness=0.5));
        connect(splSupRoo1.port_2, splSupSou.port_1) annotation (Line(
            points={{600,-40},{760,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupSou.port_3, sou.port_aAir) annotation (Line(
            points={{770,-30},{770,-6},{770,20},{770,20}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupSou.port_2, splSupEas.port_1) annotation (Line(
            points={{780,-40},{940,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupEas.port_3, eas.port_aAir) annotation (Line(
            points={{950,-30},{950,-6},{950,20},{950,20}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupEas.port_2, splSupNor.port_1) annotation (Line(
            points={{960,-40},{1100,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupNor.port_3, nor.port_aAir) annotation (Line(
            points={{1110,-30},{1110,-6},{1110,20},{1110,20}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(splSupNor.port_2, wes.port_aAir) annotation (Line(
            points={{1120,-40},{1310,-40},{1310,20}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));
        connect(weaBus.TDryBul, TOut.u) annotation (Line(
            points={{-320,180},{-302,180}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(amb.weaBus, weaBus) annotation (Line(
            points={{-136,-44.78},{-320,-44.78},{-320,180}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(splRetRoo1.port_3, flo.portsCor[2]) annotation (Line(
            points={{640,10},{640,118},{892,118},{892,472},{898,472},{898,
              511.077},{906.052,511.077}},
            color={0,127,255},
            thickness=0.5));
        connect(splRetSou.port_3, flo.portsSou[2]) annotation (Line(
            points={{822,10},{822,152},{900,152},{900,443.385},{906.052,443.385}},
            color={0,127,255},
            thickness=0.5));
        connect(splRetEas.port_3, flo.portsEas[2]) annotation (Line(
            points={{1002,10},{1002,120},{1068.63,120},{1068.63,511.077}},
            color={0,127,255},
            thickness=0.5));
        connect(splRetNor.port_3, flo.portsNor[2]) annotation (Line(
            points={{1152,10},{1152,214},{906.052,214},{906.052,568.615}},
            color={0,127,255},
            thickness=0.5));
        connect(splRetNor.port_2, flo.portsWes[2]) annotation (Line(
            points={{1162,0},{1188,0},{1188,346},{818,346},{818,484},{817.635,
              484},{817.635,511.077}},
            color={0,127,255},
            thickness=0.5));
        connect(weaBus, flo.weaBus) annotation (Line(
            points={{-320,180},{-320,649.846},{978.783,649.846}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(flo.TRooAir, min.u) annotation (Line(
            points={{1107.13,506},{1164.7,506},{1164.7,450},{1198,450}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
        connect(flo.TRooAir, ave.u) annotation (Line(
            points={{1107.13,506},{1166,506},{1166,420},{1198,420}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));
        connect(TRooAir.u, flo.TRooAir) annotation (Line(
            points={{488,298},{488,538},{1164,538},{1164,506},{1107.13,506}},
            color={0,0,127},
            smooth=Smooth.None,
            pattern=LinePattern.Dash));

        connect(cooCoi.port_b2, fanSup.port_a) annotation (Line(
            points={{210,-40},{300,-40}},
            color={0,127,255},
            smooth=Smooth.None,
            thickness=0.5));

        connect(cor.port_bAir, flo.portsCor[1]) annotation (Line(
            points={{590,62},{590,120},{891.791,120},{891.791,511.077}},
            color={0,127,255},
            thickness=0.5));
        connect(sou.port_bAir, flo.portsSou[1]) annotation (Line(
            points={{770,60},{770,152},{891.791,152},{891.791,443.385}},
            color={0,127,255},
            thickness=0.5));
        connect(eas.port_bAir, flo.portsEas[1]) annotation (Line(
            points={{950,60},{950,120},{1054,120},{1054,506},{1054.37,506},{
              1054.37,511.077}},
            color={0,127,255},
            thickness=0.5));
        connect(nor.port_bAir, flo.portsNor[1]) annotation (Line(
            points={{1110,60},{1110,214},{926,214},{926,326},{891.791,326},{
              891.791,568.615}},
            color={0,127,255},
            thickness=0.5));
        connect(wes.port_bAir, flo.portsWes[1]) annotation (Line(
            points={{1310,60},{1310,344},{804,344},{804,424},{803.374,424},{
              803.374,511.077}},
            color={0,127,255},
            thickness=0.5));

        connect(senRetFlo.port_a, dpRetDuc.port_b)
          annotation (Line(points={{360,140},{380,140}}, color={0,127,255}));
        connect(TSup.port_b, senSupFlo.port_a)
          annotation (Line(points={{350,-40},{400,-40}}, color={0,127,255}));
        connect(senSupFlo.port_b, splSupRoo1.port_1)
          annotation (Line(points={{420,-40},{580,-40}}, color={0,127,255}));
        connect(dpDisSupFan.port_b, amb.ports[2]) annotation (Line(
            points={{320,10},{320,14},{-106,14},{-106,-48},{-110,-48},{-110,-47.2},{-114,
                -47.2}},
            color={0,0,0},
            pattern=LinePattern.Dot));
        connect(senRetFlo.port_b, TRet.port_a) annotation (Line(points={{340,140},{
                226,140},{110,140}}, color={0,127,255}));
        connect(freSta.u, TMix.T) annotation (Line(points={{-142,-90},{-148,-90},{-148,
                -70},{20,-70},{20,-20},{40,-20},{40,-29}},
                                                      color={0,0,127}));
        connect(TMix.port_b, heaCoi.port_a2) annotation (Line(
            points={{50,-40},{98,-40}},
            color={0,127,255},
            thickness=0.5));
        connect(heaCoi.port_b2, cooCoi.port_a2)
          annotation (Line(
            points={{118,-40},{190,-40}},
            color={0,127,255},
            thickness=0.5));
        connect(VOut1.port_b, damOut.port_a)
          annotation (Line(points={{-70,-40},{-50,-40}}, color={0,127,255}));
        connect(damOut.port_b, TMix.port_a)
          annotation (Line(points={{-30,-40},{30,-40}}, color={0,127,255}));
        connect(damRet.port_a, TRet.port_b)
          annotation (Line(points={{0,0},{0,140},{90,140}}, color={0,127,255}));
        connect(damRet.port_b, TMix.port_a)
          annotation (Line(points={{0,-20},{0,-40},{30,-40}}, color={0,127,255}));
        connect(pumHeaCoi.port_b, heaCoi.port_a1) annotation (Line(points={{140,-110},
                {140,-52},{118,-52}}, color={0,127,255}));
        connect(heaCoi.port_b1,splHeaRet. port_2)
          annotation (Line(points={{98,-52},{80,-52},{80,-160}}, color={0,127,255}));
        connect(cooCoi.port_b1,pumCooCoi. port_a) annotation (Line(points={{190,-52},{
                180,-52},{180,-110}}, color={0,127,255}));
        connect(splCooSup.port_2, cooCoi.port_a1) annotation (Line(points={{220,-156},
                {220,-52},{210,-52}}, color={0,127,255}));
        connect(splCooRet.port_3,splCooSup. port_3)
          annotation (Line(points={{190,-166},{210,-166}}, color={0,127,255}));
        connect(pumCooCoi.port_b, splCooRet.port_2)
          annotation (Line(points={{180,-130},{180,-156}}, color={0,127,255}));
        connect(valCooCoi.port_a, splCooRet.port_1)
          annotation (Line(points={{180,-200},{180,-176}}, color={0,127,255}));
        connect(pumHeaCoi.port_a, valHeaCoi.port_2)
          annotation (Line(points={{140,-130},{140,-160}}, color={0,127,255}));
        connect(valHeaCoi.port_3, splHeaRet.port_3)
          annotation (Line(points={{130,-170},{90,-170}}, color={0,127,255}));
        connect(splHeaRet.port_1, portHeaCoiRet)
          annotation (Line(points={{80,-180},{80,-360},{60,-360},{60,-400}},
                                                         color={0,127,255}));
        connect(valHeaCoi.port_1, portHeaCoiSup)
          annotation (Line(points={{140,-180},{140,-400}}, color={0,127,255}));
        connect(valCooCoi.port_b, portCooCoiRet)
          annotation (Line(points={{180,-220},{180,-400}}, color={0,127,255}));
        connect(splCooSup.port_1, portCooCoiSup)
          annotation (Line(points={{220,-176},{220,-360},{260,-360},{260,-400}},
                                                           color={0,127,255}));
        connect(portHeaTerSup, cor.port_aHotWat) annotation (Line(points={{460,-400},{
                460,-80},{520,-80},{520,42},{570,42}}, color={0,127,255}));
        connect(portHeaTerSup, sou.port_aHotWat) annotation (Line(points={{460,-400},{
                460,-80},{720,-80},{720,40},{750,40}}, color={0,127,255}));
        connect(portHeaTerSup, eas.port_aHotWat) annotation (Line(points={{460,-400},{
                460,-80},{900,-80},{900,40},{930,40}}, color={0,127,255}));
        connect(portHeaTerSup, nor.port_aHotWat) annotation (Line(points={{460,-400},{
                460,-80},{1060,-80},{1060,40},{1090,40}}, color={0,127,255}));
        connect(portHeaTerSup, wes.port_aHotWat) annotation (Line(points={{460,-400},{
                460,-80},{1260,-80},{1260,40},{1290,40}}, color={0,127,255}));
        connect(portHeaTerRet, cor.port_bHotWat) annotation (Line(points={{380,-400},{
                380,-120},{540,-120},{540,30},{570,30}}, color={0,127,255}));
        connect(portHeaTerRet, sou.port_bHotWat) annotation (Line(points={{380,-400},{
                380,-120},{732,-120},{732,28},{750,28}}, color={0,127,255}));
        connect(portHeaTerRet, eas.port_bHotWat) annotation (Line(points={{380,-400},{
                380,-120},{910,-120},{910,28},{930,28}}, color={0,127,255}));
        connect(portHeaTerRet, nor.port_bHotWat) annotation (Line(points={{380,-400},{
                380,-120},{1072,-120},{1072,28},{1090,28}}, color={0,127,255}));
        connect(portHeaTerRet, wes.port_bHotWat) annotation (Line(points={{380,-400},{
                380,-120},{1270,-120},{1270,28},{1290,28}}, color={0,127,255}));
        annotation (
            Icon(
            coordinateSystem(
              extent={{-400,-400},{1380,680}},
              preserveAspectRatio=true), graphics={Rectangle(
                extent={{-400,680},{1380,-400}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Diagram(
            coordinateSystem(
              preserveAspectRatio=false,
              extent={{-400,-400},{1380,680}})),
              Documentation(info="<html>
<p>
This model consist of an HVAC system, a building envelope model and a model
for air flow through building leakage and through open doors.
</p>
<p>
The HVAC system is a variable air volume (VAV) flow system with economizer
and a heating and cooling coil in the air handler unit. There is also a
reheat coil and an air damper in each of the five zone inlet branches.
The figure below shows the schematic diagram of the HVAC system
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Examples/VAVReheat/vavSchematics.png\" border=\"1\"/>
</p>
<p>
Most of the HVAC control in this model is open loop.
Two models that extend this model, namely
<a href=\"modelica://Buildings.Examples.VAVReheat.ASHRAE2006\">
Buildings.Examples.VAVReheat.ASHRAE2006</a>
and
<a href=\"modelica://Buildings.Examples.VAVReheat.Guideline36\">
Buildings.Examples.VAVReheat.Guideline36</a>
add closed loop control. See these models for a description of
the control sequence.
</p>
<p>
To model the heat transfer through the building envelope,
a model of five interconnected rooms is used.
The five room model is representative of one floor of the
new construction medium office building for Chicago, IL,
as described in the set of DOE Commercial Building Benchmarks
(Deru et al, 2009). There are four perimeter zones and one core zone.
The envelope thermal properties meet ASHRAE Standard 90.1-2004.
The thermal room model computes transient heat conduction through
walls, floors and ceilings and long-wave radiative heat exchange between
surfaces. The convective heat transfer coefficient is computed based
on the temperature difference between the surface and the room air.
There is also a layer-by-layer short-wave radiation,
long-wave radiation, convection and conduction heat transfer model for the
windows. The model is similar to the
Window 5 model and described in TARCOG 2006.
</p>
<p>
Each thermal zone can have air flow from the HVAC system, through leakages of the building envelope (except for the core zone) and through bi-directional air exchange through open doors that connect adjacent zones. The bi-directional air exchange is modeled based on the differences in static pressure between adjacent rooms at a reference height plus the difference in static pressure across the door height as a function of the difference in air density.
Infiltration is a function of the
flow imbalance of the HVAC system.
</p>
<h4>References</h4>
<p>
Deru M., K. Field, D. Studer, K. Benne, B. Griffith, P. Torcellini,
 M. Halverson, D. Winiarski, B. Liu, M. Rosenberg, J. Huang, M. Yazdanian, and D. Crawley.
<i>DOE commercial building research benchmarks for commercial buildings</i>.
Technical report, U.S. Department of Energy, Energy Efficiency and
Renewable Energy, Office of Building Technologies, Washington, DC, 2009.
</p>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2021, by Michael Wetter:<br/>
Changed model to include the hydraulic configurations of the cooling coil,
heating coil and VAV terminal box.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2594\">issue #2594</a>.
</li>
<li>
June 30, 2021, by Antoine Gautier:<br/>
Changed cooling coil model. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2549\">issue #2549</a>.
</li>
<li>
May 6, 2021, by David Blum:<br/>
Change to <code>from_dp=false</code> for all mixing box dampers.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2485\">issue #2485</a>.
</li>
<li>
April 30, 2021, by Michael Wetter:<br/>
Reformulated replaceable class and introduced floor areas in base class
to avoid access of components that are not in the constraining type.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2471\">issue #2471</a>.
</li>
<li>
April 16, 2021, by Michael Wetter:<br/>
Refactored model to implement the economizer dampers directly in
<code>Buildings.Examples.VAVReheat.BaseClasses.PartialOpenLoop</code> rather than through the
model of a mixing box. Since the version of the Guideline 36 model has no exhaust air damper,
this leads to simpler equations.
<br/> This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2454\">issue #2454</a>.
</li>
<li>
March 11, 2021, by Michael Wetter:<br/>
Set parameter in weather data reader to avoid computation of wet bulb temperature which is need needed for this model.
</li>
<li>
February 03, 2021, by Baptiste Ravache:<br/>
Refactored the sizing of the heating coil in the <code>VAVBranch</code> (renamed <code>VAVReheatBox</code>) class.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2059\">#2024</a>.
</li>
<li>
July 10, 2020, by Antoine Gautier:<br/>
Added design parameters for outdoor air flow.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2019\">#2019</a>
</li>
<li>
November 25, 2019, by Milica Grahovac:<br/>
Declared the floor model as replaceable.
</li>
<li>
September 26, 2017, by Michael Wetter:<br/>
Separated physical model from control to facilitate implementation of alternate control
sequences.
</li>
<li>
May 19, 2016, by Michael Wetter:<br/>
Changed chilled water supply temperature to <i>6&deg;C</i>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/509\">#509</a>.
</li>
<li>
April 26, 2016, by Michael Wetter:<br/>
Changed controller for freeze protection as the old implementation closed
the outdoor air damper during summer.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/511\">#511</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Set default temperature for medium to avoid conflicting
start values for alias variables of the temperature
of the building and the ambient air.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
</ul>
</html>"));
      end PartialOpenLoop;
    end BaseClasses;
  end VAV;
annotation (
uses(
  Buildings(version="9.0.0"),
  Modelica(version="3.2.3")));
end SystemModel;
model SystemModel_VAV_System
 extends SystemModel.VAV.System;
  annotation(experiment(
  StartTime=432000,
  StopTime=864000,
  Tolerance=1e-07));
end SystemModel_VAV_System;
